// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TPCommandArchives.proto

#include "TPCommandArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TP {
PROTOBUF_CONSTEXPR InsertDrawablesCommandArchive::InsertDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.page_index_)*/0u
  , /*decltype(_impl_.z_order_)*/0u
  , /*decltype(_impl_.forpaste_)*/false} {}
struct InsertDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    InsertDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertDrawablesCommandArchiveDefaultTypeInternal _InsertDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PasteDrawablesCommandArchive_DrawableAndPage::PasteDrawablesCommandArchive_DrawableAndPage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.page_index_)*/0u} {}
struct PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal() {}
  union {
    PasteDrawablesCommandArchive_DrawableAndPage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal _PasteDrawablesCommandArchive_DrawableAndPage_default_instance_;
PROTOBUF_CONSTEXPR PasteDrawablesCommandArchive::PasteDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct PasteDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    PasteDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteDrawablesCommandArchiveDefaultTypeInternal _PasteDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PasteAnchoredDrawablesCommandArchive::PasteAnchoredDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.deprecated_super_)*/nullptr
  , /*decltype(_impl_.deprecated_undo_selection_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.canvas_selection_)*/nullptr
  , /*decltype(_impl_.select_)*/false} {}
struct PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    PasteAnchoredDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal _PasteAnchoredDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchive_Drawable::MoveDrawablesPageIndexCommandArchive_Drawable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.z_order_)*/0u} {}
struct MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal() {}
  union {
    MoveDrawablesPageIndexCommandArchive_Drawable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal _MoveDrawablesPageIndexCommandArchive_Drawable_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchive::MoveDrawablesPageIndexCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.page_index_)*/0u} {}
struct MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal() {}
  union {
    MoveDrawablesPageIndexCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal _MoveDrawablesPageIndexCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertSectionBreakCommandArchive::InsertSectionBreakCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct InsertSectionBreakCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertSectionBreakCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertSectionBreakCommandArchiveDefaultTypeInternal() {}
  union {
    InsertSectionBreakCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertSectionBreakCommandArchiveDefaultTypeInternal _InsertSectionBreakCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DeleteSectionCommandArchive::DeleteSectionCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct DeleteSectionCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteSectionCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteSectionCommandArchiveDefaultTypeInternal() {}
  union {
    DeleteSectionCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteSectionCommandArchiveDefaultTypeInternal _DeleteSectionCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceSectionCommandArchive::ReplaceSectionCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ReplaceSectionCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceSectionCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceSectionCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceSectionCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceSectionCommandArchiveDefaultTypeInternal _ReplaceSectionCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeSectionPropertyCommandArchive::ChangeSectionPropertyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.section_property_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.section_index_)*/0u
  , /*decltype(_impl_.section_value_bool_)*/false} {}
struct ChangeSectionPropertyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeSectionPropertyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeSectionPropertyCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeSectionPropertyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeSectionPropertyCommandArchiveDefaultTypeInternal _ChangeSectionPropertyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchive_SwapPair::SwapDrawableZOrderCommandArchive_SwapPair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.z_order_1_)*/0u
  , /*decltype(_impl_.z_order_2_)*/0u} {}
struct SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal() {}
  union {
    SwapDrawableZOrderCommandArchive_SwapPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal _SwapDrawableZOrderCommandArchive_SwapPair_default_instance_;
PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchive::SwapDrawableZOrderCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.swap_pairs_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct SwapDrawableZOrderCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SwapDrawableZOrderCommandArchiveDefaultTypeInternal() {}
  union {
    SwapDrawableZOrderCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SwapDrawableZOrderCommandArchiveDefaultTypeInternal _SwapDrawableZOrderCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchive_DrawableInfo::RemoveDrawablesCommandArchive_DrawableInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_object_)*/nullptr
  , /*decltype(_impl_.page_index_)*/0u
  , /*decltype(_impl_.z_order_)*/0} {}
struct RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal() {}
  union {
    RemoveDrawablesCommandArchive_DrawableInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal _RemoveDrawablesCommandArchive_DrawableInfo_default_instance_;
PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchive::RemoveDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct RemoveDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveDrawablesCommandArchiveDefaultTypeInternal _RemoveDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR NudgeDrawablesCommandArchive::NudgeDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.child_commands_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct NudgeDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NudgeDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NudgeDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    NudgeDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NudgeDrawablesCommandArchiveDefaultTypeInternal _NudgeDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeHeaderFooterVisibilityCommandArchive::ChangeHeaderFooterVisibilityCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.storages_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.visible_)*/false
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.index_to_select_)*/0} {}
struct ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeHeaderFooterVisibilityCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal _ChangeHeaderFooterVisibilityCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeSectionMarginsCommandArchive::ChangeSectionMarginsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.section_)*/nullptr
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.margin_value_)*/0} {}
struct ChangeSectionMarginsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeSectionMarginsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeSectionMarginsCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeSectionMarginsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeSectionMarginsCommandArchiveDefaultTypeInternal _ChangeSectionMarginsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeDocumentPrinterOptionsCommandArchive::ChangeDocumentPrinterOptionsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.printer_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.paper_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.obsolete_section_)*/nullptr
  , /*decltype(_impl_.paper_width_)*/0
  , /*decltype(_impl_.paper_height_)*/0
  , /*decltype(_impl_.page_scale_)*/0
  , /*decltype(_impl_.orientation_)*/0u} {}
struct ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeDocumentPrinterOptionsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal _ChangeDocumentPrinterOptionsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertMasterDrawablesCommandArchive::InsertMasterDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.obsolete_section_)*/nullptr
  , /*decltype(_impl_.master_drawable_provider_)*/nullptr
  , /*decltype(_impl_.drawable_index_)*/0u} {}
struct InsertMasterDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertMasterDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertMasterDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    InsertMasterDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertMasterDrawablesCommandArchiveDefaultTypeInternal _InsertMasterDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveMasterDrawableZOrderCommandArchive::MoveMasterDrawableZOrderCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_drawables_)*/{}
  , /*decltype(_impl_.indexes_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.obsolete_section_)*/nullptr
  , /*decltype(_impl_.master_drawable_provider_)*/nullptr} {}
struct MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal() {}
  union {
    MoveMasterDrawableZOrderCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal _MoveMasterDrawableZOrderCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchive_MasterDrawable::RemoveMasterDrawablesCommandArchive_MasterDrawable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.drawable_index_)*/0u} {}
struct RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal() {}
  union {
    RemoveMasterDrawablesCommandArchive_MasterDrawable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal _RemoveMasterDrawablesCommandArchive_MasterDrawable_default_instance_;
PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchive::RemoveMasterDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.obsolete_section_)*/nullptr
  , /*decltype(_impl_.master_drawable_provider_)*/nullptr} {}
struct RemoveMasterDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveMasterDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveMasterDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveMasterDrawablesCommandArchiveDefaultTypeInternal _RemoveMasterDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PasteMasterDrawablesCommandArchive::PasteMasterDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.section_)*/nullptr
  , /*decltype(_impl_.drawable_index_)*/0u} {}
struct PasteMasterDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteMasterDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteMasterDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    PasteMasterDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteMasterDrawablesCommandArchiveDefaultTypeInternal _PasteMasterDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchive_FloatingUndo::MoveDrawablesAttachedCommandArchive_FloatingUndo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.attachment_)*/nullptr
  , /*decltype(_impl_.wrap_type_)*/0u
  , /*decltype(_impl_.page_index_)*/0u
  , /*decltype(_impl_.z_order_)*/0} {}
struct MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal() {}
  union {
    MoveDrawablesAttachedCommandArchive_FloatingUndo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal _MoveDrawablesAttachedCommandArchive_FloatingUndo_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchive::MoveDrawablesAttachedCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.floating_undo_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.select_)*/false
  , /*decltype(_impl_.make_inline_)*/false} {}
struct MoveDrawablesAttachedCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesAttachedCommandArchiveDefaultTypeInternal() {}
  union {
    MoveDrawablesAttachedCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesAttachedCommandArchiveDefaultTypeInternal _MoveDrawablesAttachedCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchive_AttachedUndo::MoveDrawablesFloatingCommandArchive_AttachedUndo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.attachment_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.page_index_)*/0u
  , /*decltype(_impl_.is_html_wrap_)*/false
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.direction_)*/0u
  , /*decltype(_impl_.fit_type_)*/0u
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.alpha_threshold_)*/0} {}
struct MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal() {}
  union {
    MoveDrawablesFloatingCommandArchive_AttachedUndo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal _MoveDrawablesFloatingCommandArchive_AttachedUndo_default_instance_;
PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchive::MoveDrawablesFloatingCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attached_undo_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.deprecated_undo_transaction_)*/nullptr
  , /*decltype(_impl_.select_)*/false} {}
struct MoveDrawablesFloatingCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDrawablesFloatingCommandArchiveDefaultTypeInternal() {}
  union {
    MoveDrawablesFloatingCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDrawablesFloatingCommandArchiveDefaultTypeInternal _MoveDrawablesFloatingCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveAnchoredDrawableCommandArchive::RemoveAnchoredDrawableCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.char_index_)*/0u
  , /*decltype(_impl_.z_order_)*/0u} {}
struct RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveAnchoredDrawableCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal _RemoveAnchoredDrawableCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeFootnoteFormatCommandArchive::ChangeFootnoteFormatCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.format_)*/0} {}
struct ChangeFootnoteFormatCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeFootnoteFormatCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeFootnoteFormatCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeFootnoteFormatCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeFootnoteFormatCommandArchiveDefaultTypeInternal _ChangeFootnoteFormatCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeFootnoteKindCommandArchive::ChangeFootnoteKindCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.kind_)*/0} {}
struct ChangeFootnoteKindCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeFootnoteKindCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeFootnoteKindCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeFootnoteKindCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeFootnoteKindCommandArchiveDefaultTypeInternal _ChangeFootnoteKindCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeFootnoteNumberingCommandArchive::ChangeFootnoteNumberingCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.numbering_)*/0} {}
struct ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeFootnoteNumberingCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal _ChangeFootnoteNumberingCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeFootnoteSpacingCommandArchive::ChangeFootnoteSpacingCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.footnote_spacing_)*/0} {}
struct ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeFootnoteSpacingCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal _ChangeFootnoteSpacingCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveInlineDrawableAnchoredCommandArchive::MoveInlineDrawableAnchoredCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.is_html_wrap_)*/false
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.direction_)*/0u
  , /*decltype(_impl_.fit_type_)*/0u
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.alpha_threshold_)*/0} {}
struct MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal() {}
  union {
    MoveInlineDrawableAnchoredCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal _MoveInlineDrawableAnchoredCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveAnchoredDrawableInlineCommandArchive::MoveAnchoredDrawableInlineCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.drawable_)*/nullptr
  , /*decltype(_impl_.is_html_wrap_)*/false
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.direction_)*/0u
  , /*decltype(_impl_.fit_type_)*/0u
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.alpha_threshold_)*/0
  , /*decltype(_impl_.z_order_)*/0u} {}
struct MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal() {}
  union {
    MoveAnchoredDrawableInlineCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal _MoveAnchoredDrawableInlineCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertFootnoteCommandArchive::InsertFootnoteCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct InsertFootnoteCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertFootnoteCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertFootnoteCommandArchiveDefaultTypeInternal() {}
  union {
    InsertFootnoteCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertFootnoteCommandArchiveDefaultTypeInternal _InsertFootnoteCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ToggleBodyLayoutDirectionCommandArchive::ToggleBodyLayoutDirectionCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.new_direction_is_vertical_)*/false} {}
struct ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal() {}
  union {
    ToggleBodyLayoutDirectionCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal _ToggleBodyLayoutDirectionCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ChangeCTVisibilityCommandArchive::ChangeCTVisibilityCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.markup_visible_)*/false
  , /*decltype(_impl_.deletions_visible_)*/false
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct ChangeCTVisibilityCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChangeCTVisibilityCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChangeCTVisibilityCommandArchiveDefaultTypeInternal() {}
  union {
    ChangeCTVisibilityCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangeCTVisibilityCommandArchiveDefaultTypeInternal _ChangeCTVisibilityCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TrackChangesCommandArchive::TrackChangesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.change_session_history_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.track_changes_)*/false
  , /*decltype(_impl_.paused_)*/false} {}
struct TrackChangesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackChangesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackChangesCommandArchiveDefaultTypeInternal() {}
  union {
    TrackChangesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackChangesCommandArchiveDefaultTypeInternal _TrackChangesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DocumentHyphenationCommandArchive::DocumentHyphenationCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.hyphenate_document_)*/false} {}
struct DocumentHyphenationCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentHyphenationCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentHyphenationCommandArchiveDefaultTypeInternal() {}
  union {
    DocumentHyphenationCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentHyphenationCommandArchiveDefaultTypeInternal _DocumentHyphenationCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DocumentLigaturesCommandArchive::DocumentLigaturesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.use_ligatures_)*/false} {}
struct DocumentLigaturesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentLigaturesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentLigaturesCommandArchiveDefaultTypeInternal() {}
  union {
    DocumentLigaturesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentLigaturesCommandArchiveDefaultTypeInternal _DocumentLigaturesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DocumentHasBodyCommandArchive::DocumentHasBodyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.has_body_)*/false} {}
struct DocumentHasBodyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentHasBodyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentHasBodyCommandArchiveDefaultTypeInternal() {}
  union {
    DocumentHasBodyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentHasBodyCommandArchiveDefaultTypeInternal _DocumentHasBodyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PauseChangeTrackingCommandArchive::PauseChangeTrackingCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.paused_)*/false} {}
struct PauseChangeTrackingCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PauseChangeTrackingCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PauseChangeTrackingCommandArchiveDefaultTypeInternal() {}
  union {
    PauseChangeTrackingCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PauseChangeTrackingCommandArchiveDefaultTypeInternal _PauseChangeTrackingCommandArchive_default_instance_;
}  // namespace TP
static ::_pb::Metadata file_level_metadata_TPCommandArchives_2eproto[42];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TPCommandArchives_2eproto[6];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TPCommandArchives_2eproto = nullptr;

const uint32_t TableStruct_TPCommandArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_.page_index_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_.z_order_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_.drawables_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertDrawablesCommandArchive, _impl_.forpaste_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive_DrawableAndPage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive_DrawableAndPage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive_DrawableAndPage, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive_DrawableAndPage, _impl_.page_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteDrawablesCommandArchive, _impl_.drawables_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_.deprecated_super_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_.select_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_.deprecated_undo_selection_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteAnchoredDrawablesCommandArchive, _impl_.canvas_selection_),
  0,
  2,
  4,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive_Drawable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive_Drawable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive_Drawable, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive_Drawable, _impl_.z_order_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive, _impl_.page_index_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesPageIndexCommandArchive, _impl_.drawables_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::InsertSectionBreakCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertSectionBreakCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::InsertSectionBreakCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TP::DeleteSectionCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::DeleteSectionCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::DeleteSectionCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TP::ReplaceSectionCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ReplaceSectionCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ReplaceSectionCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _impl_.section_index_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _impl_.section_property_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionPropertyCommandArchive, _impl_.section_value_bool_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive_SwapPair, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive_SwapPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive_SwapPair, _impl_.z_order_1_),
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive_SwapPair, _impl_.z_order_2_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::SwapDrawableZOrderCommandArchive, _impl_.swap_pairs_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive_DrawableInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive_DrawableInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive_DrawableInfo, _impl_.page_index_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive_DrawableInfo, _impl_.z_order_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive_DrawableInfo, _impl_.drawable_object_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveDrawablesCommandArchive, _impl_.drawables_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::NudgeDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::NudgeDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::NudgeDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::NudgeDrawablesCommandArchive, _impl_.child_commands_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_.visible_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_.index_to_select_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeHeaderFooterVisibilityCommandArchive, _impl_.storages_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _impl_.section_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeSectionMarginsCommandArchive, _impl_.margin_value_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.obsolete_section_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.paper_width_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.paper_height_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.page_scale_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.orientation_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.printer_id_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeDocumentPrinterOptionsCommandArchive, _impl_.paper_id_),
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_.obsolete_section_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_.master_drawables_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_.drawable_index_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertMasterDrawablesCommandArchive, _impl_.master_drawable_provider_),
  0,
  1,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_.obsolete_section_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_.master_drawables_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_.indexes_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveMasterDrawableZOrderCommandArchive, _impl_.master_drawable_provider_),
  0,
  1,
  ~0u,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable, _impl_.drawable_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _impl_.obsolete_section_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _impl_.master_drawables_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveMasterDrawablesCommandArchive, _impl_.master_drawable_provider_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _impl_.section_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _impl_.master_drawables_),
  PROTOBUF_FIELD_OFFSET(::TP::PasteMasterDrawablesCommandArchive, _impl_.drawable_index_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.attachment_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.wrap_type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.page_index_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.z_order_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_.floating_undo_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_.select_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesAttachedCommandArchive, _impl_.make_inline_),
  0,
  1,
  ~0u,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.attachment_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.page_index_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.is_html_wrap_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.fit_type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.alpha_threshold_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.undo_transaction_),
  0,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _impl_.deprecated_undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _impl_.attached_undo_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveDrawablesFloatingCommandArchive, _impl_.select_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::RemoveAnchoredDrawableCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveAnchoredDrawableCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::RemoveAnchoredDrawableCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveAnchoredDrawableCommandArchive, _impl_.char_index_),
  PROTOBUF_FIELD_OFFSET(::TP::RemoveAnchoredDrawableCommandArchive, _impl_.z_order_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteFormatCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteFormatCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteFormatCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteFormatCommandArchive, _impl_.format_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteKindCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteKindCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteKindCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteKindCommandArchive, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteKindCommandArchive, _impl_.undo_transaction_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteNumberingCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteNumberingCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteNumberingCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteNumberingCommandArchive, _impl_.numbering_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteSpacingCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteSpacingCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteSpacingCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeFootnoteSpacingCommandArchive, _impl_.footnote_spacing_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.is_html_wrap_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.fit_type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveInlineDrawableAnchoredCommandArchive, _impl_.alpha_threshold_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.drawable_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.is_html_wrap_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.fit_type_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.alpha_threshold_),
  PROTOBUF_FIELD_OFFSET(::TP::MoveAnchoredDrawableInlineCommandArchive, _impl_.z_order_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TP::InsertFootnoteCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::InsertFootnoteCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::InsertFootnoteCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TP::ToggleBodyLayoutDirectionCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ToggleBodyLayoutDirectionCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ToggleBodyLayoutDirectionCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ToggleBodyLayoutDirectionCommandArchive, _impl_.new_direction_is_vertical_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_.markup_visible_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_.deletions_visible_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TP::ChangeCTVisibilityCommandArchive, _impl_.selection_range_length_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _impl_.track_changes_),
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _impl_.change_session_history_),
  PROTOBUF_FIELD_OFFSET(::TP::TrackChangesCommandArchive, _impl_.paused_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHyphenationCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHyphenationCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHyphenationCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHyphenationCommandArchive, _impl_.hyphenate_document_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::DocumentLigaturesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentLigaturesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::DocumentLigaturesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentLigaturesCommandArchive, _impl_.use_ligatures_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHasBodyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHasBodyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHasBodyCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::DocumentHasBodyCommandArchive, _impl_.has_body_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TP::PauseChangeTrackingCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TP::PauseChangeTrackingCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TP::PauseChangeTrackingCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TP::PauseChangeTrackingCommandArchive, _impl_.paused_),
  0,
  1,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::TP::InsertDrawablesCommandArchive)},
  { 16, 24, -1, sizeof(::TP::PasteDrawablesCommandArchive_DrawableAndPage)},
  { 26, 34, -1, sizeof(::TP::PasteDrawablesCommandArchive)},
  { 36, 47, -1, sizeof(::TP::PasteAnchoredDrawablesCommandArchive)},
  { 52, 60, -1, sizeof(::TP::MoveDrawablesPageIndexCommandArchive_Drawable)},
  { 62, 71, -1, sizeof(::TP::MoveDrawablesPageIndexCommandArchive)},
  { 74, 81, -1, sizeof(::TP::InsertSectionBreakCommandArchive)},
  { 82, 89, -1, sizeof(::TP::DeleteSectionCommandArchive)},
  { 90, 97, -1, sizeof(::TP::ReplaceSectionCommandArchive)},
  { 98, 108, -1, sizeof(::TP::ChangeSectionPropertyCommandArchive)},
  { 112, 120, -1, sizeof(::TP::SwapDrawableZOrderCommandArchive_SwapPair)},
  { 122, 130, -1, sizeof(::TP::SwapDrawableZOrderCommandArchive)},
  { 132, 141, -1, sizeof(::TP::RemoveDrawablesCommandArchive_DrawableInfo)},
  { 144, 152, -1, sizeof(::TP::RemoveDrawablesCommandArchive)},
  { 154, 162, -1, sizeof(::TP::NudgeDrawablesCommandArchive)},
  { 164, 175, -1, sizeof(::TP::ChangeHeaderFooterVisibilityCommandArchive)},
  { 180, 190, -1, sizeof(::TP::ChangeSectionMarginsCommandArchive)},
  { 194, 208, -1, sizeof(::TP::ChangeDocumentPrinterOptionsCommandArchive)},
  { 216, 227, -1, sizeof(::TP::InsertMasterDrawablesCommandArchive)},
  { 232, 243, -1, sizeof(::TP::MoveMasterDrawableZOrderCommandArchive)},
  { 248, 256, -1, sizeof(::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable)},
  { 258, 268, -1, sizeof(::TP::RemoveMasterDrawablesCommandArchive)},
  { 272, 282, -1, sizeof(::TP::PasteMasterDrawablesCommandArchive)},
  { 286, 298, -1, sizeof(::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo)},
  { 304, 315, -1, sizeof(::TP::MoveDrawablesAttachedCommandArchive)},
  { 320, 338, -1, sizeof(::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo)},
  { 350, 360, -1, sizeof(::TP::MoveDrawablesFloatingCommandArchive)},
  { 364, 373, -1, sizeof(::TP::RemoveAnchoredDrawableCommandArchive)},
  { 376, 384, -1, sizeof(::TP::ChangeFootnoteFormatCommandArchive)},
  { 386, 395, -1, sizeof(::TP::ChangeFootnoteKindCommandArchive)},
  { 398, 406, -1, sizeof(::TP::ChangeFootnoteNumberingCommandArchive)},
  { 408, 416, -1, sizeof(::TP::ChangeFootnoteSpacingCommandArchive)},
  { 418, 432, -1, sizeof(::TP::MoveInlineDrawableAnchoredCommandArchive)},
  { 440, 455, -1, sizeof(::TP::MoveAnchoredDrawableInlineCommandArchive)},
  { 464, 471, -1, sizeof(::TP::InsertFootnoteCommandArchive)},
  { 472, 480, -1, sizeof(::TP::ToggleBodyLayoutDirectionCommandArchive)},
  { 482, 493, -1, sizeof(::TP::ChangeCTVisibilityCommandArchive)},
  { 498, 508, -1, sizeof(::TP::TrackChangesCommandArchive)},
  { 512, 520, -1, sizeof(::TP::DocumentHyphenationCommandArchive)},
  { 522, 530, -1, sizeof(::TP::DocumentLigaturesCommandArchive)},
  { 532, 540, -1, sizeof(::TP::DocumentHasBodyCommandArchive)},
  { 542, 550, -1, sizeof(::TP::PauseChangeTrackingCommandArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TP::_InsertDrawablesCommandArchive_default_instance_._instance,
  &::TP::_PasteDrawablesCommandArchive_DrawableAndPage_default_instance_._instance,
  &::TP::_PasteDrawablesCommandArchive_default_instance_._instance,
  &::TP::_PasteAnchoredDrawablesCommandArchive_default_instance_._instance,
  &::TP::_MoveDrawablesPageIndexCommandArchive_Drawable_default_instance_._instance,
  &::TP::_MoveDrawablesPageIndexCommandArchive_default_instance_._instance,
  &::TP::_InsertSectionBreakCommandArchive_default_instance_._instance,
  &::TP::_DeleteSectionCommandArchive_default_instance_._instance,
  &::TP::_ReplaceSectionCommandArchive_default_instance_._instance,
  &::TP::_ChangeSectionPropertyCommandArchive_default_instance_._instance,
  &::TP::_SwapDrawableZOrderCommandArchive_SwapPair_default_instance_._instance,
  &::TP::_SwapDrawableZOrderCommandArchive_default_instance_._instance,
  &::TP::_RemoveDrawablesCommandArchive_DrawableInfo_default_instance_._instance,
  &::TP::_RemoveDrawablesCommandArchive_default_instance_._instance,
  &::TP::_NudgeDrawablesCommandArchive_default_instance_._instance,
  &::TP::_ChangeHeaderFooterVisibilityCommandArchive_default_instance_._instance,
  &::TP::_ChangeSectionMarginsCommandArchive_default_instance_._instance,
  &::TP::_ChangeDocumentPrinterOptionsCommandArchive_default_instance_._instance,
  &::TP::_InsertMasterDrawablesCommandArchive_default_instance_._instance,
  &::TP::_MoveMasterDrawableZOrderCommandArchive_default_instance_._instance,
  &::TP::_RemoveMasterDrawablesCommandArchive_MasterDrawable_default_instance_._instance,
  &::TP::_RemoveMasterDrawablesCommandArchive_default_instance_._instance,
  &::TP::_PasteMasterDrawablesCommandArchive_default_instance_._instance,
  &::TP::_MoveDrawablesAttachedCommandArchive_FloatingUndo_default_instance_._instance,
  &::TP::_MoveDrawablesAttachedCommandArchive_default_instance_._instance,
  &::TP::_MoveDrawablesFloatingCommandArchive_AttachedUndo_default_instance_._instance,
  &::TP::_MoveDrawablesFloatingCommandArchive_default_instance_._instance,
  &::TP::_RemoveAnchoredDrawableCommandArchive_default_instance_._instance,
  &::TP::_ChangeFootnoteFormatCommandArchive_default_instance_._instance,
  &::TP::_ChangeFootnoteKindCommandArchive_default_instance_._instance,
  &::TP::_ChangeFootnoteNumberingCommandArchive_default_instance_._instance,
  &::TP::_ChangeFootnoteSpacingCommandArchive_default_instance_._instance,
  &::TP::_MoveInlineDrawableAnchoredCommandArchive_default_instance_._instance,
  &::TP::_MoveAnchoredDrawableInlineCommandArchive_default_instance_._instance,
  &::TP::_InsertFootnoteCommandArchive_default_instance_._instance,
  &::TP::_ToggleBodyLayoutDirectionCommandArchive_default_instance_._instance,
  &::TP::_ChangeCTVisibilityCommandArchive_default_instance_._instance,
  &::TP::_TrackChangesCommandArchive_default_instance_._instance,
  &::TP::_DocumentHyphenationCommandArchive_default_instance_._instance,
  &::TP::_DocumentLigaturesCommandArchive_default_instance_._instance,
  &::TP::_DocumentHasBodyCommandArchive_default_instance_._instance,
  &::TP::_PauseChangeTrackingCommandArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TPCommandArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027TPCommandArchives.proto\022\002TP\032\021TSDArchiv"
  "es.proto\032\021TSKArchives.proto\032\021TSPMessages"
  ".proto\032\022TSWPArchives.proto\032\021TSSArchives."
  "proto\032\021TSAArchives.proto\032\020TPArchives.pro"
  "to\032\031TSWPCommandArchives.proto\"\235\001\n\035Insert"
  "DrawablesCommandArchive\022\"\n\005super\030\001 \002(\0132\023"
  ".TSK.CommandArchive\022\022\n\npage_index\030\002 \001(\r\022"
  "\017\n\007z_order\030\003 \001(\r\022!\n\tdrawables\030\004 \003(\0132\016.TS"
  "P.Reference\022\020\n\010forPaste\030\005 \001(\010\"\320\001\n\034PasteD"
  "rawablesCommandArchive\022\"\n\005super\030\001 \002(\0132\023."
  "TSK.CommandArchive\022C\n\tdrawables\030\002 \003(\01320."
  "TP.PasteDrawablesCommandArchive.Drawable"
  "AndPage\032G\n\017DrawableAndPage\022 \n\010drawable\030\001"
  " \001(\0132\016.TSP.Reference\022\022\n\npage_index\030\002 \001(\r"
  "\"\353\001\n$PasteAnchoredDrawablesCommandArchiv"
  "e\0222\n\020deprecated_super\030\001 \002(\0132\030.TSK.Comman"
  "dGroupArchive\022\"\n\005super\030\004 \001(\0132\023.TSK.Comma"
  "ndArchive\022\016\n\006select\030\002 \001(\010\0221\n\031deprecated_"
  "undo_selection\030\003 \001(\0132\016.TSP.Reference\022(\n\020"
  "canvas_selection\030\005 \001(\0132\016.TSP.Reference\"\343"
  "\001\n$MoveDrawablesPageIndexCommandArchive\022"
  "\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\022\n\np"
  "age_index\030\002 \001(\r\022D\n\tdrawables\030\003 \003(\01321.TP."
  "MoveDrawablesPageIndexCommandArchive.Dra"
  "wable\032=\n\010Drawable\022 \n\010drawable\030\001 \001(\0132\016.TS"
  "P.Reference\022\017\n\007z_order\030\002 \001(\r\"K\n InsertSe"
  "ctionBreakCommandArchive\022\'\n\005super\030\001 \002(\0132"
  "\030.TSWP.TextCommandArchive\"A\n\033DeleteSecti"
  "onCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Co"
  "mmandArchive\"G\n\034ReplaceSectionCommandArc"
  "hive\022\'\n\005super\030\001 \002(\0132\030.TSWP.TextCommandAr"
  "chive\"\226\001\n#ChangeSectionPropertyCommandAr"
  "chive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchiv"
  "e\022\025\n\rsection_index\030\002 \001(\r\022\030\n\020section_prop"
  "erty\030\003 \001(\t\022\032\n\022section_value_bool\030\004 \001(\010\"\273"
  "\001\n SwapDrawableZOrderCommandArchive\022\"\n\005s"
  "uper\030\001 \002(\0132\023.TSK.CommandArchive\022A\n\nswap_"
  "pairs\030\002 \003(\0132-.TP.SwapDrawableZOrderComma"
  "ndArchive.SwapPair\0320\n\010SwapPair\022\021\n\tz_orde"
  "r_1\030\001 \002(\r\022\021\n\tz_order_2\030\002 \002(\r\"\344\001\n\035RemoveD"
  "rawablesCommandArchive\022\"\n\005super\030\001 \002(\0132\023."
  "TSK.CommandArchive\022A\n\tdrawables\030\002 \003(\0132.."
  "TP.RemoveDrawablesCommandArchive.Drawabl"
  "eInfo\032\\\n\014DrawableInfo\022\022\n\npage_index\030\001 \001("
  "\r\022\017\n\007z_order\030\002 \001(\005\022\'\n\017drawable_object\030\003 "
  "\001(\0132\016.TSP.Reference\"j\n\034NudgeDrawablesCom"
  "mandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Command"
  "Archive\022&\n\016child_commands\030\002 \003(\0132\016.TSP.Re"
  "ference\"\304\003\n*ChangeHeaderFooterVisibility"
  "CommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Comm"
  "andArchive\022\017\n\007visible\030\002 \001(\010\022O\n\004type\030\003 \001("
  "\0162A.TP.ChangeHeaderFooterVisibilityComma"
  "ndArchive.TPHeaderFooterType\022]\n\017index_to"
  "_select\030\004 \001(\0162D.TP.ChangeHeaderFooterVis"
  "ibilityCommandArchive.TPHeaderFragmentIn"
  "dex\022 \n\010storages\030\005 \003(\0132\016.TSP.Reference\":\n"
  "\022TPHeaderFooterType\022\021\n\rkTPHeaderType\020\000\022\021"
  "\n\rkTPFooterType\020\001\"S\n\025TPHeaderFragmentInd"
  "ex\022\021\n\rkTPHeaderLeft\020\000\022\023\n\017kTPHeaderCenter"
  "\020\001\022\022\n\016kTPHeaderRight\020\002\"\355\002\n\"ChangeSection"
  "MarginsCommandArchive\022\"\n\005super\030\001 \002(\0132\023.T"
  "SK.CommandArchive\022\037\n\007section\030\002 \001(\0132\016.TSP"
  ".Reference\022D\n\006margin\030\003 \001(\01624.TP.ChangeSe"
  "ctionMarginsCommandArchive.SectionMargin"
  "\022\024\n\014margin_value\030\004 \001(\002\"\245\001\n\rSectionMargin"
  "\022\026\n\022kSectionMarginLeft\020\000\022\027\n\023kSectionMarg"
  "inRight\020\001\022\025\n\021kSectionMarginTop\020\002\022\030\n\024kSec"
  "tionMarginBottom\020\003\022\030\n\024kSectionMarginHead"
  "er\020\004\022\030\n\024kSectionMarginFooter\020\005\"\364\001\n*Chang"
  "eDocumentPrinterOptionsCommandArchive\022\"\n"
  "\005super\030\001 \002(\0132\023.TSK.CommandArchive\022(\n\020OBS"
  "OLETE_section\030\002 \001(\0132\016.TSP.Reference\022\023\n\013p"
  "aper_width\030\003 \001(\002\022\024\n\014paper_height\030\004 \001(\002\022\022"
  "\n\npage_scale\030\005 \001(\002\022\023\n\013orientation\030\006 \001(\r\022"
  "\022\n\nprinter_id\030\007 \001(\t\022\020\n\010paper_id\030\010 \001(\t\"\347\001"
  "\n#InsertMasterDrawablesCommandArchive\022\"\n"
  "\005super\030\001 \002(\0132\023.TSK.CommandArchive\022(\n\020OBS"
  "OLETE_section\030\002 \001(\0132\016.TSP.Reference\022(\n\020m"
  "aster_drawables\030\003 \003(\0132\016.TSP.Reference\022\026\n"
  "\016drawable_index\030\004 \001(\r\0220\n\030master_drawable"
  "_provider\030\005 \001(\0132\016.TSP.Reference\"\343\001\n&Move"
  "MasterDrawableZOrderCommandArchive\022\"\n\005su"
  "per\030\001 \002(\0132\023.TSK.CommandArchive\022(\n\020OBSOLE"
  "TE_section\030\002 \001(\0132\016.TSP.Reference\022(\n\020mast"
  "er_drawables\030\003 \003(\0132\016.TSP.Reference\022\017\n\007in"
  "dexes\030\004 \003(\r\0220\n\030master_drawable_provider\030"
  "\005 \001(\0132\016.TSP.Reference\"\303\002\n#RemoveMasterDr"
  "awablesCommandArchive\022\"\n\005super\030\001 \002(\0132\023.T"
  "SK.CommandArchive\022(\n\020OBSOLETE_section\030\002 "
  "\001(\0132\016.TSP.Reference\022P\n\020master_drawables\030"
  "\003 \003(\01326.TP.RemoveMasterDrawablesCommandA"
  "rchive.MasterDrawable\0220\n\030master_drawable"
  "_provider\030\004 \001(\0132\016.TSP.Reference\032J\n\016Maste"
  "rDrawable\022 \n\010drawable\030\001 \001(\0132\016.TSP.Refere"
  "nce\022\026\n\016drawable_index\030\002 \001(\r\"\253\001\n\"PasteMas"
  "terDrawablesCommandArchive\022\"\n\005super\030\001 \002("
  "\0132\023.TSK.CommandArchive\022\037\n\007section\030\002 \001(\0132"
  "\016.TSP.Reference\022(\n\020master_drawables\030\003 \003("
  "\0132\016.TSP.Reference\022\026\n\016drawable_index\030\004 \001("
  "\r\"\243\003\n#MoveDrawablesAttachedCommandArchiv"
  "e\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022/\n"
  "\020undo_transaction\030\002 \001(\0132\025.TSWP.UndoTrans"
  "action\022K\n\rfloating_undo\030\003 \003(\01324.TP.MoveD"
  "rawablesAttachedCommandArchive.FloatingU"
  "ndo\022\016\n\006select\030\004 \001(\010\022\023\n\013make_inline\030\005 \001(\010"
  "\032\264\001\n\014FloatingUndo\022 \n\010drawable\030\001 \001(\0132\016.TS"
  "P.Reference\022&\n\010geometry\030\002 \001(\0132\024.TSD.Geom"
  "etryArchive\022\"\n\nattachment\030\003 \001(\0132\016.TSP.Re"
  "ference\022\021\n\twrap_type\030\004 \001(\r\022\022\n\npage_index"
  "\030\005 \001(\r\022\017\n\007z_order\030\006 \001(\005\"\271\004\n#MoveDrawable"
  "sFloatingCommandArchive\022\"\n\005super\030\001 \002(\0132\023"
  ".TSK.CommandArchive\022:\n\033deprecated_undo_t"
  "ransaction\030\002 \001(\0132\025.TSWP.UndoTransaction\022"
  "K\n\rattached_undo\030\003 \003(\01324.TP.MoveDrawable"
  "sFloatingCommandArchive.AttachedUndo\022\016\n\006"
  "select\030\004 \001(\010\032\324\002\n\014AttachedUndo\022 \n\010drawabl"
  "e\030\001 \001(\0132\016.TSP.Reference\022&\n\010geometry\030\002 \001("
  "\0132\024.TSD.GeometryArchive\022\"\n\nattachment\030\003 "
  "\001(\0132\016.TSP.Reference\022\022\n\npage_index\030\004 \001(\r\022"
  "\024\n\014is_html_wrap\030\005 \001(\010\022\014\n\004type\030\006 \001(\r\022\021\n\td"
  "irection\030\007 \001(\r\022\020\n\010fit_type\030\010 \001(\r\022\016\n\006marg"
  "in\030\t \001(\002\022\027\n\017alpha_threshold\030\n \001(\002\022\037\n\007sto"
  "rage\030\013 \001(\0132\016.TSP.Reference\022/\n\020undo_trans"
  "action\030\014 \001(\0132\025.TSWP.UndoTransaction\"t\n$R"
  "emoveAnchoredDrawableCommandArchive\022\'\n\005s"
  "uper\030\001 \002(\0132\030.TSWP.TextCommandArchive\022\022\n\n"
  "char_index\030\002 \001(\r\022\017\n\007z_order\030\003 \001(\r\"\301\002\n\"Ch"
  "angeFootnoteFormatCommandArchive\022\"\n\005supe"
  "r\030\001 \002(\0132\023.TSK.CommandArchive\022E\n\006format\030\002"
  " \001(\01625.TP.ChangeFootnoteFormatCommandArc"
  "hive.FootnoteFormat\"\257\001\n\016FootnoteFormat\022\032"
  "\n\026kFootnoteFormatNumeric\020\000\022\030\n\024kFootnoteF"
  "ormatRoman\020\001\022\033\n\027kFootnoteFormatSymbolic\020"
  "\002\022\"\n\036kFootnoteFormatJapaneseNumeric\020\003\022&\n"
  "\"kFootnoteFormatJapaneseIdeographic\020\004\"\251\002"
  "\n ChangeFootnoteKindCommandArchive\022\"\n\005su"
  "per\030\001 \002(\0132\023.TSK.CommandArchive\022\?\n\004kind\030\002"
  " \001(\01621.TP.ChangeFootnoteKindCommandArchi"
  "ve.FootnoteKind\022/\n\020undo_transaction\030\003 \001("
  "\0132\025.TSWP.UndoTransaction\"o\n\014FootnoteKind"
  "\022\032\n\026kFootnoteKindFootnotes\020\000\022!\n\035kFootnot"
  "eKindDocumentEndnotes\020\001\022 \n\034kFootnoteKind"
  "SectionEndnotes\020\002\"\244\002\n%ChangeFootnoteNumb"
  "eringCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK"
  ".CommandArchive\022N\n\tnumbering\030\002 \001(\0162;.TP."
  "ChangeFootnoteNumberingCommandArchive.Fo"
  "otnoteNumbering\"\206\001\n\021FootnoteNumbering\022 \n"
  "\034kFootnoteNumberingContinuous\020\000\022%\n!kFoot"
  "noteNumberingRestartEachPage\020\001\022(\n$kFootn"
  "oteNumberingRestartEachSection\020\002\"c\n#Chan"
  "geFootnoteSpacingCommandArchive\022\"\n\005super"
  "\030\001 \002(\0132\023.TSK.CommandArchive\022\030\n\020footnote_"
  "spacing\030\002 \001(\005\"\342\001\n(MoveInlineDrawableAnch"
  "oredCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK."
  "CommandArchive\022 \n\010drawable\030\002 \001(\0132\016.TSP.R"
  "eference\022\024\n\014is_html_wrap\030\003 \001(\010\022\014\n\004type\030\004"
  " \001(\r\022\021\n\tdirection\030\005 \001(\r\022\020\n\010fit_type\030\006 \001("
  "\r\022\016\n\006margin\030\007 \001(\002\022\027\n\017alpha_threshold\030\010 \001"
  "(\002\"\363\001\n(MoveAnchoredDrawableInlineCommand"
  "Archive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArch"
  "ive\022 \n\010drawable\030\002 \001(\0132\016.TSP.Reference\022\024\n"
  "\014is_html_wrap\030\003 \001(\010\022\014\n\004type\030\004 \001(\r\022\021\n\tdir"
  "ection\030\005 \001(\r\022\020\n\010fit_type\030\006 \001(\r\022\016\n\006margin"
  "\030\007 \001(\002\022\027\n\017alpha_threshold\030\010 \001(\002\022\017\n\007z_ord"
  "er\030\t \001(\r\"G\n\034InsertFootnoteCommandArchive"
  "\022\'\n\005super\030\001 \002(\0132\030.TSWP.TextCommandArchiv"
  "e\"p\n\'ToggleBodyLayoutDirectionCommandArc"
  "hive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive"
  "\022!\n\031new_direction_is_vertical\030\002 \001(\010\"\273\001\n "
  "ChangeCTVisibilityCommandArchive\022\"\n\005supe"
  "r\030\001 \002(\0132\023.TSK.CommandArchive\022\026\n\016markup_v"
  "isible\030\002 \001(\010\022\031\n\021deletions_visible\030\003 \001(\010\022"
  " \n\030selection_range_location\030\004 \001(\r\022\036\n\026sel"
  "ection_range_length\030\005 \001(\r\"\227\001\n\032TrackChang"
  "esCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Co"
  "mmandArchive\022\025\n\rtrack_changes\030\002 \001(\010\022.\n\026c"
  "hange_session_history\030\003 \003(\0132\016.TSP.Refere"
  "nce\022\016\n\006paused\030\004 \001(\010\"c\n!DocumentHyphenati"
  "onCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Co"
  "mmandArchive\022\032\n\022hyphenate_document\030\002 \001(\010"
  "\"\\\n\037DocumentLigaturesCommandArchive\022\"\n\005s"
  "uper\030\001 \002(\0132\023.TSK.CommandArchive\022\025\n\ruse_l"
  "igatures\030\002 \001(\010\"U\n\035DocumentHasBodyCommand"
  "Archive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArch"
  "ive\022\020\n\010has_body\030\002 \001(\010\"W\n!PauseChangeTrac"
  "kingCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK."
  "CommandArchive\022\016\n\006paused\030\002 \001(\010"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TPCommandArchives_2eproto_deps[8] = {
  &::descriptor_table_TPArchives_2eproto,
  &::descriptor_table_TSAArchives_2eproto,
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
  &::descriptor_table_TSWPArchives_2eproto,
  &::descriptor_table_TSWPCommandArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TPCommandArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TPCommandArchives_2eproto = {
    false, false, 7470, descriptor_table_protodef_TPCommandArchives_2eproto,
    "TPCommandArchives.proto",
    &descriptor_table_TPCommandArchives_2eproto_once, descriptor_table_TPCommandArchives_2eproto_deps, 8, 42,
    schemas, file_default_instances, TableStruct_TPCommandArchives_2eproto::offsets,
    file_level_metadata_TPCommandArchives_2eproto, file_level_enum_descriptors_TPCommandArchives_2eproto,
    file_level_service_descriptors_TPCommandArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TPCommandArchives_2eproto_getter() {
  return &descriptor_table_TPCommandArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TPCommandArchives_2eproto(&descriptor_table_TPCommandArchives_2eproto);
namespace TP {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[0];
}
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::kTPHeaderType;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::kTPFooterType;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFooterType_MIN;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFooterType_MAX;
constexpr int ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFooterType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[1];
}
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::kTPHeaderLeft;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::kTPHeaderCenter;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::kTPHeaderRight;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFragmentIndex_MIN;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFragmentIndex_MAX;
constexpr int ChangeHeaderFooterVisibilityCommandArchive::TPHeaderFragmentIndex_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeSectionMarginsCommandArchive_SectionMargin_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[2];
}
bool ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginLeft;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginRight;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginTop;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginBottom;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginHeader;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::kSectionMarginFooter;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::SectionMargin_MIN;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::SectionMargin_MAX;
constexpr int ChangeSectionMarginsCommandArchive::SectionMargin_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[3];
}
bool ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::kFootnoteFormatNumeric;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::kFootnoteFormatRoman;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::kFootnoteFormatSymbolic;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::kFootnoteFormatJapaneseNumeric;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::kFootnoteFormatJapaneseIdeographic;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::FootnoteFormat_MIN;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::FootnoteFormat_MAX;
constexpr int ChangeFootnoteFormatCommandArchive::FootnoteFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[4];
}
bool ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::kFootnoteKindFootnotes;
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::kFootnoteKindDocumentEndnotes;
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::kFootnoteKindSectionEndnotes;
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::FootnoteKind_MIN;
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::FootnoteKind_MAX;
constexpr int ChangeFootnoteKindCommandArchive::FootnoteKind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TPCommandArchives_2eproto);
  return file_level_enum_descriptors_TPCommandArchives_2eproto[5];
}
bool ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::kFootnoteNumberingContinuous;
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::kFootnoteNumberingRestartEachPage;
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::kFootnoteNumberingRestartEachSection;
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::FootnoteNumbering_MIN;
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::FootnoteNumbering_MAX;
constexpr int ChangeFootnoteNumberingCommandArchive::FootnoteNumbering_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class InsertDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forpaste(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
InsertDrawablesCommandArchive::_Internal::super(const InsertDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void InsertDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertDrawablesCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
InsertDrawablesCommandArchive::InsertDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.InsertDrawablesCommandArchive)
}
InsertDrawablesCommandArchive::InsertDrawablesCommandArchive(const InsertDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.page_index_){}
    , decltype(_impl_.z_order_){}
    , decltype(_impl_.forpaste_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.page_index_, &from._impl_.page_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.forpaste_) -
    reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.forpaste_));
  // @@protoc_insertion_point(copy_constructor:TP.InsertDrawablesCommandArchive)
}

inline void InsertDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.page_index_){0u}
    , decltype(_impl_.z_order_){0u}
    , decltype(_impl_.forpaste_){false}
  };
}

InsertDrawablesCommandArchive::~InsertDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.InsertDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void InsertDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.InsertDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.page_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.forpaste_) -
        reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.forpaste_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 page_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 z_order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference drawables = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool forPaste = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_forpaste(&has_bits);
          _impl_.forpaste_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.InsertDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 page_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_page_index(), target);
  }

  // optional uint32 z_order = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_z_order(), target);
  }

  // repeated .TSP.Reference drawables = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool forPaste = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_forpaste(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.InsertDrawablesCommandArchive)
  return target;
}

size_t InsertDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.InsertDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference drawables = 4;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 page_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
    }

    // optional uint32 z_order = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order());
    }

    // optional bool forPaste = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void InsertDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.InsertDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_order_ = from._impl_.z_order_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.forpaste_ = from._impl_.forpaste_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertDrawablesCommandArchive::CopyFrom(const InsertDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.InsertDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void InsertDrawablesCommandArchive::InternalSwap(InsertDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertDrawablesCommandArchive, _impl_.forpaste_)
      + sizeof(InsertDrawablesCommandArchive::_impl_.forpaste_)
      - PROTOBUF_FIELD_OFFSET(InsertDrawablesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[0]);
}

// ===================================================================

class PasteDrawablesCommandArchive_DrawableAndPage::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteDrawablesCommandArchive_DrawableAndPage>()._impl_._has_bits_);
  static const ::TSP::Reference& drawable(const PasteDrawablesCommandArchive_DrawableAndPage* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
PasteDrawablesCommandArchive_DrawableAndPage::_Internal::drawable(const PasteDrawablesCommandArchive_DrawableAndPage* msg) {
  return *msg->_impl_.drawable_;
}
void PasteDrawablesCommandArchive_DrawableAndPage::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PasteDrawablesCommandArchive_DrawableAndPage::PasteDrawablesCommandArchive_DrawableAndPage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.PasteDrawablesCommandArchive.DrawableAndPage)
}
PasteDrawablesCommandArchive_DrawableAndPage::PasteDrawablesCommandArchive_DrawableAndPage(const PasteDrawablesCommandArchive_DrawableAndPage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteDrawablesCommandArchive_DrawableAndPage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.page_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  _this->_impl_.page_index_ = from._impl_.page_index_;
  // @@protoc_insertion_point(copy_constructor:TP.PasteDrawablesCommandArchive.DrawableAndPage)
}

inline void PasteDrawablesCommandArchive_DrawableAndPage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.page_index_){0u}
  };
}

PasteDrawablesCommandArchive_DrawableAndPage::~PasteDrawablesCommandArchive_DrawableAndPage() {
  // @@protoc_insertion_point(destructor:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteDrawablesCommandArchive_DrawableAndPage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_;
}

void PasteDrawablesCommandArchive_DrawableAndPage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteDrawablesCommandArchive_DrawableAndPage::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
    _impl_.drawable_->Clear();
  }
  _impl_.page_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteDrawablesCommandArchive_DrawableAndPage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference drawable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 page_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteDrawablesCommandArchive_DrawableAndPage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference drawable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional uint32 page_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_page_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  return target;
}

size_t PasteDrawablesCommandArchive_DrawableAndPage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference drawable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional uint32 page_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteDrawablesCommandArchive_DrawableAndPage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteDrawablesCommandArchive_DrawableAndPage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteDrawablesCommandArchive_DrawableAndPage::GetClassData() const { return &_class_data_; }


void PasteDrawablesCommandArchive_DrawableAndPage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteDrawablesCommandArchive_DrawableAndPage*>(&to_msg);
  auto& from = static_cast<const PasteDrawablesCommandArchive_DrawableAndPage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteDrawablesCommandArchive_DrawableAndPage::CopyFrom(const PasteDrawablesCommandArchive_DrawableAndPage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.PasteDrawablesCommandArchive.DrawableAndPage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteDrawablesCommandArchive_DrawableAndPage::IsInitialized() const {
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  return true;
}

void PasteDrawablesCommandArchive_DrawableAndPage::InternalSwap(PasteDrawablesCommandArchive_DrawableAndPage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasteDrawablesCommandArchive_DrawableAndPage, _impl_.page_index_)
      + sizeof(PasteDrawablesCommandArchive_DrawableAndPage::_impl_.page_index_)
      - PROTOBUF_FIELD_OFFSET(PasteDrawablesCommandArchive_DrawableAndPage, _impl_.drawable_)>(
          reinterpret_cast<char*>(&_impl_.drawable_),
          reinterpret_cast<char*>(&other->_impl_.drawable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteDrawablesCommandArchive_DrawableAndPage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[1]);
}

// ===================================================================

class PasteDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const PasteDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
PasteDrawablesCommandArchive::_Internal::super(const PasteDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void PasteDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PasteDrawablesCommandArchive::PasteDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.PasteDrawablesCommandArchive)
}
PasteDrawablesCommandArchive::PasteDrawablesCommandArchive(const PasteDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.PasteDrawablesCommandArchive)
}

inline void PasteDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

PasteDrawablesCommandArchive::~PasteDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.PasteDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void PasteDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.PasteDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.PasteDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.PasteDrawablesCommandArchive)
  return target;
}

size_t PasteDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.PasteDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void PasteDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const PasteDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.PasteDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteDrawablesCommandArchive::CopyFrom(const PasteDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.PasteDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void PasteDrawablesCommandArchive::InternalSwap(PasteDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[2]);
}

// ===================================================================

class PasteAnchoredDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteAnchoredDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandGroupArchive& deprecated_super(const PasteAnchoredDrawablesCommandArchive* msg);
  static void set_has_deprecated_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSK::CommandArchive& super(const PasteAnchoredDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_select(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& deprecated_undo_selection(const PasteAnchoredDrawablesCommandArchive* msg);
  static void set_has_deprecated_undo_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& canvas_selection(const PasteAnchoredDrawablesCommandArchive* msg);
  static void set_has_canvas_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandGroupArchive&
PasteAnchoredDrawablesCommandArchive::_Internal::deprecated_super(const PasteAnchoredDrawablesCommandArchive* msg) {
  return *msg->_impl_.deprecated_super_;
}
const ::TSK::CommandArchive&
PasteAnchoredDrawablesCommandArchive::_Internal::super(const PasteAnchoredDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
PasteAnchoredDrawablesCommandArchive::_Internal::deprecated_undo_selection(const PasteAnchoredDrawablesCommandArchive* msg) {
  return *msg->_impl_.deprecated_undo_selection_;
}
const ::TSP::Reference&
PasteAnchoredDrawablesCommandArchive::_Internal::canvas_selection(const PasteAnchoredDrawablesCommandArchive* msg) {
  return *msg->_impl_.canvas_selection_;
}
void PasteAnchoredDrawablesCommandArchive::clear_deprecated_super() {
  if (_impl_.deprecated_super_ != nullptr) _impl_.deprecated_super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PasteAnchoredDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PasteAnchoredDrawablesCommandArchive::clear_deprecated_undo_selection() {
  if (_impl_.deprecated_undo_selection_ != nullptr) _impl_.deprecated_undo_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PasteAnchoredDrawablesCommandArchive::clear_canvas_selection() {
  if (_impl_.canvas_selection_ != nullptr) _impl_.canvas_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PasteAnchoredDrawablesCommandArchive::PasteAnchoredDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.PasteAnchoredDrawablesCommandArchive)
}
PasteAnchoredDrawablesCommandArchive::PasteAnchoredDrawablesCommandArchive(const PasteAnchoredDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteAnchoredDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_super_){nullptr}
    , decltype(_impl_.deprecated_undo_selection_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.canvas_selection_){nullptr}
    , decltype(_impl_.select_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_deprecated_super()) {
    _this->_impl_.deprecated_super_ = new ::TSK::CommandGroupArchive(*from._impl_.deprecated_super_);
  }
  if (from._internal_has_deprecated_undo_selection()) {
    _this->_impl_.deprecated_undo_selection_ = new ::TSP::Reference(*from._impl_.deprecated_undo_selection_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_canvas_selection()) {
    _this->_impl_.canvas_selection_ = new ::TSP::Reference(*from._impl_.canvas_selection_);
  }
  _this->_impl_.select_ = from._impl_.select_;
  // @@protoc_insertion_point(copy_constructor:TP.PasteAnchoredDrawablesCommandArchive)
}

inline void PasteAnchoredDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_super_){nullptr}
    , decltype(_impl_.deprecated_undo_selection_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.canvas_selection_){nullptr}
    , decltype(_impl_.select_){false}
  };
}

PasteAnchoredDrawablesCommandArchive::~PasteAnchoredDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.PasteAnchoredDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteAnchoredDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.deprecated_super_;
  if (this != internal_default_instance()) delete _impl_.deprecated_undo_selection_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.canvas_selection_;
}

void PasteAnchoredDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteAnchoredDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.PasteAnchoredDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.deprecated_super_ != nullptr);
      _impl_.deprecated_super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.deprecated_undo_selection_ != nullptr);
      _impl_.deprecated_undo_selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.canvas_selection_ != nullptr);
      _impl_.canvas_selection_->Clear();
    }
  }
  _impl_.select_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteAnchoredDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandGroupArchive deprecated_super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_deprecated_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool select = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_select(&has_bits);
          _impl_.select_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference deprecated_undo_selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_deprecated_undo_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.CommandArchive super = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference canvas_selection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_canvas_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteAnchoredDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.PasteAnchoredDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandGroupArchive deprecated_super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::deprecated_super(this),
        _Internal::deprecated_super(this).GetCachedSize(), target, stream);
  }

  // optional bool select = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_select(), target);
  }

  // optional .TSP.Reference deprecated_undo_selection = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::deprecated_undo_selection(this),
        _Internal::deprecated_undo_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.CommandArchive super = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference canvas_selection = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::canvas_selection(this),
        _Internal::canvas_selection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.PasteAnchoredDrawablesCommandArchive)
  return target;
}

size_t PasteAnchoredDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.PasteAnchoredDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandGroupArchive deprecated_super = 1;
  if (_internal_has_deprecated_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.deprecated_super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSP.Reference deprecated_undo_selection = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deprecated_undo_selection_);
    }

    // optional .TSK.CommandArchive super = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference canvas_selection = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.canvas_selection_);
    }

    // optional bool select = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteAnchoredDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteAnchoredDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteAnchoredDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void PasteAnchoredDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteAnchoredDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const PasteAnchoredDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.PasteAnchoredDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_deprecated_super()->::TSK::CommandGroupArchive::MergeFrom(
          from._internal_deprecated_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_deprecated_undo_selection()->::TSP::Reference::MergeFrom(
          from._internal_deprecated_undo_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_canvas_selection()->::TSP::Reference::MergeFrom(
          from._internal_canvas_selection());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.select_ = from._impl_.select_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteAnchoredDrawablesCommandArchive::CopyFrom(const PasteAnchoredDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.PasteAnchoredDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteAnchoredDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_deprecated_super()) {
    if (!_impl_.deprecated_super_->IsInitialized()) return false;
  }
  if (_internal_has_deprecated_undo_selection()) {
    if (!_impl_.deprecated_undo_selection_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_canvas_selection()) {
    if (!_impl_.canvas_selection_->IsInitialized()) return false;
  }
  return true;
}

void PasteAnchoredDrawablesCommandArchive::InternalSwap(PasteAnchoredDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasteAnchoredDrawablesCommandArchive, _impl_.select_)
      + sizeof(PasteAnchoredDrawablesCommandArchive::_impl_.select_)
      - PROTOBUF_FIELD_OFFSET(PasteAnchoredDrawablesCommandArchive, _impl_.deprecated_super_)>(
          reinterpret_cast<char*>(&_impl_.deprecated_super_),
          reinterpret_cast<char*>(&other->_impl_.deprecated_super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteAnchoredDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[3]);
}

// ===================================================================

class MoveDrawablesPageIndexCommandArchive_Drawable::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesPageIndexCommandArchive_Drawable>()._impl_._has_bits_);
  static const ::TSP::Reference& drawable(const MoveDrawablesPageIndexCommandArchive_Drawable* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
MoveDrawablesPageIndexCommandArchive_Drawable::_Internal::drawable(const MoveDrawablesPageIndexCommandArchive_Drawable* msg) {
  return *msg->_impl_.drawable_;
}
void MoveDrawablesPageIndexCommandArchive_Drawable::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
MoveDrawablesPageIndexCommandArchive_Drawable::MoveDrawablesPageIndexCommandArchive_Drawable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
}
MoveDrawablesPageIndexCommandArchive_Drawable::MoveDrawablesPageIndexCommandArchive_Drawable(const MoveDrawablesPageIndexCommandArchive_Drawable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesPageIndexCommandArchive_Drawable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.z_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  _this->_impl_.z_order_ = from._impl_.z_order_;
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
}

inline void MoveDrawablesPageIndexCommandArchive_Drawable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.z_order_){0u}
  };
}

MoveDrawablesPageIndexCommandArchive_Drawable::~MoveDrawablesPageIndexCommandArchive_Drawable() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesPageIndexCommandArchive_Drawable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_;
}

void MoveDrawablesPageIndexCommandArchive_Drawable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesPageIndexCommandArchive_Drawable::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
    _impl_.drawable_->Clear();
  }
  _impl_.z_order_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesPageIndexCommandArchive_Drawable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference drawable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 z_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesPageIndexCommandArchive_Drawable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference drawable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional uint32 z_order = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_z_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  return target;
}

size_t MoveDrawablesPageIndexCommandArchive_Drawable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference drawable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional uint32 z_order = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesPageIndexCommandArchive_Drawable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesPageIndexCommandArchive_Drawable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesPageIndexCommandArchive_Drawable::GetClassData() const { return &_class_data_; }


void MoveDrawablesPageIndexCommandArchive_Drawable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesPageIndexCommandArchive_Drawable*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesPageIndexCommandArchive_Drawable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.z_order_ = from._impl_.z_order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesPageIndexCommandArchive_Drawable::CopyFrom(const MoveDrawablesPageIndexCommandArchive_Drawable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesPageIndexCommandArchive_Drawable::IsInitialized() const {
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesPageIndexCommandArchive_Drawable::InternalSwap(MoveDrawablesPageIndexCommandArchive_Drawable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesPageIndexCommandArchive_Drawable, _impl_.z_order_)
      + sizeof(MoveDrawablesPageIndexCommandArchive_Drawable::_impl_.z_order_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesPageIndexCommandArchive_Drawable, _impl_.drawable_)>(
          reinterpret_cast<char*>(&_impl_.drawable_),
          reinterpret_cast<char*>(&other->_impl_.drawable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesPageIndexCommandArchive_Drawable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[4]);
}

// ===================================================================

class MoveDrawablesPageIndexCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesPageIndexCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveDrawablesPageIndexCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveDrawablesPageIndexCommandArchive::_Internal::super(const MoveDrawablesPageIndexCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void MoveDrawablesPageIndexCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
MoveDrawablesPageIndexCommandArchive::MoveDrawablesPageIndexCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesPageIndexCommandArchive)
}
MoveDrawablesPageIndexCommandArchive::MoveDrawablesPageIndexCommandArchive(const MoveDrawablesPageIndexCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesPageIndexCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.page_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.page_index_ = from._impl_.page_index_;
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesPageIndexCommandArchive)
}

inline void MoveDrawablesPageIndexCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.page_index_){0u}
  };
}

MoveDrawablesPageIndexCommandArchive::~MoveDrawablesPageIndexCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesPageIndexCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesPageIndexCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void MoveDrawablesPageIndexCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesPageIndexCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesPageIndexCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.page_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesPageIndexCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 page_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesPageIndexCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesPageIndexCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 page_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_page_index(), target);
  }

  // repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesPageIndexCommandArchive)
  return target;
}

size_t MoveDrawablesPageIndexCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesPageIndexCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 page_index = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesPageIndexCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesPageIndexCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesPageIndexCommandArchive::GetClassData() const { return &_class_data_; }


void MoveDrawablesPageIndexCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesPageIndexCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesPageIndexCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesPageIndexCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesPageIndexCommandArchive::CopyFrom(const MoveDrawablesPageIndexCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesPageIndexCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesPageIndexCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesPageIndexCommandArchive::InternalSwap(MoveDrawablesPageIndexCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesPageIndexCommandArchive, _impl_.page_index_)
      + sizeof(MoveDrawablesPageIndexCommandArchive::_impl_.page_index_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesPageIndexCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesPageIndexCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[5]);
}

// ===================================================================

class InsertSectionBreakCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertSectionBreakCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const InsertSectionBreakCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::TextCommandArchive&
InsertSectionBreakCommandArchive::_Internal::super(const InsertSectionBreakCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void InsertSectionBreakCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
InsertSectionBreakCommandArchive::InsertSectionBreakCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.InsertSectionBreakCommandArchive)
}
InsertSectionBreakCommandArchive::InsertSectionBreakCommandArchive(const InsertSectionBreakCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertSectionBreakCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.InsertSectionBreakCommandArchive)
}

inline void InsertSectionBreakCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

InsertSectionBreakCommandArchive::~InsertSectionBreakCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.InsertSectionBreakCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertSectionBreakCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void InsertSectionBreakCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertSectionBreakCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.InsertSectionBreakCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertSectionBreakCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertSectionBreakCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.InsertSectionBreakCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.InsertSectionBreakCommandArchive)
  return target;
}

size_t InsertSectionBreakCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.InsertSectionBreakCommandArchive)
  size_t total_size = 0;

  // required .TSWP.TextCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertSectionBreakCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertSectionBreakCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertSectionBreakCommandArchive::GetClassData() const { return &_class_data_; }


void InsertSectionBreakCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertSectionBreakCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertSectionBreakCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.InsertSectionBreakCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertSectionBreakCommandArchive::CopyFrom(const InsertSectionBreakCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.InsertSectionBreakCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertSectionBreakCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void InsertSectionBreakCommandArchive::InternalSwap(InsertSectionBreakCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertSectionBreakCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[6]);
}

// ===================================================================

class DeleteSectionCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteSectionCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DeleteSectionCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DeleteSectionCommandArchive::_Internal::super(const DeleteSectionCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void DeleteSectionCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DeleteSectionCommandArchive::DeleteSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.DeleteSectionCommandArchive)
}
DeleteSectionCommandArchive::DeleteSectionCommandArchive(const DeleteSectionCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteSectionCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.DeleteSectionCommandArchive)
}

inline void DeleteSectionCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

DeleteSectionCommandArchive::~DeleteSectionCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.DeleteSectionCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteSectionCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DeleteSectionCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteSectionCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.DeleteSectionCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteSectionCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteSectionCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.DeleteSectionCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.DeleteSectionCommandArchive)
  return target;
}

size_t DeleteSectionCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.DeleteSectionCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteSectionCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteSectionCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteSectionCommandArchive::GetClassData() const { return &_class_data_; }


void DeleteSectionCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteSectionCommandArchive*>(&to_msg);
  auto& from = static_cast<const DeleteSectionCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.DeleteSectionCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteSectionCommandArchive::CopyFrom(const DeleteSectionCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.DeleteSectionCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteSectionCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DeleteSectionCommandArchive::InternalSwap(DeleteSectionCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteSectionCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[7]);
}

// ===================================================================

class ReplaceSectionCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceSectionCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const ReplaceSectionCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::TextCommandArchive&
ReplaceSectionCommandArchive::_Internal::super(const ReplaceSectionCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ReplaceSectionCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ReplaceSectionCommandArchive::ReplaceSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ReplaceSectionCommandArchive)
}
ReplaceSectionCommandArchive::ReplaceSectionCommandArchive(const ReplaceSectionCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceSectionCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.ReplaceSectionCommandArchive)
}

inline void ReplaceSectionCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ReplaceSectionCommandArchive::~ReplaceSectionCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ReplaceSectionCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceSectionCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ReplaceSectionCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceSectionCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ReplaceSectionCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceSectionCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceSectionCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ReplaceSectionCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ReplaceSectionCommandArchive)
  return target;
}

size_t ReplaceSectionCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ReplaceSectionCommandArchive)
  size_t total_size = 0;

  // required .TSWP.TextCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceSectionCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceSectionCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceSectionCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceSectionCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceSectionCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceSectionCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ReplaceSectionCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceSectionCommandArchive::CopyFrom(const ReplaceSectionCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ReplaceSectionCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceSectionCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceSectionCommandArchive::InternalSwap(ReplaceSectionCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceSectionCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[8]);
}

// ===================================================================

class ChangeSectionPropertyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeSectionPropertyCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeSectionPropertyCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_section_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_section_property(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_section_value_bool(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeSectionPropertyCommandArchive::_Internal::super(const ChangeSectionPropertyCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeSectionPropertyCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ChangeSectionPropertyCommandArchive::ChangeSectionPropertyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeSectionPropertyCommandArchive)
}
ChangeSectionPropertyCommandArchive::ChangeSectionPropertyCommandArchive(const ChangeSectionPropertyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeSectionPropertyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.section_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_index_){}
    , decltype(_impl_.section_value_bool_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.section_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.section_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_section_property()) {
    _this->_impl_.section_property_.Set(from._internal_section_property(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.section_index_, &from._impl_.section_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.section_value_bool_) -
    reinterpret_cast<char*>(&_impl_.section_index_)) + sizeof(_impl_.section_value_bool_));
  // @@protoc_insertion_point(copy_constructor:TP.ChangeSectionPropertyCommandArchive)
}

inline void ChangeSectionPropertyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.section_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_index_){0u}
    , decltype(_impl_.section_value_bool_){false}
  };
  _impl_.section_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.section_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChangeSectionPropertyCommandArchive::~ChangeSectionPropertyCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeSectionPropertyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeSectionPropertyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.section_property_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeSectionPropertyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeSectionPropertyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeSectionPropertyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.section_property_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.section_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.section_value_bool_) -
        reinterpret_cast<char*>(&_impl_.section_index_)) + sizeof(_impl_.section_value_bool_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeSectionPropertyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 section_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_section_index(&has_bits);
          _impl_.section_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string section_property = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_section_property();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TP.ChangeSectionPropertyCommandArchive.section_property");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool section_value_bool = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_section_value_bool(&has_bits);
          _impl_.section_value_bool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeSectionPropertyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeSectionPropertyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 section_index = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_section_index(), target);
  }

  // optional string section_property = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_section_property().data(), static_cast<int>(this->_internal_section_property().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TP.ChangeSectionPropertyCommandArchive.section_property");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_section_property(), target);
  }

  // optional bool section_value_bool = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_section_value_bool(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeSectionPropertyCommandArchive)
  return target;
}

size_t ChangeSectionPropertyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeSectionPropertyCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string section_property = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_section_property());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional uint32 section_index = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_section_index());
    }

    // optional bool section_value_bool = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeSectionPropertyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeSectionPropertyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeSectionPropertyCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeSectionPropertyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeSectionPropertyCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeSectionPropertyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeSectionPropertyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_section_property(from._internal_section_property());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.section_index_ = from._impl_.section_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.section_value_bool_ = from._impl_.section_value_bool_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeSectionPropertyCommandArchive::CopyFrom(const ChangeSectionPropertyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeSectionPropertyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeSectionPropertyCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeSectionPropertyCommandArchive::InternalSwap(ChangeSectionPropertyCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.section_property_, lhs_arena,
      &other->_impl_.section_property_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeSectionPropertyCommandArchive, _impl_.section_value_bool_)
      + sizeof(ChangeSectionPropertyCommandArchive::_impl_.section_value_bool_)
      - PROTOBUF_FIELD_OFFSET(ChangeSectionPropertyCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeSectionPropertyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[9]);
}

// ===================================================================

class SwapDrawableZOrderCommandArchive_SwapPair::_Internal {
 public:
  using HasBits = decltype(std::declval<SwapDrawableZOrderCommandArchive_SwapPair>()._impl_._has_bits_);
  static void set_has_z_order_1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_z_order_2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SwapDrawableZOrderCommandArchive_SwapPair::SwapDrawableZOrderCommandArchive_SwapPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.SwapDrawableZOrderCommandArchive.SwapPair)
}
SwapDrawableZOrderCommandArchive_SwapPair::SwapDrawableZOrderCommandArchive_SwapPair(const SwapDrawableZOrderCommandArchive_SwapPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SwapDrawableZOrderCommandArchive_SwapPair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.z_order_1_){}
    , decltype(_impl_.z_order_2_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.z_order_1_, &from._impl_.z_order_1_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_order_2_) -
    reinterpret_cast<char*>(&_impl_.z_order_1_)) + sizeof(_impl_.z_order_2_));
  // @@protoc_insertion_point(copy_constructor:TP.SwapDrawableZOrderCommandArchive.SwapPair)
}

inline void SwapDrawableZOrderCommandArchive_SwapPair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.z_order_1_){0u}
    , decltype(_impl_.z_order_2_){0u}
  };
}

SwapDrawableZOrderCommandArchive_SwapPair::~SwapDrawableZOrderCommandArchive_SwapPair() {
  // @@protoc_insertion_point(destructor:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SwapDrawableZOrderCommandArchive_SwapPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SwapDrawableZOrderCommandArchive_SwapPair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SwapDrawableZOrderCommandArchive_SwapPair::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.z_order_1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_order_2_) -
        reinterpret_cast<char*>(&_impl_.z_order_1_)) + sizeof(_impl_.z_order_2_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SwapDrawableZOrderCommandArchive_SwapPair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 z_order_1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_z_order_1(&has_bits);
          _impl_.z_order_1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 z_order_2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_z_order_2(&has_bits);
          _impl_.z_order_2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SwapDrawableZOrderCommandArchive_SwapPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 z_order_1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_z_order_1(), target);
  }

  // required uint32 z_order_2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_z_order_2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  return target;
}

size_t SwapDrawableZOrderCommandArchive_SwapPair::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  size_t total_size = 0;

  if (_internal_has_z_order_1()) {
    // required uint32 z_order_1 = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order_1());
  }

  if (_internal_has_z_order_2()) {
    // required uint32 z_order_2 = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order_2());
  }

  return total_size;
}
size_t SwapDrawableZOrderCommandArchive_SwapPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 z_order_1 = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order_1());

    // required uint32 z_order_2 = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order_2());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SwapDrawableZOrderCommandArchive_SwapPair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SwapDrawableZOrderCommandArchive_SwapPair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SwapDrawableZOrderCommandArchive_SwapPair::GetClassData() const { return &_class_data_; }


void SwapDrawableZOrderCommandArchive_SwapPair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SwapDrawableZOrderCommandArchive_SwapPair*>(&to_msg);
  auto& from = static_cast<const SwapDrawableZOrderCommandArchive_SwapPair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.z_order_1_ = from._impl_.z_order_1_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.z_order_2_ = from._impl_.z_order_2_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SwapDrawableZOrderCommandArchive_SwapPair::CopyFrom(const SwapDrawableZOrderCommandArchive_SwapPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.SwapDrawableZOrderCommandArchive.SwapPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwapDrawableZOrderCommandArchive_SwapPair::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SwapDrawableZOrderCommandArchive_SwapPair::InternalSwap(SwapDrawableZOrderCommandArchive_SwapPair* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SwapDrawableZOrderCommandArchive_SwapPair, _impl_.z_order_2_)
      + sizeof(SwapDrawableZOrderCommandArchive_SwapPair::_impl_.z_order_2_)
      - PROTOBUF_FIELD_OFFSET(SwapDrawableZOrderCommandArchive_SwapPair, _impl_.z_order_1_)>(
          reinterpret_cast<char*>(&_impl_.z_order_1_),
          reinterpret_cast<char*>(&other->_impl_.z_order_1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SwapDrawableZOrderCommandArchive_SwapPair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[10]);
}

// ===================================================================

class SwapDrawableZOrderCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SwapDrawableZOrderCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const SwapDrawableZOrderCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
SwapDrawableZOrderCommandArchive::_Internal::super(const SwapDrawableZOrderCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void SwapDrawableZOrderCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SwapDrawableZOrderCommandArchive::SwapDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.SwapDrawableZOrderCommandArchive)
}
SwapDrawableZOrderCommandArchive::SwapDrawableZOrderCommandArchive(const SwapDrawableZOrderCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SwapDrawableZOrderCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.swap_pairs_){from._impl_.swap_pairs_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.SwapDrawableZOrderCommandArchive)
}

inline void SwapDrawableZOrderCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.swap_pairs_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

SwapDrawableZOrderCommandArchive::~SwapDrawableZOrderCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.SwapDrawableZOrderCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SwapDrawableZOrderCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.swap_pairs_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void SwapDrawableZOrderCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SwapDrawableZOrderCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.SwapDrawableZOrderCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.swap_pairs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SwapDrawableZOrderCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_swap_pairs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SwapDrawableZOrderCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.SwapDrawableZOrderCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_swap_pairs_size()); i < n; i++) {
    const auto& repfield = this->_internal_swap_pairs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.SwapDrawableZOrderCommandArchive)
  return target;
}

size_t SwapDrawableZOrderCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.SwapDrawableZOrderCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
  total_size += 1UL * this->_internal_swap_pairs_size();
  for (const auto& msg : this->_impl_.swap_pairs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SwapDrawableZOrderCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SwapDrawableZOrderCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SwapDrawableZOrderCommandArchive::GetClassData() const { return &_class_data_; }


void SwapDrawableZOrderCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SwapDrawableZOrderCommandArchive*>(&to_msg);
  auto& from = static_cast<const SwapDrawableZOrderCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.SwapDrawableZOrderCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.swap_pairs_.MergeFrom(from._impl_.swap_pairs_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SwapDrawableZOrderCommandArchive::CopyFrom(const SwapDrawableZOrderCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.SwapDrawableZOrderCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SwapDrawableZOrderCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.swap_pairs_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void SwapDrawableZOrderCommandArchive::InternalSwap(SwapDrawableZOrderCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.swap_pairs_.InternalSwap(&other->_impl_.swap_pairs_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SwapDrawableZOrderCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[11]);
}

// ===================================================================

class RemoveDrawablesCommandArchive_DrawableInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveDrawablesCommandArchive_DrawableInfo>()._impl_._has_bits_);
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& drawable_object(const RemoveDrawablesCommandArchive_DrawableInfo* msg);
  static void set_has_drawable_object(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
RemoveDrawablesCommandArchive_DrawableInfo::_Internal::drawable_object(const RemoveDrawablesCommandArchive_DrawableInfo* msg) {
  return *msg->_impl_.drawable_object_;
}
void RemoveDrawablesCommandArchive_DrawableInfo::clear_drawable_object() {
  if (_impl_.drawable_object_ != nullptr) _impl_.drawable_object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RemoveDrawablesCommandArchive_DrawableInfo::RemoveDrawablesCommandArchive_DrawableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.RemoveDrawablesCommandArchive.DrawableInfo)
}
RemoveDrawablesCommandArchive_DrawableInfo::RemoveDrawablesCommandArchive_DrawableInfo(const RemoveDrawablesCommandArchive_DrawableInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveDrawablesCommandArchive_DrawableInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_object_){nullptr}
    , decltype(_impl_.page_index_){}
    , decltype(_impl_.z_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable_object()) {
    _this->_impl_.drawable_object_ = new ::TSP::Reference(*from._impl_.drawable_object_);
  }
  ::memcpy(&_impl_.page_index_, &from._impl_.page_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_order_) -
    reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.z_order_));
  // @@protoc_insertion_point(copy_constructor:TP.RemoveDrawablesCommandArchive.DrawableInfo)
}

inline void RemoveDrawablesCommandArchive_DrawableInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_object_){nullptr}
    , decltype(_impl_.page_index_){0u}
    , decltype(_impl_.z_order_){0}
  };
}

RemoveDrawablesCommandArchive_DrawableInfo::~RemoveDrawablesCommandArchive_DrawableInfo() {
  // @@protoc_insertion_point(destructor:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveDrawablesCommandArchive_DrawableInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_object_;
}

void RemoveDrawablesCommandArchive_DrawableInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveDrawablesCommandArchive_DrawableInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.drawable_object_ != nullptr);
    _impl_.drawable_object_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.page_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_order_) -
        reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.z_order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveDrawablesCommandArchive_DrawableInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 page_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 z_order = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference drawable_object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveDrawablesCommandArchive_DrawableInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 page_index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_page_index(), target);
  }

  // optional int32 z_order = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_z_order(), target);
  }

  // optional .TSP.Reference drawable_object = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::drawable_object(this),
        _Internal::drawable_object(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  return target;
}

size_t RemoveDrawablesCommandArchive_DrawableInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Reference drawable_object = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_object_);
    }

    // optional uint32 page_index = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
    }

    // optional int32 z_order = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveDrawablesCommandArchive_DrawableInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveDrawablesCommandArchive_DrawableInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveDrawablesCommandArchive_DrawableInfo::GetClassData() const { return &_class_data_; }


void RemoveDrawablesCommandArchive_DrawableInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveDrawablesCommandArchive_DrawableInfo*>(&to_msg);
  auto& from = static_cast<const RemoveDrawablesCommandArchive_DrawableInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable_object()->::TSP::Reference::MergeFrom(
          from._internal_drawable_object());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_order_ = from._impl_.z_order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveDrawablesCommandArchive_DrawableInfo::CopyFrom(const RemoveDrawablesCommandArchive_DrawableInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.RemoveDrawablesCommandArchive.DrawableInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveDrawablesCommandArchive_DrawableInfo::IsInitialized() const {
  if (_internal_has_drawable_object()) {
    if (!_impl_.drawable_object_->IsInitialized()) return false;
  }
  return true;
}

void RemoveDrawablesCommandArchive_DrawableInfo::InternalSwap(RemoveDrawablesCommandArchive_DrawableInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveDrawablesCommandArchive_DrawableInfo, _impl_.z_order_)
      + sizeof(RemoveDrawablesCommandArchive_DrawableInfo::_impl_.z_order_)
      - PROTOBUF_FIELD_OFFSET(RemoveDrawablesCommandArchive_DrawableInfo, _impl_.drawable_object_)>(
          reinterpret_cast<char*>(&_impl_.drawable_object_),
          reinterpret_cast<char*>(&other->_impl_.drawable_object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveDrawablesCommandArchive_DrawableInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[12]);
}

// ===================================================================

class RemoveDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
RemoveDrawablesCommandArchive::_Internal::super(const RemoveDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void RemoveDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RemoveDrawablesCommandArchive::RemoveDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.RemoveDrawablesCommandArchive)
}
RemoveDrawablesCommandArchive::RemoveDrawablesCommandArchive(const RemoveDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.RemoveDrawablesCommandArchive)
}

inline void RemoveDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

RemoveDrawablesCommandArchive::~RemoveDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.RemoveDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void RemoveDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.RemoveDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.RemoveDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.RemoveDrawablesCommandArchive)
  return target;
}

size_t RemoveDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.RemoveDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.RemoveDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveDrawablesCommandArchive::CopyFrom(const RemoveDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.RemoveDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void RemoveDrawablesCommandArchive::InternalSwap(RemoveDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[13]);
}

// ===================================================================

class NudgeDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<NudgeDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const NudgeDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
NudgeDrawablesCommandArchive::_Internal::super(const NudgeDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void NudgeDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void NudgeDrawablesCommandArchive::clear_child_commands() {
  _impl_.child_commands_.Clear();
}
NudgeDrawablesCommandArchive::NudgeDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.NudgeDrawablesCommandArchive)
}
NudgeDrawablesCommandArchive::NudgeDrawablesCommandArchive(const NudgeDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NudgeDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_commands_){from._impl_.child_commands_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.NudgeDrawablesCommandArchive)
}

inline void NudgeDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.child_commands_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

NudgeDrawablesCommandArchive::~NudgeDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.NudgeDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NudgeDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.child_commands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void NudgeDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NudgeDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.NudgeDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.child_commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NudgeDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference child_commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_child_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NudgeDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.NudgeDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference child_commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_child_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_child_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.NudgeDrawablesCommandArchive)
  return target;
}

size_t NudgeDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.NudgeDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference child_commands = 2;
  total_size += 1UL * this->_internal_child_commands_size();
  for (const auto& msg : this->_impl_.child_commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NudgeDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NudgeDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NudgeDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void NudgeDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NudgeDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const NudgeDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.NudgeDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.child_commands_.MergeFrom(from._impl_.child_commands_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NudgeDrawablesCommandArchive::CopyFrom(const NudgeDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.NudgeDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NudgeDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.child_commands_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void NudgeDrawablesCommandArchive::InternalSwap(NudgeDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.child_commands_.InternalSwap(&other->_impl_.child_commands_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NudgeDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[14]);
}

// ===================================================================

class ChangeHeaderFooterVisibilityCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeHeaderFooterVisibilityCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeHeaderFooterVisibilityCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_index_to_select(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeHeaderFooterVisibilityCommandArchive::_Internal::super(const ChangeHeaderFooterVisibilityCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeHeaderFooterVisibilityCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ChangeHeaderFooterVisibilityCommandArchive::clear_storages() {
  _impl_.storages_.Clear();
}
ChangeHeaderFooterVisibilityCommandArchive::ChangeHeaderFooterVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeHeaderFooterVisibilityCommandArchive)
}
ChangeHeaderFooterVisibilityCommandArchive::ChangeHeaderFooterVisibilityCommandArchive(const ChangeHeaderFooterVisibilityCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeHeaderFooterVisibilityCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storages_){from._impl_.storages_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.visible_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.index_to_select_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.visible_, &from._impl_.visible_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.index_to_select_) -
    reinterpret_cast<char*>(&_impl_.visible_)) + sizeof(_impl_.index_to_select_));
  // @@protoc_insertion_point(copy_constructor:TP.ChangeHeaderFooterVisibilityCommandArchive)
}

inline void ChangeHeaderFooterVisibilityCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storages_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.visible_){false}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.index_to_select_){0}
  };
}

ChangeHeaderFooterVisibilityCommandArchive::~ChangeHeaderFooterVisibilityCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeHeaderFooterVisibilityCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeHeaderFooterVisibilityCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.storages_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeHeaderFooterVisibilityCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeHeaderFooterVisibilityCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeHeaderFooterVisibilityCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.storages_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.visible_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.index_to_select_) -
        reinterpret_cast<char*>(&_impl_.visible_)) + sizeof(_impl_.index_to_select_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeHeaderFooterVisibilityCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool visible = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_visible(&has_bits);
          _impl_.visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(val))) {
            _internal_set_type(static_cast<::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(val))) {
            _internal_set_index_to_select(static_cast<::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference storages = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_storages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeHeaderFooterVisibilityCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeHeaderFooterVisibilityCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool visible = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_visible(), target);
  }

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_index_to_select(), target);
  }

  // repeated .TSP.Reference storages = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_storages_size()); i < n; i++) {
    const auto& repfield = this->_internal_storages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeHeaderFooterVisibilityCommandArchive)
  return target;
}

size_t ChangeHeaderFooterVisibilityCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeHeaderFooterVisibilityCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference storages = 5;
  total_size += 1UL * this->_internal_storages_size();
  for (const auto& msg : this->_impl_.storages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bool visible = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_index_to_select());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeHeaderFooterVisibilityCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeHeaderFooterVisibilityCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeHeaderFooterVisibilityCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeHeaderFooterVisibilityCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeHeaderFooterVisibilityCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeHeaderFooterVisibilityCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeHeaderFooterVisibilityCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.storages_.MergeFrom(from._impl_.storages_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.visible_ = from._impl_.visible_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.index_to_select_ = from._impl_.index_to_select_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeHeaderFooterVisibilityCommandArchive::CopyFrom(const ChangeHeaderFooterVisibilityCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeHeaderFooterVisibilityCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeHeaderFooterVisibilityCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.storages_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeHeaderFooterVisibilityCommandArchive::InternalSwap(ChangeHeaderFooterVisibilityCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.storages_.InternalSwap(&other->_impl_.storages_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeHeaderFooterVisibilityCommandArchive, _impl_.index_to_select_)
      + sizeof(ChangeHeaderFooterVisibilityCommandArchive::_impl_.index_to_select_)
      - PROTOBUF_FIELD_OFFSET(ChangeHeaderFooterVisibilityCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeHeaderFooterVisibilityCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[15]);
}

// ===================================================================

class ChangeSectionMarginsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeSectionMarginsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeSectionMarginsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& section(const ChangeSectionMarginsCommandArchive* msg);
  static void set_has_section(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_margin_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeSectionMarginsCommandArchive::_Internal::super(const ChangeSectionMarginsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ChangeSectionMarginsCommandArchive::_Internal::section(const ChangeSectionMarginsCommandArchive* msg) {
  return *msg->_impl_.section_;
}
void ChangeSectionMarginsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ChangeSectionMarginsCommandArchive::clear_section() {
  if (_impl_.section_ != nullptr) _impl_.section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ChangeSectionMarginsCommandArchive::ChangeSectionMarginsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeSectionMarginsCommandArchive)
}
ChangeSectionMarginsCommandArchive::ChangeSectionMarginsCommandArchive(const ChangeSectionMarginsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeSectionMarginsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_){nullptr}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.margin_value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_section()) {
    _this->_impl_.section_ = new ::TSP::Reference(*from._impl_.section_);
  }
  ::memcpy(&_impl_.margin_, &from._impl_.margin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.margin_value_) -
    reinterpret_cast<char*>(&_impl_.margin_)) + sizeof(_impl_.margin_value_));
  // @@protoc_insertion_point(copy_constructor:TP.ChangeSectionMarginsCommandArchive)
}

inline void ChangeSectionMarginsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_){nullptr}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.margin_value_){0}
  };
}

ChangeSectionMarginsCommandArchive::~ChangeSectionMarginsCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeSectionMarginsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeSectionMarginsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.section_;
}

void ChangeSectionMarginsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeSectionMarginsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeSectionMarginsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.section_ != nullptr);
      _impl_.section_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.margin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.margin_value_) -
        reinterpret_cast<char*>(&_impl_.margin_)) + sizeof(_impl_.margin_value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeSectionMarginsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(val))) {
            _internal_set_margin(static_cast<::TP::ChangeSectionMarginsCommandArchive_SectionMargin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float margin_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_margin_value(&has_bits);
          _impl_.margin_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeSectionMarginsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeSectionMarginsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference section = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::section(this),
        _Internal::section(this).GetCachedSize(), target, stream);
  }

  // optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_margin(), target);
  }

  // optional float margin_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_margin_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeSectionMarginsCommandArchive)
  return target;
}

size_t ChangeSectionMarginsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeSectionMarginsCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference section = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.section_);
    }

    // optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_margin());
    }

    // optional float margin_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeSectionMarginsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeSectionMarginsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeSectionMarginsCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeSectionMarginsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeSectionMarginsCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeSectionMarginsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeSectionMarginsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_section()->::TSP::Reference::MergeFrom(
          from._internal_section());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.margin_value_ = from._impl_.margin_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeSectionMarginsCommandArchive::CopyFrom(const ChangeSectionMarginsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeSectionMarginsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeSectionMarginsCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_section()) {
    if (!_impl_.section_->IsInitialized()) return false;
  }
  return true;
}

void ChangeSectionMarginsCommandArchive::InternalSwap(ChangeSectionMarginsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeSectionMarginsCommandArchive, _impl_.margin_value_)
      + sizeof(ChangeSectionMarginsCommandArchive::_impl_.margin_value_)
      - PROTOBUF_FIELD_OFFSET(ChangeSectionMarginsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeSectionMarginsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[16]);
}

// ===================================================================

class ChangeDocumentPrinterOptionsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeDocumentPrinterOptionsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeDocumentPrinterOptionsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& obsolete_section(const ChangeDocumentPrinterOptionsCommandArchive* msg);
  static void set_has_obsolete_section(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_paper_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_paper_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_page_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_printer_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_paper_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeDocumentPrinterOptionsCommandArchive::_Internal::super(const ChangeDocumentPrinterOptionsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ChangeDocumentPrinterOptionsCommandArchive::_Internal::obsolete_section(const ChangeDocumentPrinterOptionsCommandArchive* msg) {
  return *msg->_impl_.obsolete_section_;
}
void ChangeDocumentPrinterOptionsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ChangeDocumentPrinterOptionsCommandArchive::clear_obsolete_section() {
  if (_impl_.obsolete_section_ != nullptr) _impl_.obsolete_section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ChangeDocumentPrinterOptionsCommandArchive::ChangeDocumentPrinterOptionsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeDocumentPrinterOptionsCommandArchive)
}
ChangeDocumentPrinterOptionsCommandArchive::ChangeDocumentPrinterOptionsCommandArchive(const ChangeDocumentPrinterOptionsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeDocumentPrinterOptionsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.printer_id_){}
    , decltype(_impl_.paper_id_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.paper_width_){}
    , decltype(_impl_.paper_height_){}
    , decltype(_impl_.page_scale_){}
    , decltype(_impl_.orientation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.printer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.printer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_printer_id()) {
    _this->_impl_.printer_id_.Set(from._internal_printer_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.paper_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paper_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_paper_id()) {
    _this->_impl_.paper_id_.Set(from._internal_paper_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_obsolete_section()) {
    _this->_impl_.obsolete_section_ = new ::TSP::Reference(*from._impl_.obsolete_section_);
  }
  ::memcpy(&_impl_.paper_width_, &from._impl_.paper_width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.orientation_) -
    reinterpret_cast<char*>(&_impl_.paper_width_)) + sizeof(_impl_.orientation_));
  // @@protoc_insertion_point(copy_constructor:TP.ChangeDocumentPrinterOptionsCommandArchive)
}

inline void ChangeDocumentPrinterOptionsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.printer_id_){}
    , decltype(_impl_.paper_id_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.paper_width_){0}
    , decltype(_impl_.paper_height_){0}
    , decltype(_impl_.page_scale_){0}
    , decltype(_impl_.orientation_){0u}
  };
  _impl_.printer_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.printer_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.paper_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paper_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChangeDocumentPrinterOptionsCommandArchive::~ChangeDocumentPrinterOptionsCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeDocumentPrinterOptionsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeDocumentPrinterOptionsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.printer_id_.Destroy();
  _impl_.paper_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.obsolete_section_;
}

void ChangeDocumentPrinterOptionsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeDocumentPrinterOptionsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeDocumentPrinterOptionsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.printer_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.paper_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.obsolete_section_ != nullptr);
      _impl_.obsolete_section_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.paper_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.orientation_) -
        reinterpret_cast<char*>(&_impl_.paper_width_)) + sizeof(_impl_.orientation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeDocumentPrinterOptionsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference OBSOLETE_section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_obsolete_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float paper_width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_paper_width(&has_bits);
          _impl_.paper_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float paper_height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_paper_height(&has_bits);
          _impl_.paper_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float page_scale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_page_scale(&has_bits);
          _impl_.page_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 orientation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_orientation(&has_bits);
          _impl_.orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string printer_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_printer_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string paper_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_paper_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeDocumentPrinterOptionsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeDocumentPrinterOptionsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference OBSOLETE_section = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::obsolete_section(this),
        _Internal::obsolete_section(this).GetCachedSize(), target, stream);
  }

  // optional float paper_width = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_paper_width(), target);
  }

  // optional float paper_height = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_paper_height(), target);
  }

  // optional float page_scale = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_page_scale(), target);
  }

  // optional uint32 orientation = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_orientation(), target);
  }

  // optional string printer_id = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_printer_id().data(), static_cast<int>(this->_internal_printer_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_printer_id(), target);
  }

  // optional string paper_id = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_paper_id().data(), static_cast<int>(this->_internal_paper_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_paper_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeDocumentPrinterOptionsCommandArchive)
  return target;
}

size_t ChangeDocumentPrinterOptionsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeDocumentPrinterOptionsCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string printer_id = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_printer_id());
    }

    // optional string paper_id = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_paper_id());
    }

  }
  if (cached_has_bits & 0x000000f8u) {
    // optional .TSP.Reference OBSOLETE_section = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obsolete_section_);
    }

    // optional float paper_width = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float paper_height = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float page_scale = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 orientation = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_orientation());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeDocumentPrinterOptionsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeDocumentPrinterOptionsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeDocumentPrinterOptionsCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeDocumentPrinterOptionsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeDocumentPrinterOptionsCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeDocumentPrinterOptionsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeDocumentPrinterOptionsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_printer_id(from._internal_printer_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_paper_id(from._internal_paper_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_obsolete_section()->::TSP::Reference::MergeFrom(
          from._internal_obsolete_section());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.paper_width_ = from._impl_.paper_width_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.paper_height_ = from._impl_.paper_height_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.page_scale_ = from._impl_.page_scale_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.orientation_ = from._impl_.orientation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeDocumentPrinterOptionsCommandArchive::CopyFrom(const ChangeDocumentPrinterOptionsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeDocumentPrinterOptionsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeDocumentPrinterOptionsCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_obsolete_section()) {
    if (!_impl_.obsolete_section_->IsInitialized()) return false;
  }
  return true;
}

void ChangeDocumentPrinterOptionsCommandArchive::InternalSwap(ChangeDocumentPrinterOptionsCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.printer_id_, lhs_arena,
      &other->_impl_.printer_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.paper_id_, lhs_arena,
      &other->_impl_.paper_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeDocumentPrinterOptionsCommandArchive, _impl_.orientation_)
      + sizeof(ChangeDocumentPrinterOptionsCommandArchive::_impl_.orientation_)
      - PROTOBUF_FIELD_OFFSET(ChangeDocumentPrinterOptionsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeDocumentPrinterOptionsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[17]);
}

// ===================================================================

class InsertMasterDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertMasterDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertMasterDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& obsolete_section(const InsertMasterDrawablesCommandArchive* msg);
  static void set_has_obsolete_section(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drawable_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& master_drawable_provider(const InsertMasterDrawablesCommandArchive* msg);
  static void set_has_master_drawable_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
InsertMasterDrawablesCommandArchive::_Internal::super(const InsertMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertMasterDrawablesCommandArchive::_Internal::obsolete_section(const InsertMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.obsolete_section_;
}
const ::TSP::Reference&
InsertMasterDrawablesCommandArchive::_Internal::master_drawable_provider(const InsertMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.master_drawable_provider_;
}
void InsertMasterDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertMasterDrawablesCommandArchive::clear_obsolete_section() {
  if (_impl_.obsolete_section_ != nullptr) _impl_.obsolete_section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertMasterDrawablesCommandArchive::clear_master_drawables() {
  _impl_.master_drawables_.Clear();
}
void InsertMasterDrawablesCommandArchive::clear_master_drawable_provider() {
  if (_impl_.master_drawable_provider_ != nullptr) _impl_.master_drawable_provider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
InsertMasterDrawablesCommandArchive::InsertMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.InsertMasterDrawablesCommandArchive)
}
InsertMasterDrawablesCommandArchive::InsertMasterDrawablesCommandArchive(const InsertMasterDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertMasterDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){from._impl_.master_drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}
    , decltype(_impl_.drawable_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_obsolete_section()) {
    _this->_impl_.obsolete_section_ = new ::TSP::Reference(*from._impl_.obsolete_section_);
  }
  if (from._internal_has_master_drawable_provider()) {
    _this->_impl_.master_drawable_provider_ = new ::TSP::Reference(*from._impl_.master_drawable_provider_);
  }
  _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
  // @@protoc_insertion_point(copy_constructor:TP.InsertMasterDrawablesCommandArchive)
}

inline void InsertMasterDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}
    , decltype(_impl_.drawable_index_){0u}
  };
}

InsertMasterDrawablesCommandArchive::~InsertMasterDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.InsertMasterDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertMasterDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.obsolete_section_;
  if (this != internal_default_instance()) delete _impl_.master_drawable_provider_;
}

void InsertMasterDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertMasterDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.InsertMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.master_drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.obsolete_section_ != nullptr);
      _impl_.obsolete_section_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.master_drawable_provider_ != nullptr);
      _impl_.master_drawable_provider_->Clear();
    }
  }
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertMasterDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference OBSOLETE_section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_obsolete_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference master_drawables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_master_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 drawable_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_drawable_index(&has_bits);
          _impl_.drawable_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference master_drawable_provider = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_master_drawable_provider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertMasterDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.InsertMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference OBSOLETE_section = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::obsolete_section(this),
        _Internal::obsolete_section(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference master_drawables = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_master_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_master_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 drawable_index = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_drawable_index(), target);
  }

  // optional .TSP.Reference master_drawable_provider = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::master_drawable_provider(this),
        _Internal::master_drawable_provider(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.InsertMasterDrawablesCommandArchive)
  return target;
}

size_t InsertMasterDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.InsertMasterDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference master_drawables = 3;
  total_size += 1UL * this->_internal_master_drawables_size();
  for (const auto& msg : this->_impl_.master_drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference OBSOLETE_section = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obsolete_section_);
    }

    // optional .TSP.Reference master_drawable_provider = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.master_drawable_provider_);
    }

    // optional uint32 drawable_index = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_drawable_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertMasterDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertMasterDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertMasterDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void InsertMasterDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertMasterDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertMasterDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.InsertMasterDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.master_drawables_.MergeFrom(from._impl_.master_drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_obsolete_section()->::TSP::Reference::MergeFrom(
          from._internal_obsolete_section());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_master_drawable_provider()->::TSP::Reference::MergeFrom(
          from._internal_master_drawable_provider());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertMasterDrawablesCommandArchive::CopyFrom(const InsertMasterDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.InsertMasterDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertMasterDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.master_drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_obsolete_section()) {
    if (!_impl_.obsolete_section_->IsInitialized()) return false;
  }
  if (_internal_has_master_drawable_provider()) {
    if (!_impl_.master_drawable_provider_->IsInitialized()) return false;
  }
  return true;
}

void InsertMasterDrawablesCommandArchive::InternalSwap(InsertMasterDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.master_drawables_.InternalSwap(&other->_impl_.master_drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertMasterDrawablesCommandArchive, _impl_.drawable_index_)
      + sizeof(InsertMasterDrawablesCommandArchive::_impl_.drawable_index_)
      - PROTOBUF_FIELD_OFFSET(InsertMasterDrawablesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertMasterDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[18]);
}

// ===================================================================

class MoveMasterDrawableZOrderCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveMasterDrawableZOrderCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveMasterDrawableZOrderCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& obsolete_section(const MoveMasterDrawableZOrderCommandArchive* msg);
  static void set_has_obsolete_section(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& master_drawable_provider(const MoveMasterDrawableZOrderCommandArchive* msg);
  static void set_has_master_drawable_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveMasterDrawableZOrderCommandArchive::_Internal::super(const MoveMasterDrawableZOrderCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveMasterDrawableZOrderCommandArchive::_Internal::obsolete_section(const MoveMasterDrawableZOrderCommandArchive* msg) {
  return *msg->_impl_.obsolete_section_;
}
const ::TSP::Reference&
MoveMasterDrawableZOrderCommandArchive::_Internal::master_drawable_provider(const MoveMasterDrawableZOrderCommandArchive* msg) {
  return *msg->_impl_.master_drawable_provider_;
}
void MoveMasterDrawableZOrderCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveMasterDrawableZOrderCommandArchive::clear_obsolete_section() {
  if (_impl_.obsolete_section_ != nullptr) _impl_.obsolete_section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveMasterDrawableZOrderCommandArchive::clear_master_drawables() {
  _impl_.master_drawables_.Clear();
}
void MoveMasterDrawableZOrderCommandArchive::clear_master_drawable_provider() {
  if (_impl_.master_drawable_provider_ != nullptr) _impl_.master_drawable_provider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveMasterDrawableZOrderCommandArchive::MoveMasterDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveMasterDrawableZOrderCommandArchive)
}
MoveMasterDrawableZOrderCommandArchive::MoveMasterDrawableZOrderCommandArchive(const MoveMasterDrawableZOrderCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveMasterDrawableZOrderCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){from._impl_.master_drawables_}
    , decltype(_impl_.indexes_){from._impl_.indexes_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_obsolete_section()) {
    _this->_impl_.obsolete_section_ = new ::TSP::Reference(*from._impl_.obsolete_section_);
  }
  if (from._internal_has_master_drawable_provider()) {
    _this->_impl_.master_drawable_provider_ = new ::TSP::Reference(*from._impl_.master_drawable_provider_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.MoveMasterDrawableZOrderCommandArchive)
}

inline void MoveMasterDrawableZOrderCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){arena}
    , decltype(_impl_.indexes_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}
  };
}

MoveMasterDrawableZOrderCommandArchive::~MoveMasterDrawableZOrderCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveMasterDrawableZOrderCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveMasterDrawableZOrderCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_drawables_.~RepeatedPtrField();
  _impl_.indexes_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.obsolete_section_;
  if (this != internal_default_instance()) delete _impl_.master_drawable_provider_;
}

void MoveMasterDrawableZOrderCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveMasterDrawableZOrderCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveMasterDrawableZOrderCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.master_drawables_.Clear();
  _impl_.indexes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.obsolete_section_ != nullptr);
      _impl_.obsolete_section_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.master_drawable_provider_ != nullptr);
      _impl_.master_drawable_provider_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveMasterDrawableZOrderCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference OBSOLETE_section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_obsolete_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference master_drawables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_master_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 indexes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference master_drawable_provider = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_master_drawable_provider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveMasterDrawableZOrderCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveMasterDrawableZOrderCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference OBSOLETE_section = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::obsolete_section(this),
        _Internal::obsolete_section(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference master_drawables = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_master_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_master_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 indexes = 4;
  for (int i = 0, n = this->_internal_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_indexes(i), target);
  }

  // optional .TSP.Reference master_drawable_provider = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::master_drawable_provider(this),
        _Internal::master_drawable_provider(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveMasterDrawableZOrderCommandArchive)
  return target;
}

size_t MoveMasterDrawableZOrderCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveMasterDrawableZOrderCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference master_drawables = 3;
  total_size += 1UL * this->_internal_master_drawables_size();
  for (const auto& msg : this->_impl_.master_drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 indexes = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.indexes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_indexes_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference OBSOLETE_section = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obsolete_section_);
    }

    // optional .TSP.Reference master_drawable_provider = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.master_drawable_provider_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveMasterDrawableZOrderCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveMasterDrawableZOrderCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveMasterDrawableZOrderCommandArchive::GetClassData() const { return &_class_data_; }


void MoveMasterDrawableZOrderCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveMasterDrawableZOrderCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveMasterDrawableZOrderCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveMasterDrawableZOrderCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.master_drawables_.MergeFrom(from._impl_.master_drawables_);
  _this->_impl_.indexes_.MergeFrom(from._impl_.indexes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_obsolete_section()->::TSP::Reference::MergeFrom(
          from._internal_obsolete_section());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_master_drawable_provider()->::TSP::Reference::MergeFrom(
          from._internal_master_drawable_provider());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveMasterDrawableZOrderCommandArchive::CopyFrom(const MoveMasterDrawableZOrderCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveMasterDrawableZOrderCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveMasterDrawableZOrderCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.master_drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_obsolete_section()) {
    if (!_impl_.obsolete_section_->IsInitialized()) return false;
  }
  if (_internal_has_master_drawable_provider()) {
    if (!_impl_.master_drawable_provider_->IsInitialized()) return false;
  }
  return true;
}

void MoveMasterDrawableZOrderCommandArchive::InternalSwap(MoveMasterDrawableZOrderCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.master_drawables_.InternalSwap(&other->_impl_.master_drawables_);
  _impl_.indexes_.InternalSwap(&other->_impl_.indexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveMasterDrawableZOrderCommandArchive, _impl_.master_drawable_provider_)
      + sizeof(MoveMasterDrawableZOrderCommandArchive::_impl_.master_drawable_provider_)
      - PROTOBUF_FIELD_OFFSET(MoveMasterDrawableZOrderCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveMasterDrawableZOrderCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[19]);
}

// ===================================================================

class RemoveMasterDrawablesCommandArchive_MasterDrawable::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveMasterDrawablesCommandArchive_MasterDrawable>()._impl_._has_bits_);
  static const ::TSP::Reference& drawable(const RemoveMasterDrawablesCommandArchive_MasterDrawable* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_drawable_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
RemoveMasterDrawablesCommandArchive_MasterDrawable::_Internal::drawable(const RemoveMasterDrawablesCommandArchive_MasterDrawable* msg) {
  return *msg->_impl_.drawable_;
}
void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RemoveMasterDrawablesCommandArchive_MasterDrawable::RemoveMasterDrawablesCommandArchive_MasterDrawable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
}
RemoveMasterDrawablesCommandArchive_MasterDrawable::RemoveMasterDrawablesCommandArchive_MasterDrawable(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveMasterDrawablesCommandArchive_MasterDrawable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.drawable_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
  // @@protoc_insertion_point(copy_constructor:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
}

inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.drawable_index_){0u}
  };
}

RemoveMasterDrawablesCommandArchive_MasterDrawable::~RemoveMasterDrawablesCommandArchive_MasterDrawable() {
  // @@protoc_insertion_point(destructor:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_;
}

void RemoveMasterDrawablesCommandArchive_MasterDrawable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveMasterDrawablesCommandArchive_MasterDrawable::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
    _impl_.drawable_->Clear();
  }
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveMasterDrawablesCommandArchive_MasterDrawable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference drawable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 drawable_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_drawable_index(&has_bits);
          _impl_.drawable_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveMasterDrawablesCommandArchive_MasterDrawable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference drawable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional uint32 drawable_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_drawable_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  return target;
}

size_t RemoveMasterDrawablesCommandArchive_MasterDrawable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference drawable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional uint32 drawable_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_drawable_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveMasterDrawablesCommandArchive_MasterDrawable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveMasterDrawablesCommandArchive_MasterDrawable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveMasterDrawablesCommandArchive_MasterDrawable::GetClassData() const { return &_class_data_; }


void RemoveMasterDrawablesCommandArchive_MasterDrawable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveMasterDrawablesCommandArchive_MasterDrawable*>(&to_msg);
  auto& from = static_cast<const RemoveMasterDrawablesCommandArchive_MasterDrawable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveMasterDrawablesCommandArchive_MasterDrawable::CopyFrom(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveMasterDrawablesCommandArchive_MasterDrawable::IsInitialized() const {
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  return true;
}

void RemoveMasterDrawablesCommandArchive_MasterDrawable::InternalSwap(RemoveMasterDrawablesCommandArchive_MasterDrawable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveMasterDrawablesCommandArchive_MasterDrawable, _impl_.drawable_index_)
      + sizeof(RemoveMasterDrawablesCommandArchive_MasterDrawable::_impl_.drawable_index_)
      - PROTOBUF_FIELD_OFFSET(RemoveMasterDrawablesCommandArchive_MasterDrawable, _impl_.drawable_)>(
          reinterpret_cast<char*>(&_impl_.drawable_),
          reinterpret_cast<char*>(&other->_impl_.drawable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveMasterDrawablesCommandArchive_MasterDrawable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[20]);
}

// ===================================================================

class RemoveMasterDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveMasterDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveMasterDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& obsolete_section(const RemoveMasterDrawablesCommandArchive* msg);
  static void set_has_obsolete_section(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& master_drawable_provider(const RemoveMasterDrawablesCommandArchive* msg);
  static void set_has_master_drawable_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
RemoveMasterDrawablesCommandArchive::_Internal::super(const RemoveMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveMasterDrawablesCommandArchive::_Internal::obsolete_section(const RemoveMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.obsolete_section_;
}
const ::TSP::Reference&
RemoveMasterDrawablesCommandArchive::_Internal::master_drawable_provider(const RemoveMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.master_drawable_provider_;
}
void RemoveMasterDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveMasterDrawablesCommandArchive::clear_obsolete_section() {
  if (_impl_.obsolete_section_ != nullptr) _impl_.obsolete_section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveMasterDrawablesCommandArchive::clear_master_drawable_provider() {
  if (_impl_.master_drawable_provider_ != nullptr) _impl_.master_drawable_provider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveMasterDrawablesCommandArchive::RemoveMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.RemoveMasterDrawablesCommandArchive)
}
RemoveMasterDrawablesCommandArchive::RemoveMasterDrawablesCommandArchive(const RemoveMasterDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveMasterDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){from._impl_.master_drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_obsolete_section()) {
    _this->_impl_.obsolete_section_ = new ::TSP::Reference(*from._impl_.obsolete_section_);
  }
  if (from._internal_has_master_drawable_provider()) {
    _this->_impl_.master_drawable_provider_ = new ::TSP::Reference(*from._impl_.master_drawable_provider_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.RemoveMasterDrawablesCommandArchive)
}

inline void RemoveMasterDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_section_){nullptr}
    , decltype(_impl_.master_drawable_provider_){nullptr}
  };
}

RemoveMasterDrawablesCommandArchive::~RemoveMasterDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.RemoveMasterDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveMasterDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.obsolete_section_;
  if (this != internal_default_instance()) delete _impl_.master_drawable_provider_;
}

void RemoveMasterDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveMasterDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.RemoveMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.master_drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.obsolete_section_ != nullptr);
      _impl_.obsolete_section_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.master_drawable_provider_ != nullptr);
      _impl_.master_drawable_provider_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveMasterDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference OBSOLETE_section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_obsolete_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_master_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference master_drawable_provider = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_master_drawable_provider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveMasterDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.RemoveMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference OBSOLETE_section = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::obsolete_section(this),
        _Internal::obsolete_section(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_master_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_master_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference master_drawable_provider = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::master_drawable_provider(this),
        _Internal::master_drawable_provider(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.RemoveMasterDrawablesCommandArchive)
  return target;
}

size_t RemoveMasterDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.RemoveMasterDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
  total_size += 1UL * this->_internal_master_drawables_size();
  for (const auto& msg : this->_impl_.master_drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference OBSOLETE_section = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obsolete_section_);
    }

    // optional .TSP.Reference master_drawable_provider = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.master_drawable_provider_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveMasterDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveMasterDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveMasterDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveMasterDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveMasterDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveMasterDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.RemoveMasterDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.master_drawables_.MergeFrom(from._impl_.master_drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_obsolete_section()->::TSP::Reference::MergeFrom(
          from._internal_obsolete_section());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_master_drawable_provider()->::TSP::Reference::MergeFrom(
          from._internal_master_drawable_provider());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveMasterDrawablesCommandArchive::CopyFrom(const RemoveMasterDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.RemoveMasterDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveMasterDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.master_drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_obsolete_section()) {
    if (!_impl_.obsolete_section_->IsInitialized()) return false;
  }
  if (_internal_has_master_drawable_provider()) {
    if (!_impl_.master_drawable_provider_->IsInitialized()) return false;
  }
  return true;
}

void RemoveMasterDrawablesCommandArchive::InternalSwap(RemoveMasterDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.master_drawables_.InternalSwap(&other->_impl_.master_drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveMasterDrawablesCommandArchive, _impl_.master_drawable_provider_)
      + sizeof(RemoveMasterDrawablesCommandArchive::_impl_.master_drawable_provider_)
      - PROTOBUF_FIELD_OFFSET(RemoveMasterDrawablesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveMasterDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[21]);
}

// ===================================================================

class PasteMasterDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteMasterDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const PasteMasterDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& section(const PasteMasterDrawablesCommandArchive* msg);
  static void set_has_section(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_drawable_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
PasteMasterDrawablesCommandArchive::_Internal::super(const PasteMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
PasteMasterDrawablesCommandArchive::_Internal::section(const PasteMasterDrawablesCommandArchive* msg) {
  return *msg->_impl_.section_;
}
void PasteMasterDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PasteMasterDrawablesCommandArchive::clear_section() {
  if (_impl_.section_ != nullptr) _impl_.section_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PasteMasterDrawablesCommandArchive::clear_master_drawables() {
  _impl_.master_drawables_.Clear();
}
PasteMasterDrawablesCommandArchive::PasteMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.PasteMasterDrawablesCommandArchive)
}
PasteMasterDrawablesCommandArchive::PasteMasterDrawablesCommandArchive(const PasteMasterDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteMasterDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){from._impl_.master_drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_){nullptr}
    , decltype(_impl_.drawable_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_section()) {
    _this->_impl_.section_ = new ::TSP::Reference(*from._impl_.section_);
  }
  _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
  // @@protoc_insertion_point(copy_constructor:TP.PasteMasterDrawablesCommandArchive)
}

inline void PasteMasterDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.section_){nullptr}
    , decltype(_impl_.drawable_index_){0u}
  };
}

PasteMasterDrawablesCommandArchive::~PasteMasterDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.PasteMasterDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteMasterDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.section_;
}

void PasteMasterDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteMasterDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.PasteMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.master_drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.section_ != nullptr);
      _impl_.section_->Clear();
    }
  }
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteMasterDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference master_drawables = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_master_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 drawable_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_drawable_index(&has_bits);
          _impl_.drawable_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteMasterDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.PasteMasterDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference section = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::section(this),
        _Internal::section(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference master_drawables = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_master_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_master_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 drawable_index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_drawable_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.PasteMasterDrawablesCommandArchive)
  return target;
}

size_t PasteMasterDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.PasteMasterDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference master_drawables = 3;
  total_size += 1UL * this->_internal_master_drawables_size();
  for (const auto& msg : this->_impl_.master_drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference section = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.section_);
    }

    // optional uint32 drawable_index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_drawable_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteMasterDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteMasterDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteMasterDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void PasteMasterDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteMasterDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const PasteMasterDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.PasteMasterDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.master_drawables_.MergeFrom(from._impl_.master_drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_section()->::TSP::Reference::MergeFrom(
          from._internal_section());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.drawable_index_ = from._impl_.drawable_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteMasterDrawablesCommandArchive::CopyFrom(const PasteMasterDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.PasteMasterDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteMasterDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.master_drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_section()) {
    if (!_impl_.section_->IsInitialized()) return false;
  }
  return true;
}

void PasteMasterDrawablesCommandArchive::InternalSwap(PasteMasterDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.master_drawables_.InternalSwap(&other->_impl_.master_drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasteMasterDrawablesCommandArchive, _impl_.drawable_index_)
      + sizeof(PasteMasterDrawablesCommandArchive::_impl_.drawable_index_)
      - PROTOBUF_FIELD_OFFSET(PasteMasterDrawablesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteMasterDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[22]);
}

// ===================================================================

class MoveDrawablesAttachedCommandArchive_FloatingUndo::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesAttachedCommandArchive_FloatingUndo>()._impl_._has_bits_);
  static const ::TSP::Reference& drawable(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::GeometryArchive& geometry(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& attachment(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg);
  static void set_has_attachment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wrap_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSP::Reference&
MoveDrawablesAttachedCommandArchive_FloatingUndo::_Internal::drawable(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg) {
  return *msg->_impl_.drawable_;
}
const ::TSD::GeometryArchive&
MoveDrawablesAttachedCommandArchive_FloatingUndo::_Internal::geometry(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
MoveDrawablesAttachedCommandArchive_FloatingUndo::_Internal::attachment(const MoveDrawablesAttachedCommandArchive_FloatingUndo* msg) {
  return *msg->_impl_.attachment_;
}
void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_attachment() {
  if (_impl_.attachment_ != nullptr) _impl_.attachment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveDrawablesAttachedCommandArchive_FloatingUndo::MoveDrawablesAttachedCommandArchive_FloatingUndo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
}
MoveDrawablesAttachedCommandArchive_FloatingUndo::MoveDrawablesAttachedCommandArchive_FloatingUndo(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesAttachedCommandArchive_FloatingUndo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.wrap_type_){}
    , decltype(_impl_.page_index_){}
    , decltype(_impl_.z_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_attachment()) {
    _this->_impl_.attachment_ = new ::TSP::Reference(*from._impl_.attachment_);
  }
  ::memcpy(&_impl_.wrap_type_, &from._impl_.wrap_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_order_) -
    reinterpret_cast<char*>(&_impl_.wrap_type_)) + sizeof(_impl_.z_order_));
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
}

inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.wrap_type_){0u}
    , decltype(_impl_.page_index_){0u}
    , decltype(_impl_.z_order_){0}
  };
}

MoveDrawablesAttachedCommandArchive_FloatingUndo::~MoveDrawablesAttachedCommandArchive_FloatingUndo() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_;
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.attachment_;
}

void MoveDrawablesAttachedCommandArchive_FloatingUndo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesAttachedCommandArchive_FloatingUndo::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
      _impl_.drawable_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.attachment_ != nullptr);
      _impl_.attachment_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.wrap_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_order_) -
        reinterpret_cast<char*>(&_impl_.wrap_type_)) + sizeof(_impl_.z_order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesAttachedCommandArchive_FloatingUndo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference drawable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive geometry = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference attachment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 wrap_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_wrap_type(&has_bits);
          _impl_.wrap_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 page_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 z_order = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesAttachedCommandArchive_FloatingUndo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference drawable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive geometry = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference attachment = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::attachment(this),
        _Internal::attachment(this).GetCachedSize(), target, stream);
  }

  // optional uint32 wrap_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_wrap_type(), target);
  }

  // optional uint32 page_index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_page_index(), target);
  }

  // optional int32 z_order = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_z_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  return target;
}

size_t MoveDrawablesAttachedCommandArchive_FloatingUndo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSP.Reference drawable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional .TSD.GeometryArchive geometry = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference attachment = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachment_);
    }

    // optional uint32 wrap_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_wrap_type());
    }

    // optional uint32 page_index = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
    }

    // optional int32 z_order = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesAttachedCommandArchive_FloatingUndo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesAttachedCommandArchive_FloatingUndo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesAttachedCommandArchive_FloatingUndo::GetClassData() const { return &_class_data_; }


void MoveDrawablesAttachedCommandArchive_FloatingUndo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesAttachedCommandArchive_FloatingUndo*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesAttachedCommandArchive_FloatingUndo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_attachment()->::TSP::Reference::MergeFrom(
          from._internal_attachment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.wrap_type_ = from._impl_.wrap_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.z_order_ = from._impl_.z_order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesAttachedCommandArchive_FloatingUndo::CopyFrom(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesAttachedCommandArchive_FloatingUndo::IsInitialized() const {
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_attachment()) {
    if (!_impl_.attachment_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesAttachedCommandArchive_FloatingUndo::InternalSwap(MoveDrawablesAttachedCommandArchive_FloatingUndo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.z_order_)
      + sizeof(MoveDrawablesAttachedCommandArchive_FloatingUndo::_impl_.z_order_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesAttachedCommandArchive_FloatingUndo, _impl_.drawable_)>(
          reinterpret_cast<char*>(&_impl_.drawable_),
          reinterpret_cast<char*>(&other->_impl_.drawable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesAttachedCommandArchive_FloatingUndo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[23]);
}

// ===================================================================

class MoveDrawablesAttachedCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesAttachedCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveDrawablesAttachedCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveDrawablesAttachedCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_select(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_make_inline(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveDrawablesAttachedCommandArchive::_Internal::super(const MoveDrawablesAttachedCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSWP::UndoTransaction&
MoveDrawablesAttachedCommandArchive::_Internal::undo_transaction(const MoveDrawablesAttachedCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveDrawablesAttachedCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveDrawablesAttachedCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MoveDrawablesAttachedCommandArchive::MoveDrawablesAttachedCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesAttachedCommandArchive)
}
MoveDrawablesAttachedCommandArchive::MoveDrawablesAttachedCommandArchive(const MoveDrawablesAttachedCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesAttachedCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.floating_undo_){from._impl_.floating_undo_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.select_){}
    , decltype(_impl_.make_inline_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.select_, &from._impl_.select_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.make_inline_) -
    reinterpret_cast<char*>(&_impl_.select_)) + sizeof(_impl_.make_inline_));
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesAttachedCommandArchive)
}

inline void MoveDrawablesAttachedCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.floating_undo_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.select_){false}
    , decltype(_impl_.make_inline_){false}
  };
}

MoveDrawablesAttachedCommandArchive::~MoveDrawablesAttachedCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesAttachedCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesAttachedCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.floating_undo_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveDrawablesAttachedCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesAttachedCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesAttachedCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.floating_undo_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  ::memset(&_impl_.select_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.make_inline_) -
      reinterpret_cast<char*>(&_impl_.select_)) + sizeof(_impl_.make_inline_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesAttachedCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_floating_undo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool select = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_select(&has_bits);
          _impl_.select_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool make_inline = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_make_inline(&has_bits);
          _impl_.make_inline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesAttachedCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesAttachedCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_floating_undo_size()); i < n; i++) {
    const auto& repfield = this->_internal_floating_undo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool select = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_select(), target);
  }

  // optional bool make_inline = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_make_inline(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesAttachedCommandArchive)
  return target;
}

size_t MoveDrawablesAttachedCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesAttachedCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
  total_size += 1UL * this->_internal_floating_undo_size();
  for (const auto& msg : this->_impl_.floating_undo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSWP.UndoTransaction undo_transaction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional bool select = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool make_inline = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesAttachedCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesAttachedCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesAttachedCommandArchive::GetClassData() const { return &_class_data_; }


void MoveDrawablesAttachedCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesAttachedCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesAttachedCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesAttachedCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.floating_undo_.MergeFrom(from._impl_.floating_undo_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.select_ = from._impl_.select_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.make_inline_ = from._impl_.make_inline_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesAttachedCommandArchive::CopyFrom(const MoveDrawablesAttachedCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesAttachedCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesAttachedCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.floating_undo_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesAttachedCommandArchive::InternalSwap(MoveDrawablesAttachedCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.floating_undo_.InternalSwap(&other->_impl_.floating_undo_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesAttachedCommandArchive, _impl_.make_inline_)
      + sizeof(MoveDrawablesAttachedCommandArchive::_impl_.make_inline_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesAttachedCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesAttachedCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[24]);
}

// ===================================================================

class MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesFloatingCommandArchive_AttachedUndo>()._impl_._has_bits_);
  static const ::TSP::Reference& drawable(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::GeometryArchive& geometry(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& attachment(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg);
  static void set_has_attachment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_page_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_alpha_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Reference& storage(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Reference&
MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal::drawable(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg) {
  return *msg->_impl_.drawable_;
}
const ::TSD::GeometryArchive&
MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal::geometry(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal::attachment(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg) {
  return *msg->_impl_.attachment_;
}
const ::TSP::Reference&
MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal::storage(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MoveDrawablesFloatingCommandArchive_AttachedUndo::_Internal::undo_transaction(const MoveDrawablesFloatingCommandArchive_AttachedUndo* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_attachment() {
  if (_impl_.attachment_ != nullptr) _impl_.attachment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
MoveDrawablesFloatingCommandArchive_AttachedUndo::MoveDrawablesFloatingCommandArchive_AttachedUndo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
}
MoveDrawablesFloatingCommandArchive_AttachedUndo::MoveDrawablesFloatingCommandArchive_AttachedUndo(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesFloatingCommandArchive_AttachedUndo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.page_index_){}
    , decltype(_impl_.is_html_wrap_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.fit_type_){}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.alpha_threshold_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_attachment()) {
    _this->_impl_.attachment_ = new ::TSP::Reference(*from._impl_.attachment_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.page_index_, &from._impl_.page_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alpha_threshold_) -
    reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.alpha_threshold_));
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
}

inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.page_index_){0u}
    , decltype(_impl_.is_html_wrap_){false}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.direction_){0u}
    , decltype(_impl_.fit_type_){0u}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.alpha_threshold_){0}
  };
}

MoveDrawablesFloatingCommandArchive_AttachedUndo::~MoveDrawablesFloatingCommandArchive_AttachedUndo() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.drawable_;
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.attachment_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveDrawablesFloatingCommandArchive_AttachedUndo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesFloatingCommandArchive_AttachedUndo::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
      _impl_.drawable_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.attachment_ != nullptr);
      _impl_.attachment_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.page_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.page_index_)) + sizeof(_impl_.type_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.alpha_threshold_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.alpha_threshold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesFloatingCommandArchive_AttachedUndo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference drawable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive geometry = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference attachment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 page_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_page_index(&has_bits);
          _impl_.page_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 direction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_direction(&has_bits);
          _impl_.direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fit_type = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_fit_type(&has_bits);
          _impl_.fit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float margin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_margin(&has_bits);
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float alpha_threshold = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_alpha_threshold(&has_bits);
          _impl_.alpha_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesFloatingCommandArchive_AttachedUndo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference drawable = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive geometry = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference attachment = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::attachment(this),
        _Internal::attachment(this).GetCachedSize(), target, stream);
  }

  // optional uint32 page_index = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_page_index(), target);
  }

  // optional bool is_html_wrap = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_html_wrap(), target);
  }

  // optional uint32 type = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_type(), target);
  }

  // optional uint32 direction = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_direction(), target);
  }

  // optional uint32 fit_type = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_fit_type(), target);
  }

  // optional float margin = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_margin(), target);
  }

  // optional float alpha_threshold = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_alpha_threshold(), target);
  }

  // optional .TSP.Reference storage = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  return target;
}

size_t MoveDrawablesFloatingCommandArchive_AttachedUndo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Reference drawable = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional .TSD.GeometryArchive geometry = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference attachment = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachment_);
    }

    // optional .TSP.Reference storage = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 page_index = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_page_index());
    }

    // optional bool is_html_wrap = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 direction = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_direction());
    }

    // optional uint32 fit_type = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fit_type());
    }

    // optional float margin = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float alpha_threshold = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesFloatingCommandArchive_AttachedUndo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesFloatingCommandArchive_AttachedUndo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesFloatingCommandArchive_AttachedUndo::GetClassData() const { return &_class_data_; }


void MoveDrawablesFloatingCommandArchive_AttachedUndo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesFloatingCommandArchive_AttachedUndo*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesFloatingCommandArchive_AttachedUndo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_attachment()->::TSP::Reference::MergeFrom(
          from._internal_attachment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.page_index_ = from._impl_.page_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.fit_type_ = from._impl_.fit_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.alpha_threshold_ = from._impl_.alpha_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesFloatingCommandArchive_AttachedUndo::CopyFrom(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesFloatingCommandArchive_AttachedUndo::IsInitialized() const {
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_attachment()) {
    if (!_impl_.attachment_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesFloatingCommandArchive_AttachedUndo::InternalSwap(MoveDrawablesFloatingCommandArchive_AttachedUndo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.alpha_threshold_)
      + sizeof(MoveDrawablesFloatingCommandArchive_AttachedUndo::_impl_.alpha_threshold_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesFloatingCommandArchive_AttachedUndo, _impl_.drawable_)>(
          reinterpret_cast<char*>(&_impl_.drawable_),
          reinterpret_cast<char*>(&other->_impl_.drawable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesFloatingCommandArchive_AttachedUndo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[25]);
}

// ===================================================================

class MoveDrawablesFloatingCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveDrawablesFloatingCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveDrawablesFloatingCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWP::UndoTransaction& deprecated_undo_transaction(const MoveDrawablesFloatingCommandArchive* msg);
  static void set_has_deprecated_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_select(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveDrawablesFloatingCommandArchive::_Internal::super(const MoveDrawablesFloatingCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSWP::UndoTransaction&
MoveDrawablesFloatingCommandArchive::_Internal::deprecated_undo_transaction(const MoveDrawablesFloatingCommandArchive* msg) {
  return *msg->_impl_.deprecated_undo_transaction_;
}
void MoveDrawablesFloatingCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveDrawablesFloatingCommandArchive::clear_deprecated_undo_transaction() {
  if (_impl_.deprecated_undo_transaction_ != nullptr) _impl_.deprecated_undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MoveDrawablesFloatingCommandArchive::MoveDrawablesFloatingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveDrawablesFloatingCommandArchive)
}
MoveDrawablesFloatingCommandArchive::MoveDrawablesFloatingCommandArchive(const MoveDrawablesFloatingCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDrawablesFloatingCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attached_undo_){from._impl_.attached_undo_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.deprecated_undo_transaction_){nullptr}
    , decltype(_impl_.select_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_deprecated_undo_transaction()) {
    _this->_impl_.deprecated_undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.deprecated_undo_transaction_);
  }
  _this->_impl_.select_ = from._impl_.select_;
  // @@protoc_insertion_point(copy_constructor:TP.MoveDrawablesFloatingCommandArchive)
}

inline void MoveDrawablesFloatingCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attached_undo_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.deprecated_undo_transaction_){nullptr}
    , decltype(_impl_.select_){false}
  };
}

MoveDrawablesFloatingCommandArchive::~MoveDrawablesFloatingCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveDrawablesFloatingCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDrawablesFloatingCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attached_undo_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.deprecated_undo_transaction_;
}

void MoveDrawablesFloatingCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDrawablesFloatingCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveDrawablesFloatingCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attached_undo_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.deprecated_undo_transaction_ != nullptr);
      _impl_.deprecated_undo_transaction_->Clear();
    }
  }
  _impl_.select_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDrawablesFloatingCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_deprecated_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attached_undo(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool select = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_select(&has_bits);
          _impl_.select_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDrawablesFloatingCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveDrawablesFloatingCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::deprecated_undo_transaction(this),
        _Internal::deprecated_undo_transaction(this).GetCachedSize(), target, stream);
  }

  // repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attached_undo_size()); i < n; i++) {
    const auto& repfield = this->_internal_attached_undo(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool select = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_select(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveDrawablesFloatingCommandArchive)
  return target;
}

size_t MoveDrawablesFloatingCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveDrawablesFloatingCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
  total_size += 1UL * this->_internal_attached_undo_size();
  for (const auto& msg : this->_impl_.attached_undo_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deprecated_undo_transaction_);
    }

    // optional bool select = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDrawablesFloatingCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDrawablesFloatingCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDrawablesFloatingCommandArchive::GetClassData() const { return &_class_data_; }


void MoveDrawablesFloatingCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDrawablesFloatingCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveDrawablesFloatingCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveDrawablesFloatingCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attached_undo_.MergeFrom(from._impl_.attached_undo_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_deprecated_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_deprecated_undo_transaction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.select_ = from._impl_.select_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDrawablesFloatingCommandArchive::CopyFrom(const MoveDrawablesFloatingCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveDrawablesFloatingCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDrawablesFloatingCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.attached_undo_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_deprecated_undo_transaction()) {
    if (!_impl_.deprecated_undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveDrawablesFloatingCommandArchive::InternalSwap(MoveDrawablesFloatingCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attached_undo_.InternalSwap(&other->_impl_.attached_undo_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDrawablesFloatingCommandArchive, _impl_.select_)
      + sizeof(MoveDrawablesFloatingCommandArchive::_impl_.select_)
      - PROTOBUF_FIELD_OFFSET(MoveDrawablesFloatingCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDrawablesFloatingCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[26]);
}

// ===================================================================

class RemoveAnchoredDrawableCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveAnchoredDrawableCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const RemoveAnchoredDrawableCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_char_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::TextCommandArchive&
RemoveAnchoredDrawableCommandArchive::_Internal::super(const RemoveAnchoredDrawableCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void RemoveAnchoredDrawableCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
RemoveAnchoredDrawableCommandArchive::RemoveAnchoredDrawableCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.RemoveAnchoredDrawableCommandArchive)
}
RemoveAnchoredDrawableCommandArchive::RemoveAnchoredDrawableCommandArchive(const RemoveAnchoredDrawableCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveAnchoredDrawableCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.char_index_){}
    , decltype(_impl_.z_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.char_index_, &from._impl_.char_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_order_) -
    reinterpret_cast<char*>(&_impl_.char_index_)) + sizeof(_impl_.z_order_));
  // @@protoc_insertion_point(copy_constructor:TP.RemoveAnchoredDrawableCommandArchive)
}

inline void RemoveAnchoredDrawableCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.char_index_){0u}
    , decltype(_impl_.z_order_){0u}
  };
}

RemoveAnchoredDrawableCommandArchive::~RemoveAnchoredDrawableCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.RemoveAnchoredDrawableCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveAnchoredDrawableCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void RemoveAnchoredDrawableCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveAnchoredDrawableCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.RemoveAnchoredDrawableCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.char_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_order_) -
        reinterpret_cast<char*>(&_impl_.char_index_)) + sizeof(_impl_.z_order_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveAnchoredDrawableCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 char_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_char_index(&has_bits);
          _impl_.char_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 z_order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveAnchoredDrawableCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.RemoveAnchoredDrawableCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 char_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_char_index(), target);
  }

  // optional uint32 z_order = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_z_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.RemoveAnchoredDrawableCommandArchive)
  return target;
}

size_t RemoveAnchoredDrawableCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.RemoveAnchoredDrawableCommandArchive)
  size_t total_size = 0;

  // required .TSWP.TextCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 char_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_char_index());
    }

    // optional uint32 z_order = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveAnchoredDrawableCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveAnchoredDrawableCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveAnchoredDrawableCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveAnchoredDrawableCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveAnchoredDrawableCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveAnchoredDrawableCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.RemoveAnchoredDrawableCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.char_index_ = from._impl_.char_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_order_ = from._impl_.z_order_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveAnchoredDrawableCommandArchive::CopyFrom(const RemoveAnchoredDrawableCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.RemoveAnchoredDrawableCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveAnchoredDrawableCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void RemoveAnchoredDrawableCommandArchive::InternalSwap(RemoveAnchoredDrawableCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveAnchoredDrawableCommandArchive, _impl_.z_order_)
      + sizeof(RemoveAnchoredDrawableCommandArchive::_impl_.z_order_)
      - PROTOBUF_FIELD_OFFSET(RemoveAnchoredDrawableCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveAnchoredDrawableCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[27]);
}

// ===================================================================

class ChangeFootnoteFormatCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeFootnoteFormatCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeFootnoteFormatCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeFootnoteFormatCommandArchive::_Internal::super(const ChangeFootnoteFormatCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeFootnoteFormatCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChangeFootnoteFormatCommandArchive::ChangeFootnoteFormatCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeFootnoteFormatCommandArchive)
}
ChangeFootnoteFormatCommandArchive::ChangeFootnoteFormatCommandArchive(const ChangeFootnoteFormatCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeFootnoteFormatCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.format_ = from._impl_.format_;
  // @@protoc_insertion_point(copy_constructor:TP.ChangeFootnoteFormatCommandArchive)
}

inline void ChangeFootnoteFormatCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_){0}
  };
}

ChangeFootnoteFormatCommandArchive::~ChangeFootnoteFormatCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeFootnoteFormatCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeFootnoteFormatCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeFootnoteFormatCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeFootnoteFormatCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeFootnoteFormatCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.format_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeFootnoteFormatCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(val))) {
            _internal_set_format(static_cast<::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeFootnoteFormatCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeFootnoteFormatCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeFootnoteFormatCommandArchive)
  return target;
}

size_t ChangeFootnoteFormatCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeFootnoteFormatCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeFootnoteFormatCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeFootnoteFormatCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeFootnoteFormatCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeFootnoteFormatCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeFootnoteFormatCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeFootnoteFormatCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeFootnoteFormatCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeFootnoteFormatCommandArchive::CopyFrom(const ChangeFootnoteFormatCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeFootnoteFormatCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFootnoteFormatCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeFootnoteFormatCommandArchive::InternalSwap(ChangeFootnoteFormatCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeFootnoteFormatCommandArchive, _impl_.format_)
      + sizeof(ChangeFootnoteFormatCommandArchive::_impl_.format_)
      - PROTOBUF_FIELD_OFFSET(ChangeFootnoteFormatCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeFootnoteFormatCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[28]);
}

// ===================================================================

class ChangeFootnoteKindCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeFootnoteKindCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeFootnoteKindCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ChangeFootnoteKindCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeFootnoteKindCommandArchive::_Internal::super(const ChangeFootnoteKindCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSWP::UndoTransaction&
ChangeFootnoteKindCommandArchive::_Internal::undo_transaction(const ChangeFootnoteKindCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ChangeFootnoteKindCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ChangeFootnoteKindCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ChangeFootnoteKindCommandArchive::ChangeFootnoteKindCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeFootnoteKindCommandArchive)
}
ChangeFootnoteKindCommandArchive::ChangeFootnoteKindCommandArchive(const ChangeFootnoteKindCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeFootnoteKindCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.kind_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  _this->_impl_.kind_ = from._impl_.kind_;
  // @@protoc_insertion_point(copy_constructor:TP.ChangeFootnoteKindCommandArchive)
}

inline void ChangeFootnoteKindCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.kind_){0}
  };
}

ChangeFootnoteKindCommandArchive::~ChangeFootnoteKindCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeFootnoteKindCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeFootnoteKindCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ChangeFootnoteKindCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeFootnoteKindCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeFootnoteKindCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_.kind_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeFootnoteKindCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(val))) {
            _internal_set_kind(static_cast<::TP::ChangeFootnoteKindCommandArchive_FootnoteKind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeFootnoteKindCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeFootnoteKindCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_kind(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeFootnoteKindCommandArchive)
  return target;
}

size_t ChangeFootnoteKindCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeFootnoteKindCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeFootnoteKindCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeFootnoteKindCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeFootnoteKindCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeFootnoteKindCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeFootnoteKindCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeFootnoteKindCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeFootnoteKindCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeFootnoteKindCommandArchive::CopyFrom(const ChangeFootnoteKindCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeFootnoteKindCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFootnoteKindCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ChangeFootnoteKindCommandArchive::InternalSwap(ChangeFootnoteKindCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeFootnoteKindCommandArchive, _impl_.kind_)
      + sizeof(ChangeFootnoteKindCommandArchive::_impl_.kind_)
      - PROTOBUF_FIELD_OFFSET(ChangeFootnoteKindCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeFootnoteKindCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[29]);
}

// ===================================================================

class ChangeFootnoteNumberingCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeFootnoteNumberingCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeFootnoteNumberingCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_numbering(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeFootnoteNumberingCommandArchive::_Internal::super(const ChangeFootnoteNumberingCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeFootnoteNumberingCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChangeFootnoteNumberingCommandArchive::ChangeFootnoteNumberingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeFootnoteNumberingCommandArchive)
}
ChangeFootnoteNumberingCommandArchive::ChangeFootnoteNumberingCommandArchive(const ChangeFootnoteNumberingCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeFootnoteNumberingCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.numbering_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.numbering_ = from._impl_.numbering_;
  // @@protoc_insertion_point(copy_constructor:TP.ChangeFootnoteNumberingCommandArchive)
}

inline void ChangeFootnoteNumberingCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.numbering_){0}
  };
}

ChangeFootnoteNumberingCommandArchive::~ChangeFootnoteNumberingCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeFootnoteNumberingCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeFootnoteNumberingCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeFootnoteNumberingCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeFootnoteNumberingCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeFootnoteNumberingCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.numbering_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeFootnoteNumberingCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(val))) {
            _internal_set_numbering(static_cast<::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeFootnoteNumberingCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeFootnoteNumberingCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_numbering(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeFootnoteNumberingCommandArchive)
  return target;
}

size_t ChangeFootnoteNumberingCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeFootnoteNumberingCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_numbering());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeFootnoteNumberingCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeFootnoteNumberingCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeFootnoteNumberingCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeFootnoteNumberingCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeFootnoteNumberingCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeFootnoteNumberingCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeFootnoteNumberingCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.numbering_ = from._impl_.numbering_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeFootnoteNumberingCommandArchive::CopyFrom(const ChangeFootnoteNumberingCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeFootnoteNumberingCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFootnoteNumberingCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeFootnoteNumberingCommandArchive::InternalSwap(ChangeFootnoteNumberingCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeFootnoteNumberingCommandArchive, _impl_.numbering_)
      + sizeof(ChangeFootnoteNumberingCommandArchive::_impl_.numbering_)
      - PROTOBUF_FIELD_OFFSET(ChangeFootnoteNumberingCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeFootnoteNumberingCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[30]);
}

// ===================================================================

class ChangeFootnoteSpacingCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeFootnoteSpacingCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeFootnoteSpacingCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_footnote_spacing(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeFootnoteSpacingCommandArchive::_Internal::super(const ChangeFootnoteSpacingCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeFootnoteSpacingCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChangeFootnoteSpacingCommandArchive::ChangeFootnoteSpacingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeFootnoteSpacingCommandArchive)
}
ChangeFootnoteSpacingCommandArchive::ChangeFootnoteSpacingCommandArchive(const ChangeFootnoteSpacingCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeFootnoteSpacingCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.footnote_spacing_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.footnote_spacing_ = from._impl_.footnote_spacing_;
  // @@protoc_insertion_point(copy_constructor:TP.ChangeFootnoteSpacingCommandArchive)
}

inline void ChangeFootnoteSpacingCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.footnote_spacing_){0}
  };
}

ChangeFootnoteSpacingCommandArchive::~ChangeFootnoteSpacingCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeFootnoteSpacingCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeFootnoteSpacingCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeFootnoteSpacingCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeFootnoteSpacingCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeFootnoteSpacingCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.footnote_spacing_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeFootnoteSpacingCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 footnote_spacing = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_footnote_spacing(&has_bits);
          _impl_.footnote_spacing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeFootnoteSpacingCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeFootnoteSpacingCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional int32 footnote_spacing = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_footnote_spacing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeFootnoteSpacingCommandArchive)
  return target;
}

size_t ChangeFootnoteSpacingCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeFootnoteSpacingCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 footnote_spacing = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_footnote_spacing());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeFootnoteSpacingCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeFootnoteSpacingCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeFootnoteSpacingCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeFootnoteSpacingCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeFootnoteSpacingCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeFootnoteSpacingCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeFootnoteSpacingCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.footnote_spacing_ = from._impl_.footnote_spacing_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeFootnoteSpacingCommandArchive::CopyFrom(const ChangeFootnoteSpacingCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeFootnoteSpacingCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFootnoteSpacingCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeFootnoteSpacingCommandArchive::InternalSwap(ChangeFootnoteSpacingCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeFootnoteSpacingCommandArchive, _impl_.footnote_spacing_)
      + sizeof(ChangeFootnoteSpacingCommandArchive::_impl_.footnote_spacing_)
      - PROTOBUF_FIELD_OFFSET(ChangeFootnoteSpacingCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeFootnoteSpacingCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[31]);
}

// ===================================================================

class MoveInlineDrawableAnchoredCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveInlineDrawableAnchoredCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveInlineDrawableAnchoredCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& drawable(const MoveInlineDrawableAnchoredCommandArchive* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alpha_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveInlineDrawableAnchoredCommandArchive::_Internal::super(const MoveInlineDrawableAnchoredCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveInlineDrawableAnchoredCommandArchive::_Internal::drawable(const MoveInlineDrawableAnchoredCommandArchive* msg) {
  return *msg->_impl_.drawable_;
}
void MoveInlineDrawableAnchoredCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveInlineDrawableAnchoredCommandArchive::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MoveInlineDrawableAnchoredCommandArchive::MoveInlineDrawableAnchoredCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveInlineDrawableAnchoredCommandArchive)
}
MoveInlineDrawableAnchoredCommandArchive::MoveInlineDrawableAnchoredCommandArchive(const MoveInlineDrawableAnchoredCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveInlineDrawableAnchoredCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.is_html_wrap_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.fit_type_){}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.alpha_threshold_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  ::memcpy(&_impl_.is_html_wrap_, &from._impl_.is_html_wrap_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alpha_threshold_) -
    reinterpret_cast<char*>(&_impl_.is_html_wrap_)) + sizeof(_impl_.alpha_threshold_));
  // @@protoc_insertion_point(copy_constructor:TP.MoveInlineDrawableAnchoredCommandArchive)
}

inline void MoveInlineDrawableAnchoredCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.is_html_wrap_){false}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.direction_){0u}
    , decltype(_impl_.fit_type_){0u}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.alpha_threshold_){0}
  };
}

MoveInlineDrawableAnchoredCommandArchive::~MoveInlineDrawableAnchoredCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveInlineDrawableAnchoredCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveInlineDrawableAnchoredCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.drawable_;
}

void MoveInlineDrawableAnchoredCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveInlineDrawableAnchoredCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveInlineDrawableAnchoredCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
      _impl_.drawable_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.is_html_wrap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.alpha_threshold_) -
        reinterpret_cast<char*>(&_impl_.is_html_wrap_)) + sizeof(_impl_.alpha_threshold_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveInlineDrawableAnchoredCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference drawable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_direction(&has_bits);
          _impl_.direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fit_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_fit_type(&has_bits);
          _impl_.fit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float margin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_margin(&has_bits);
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float alpha_threshold = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_alpha_threshold(&has_bits);
          _impl_.alpha_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveInlineDrawableAnchoredCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveInlineDrawableAnchoredCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference drawable = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional bool is_html_wrap = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_html_wrap(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_type(), target);
  }

  // optional uint32 direction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_direction(), target);
  }

  // optional uint32 fit_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_fit_type(), target);
  }

  // optional float margin = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_margin(), target);
  }

  // optional float alpha_threshold = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_alpha_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveInlineDrawableAnchoredCommandArchive)
  return target;
}

size_t MoveInlineDrawableAnchoredCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveInlineDrawableAnchoredCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .TSP.Reference drawable = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional bool is_html_wrap = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 direction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_direction());
    }

    // optional uint32 fit_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fit_type());
    }

    // optional float margin = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float alpha_threshold = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveInlineDrawableAnchoredCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveInlineDrawableAnchoredCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveInlineDrawableAnchoredCommandArchive::GetClassData() const { return &_class_data_; }


void MoveInlineDrawableAnchoredCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveInlineDrawableAnchoredCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveInlineDrawableAnchoredCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveInlineDrawableAnchoredCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.fit_type_ = from._impl_.fit_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.alpha_threshold_ = from._impl_.alpha_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveInlineDrawableAnchoredCommandArchive::CopyFrom(const MoveInlineDrawableAnchoredCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveInlineDrawableAnchoredCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveInlineDrawableAnchoredCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  return true;
}

void MoveInlineDrawableAnchoredCommandArchive::InternalSwap(MoveInlineDrawableAnchoredCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveInlineDrawableAnchoredCommandArchive, _impl_.alpha_threshold_)
      + sizeof(MoveInlineDrawableAnchoredCommandArchive::_impl_.alpha_threshold_)
      - PROTOBUF_FIELD_OFFSET(MoveInlineDrawableAnchoredCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveInlineDrawableAnchoredCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[32]);
}

// ===================================================================

class MoveAnchoredDrawableInlineCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveAnchoredDrawableInlineCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveAnchoredDrawableInlineCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& drawable(const MoveAnchoredDrawableInlineCommandArchive* msg);
  static void set_has_drawable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_alpha_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_z_order(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MoveAnchoredDrawableInlineCommandArchive::_Internal::super(const MoveAnchoredDrawableInlineCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveAnchoredDrawableInlineCommandArchive::_Internal::drawable(const MoveAnchoredDrawableInlineCommandArchive* msg) {
  return *msg->_impl_.drawable_;
}
void MoveAnchoredDrawableInlineCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveAnchoredDrawableInlineCommandArchive::clear_drawable() {
  if (_impl_.drawable_ != nullptr) _impl_.drawable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MoveAnchoredDrawableInlineCommandArchive::MoveAnchoredDrawableInlineCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.MoveAnchoredDrawableInlineCommandArchive)
}
MoveAnchoredDrawableInlineCommandArchive::MoveAnchoredDrawableInlineCommandArchive(const MoveAnchoredDrawableInlineCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveAnchoredDrawableInlineCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.is_html_wrap_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.fit_type_){}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.alpha_threshold_){}
    , decltype(_impl_.z_order_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_drawable()) {
    _this->_impl_.drawable_ = new ::TSP::Reference(*from._impl_.drawable_);
  }
  ::memcpy(&_impl_.is_html_wrap_, &from._impl_.is_html_wrap_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_order_) -
    reinterpret_cast<char*>(&_impl_.is_html_wrap_)) + sizeof(_impl_.z_order_));
  // @@protoc_insertion_point(copy_constructor:TP.MoveAnchoredDrawableInlineCommandArchive)
}

inline void MoveAnchoredDrawableInlineCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.drawable_){nullptr}
    , decltype(_impl_.is_html_wrap_){false}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.direction_){0u}
    , decltype(_impl_.fit_type_){0u}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.alpha_threshold_){0}
    , decltype(_impl_.z_order_){0u}
  };
}

MoveAnchoredDrawableInlineCommandArchive::~MoveAnchoredDrawableInlineCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.MoveAnchoredDrawableInlineCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveAnchoredDrawableInlineCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.drawable_;
}

void MoveAnchoredDrawableInlineCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveAnchoredDrawableInlineCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.MoveAnchoredDrawableInlineCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.drawable_ != nullptr);
      _impl_.drawable_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.is_html_wrap_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.alpha_threshold_) -
        reinterpret_cast<char*>(&_impl_.is_html_wrap_)) + sizeof(_impl_.alpha_threshold_));
  }
  _impl_.z_order_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveAnchoredDrawableInlineCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference drawable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_direction(&has_bits);
          _impl_.direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fit_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_fit_type(&has_bits);
          _impl_.fit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float margin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_margin(&has_bits);
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float alpha_threshold = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_alpha_threshold(&has_bits);
          _impl_.alpha_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 z_order = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_z_order(&has_bits);
          _impl_.z_order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveAnchoredDrawableInlineCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.MoveAnchoredDrawableInlineCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference drawable = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  // optional bool is_html_wrap = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_html_wrap(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_type(), target);
  }

  // optional uint32 direction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_direction(), target);
  }

  // optional uint32 fit_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_fit_type(), target);
  }

  // optional float margin = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_margin(), target);
  }

  // optional float alpha_threshold = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_alpha_threshold(), target);
  }

  // optional uint32 z_order = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_z_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.MoveAnchoredDrawableInlineCommandArchive)
  return target;
}

size_t MoveAnchoredDrawableInlineCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.MoveAnchoredDrawableInlineCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .TSP.Reference drawable = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.drawable_);
    }

    // optional bool is_html_wrap = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 direction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_direction());
    }

    // optional uint32 fit_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fit_type());
    }

    // optional float margin = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float alpha_threshold = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional uint32 z_order = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_z_order());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveAnchoredDrawableInlineCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveAnchoredDrawableInlineCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveAnchoredDrawableInlineCommandArchive::GetClassData() const { return &_class_data_; }


void MoveAnchoredDrawableInlineCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveAnchoredDrawableInlineCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveAnchoredDrawableInlineCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.MoveAnchoredDrawableInlineCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_drawable()->::TSP::Reference::MergeFrom(
          from._internal_drawable());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.fit_type_ = from._impl_.fit_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.alpha_threshold_ = from._impl_.alpha_threshold_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_z_order(from._internal_z_order());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveAnchoredDrawableInlineCommandArchive::CopyFrom(const MoveAnchoredDrawableInlineCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.MoveAnchoredDrawableInlineCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveAnchoredDrawableInlineCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_drawable()) {
    if (!_impl_.drawable_->IsInitialized()) return false;
  }
  return true;
}

void MoveAnchoredDrawableInlineCommandArchive::InternalSwap(MoveAnchoredDrawableInlineCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveAnchoredDrawableInlineCommandArchive, _impl_.z_order_)
      + sizeof(MoveAnchoredDrawableInlineCommandArchive::_impl_.z_order_)
      - PROTOBUF_FIELD_OFFSET(MoveAnchoredDrawableInlineCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveAnchoredDrawableInlineCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[33]);
}

// ===================================================================

class InsertFootnoteCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertFootnoteCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const InsertFootnoteCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::TextCommandArchive&
InsertFootnoteCommandArchive::_Internal::super(const InsertFootnoteCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void InsertFootnoteCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
InsertFootnoteCommandArchive::InsertFootnoteCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.InsertFootnoteCommandArchive)
}
InsertFootnoteCommandArchive::InsertFootnoteCommandArchive(const InsertFootnoteCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertFootnoteCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TP.InsertFootnoteCommandArchive)
}

inline void InsertFootnoteCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

InsertFootnoteCommandArchive::~InsertFootnoteCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.InsertFootnoteCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertFootnoteCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void InsertFootnoteCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertFootnoteCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.InsertFootnoteCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertFootnoteCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertFootnoteCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.InsertFootnoteCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.InsertFootnoteCommandArchive)
  return target;
}

size_t InsertFootnoteCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.InsertFootnoteCommandArchive)
  size_t total_size = 0;

  // required .TSWP.TextCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertFootnoteCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertFootnoteCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertFootnoteCommandArchive::GetClassData() const { return &_class_data_; }


void InsertFootnoteCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertFootnoteCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertFootnoteCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.InsertFootnoteCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertFootnoteCommandArchive::CopyFrom(const InsertFootnoteCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.InsertFootnoteCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertFootnoteCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void InsertFootnoteCommandArchive::InternalSwap(InsertFootnoteCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertFootnoteCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[34]);
}

// ===================================================================

class ToggleBodyLayoutDirectionCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ToggleBodyLayoutDirectionCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ToggleBodyLayoutDirectionCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_direction_is_vertical(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ToggleBodyLayoutDirectionCommandArchive::_Internal::super(const ToggleBodyLayoutDirectionCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ToggleBodyLayoutDirectionCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ToggleBodyLayoutDirectionCommandArchive::ToggleBodyLayoutDirectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ToggleBodyLayoutDirectionCommandArchive)
}
ToggleBodyLayoutDirectionCommandArchive::ToggleBodyLayoutDirectionCommandArchive(const ToggleBodyLayoutDirectionCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ToggleBodyLayoutDirectionCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.new_direction_is_vertical_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.new_direction_is_vertical_ = from._impl_.new_direction_is_vertical_;
  // @@protoc_insertion_point(copy_constructor:TP.ToggleBodyLayoutDirectionCommandArchive)
}

inline void ToggleBodyLayoutDirectionCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.new_direction_is_vertical_){false}
  };
}

ToggleBodyLayoutDirectionCommandArchive::~ToggleBodyLayoutDirectionCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ToggleBodyLayoutDirectionCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToggleBodyLayoutDirectionCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ToggleBodyLayoutDirectionCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ToggleBodyLayoutDirectionCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ToggleBodyLayoutDirectionCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.new_direction_is_vertical_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ToggleBodyLayoutDirectionCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool new_direction_is_vertical = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_new_direction_is_vertical(&has_bits);
          _impl_.new_direction_is_vertical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToggleBodyLayoutDirectionCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ToggleBodyLayoutDirectionCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool new_direction_is_vertical = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_new_direction_is_vertical(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ToggleBodyLayoutDirectionCommandArchive)
  return target;
}

size_t ToggleBodyLayoutDirectionCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ToggleBodyLayoutDirectionCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool new_direction_is_vertical = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ToggleBodyLayoutDirectionCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ToggleBodyLayoutDirectionCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ToggleBodyLayoutDirectionCommandArchive::GetClassData() const { return &_class_data_; }


void ToggleBodyLayoutDirectionCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ToggleBodyLayoutDirectionCommandArchive*>(&to_msg);
  auto& from = static_cast<const ToggleBodyLayoutDirectionCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ToggleBodyLayoutDirectionCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.new_direction_is_vertical_ = from._impl_.new_direction_is_vertical_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ToggleBodyLayoutDirectionCommandArchive::CopyFrom(const ToggleBodyLayoutDirectionCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ToggleBodyLayoutDirectionCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleBodyLayoutDirectionCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ToggleBodyLayoutDirectionCommandArchive::InternalSwap(ToggleBodyLayoutDirectionCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ToggleBodyLayoutDirectionCommandArchive, _impl_.new_direction_is_vertical_)
      + sizeof(ToggleBodyLayoutDirectionCommandArchive::_impl_.new_direction_is_vertical_)
      - PROTOBUF_FIELD_OFFSET(ToggleBodyLayoutDirectionCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ToggleBodyLayoutDirectionCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[35]);
}

// ===================================================================

class ChangeCTVisibilityCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ChangeCTVisibilityCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ChangeCTVisibilityCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_markup_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deletions_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ChangeCTVisibilityCommandArchive::_Internal::super(const ChangeCTVisibilityCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ChangeCTVisibilityCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ChangeCTVisibilityCommandArchive::ChangeCTVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.ChangeCTVisibilityCommandArchive)
}
ChangeCTVisibilityCommandArchive::ChangeCTVisibilityCommandArchive(const ChangeCTVisibilityCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ChangeCTVisibilityCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.markup_visible_){}
    , decltype(_impl_.deletions_visible_){}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.markup_visible_, &from._impl_.markup_visible_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.markup_visible_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TP.ChangeCTVisibilityCommandArchive)
}

inline void ChangeCTVisibilityCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.markup_visible_){false}
    , decltype(_impl_.deletions_visible_){false}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
}

ChangeCTVisibilityCommandArchive::~ChangeCTVisibilityCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.ChangeCTVisibilityCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChangeCTVisibilityCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ChangeCTVisibilityCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ChangeCTVisibilityCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.ChangeCTVisibilityCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.markup_visible_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.markup_visible_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChangeCTVisibilityCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool markup_visible = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_markup_visible(&has_bits);
          _impl_.markup_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool deletions_visible = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_deletions_visible(&has_bits);
          _impl_.deletions_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChangeCTVisibilityCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.ChangeCTVisibilityCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool markup_visible = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_markup_visible(), target);
  }

  // optional bool deletions_visible = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_deletions_visible(), target);
  }

  // optional uint32 selection_range_location = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_selection_range_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.ChangeCTVisibilityCommandArchive)
  return target;
}

size_t ChangeCTVisibilityCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.ChangeCTVisibilityCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional bool markup_visible = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool deletions_visible = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 selection_range_location = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ChangeCTVisibilityCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ChangeCTVisibilityCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ChangeCTVisibilityCommandArchive::GetClassData() const { return &_class_data_; }


void ChangeCTVisibilityCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ChangeCTVisibilityCommandArchive*>(&to_msg);
  auto& from = static_cast<const ChangeCTVisibilityCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.ChangeCTVisibilityCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.markup_visible_ = from._impl_.markup_visible_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.deletions_visible_ = from._impl_.deletions_visible_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ChangeCTVisibilityCommandArchive::CopyFrom(const ChangeCTVisibilityCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.ChangeCTVisibilityCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeCTVisibilityCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ChangeCTVisibilityCommandArchive::InternalSwap(ChangeCTVisibilityCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChangeCTVisibilityCommandArchive, _impl_.selection_range_length_)
      + sizeof(ChangeCTVisibilityCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(ChangeCTVisibilityCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChangeCTVisibilityCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[36]);
}

// ===================================================================

class TrackChangesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TrackChangesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const TrackChangesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_track_changes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
TrackChangesCommandArchive::_Internal::super(const TrackChangesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void TrackChangesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TrackChangesCommandArchive::clear_change_session_history() {
  _impl_.change_session_history_.Clear();
}
TrackChangesCommandArchive::TrackChangesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.TrackChangesCommandArchive)
}
TrackChangesCommandArchive::TrackChangesCommandArchive(const TrackChangesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackChangesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.change_session_history_){from._impl_.change_session_history_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.track_changes_){}
    , decltype(_impl_.paused_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.track_changes_, &from._impl_.track_changes_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.paused_) -
    reinterpret_cast<char*>(&_impl_.track_changes_)) + sizeof(_impl_.paused_));
  // @@protoc_insertion_point(copy_constructor:TP.TrackChangesCommandArchive)
}

inline void TrackChangesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.change_session_history_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.track_changes_){false}
    , decltype(_impl_.paused_){false}
  };
}

TrackChangesCommandArchive::~TrackChangesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.TrackChangesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackChangesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.change_session_history_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void TrackChangesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackChangesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.TrackChangesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.change_session_history_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  ::memset(&_impl_.track_changes_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.paused_) -
      reinterpret_cast<char*>(&_impl_.track_changes_)) + sizeof(_impl_.paused_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackChangesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool track_changes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_track_changes(&has_bits);
          _impl_.track_changes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference change_session_history = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_change_session_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool paused = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_paused(&has_bits);
          _impl_.paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackChangesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.TrackChangesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool track_changes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_track_changes(), target);
  }

  // repeated .TSP.Reference change_session_history = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_change_session_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_change_session_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool paused = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_paused(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.TrackChangesCommandArchive)
  return target;
}

size_t TrackChangesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.TrackChangesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference change_session_history = 3;
  total_size += 1UL * this->_internal_change_session_history_size();
  for (const auto& msg : this->_impl_.change_session_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool track_changes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool paused = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackChangesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackChangesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackChangesCommandArchive::GetClassData() const { return &_class_data_; }


void TrackChangesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackChangesCommandArchive*>(&to_msg);
  auto& from = static_cast<const TrackChangesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.TrackChangesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.change_session_history_.MergeFrom(from._impl_.change_session_history_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.track_changes_ = from._impl_.track_changes_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.paused_ = from._impl_.paused_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackChangesCommandArchive::CopyFrom(const TrackChangesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.TrackChangesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackChangesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.change_session_history_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void TrackChangesCommandArchive::InternalSwap(TrackChangesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.change_session_history_.InternalSwap(&other->_impl_.change_session_history_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackChangesCommandArchive, _impl_.paused_)
      + sizeof(TrackChangesCommandArchive::_impl_.paused_)
      - PROTOBUF_FIELD_OFFSET(TrackChangesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackChangesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[37]);
}

// ===================================================================

class DocumentHyphenationCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentHyphenationCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DocumentHyphenationCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hyphenate_document(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DocumentHyphenationCommandArchive::_Internal::super(const DocumentHyphenationCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void DocumentHyphenationCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DocumentHyphenationCommandArchive::DocumentHyphenationCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.DocumentHyphenationCommandArchive)
}
DocumentHyphenationCommandArchive::DocumentHyphenationCommandArchive(const DocumentHyphenationCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DocumentHyphenationCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.hyphenate_document_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.hyphenate_document_ = from._impl_.hyphenate_document_;
  // @@protoc_insertion_point(copy_constructor:TP.DocumentHyphenationCommandArchive)
}

inline void DocumentHyphenationCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.hyphenate_document_){false}
  };
}

DocumentHyphenationCommandArchive::~DocumentHyphenationCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.DocumentHyphenationCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DocumentHyphenationCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DocumentHyphenationCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DocumentHyphenationCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.DocumentHyphenationCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.hyphenate_document_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DocumentHyphenationCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hyphenate_document = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hyphenate_document(&has_bits);
          _impl_.hyphenate_document_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DocumentHyphenationCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.DocumentHyphenationCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool hyphenate_document = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_hyphenate_document(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.DocumentHyphenationCommandArchive)
  return target;
}

size_t DocumentHyphenationCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.DocumentHyphenationCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool hyphenate_document = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DocumentHyphenationCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DocumentHyphenationCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DocumentHyphenationCommandArchive::GetClassData() const { return &_class_data_; }


void DocumentHyphenationCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DocumentHyphenationCommandArchive*>(&to_msg);
  auto& from = static_cast<const DocumentHyphenationCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.DocumentHyphenationCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.hyphenate_document_ = from._impl_.hyphenate_document_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DocumentHyphenationCommandArchive::CopyFrom(const DocumentHyphenationCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.DocumentHyphenationCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentHyphenationCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DocumentHyphenationCommandArchive::InternalSwap(DocumentHyphenationCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DocumentHyphenationCommandArchive, _impl_.hyphenate_document_)
      + sizeof(DocumentHyphenationCommandArchive::_impl_.hyphenate_document_)
      - PROTOBUF_FIELD_OFFSET(DocumentHyphenationCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DocumentHyphenationCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[38]);
}

// ===================================================================

class DocumentLigaturesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentLigaturesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DocumentLigaturesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_ligatures(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DocumentLigaturesCommandArchive::_Internal::super(const DocumentLigaturesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void DocumentLigaturesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DocumentLigaturesCommandArchive::DocumentLigaturesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.DocumentLigaturesCommandArchive)
}
DocumentLigaturesCommandArchive::DocumentLigaturesCommandArchive(const DocumentLigaturesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DocumentLigaturesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.use_ligatures_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.use_ligatures_ = from._impl_.use_ligatures_;
  // @@protoc_insertion_point(copy_constructor:TP.DocumentLigaturesCommandArchive)
}

inline void DocumentLigaturesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.use_ligatures_){false}
  };
}

DocumentLigaturesCommandArchive::~DocumentLigaturesCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.DocumentLigaturesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DocumentLigaturesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DocumentLigaturesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DocumentLigaturesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.DocumentLigaturesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.use_ligatures_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DocumentLigaturesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_ligatures = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_ligatures(&has_bits);
          _impl_.use_ligatures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DocumentLigaturesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.DocumentLigaturesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool use_ligatures = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_use_ligatures(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.DocumentLigaturesCommandArchive)
  return target;
}

size_t DocumentLigaturesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.DocumentLigaturesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool use_ligatures = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DocumentLigaturesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DocumentLigaturesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DocumentLigaturesCommandArchive::GetClassData() const { return &_class_data_; }


void DocumentLigaturesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DocumentLigaturesCommandArchive*>(&to_msg);
  auto& from = static_cast<const DocumentLigaturesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.DocumentLigaturesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.use_ligatures_ = from._impl_.use_ligatures_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DocumentLigaturesCommandArchive::CopyFrom(const DocumentLigaturesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.DocumentLigaturesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentLigaturesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DocumentLigaturesCommandArchive::InternalSwap(DocumentLigaturesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DocumentLigaturesCommandArchive, _impl_.use_ligatures_)
      + sizeof(DocumentLigaturesCommandArchive::_impl_.use_ligatures_)
      - PROTOBUF_FIELD_OFFSET(DocumentLigaturesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DocumentLigaturesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[39]);
}

// ===================================================================

class DocumentHasBodyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentHasBodyCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DocumentHasBodyCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DocumentHasBodyCommandArchive::_Internal::super(const DocumentHasBodyCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void DocumentHasBodyCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
DocumentHasBodyCommandArchive::DocumentHasBodyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.DocumentHasBodyCommandArchive)
}
DocumentHasBodyCommandArchive::DocumentHasBodyCommandArchive(const DocumentHasBodyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DocumentHasBodyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.has_body_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.has_body_ = from._impl_.has_body_;
  // @@protoc_insertion_point(copy_constructor:TP.DocumentHasBodyCommandArchive)
}

inline void DocumentHasBodyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.has_body_){false}
  };
}

DocumentHasBodyCommandArchive::~DocumentHasBodyCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.DocumentHasBodyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DocumentHasBodyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DocumentHasBodyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DocumentHasBodyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.DocumentHasBodyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.has_body_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DocumentHasBodyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_has_body(&has_bits);
          _impl_.has_body_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DocumentHasBodyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.DocumentHasBodyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool has_body = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.DocumentHasBodyCommandArchive)
  return target;
}

size_t DocumentHasBodyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.DocumentHasBodyCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_body = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DocumentHasBodyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DocumentHasBodyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DocumentHasBodyCommandArchive::GetClassData() const { return &_class_data_; }


void DocumentHasBodyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DocumentHasBodyCommandArchive*>(&to_msg);
  auto& from = static_cast<const DocumentHasBodyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.DocumentHasBodyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.has_body_ = from._impl_.has_body_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DocumentHasBodyCommandArchive::CopyFrom(const DocumentHasBodyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.DocumentHasBodyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentHasBodyCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DocumentHasBodyCommandArchive::InternalSwap(DocumentHasBodyCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DocumentHasBodyCommandArchive, _impl_.has_body_)
      + sizeof(DocumentHasBodyCommandArchive::_impl_.has_body_)
      - PROTOBUF_FIELD_OFFSET(DocumentHasBodyCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DocumentHasBodyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[40]);
}

// ===================================================================

class PauseChangeTrackingCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PauseChangeTrackingCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const PauseChangeTrackingCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
PauseChangeTrackingCommandArchive::_Internal::super(const PauseChangeTrackingCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void PauseChangeTrackingCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
PauseChangeTrackingCommandArchive::PauseChangeTrackingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TP.PauseChangeTrackingCommandArchive)
}
PauseChangeTrackingCommandArchive::PauseChangeTrackingCommandArchive(const PauseChangeTrackingCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PauseChangeTrackingCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.paused_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.paused_ = from._impl_.paused_;
  // @@protoc_insertion_point(copy_constructor:TP.PauseChangeTrackingCommandArchive)
}

inline void PauseChangeTrackingCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.paused_){false}
  };
}

PauseChangeTrackingCommandArchive::~PauseChangeTrackingCommandArchive() {
  // @@protoc_insertion_point(destructor:TP.PauseChangeTrackingCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PauseChangeTrackingCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void PauseChangeTrackingCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PauseChangeTrackingCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TP.PauseChangeTrackingCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.paused_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PauseChangeTrackingCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool paused = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_paused(&has_bits);
          _impl_.paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PauseChangeTrackingCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TP.PauseChangeTrackingCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool paused = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_paused(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TP.PauseChangeTrackingCommandArchive)
  return target;
}

size_t PauseChangeTrackingCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TP.PauseChangeTrackingCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool paused = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PauseChangeTrackingCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PauseChangeTrackingCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PauseChangeTrackingCommandArchive::GetClassData() const { return &_class_data_; }


void PauseChangeTrackingCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PauseChangeTrackingCommandArchive*>(&to_msg);
  auto& from = static_cast<const PauseChangeTrackingCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TP.PauseChangeTrackingCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.paused_ = from._impl_.paused_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PauseChangeTrackingCommandArchive::CopyFrom(const PauseChangeTrackingCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TP.PauseChangeTrackingCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PauseChangeTrackingCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void PauseChangeTrackingCommandArchive::InternalSwap(PauseChangeTrackingCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PauseChangeTrackingCommandArchive, _impl_.paused_)
      + sizeof(PauseChangeTrackingCommandArchive::_impl_.paused_)
      - PROTOBUF_FIELD_OFFSET(PauseChangeTrackingCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PauseChangeTrackingCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TPCommandArchives_2eproto_getter, &descriptor_table_TPCommandArchives_2eproto_once,
      file_level_metadata_TPCommandArchives_2eproto[41]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TP::InsertDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::InsertDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::InsertDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::PasteDrawablesCommandArchive_DrawableAndPage*
Arena::CreateMaybeMessage< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::PasteDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::PasteDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::PasteDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::PasteAnchoredDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::PasteAnchoredDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::PasteAnchoredDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesPageIndexCommandArchive_Drawable*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesPageIndexCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesPageIndexCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesPageIndexCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::InsertSectionBreakCommandArchive*
Arena::CreateMaybeMessage< ::TP::InsertSectionBreakCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::InsertSectionBreakCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::DeleteSectionCommandArchive*
Arena::CreateMaybeMessage< ::TP::DeleteSectionCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::DeleteSectionCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ReplaceSectionCommandArchive*
Arena::CreateMaybeMessage< ::TP::ReplaceSectionCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ReplaceSectionCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeSectionPropertyCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeSectionPropertyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeSectionPropertyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::SwapDrawableZOrderCommandArchive_SwapPair*
Arena::CreateMaybeMessage< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::SwapDrawableZOrderCommandArchive*
Arena::CreateMaybeMessage< ::TP::SwapDrawableZOrderCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::SwapDrawableZOrderCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::RemoveDrawablesCommandArchive_DrawableInfo*
Arena::CreateMaybeMessage< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::RemoveDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::RemoveDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::RemoveDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::NudgeDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::NudgeDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::NudgeDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeHeaderFooterVisibilityCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeHeaderFooterVisibilityCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeHeaderFooterVisibilityCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeSectionMarginsCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeSectionMarginsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeSectionMarginsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeDocumentPrinterOptionsCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeDocumentPrinterOptionsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeDocumentPrinterOptionsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::InsertMasterDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::InsertMasterDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::InsertMasterDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveMasterDrawableZOrderCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveMasterDrawableZOrderCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveMasterDrawableZOrderCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable*
Arena::CreateMaybeMessage< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::RemoveMasterDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::RemoveMasterDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::RemoveMasterDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::PasteMasterDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TP::PasteMasterDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::PasteMasterDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesAttachedCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesAttachedCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesAttachedCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveDrawablesFloatingCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveDrawablesFloatingCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveDrawablesFloatingCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::RemoveAnchoredDrawableCommandArchive*
Arena::CreateMaybeMessage< ::TP::RemoveAnchoredDrawableCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::RemoveAnchoredDrawableCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeFootnoteFormatCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeFootnoteFormatCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeFootnoteFormatCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeFootnoteKindCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeFootnoteKindCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeFootnoteKindCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeFootnoteNumberingCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeFootnoteNumberingCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeFootnoteNumberingCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeFootnoteSpacingCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeFootnoteSpacingCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeFootnoteSpacingCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveInlineDrawableAnchoredCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveInlineDrawableAnchoredCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveInlineDrawableAnchoredCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::MoveAnchoredDrawableInlineCommandArchive*
Arena::CreateMaybeMessage< ::TP::MoveAnchoredDrawableInlineCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::MoveAnchoredDrawableInlineCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::InsertFootnoteCommandArchive*
Arena::CreateMaybeMessage< ::TP::InsertFootnoteCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::InsertFootnoteCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ToggleBodyLayoutDirectionCommandArchive*
Arena::CreateMaybeMessage< ::TP::ToggleBodyLayoutDirectionCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ToggleBodyLayoutDirectionCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::ChangeCTVisibilityCommandArchive*
Arena::CreateMaybeMessage< ::TP::ChangeCTVisibilityCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::ChangeCTVisibilityCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::TrackChangesCommandArchive*
Arena::CreateMaybeMessage< ::TP::TrackChangesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::TrackChangesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::DocumentHyphenationCommandArchive*
Arena::CreateMaybeMessage< ::TP::DocumentHyphenationCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::DocumentHyphenationCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::DocumentLigaturesCommandArchive*
Arena::CreateMaybeMessage< ::TP::DocumentLigaturesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::DocumentLigaturesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::DocumentHasBodyCommandArchive*
Arena::CreateMaybeMessage< ::TP::DocumentHasBodyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::DocumentHasBodyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TP::PauseChangeTrackingCommandArchive*
Arena::CreateMaybeMessage< ::TP::PauseChangeTrackingCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TP::PauseChangeTrackingCommandArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
