// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TPCommandArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TPCommandArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TPCommandArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSPMessages.pb.h"
#include "TSWPArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSAArchives.pb.h"
#include "TPArchives.pb.h"
#include "TSWPCommandArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TPCommandArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TPCommandArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TPCommandArchives_2eproto;
namespace TP {
class ChangeCTVisibilityCommandArchive;
struct ChangeCTVisibilityCommandArchiveDefaultTypeInternal;
extern ChangeCTVisibilityCommandArchiveDefaultTypeInternal _ChangeCTVisibilityCommandArchive_default_instance_;
class ChangeDocumentPrinterOptionsCommandArchive;
struct ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal;
extern ChangeDocumentPrinterOptionsCommandArchiveDefaultTypeInternal _ChangeDocumentPrinterOptionsCommandArchive_default_instance_;
class ChangeFootnoteFormatCommandArchive;
struct ChangeFootnoteFormatCommandArchiveDefaultTypeInternal;
extern ChangeFootnoteFormatCommandArchiveDefaultTypeInternal _ChangeFootnoteFormatCommandArchive_default_instance_;
class ChangeFootnoteKindCommandArchive;
struct ChangeFootnoteKindCommandArchiveDefaultTypeInternal;
extern ChangeFootnoteKindCommandArchiveDefaultTypeInternal _ChangeFootnoteKindCommandArchive_default_instance_;
class ChangeFootnoteNumberingCommandArchive;
struct ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal;
extern ChangeFootnoteNumberingCommandArchiveDefaultTypeInternal _ChangeFootnoteNumberingCommandArchive_default_instance_;
class ChangeFootnoteSpacingCommandArchive;
struct ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal;
extern ChangeFootnoteSpacingCommandArchiveDefaultTypeInternal _ChangeFootnoteSpacingCommandArchive_default_instance_;
class ChangeHeaderFooterVisibilityCommandArchive;
struct ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal;
extern ChangeHeaderFooterVisibilityCommandArchiveDefaultTypeInternal _ChangeHeaderFooterVisibilityCommandArchive_default_instance_;
class ChangeSectionMarginsCommandArchive;
struct ChangeSectionMarginsCommandArchiveDefaultTypeInternal;
extern ChangeSectionMarginsCommandArchiveDefaultTypeInternal _ChangeSectionMarginsCommandArchive_default_instance_;
class ChangeSectionPropertyCommandArchive;
struct ChangeSectionPropertyCommandArchiveDefaultTypeInternal;
extern ChangeSectionPropertyCommandArchiveDefaultTypeInternal _ChangeSectionPropertyCommandArchive_default_instance_;
class DeleteSectionCommandArchive;
struct DeleteSectionCommandArchiveDefaultTypeInternal;
extern DeleteSectionCommandArchiveDefaultTypeInternal _DeleteSectionCommandArchive_default_instance_;
class DocumentHasBodyCommandArchive;
struct DocumentHasBodyCommandArchiveDefaultTypeInternal;
extern DocumentHasBodyCommandArchiveDefaultTypeInternal _DocumentHasBodyCommandArchive_default_instance_;
class DocumentHyphenationCommandArchive;
struct DocumentHyphenationCommandArchiveDefaultTypeInternal;
extern DocumentHyphenationCommandArchiveDefaultTypeInternal _DocumentHyphenationCommandArchive_default_instance_;
class DocumentLigaturesCommandArchive;
struct DocumentLigaturesCommandArchiveDefaultTypeInternal;
extern DocumentLigaturesCommandArchiveDefaultTypeInternal _DocumentLigaturesCommandArchive_default_instance_;
class InsertDrawablesCommandArchive;
struct InsertDrawablesCommandArchiveDefaultTypeInternal;
extern InsertDrawablesCommandArchiveDefaultTypeInternal _InsertDrawablesCommandArchive_default_instance_;
class InsertFootnoteCommandArchive;
struct InsertFootnoteCommandArchiveDefaultTypeInternal;
extern InsertFootnoteCommandArchiveDefaultTypeInternal _InsertFootnoteCommandArchive_default_instance_;
class InsertMasterDrawablesCommandArchive;
struct InsertMasterDrawablesCommandArchiveDefaultTypeInternal;
extern InsertMasterDrawablesCommandArchiveDefaultTypeInternal _InsertMasterDrawablesCommandArchive_default_instance_;
class InsertSectionBreakCommandArchive;
struct InsertSectionBreakCommandArchiveDefaultTypeInternal;
extern InsertSectionBreakCommandArchiveDefaultTypeInternal _InsertSectionBreakCommandArchive_default_instance_;
class MoveAnchoredDrawableInlineCommandArchive;
struct MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal;
extern MoveAnchoredDrawableInlineCommandArchiveDefaultTypeInternal _MoveAnchoredDrawableInlineCommandArchive_default_instance_;
class MoveDrawablesAttachedCommandArchive;
struct MoveDrawablesAttachedCommandArchiveDefaultTypeInternal;
extern MoveDrawablesAttachedCommandArchiveDefaultTypeInternal _MoveDrawablesAttachedCommandArchive_default_instance_;
class MoveDrawablesAttachedCommandArchive_FloatingUndo;
struct MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal;
extern MoveDrawablesAttachedCommandArchive_FloatingUndoDefaultTypeInternal _MoveDrawablesAttachedCommandArchive_FloatingUndo_default_instance_;
class MoveDrawablesFloatingCommandArchive;
struct MoveDrawablesFloatingCommandArchiveDefaultTypeInternal;
extern MoveDrawablesFloatingCommandArchiveDefaultTypeInternal _MoveDrawablesFloatingCommandArchive_default_instance_;
class MoveDrawablesFloatingCommandArchive_AttachedUndo;
struct MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal;
extern MoveDrawablesFloatingCommandArchive_AttachedUndoDefaultTypeInternal _MoveDrawablesFloatingCommandArchive_AttachedUndo_default_instance_;
class MoveDrawablesPageIndexCommandArchive;
struct MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal;
extern MoveDrawablesPageIndexCommandArchiveDefaultTypeInternal _MoveDrawablesPageIndexCommandArchive_default_instance_;
class MoveDrawablesPageIndexCommandArchive_Drawable;
struct MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal;
extern MoveDrawablesPageIndexCommandArchive_DrawableDefaultTypeInternal _MoveDrawablesPageIndexCommandArchive_Drawable_default_instance_;
class MoveInlineDrawableAnchoredCommandArchive;
struct MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal;
extern MoveInlineDrawableAnchoredCommandArchiveDefaultTypeInternal _MoveInlineDrawableAnchoredCommandArchive_default_instance_;
class MoveMasterDrawableZOrderCommandArchive;
struct MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal;
extern MoveMasterDrawableZOrderCommandArchiveDefaultTypeInternal _MoveMasterDrawableZOrderCommandArchive_default_instance_;
class NudgeDrawablesCommandArchive;
struct NudgeDrawablesCommandArchiveDefaultTypeInternal;
extern NudgeDrawablesCommandArchiveDefaultTypeInternal _NudgeDrawablesCommandArchive_default_instance_;
class PasteAnchoredDrawablesCommandArchive;
struct PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal;
extern PasteAnchoredDrawablesCommandArchiveDefaultTypeInternal _PasteAnchoredDrawablesCommandArchive_default_instance_;
class PasteDrawablesCommandArchive;
struct PasteDrawablesCommandArchiveDefaultTypeInternal;
extern PasteDrawablesCommandArchiveDefaultTypeInternal _PasteDrawablesCommandArchive_default_instance_;
class PasteDrawablesCommandArchive_DrawableAndPage;
struct PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal;
extern PasteDrawablesCommandArchive_DrawableAndPageDefaultTypeInternal _PasteDrawablesCommandArchive_DrawableAndPage_default_instance_;
class PasteMasterDrawablesCommandArchive;
struct PasteMasterDrawablesCommandArchiveDefaultTypeInternal;
extern PasteMasterDrawablesCommandArchiveDefaultTypeInternal _PasteMasterDrawablesCommandArchive_default_instance_;
class PauseChangeTrackingCommandArchive;
struct PauseChangeTrackingCommandArchiveDefaultTypeInternal;
extern PauseChangeTrackingCommandArchiveDefaultTypeInternal _PauseChangeTrackingCommandArchive_default_instance_;
class RemoveAnchoredDrawableCommandArchive;
struct RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal;
extern RemoveAnchoredDrawableCommandArchiveDefaultTypeInternal _RemoveAnchoredDrawableCommandArchive_default_instance_;
class RemoveDrawablesCommandArchive;
struct RemoveDrawablesCommandArchiveDefaultTypeInternal;
extern RemoveDrawablesCommandArchiveDefaultTypeInternal _RemoveDrawablesCommandArchive_default_instance_;
class RemoveDrawablesCommandArchive_DrawableInfo;
struct RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal;
extern RemoveDrawablesCommandArchive_DrawableInfoDefaultTypeInternal _RemoveDrawablesCommandArchive_DrawableInfo_default_instance_;
class RemoveMasterDrawablesCommandArchive;
struct RemoveMasterDrawablesCommandArchiveDefaultTypeInternal;
extern RemoveMasterDrawablesCommandArchiveDefaultTypeInternal _RemoveMasterDrawablesCommandArchive_default_instance_;
class RemoveMasterDrawablesCommandArchive_MasterDrawable;
struct RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal;
extern RemoveMasterDrawablesCommandArchive_MasterDrawableDefaultTypeInternal _RemoveMasterDrawablesCommandArchive_MasterDrawable_default_instance_;
class ReplaceSectionCommandArchive;
struct ReplaceSectionCommandArchiveDefaultTypeInternal;
extern ReplaceSectionCommandArchiveDefaultTypeInternal _ReplaceSectionCommandArchive_default_instance_;
class SwapDrawableZOrderCommandArchive;
struct SwapDrawableZOrderCommandArchiveDefaultTypeInternal;
extern SwapDrawableZOrderCommandArchiveDefaultTypeInternal _SwapDrawableZOrderCommandArchive_default_instance_;
class SwapDrawableZOrderCommandArchive_SwapPair;
struct SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal;
extern SwapDrawableZOrderCommandArchive_SwapPairDefaultTypeInternal _SwapDrawableZOrderCommandArchive_SwapPair_default_instance_;
class ToggleBodyLayoutDirectionCommandArchive;
struct ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal;
extern ToggleBodyLayoutDirectionCommandArchiveDefaultTypeInternal _ToggleBodyLayoutDirectionCommandArchive_default_instance_;
class TrackChangesCommandArchive;
struct TrackChangesCommandArchiveDefaultTypeInternal;
extern TrackChangesCommandArchiveDefaultTypeInternal _TrackChangesCommandArchive_default_instance_;
}  // namespace TP
PROTOBUF_NAMESPACE_OPEN
template<> ::TP::ChangeCTVisibilityCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeCTVisibilityCommandArchive>(Arena*);
template<> ::TP::ChangeDocumentPrinterOptionsCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeDocumentPrinterOptionsCommandArchive>(Arena*);
template<> ::TP::ChangeFootnoteFormatCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeFootnoteFormatCommandArchive>(Arena*);
template<> ::TP::ChangeFootnoteKindCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeFootnoteKindCommandArchive>(Arena*);
template<> ::TP::ChangeFootnoteNumberingCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeFootnoteNumberingCommandArchive>(Arena*);
template<> ::TP::ChangeFootnoteSpacingCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeFootnoteSpacingCommandArchive>(Arena*);
template<> ::TP::ChangeHeaderFooterVisibilityCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeHeaderFooterVisibilityCommandArchive>(Arena*);
template<> ::TP::ChangeSectionMarginsCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeSectionMarginsCommandArchive>(Arena*);
template<> ::TP::ChangeSectionPropertyCommandArchive* Arena::CreateMaybeMessage<::TP::ChangeSectionPropertyCommandArchive>(Arena*);
template<> ::TP::DeleteSectionCommandArchive* Arena::CreateMaybeMessage<::TP::DeleteSectionCommandArchive>(Arena*);
template<> ::TP::DocumentHasBodyCommandArchive* Arena::CreateMaybeMessage<::TP::DocumentHasBodyCommandArchive>(Arena*);
template<> ::TP::DocumentHyphenationCommandArchive* Arena::CreateMaybeMessage<::TP::DocumentHyphenationCommandArchive>(Arena*);
template<> ::TP::DocumentLigaturesCommandArchive* Arena::CreateMaybeMessage<::TP::DocumentLigaturesCommandArchive>(Arena*);
template<> ::TP::InsertDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::InsertDrawablesCommandArchive>(Arena*);
template<> ::TP::InsertFootnoteCommandArchive* Arena::CreateMaybeMessage<::TP::InsertFootnoteCommandArchive>(Arena*);
template<> ::TP::InsertMasterDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::InsertMasterDrawablesCommandArchive>(Arena*);
template<> ::TP::InsertSectionBreakCommandArchive* Arena::CreateMaybeMessage<::TP::InsertSectionBreakCommandArchive>(Arena*);
template<> ::TP::MoveAnchoredDrawableInlineCommandArchive* Arena::CreateMaybeMessage<::TP::MoveAnchoredDrawableInlineCommandArchive>(Arena*);
template<> ::TP::MoveDrawablesAttachedCommandArchive* Arena::CreateMaybeMessage<::TP::MoveDrawablesAttachedCommandArchive>(Arena*);
template<> ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* Arena::CreateMaybeMessage<::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo>(Arena*);
template<> ::TP::MoveDrawablesFloatingCommandArchive* Arena::CreateMaybeMessage<::TP::MoveDrawablesFloatingCommandArchive>(Arena*);
template<> ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* Arena::CreateMaybeMessage<::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo>(Arena*);
template<> ::TP::MoveDrawablesPageIndexCommandArchive* Arena::CreateMaybeMessage<::TP::MoveDrawablesPageIndexCommandArchive>(Arena*);
template<> ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* Arena::CreateMaybeMessage<::TP::MoveDrawablesPageIndexCommandArchive_Drawable>(Arena*);
template<> ::TP::MoveInlineDrawableAnchoredCommandArchive* Arena::CreateMaybeMessage<::TP::MoveInlineDrawableAnchoredCommandArchive>(Arena*);
template<> ::TP::MoveMasterDrawableZOrderCommandArchive* Arena::CreateMaybeMessage<::TP::MoveMasterDrawableZOrderCommandArchive>(Arena*);
template<> ::TP::NudgeDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::NudgeDrawablesCommandArchive>(Arena*);
template<> ::TP::PasteAnchoredDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::PasteAnchoredDrawablesCommandArchive>(Arena*);
template<> ::TP::PasteDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::PasteDrawablesCommandArchive>(Arena*);
template<> ::TP::PasteDrawablesCommandArchive_DrawableAndPage* Arena::CreateMaybeMessage<::TP::PasteDrawablesCommandArchive_DrawableAndPage>(Arena*);
template<> ::TP::PasteMasterDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::PasteMasterDrawablesCommandArchive>(Arena*);
template<> ::TP::PauseChangeTrackingCommandArchive* Arena::CreateMaybeMessage<::TP::PauseChangeTrackingCommandArchive>(Arena*);
template<> ::TP::RemoveAnchoredDrawableCommandArchive* Arena::CreateMaybeMessage<::TP::RemoveAnchoredDrawableCommandArchive>(Arena*);
template<> ::TP::RemoveDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::RemoveDrawablesCommandArchive>(Arena*);
template<> ::TP::RemoveDrawablesCommandArchive_DrawableInfo* Arena::CreateMaybeMessage<::TP::RemoveDrawablesCommandArchive_DrawableInfo>(Arena*);
template<> ::TP::RemoveMasterDrawablesCommandArchive* Arena::CreateMaybeMessage<::TP::RemoveMasterDrawablesCommandArchive>(Arena*);
template<> ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* Arena::CreateMaybeMessage<::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable>(Arena*);
template<> ::TP::ReplaceSectionCommandArchive* Arena::CreateMaybeMessage<::TP::ReplaceSectionCommandArchive>(Arena*);
template<> ::TP::SwapDrawableZOrderCommandArchive* Arena::CreateMaybeMessage<::TP::SwapDrawableZOrderCommandArchive>(Arena*);
template<> ::TP::SwapDrawableZOrderCommandArchive_SwapPair* Arena::CreateMaybeMessage<::TP::SwapDrawableZOrderCommandArchive_SwapPair>(Arena*);
template<> ::TP::ToggleBodyLayoutDirectionCommandArchive* Arena::CreateMaybeMessage<::TP::ToggleBodyLayoutDirectionCommandArchive>(Arena*);
template<> ::TP::TrackChangesCommandArchive* Arena::CreateMaybeMessage<::TP::TrackChangesCommandArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TP {

enum ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType : int {
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType = 0,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType = 1
};
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(int value);
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MIN = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType;
constexpr int ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_ARRAYSIZE = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
template<typename T>
inline const std::string& ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor(), enum_t_value);
}
inline bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor(), name, value);
}
enum ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex : int {
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft = 0,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderCenter = 1,
  ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight = 2
};
bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(int value);
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MIN = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft;
constexpr ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight;
constexpr int ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_ARRAYSIZE = ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
template<typename T>
inline const std::string& ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor(), enum_t_value);
}
inline bool ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>(
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor(), name, value);
}
enum ChangeSectionMarginsCommandArchive_SectionMargin : int {
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft = 0,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginRight = 1,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginTop = 2,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginBottom = 3,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginHeader = 4,
  ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter = 5
};
bool ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(int value);
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MIN = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft;
constexpr ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX = ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter;
constexpr int ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_ARRAYSIZE = ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
template<typename T>
inline const std::string& ChangeSectionMarginsCommandArchive_SectionMargin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeSectionMarginsCommandArchive_SectionMargin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeSectionMarginsCommandArchive_SectionMargin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeSectionMarginsCommandArchive_SectionMargin_descriptor(), enum_t_value);
}
inline bool ChangeSectionMarginsCommandArchive_SectionMargin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeSectionMarginsCommandArchive_SectionMargin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeSectionMarginsCommandArchive_SectionMargin>(
    ChangeSectionMarginsCommandArchive_SectionMargin_descriptor(), name, value);
}
enum ChangeFootnoteFormatCommandArchive_FootnoteFormat : int {
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric = 0,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatRoman = 1,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatSymbolic = 2,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseNumeric = 3,
  ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic = 4
};
bool ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(int value);
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MIN = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric;
constexpr ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX = ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic;
constexpr int ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_ARRAYSIZE = ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
template<typename T>
inline const std::string& ChangeFootnoteFormatCommandArchive_FootnoteFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeFootnoteFormatCommandArchive_FootnoteFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeFootnoteFormatCommandArchive_FootnoteFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor(), enum_t_value);
}
inline bool ChangeFootnoteFormatCommandArchive_FootnoteFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeFootnoteFormatCommandArchive_FootnoteFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeFootnoteFormatCommandArchive_FootnoteFormat>(
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor(), name, value);
}
enum ChangeFootnoteKindCommandArchive_FootnoteKind : int {
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes = 0,
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindDocumentEndnotes = 1,
  ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes = 2
};
bool ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(int value);
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MIN = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes;
constexpr ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX = ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes;
constexpr int ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_ARRAYSIZE = ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
template<typename T>
inline const std::string& ChangeFootnoteKindCommandArchive_FootnoteKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeFootnoteKindCommandArchive_FootnoteKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeFootnoteKindCommandArchive_FootnoteKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor(), enum_t_value);
}
inline bool ChangeFootnoteKindCommandArchive_FootnoteKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeFootnoteKindCommandArchive_FootnoteKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeFootnoteKindCommandArchive_FootnoteKind>(
    ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor(), name, value);
}
enum ChangeFootnoteNumberingCommandArchive_FootnoteNumbering : int {
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous = 0,
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachPage = 1,
  ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection = 2
};
bool ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(int value);
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MIN = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous;
constexpr ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection;
constexpr int ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_ARRAYSIZE = ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
template<typename T>
inline const std::string& ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor(), enum_t_value);
}
inline bool ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChangeFootnoteNumberingCommandArchive_FootnoteNumbering* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>(
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor(), name, value);
}
// ===================================================================

class InsertDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.InsertDrawablesCommandArchive) */ {
 public:
  inline InsertDrawablesCommandArchive() : InsertDrawablesCommandArchive(nullptr) {}
  ~InsertDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertDrawablesCommandArchive(const InsertDrawablesCommandArchive& from);
  InsertDrawablesCommandArchive(InsertDrawablesCommandArchive&& from) noexcept
    : InsertDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertDrawablesCommandArchive& operator=(const InsertDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertDrawablesCommandArchive& operator=(InsertDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertDrawablesCommandArchive*>(
               &_InsertDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InsertDrawablesCommandArchive& a, InsertDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertDrawablesCommandArchive& from) {
    InsertDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.InsertDrawablesCommandArchive";
  }
  protected:
  explicit InsertDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablesFieldNumber = 4,
    kSuperFieldNumber = 1,
    kPageIndexFieldNumber = 2,
    kZOrderFieldNumber = 3,
    kForPasteFieldNumber = 5,
  };
  // repeated .TSP.Reference drawables = 4;
  int drawables_size() const;
  private:
  int _internal_drawables_size() const;
  public:
  void clear_drawables();
  ::TSP::Reference* mutable_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();
  private:
  const ::TSP::Reference& _internal_drawables(int index) const;
  ::TSP::Reference* _internal_add_drawables();
  public:
  const ::TSP::Reference& drawables(int index) const;
  ::TSP::Reference* add_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional uint32 page_index = 2;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // optional uint32 z_order = 3;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  uint32_t z_order() const;
  void set_z_order(uint32_t value);
  private:
  uint32_t _internal_z_order() const;
  void _internal_set_z_order(uint32_t value);
  public:

  // optional bool forPaste = 5;
  bool has_forpaste() const;
  private:
  bool _internal_has_forpaste() const;
  public:
  void clear_forpaste();
  bool forpaste() const;
  void set_forpaste(bool value);
  private:
  bool _internal_forpaste() const;
  void _internal_set_forpaste(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.InsertDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > drawables_;
    ::TSK::CommandArchive* super_;
    uint32_t page_index_;
    uint32_t z_order_;
    bool forpaste_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class PasteDrawablesCommandArchive_DrawableAndPage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.PasteDrawablesCommandArchive.DrawableAndPage) */ {
 public:
  inline PasteDrawablesCommandArchive_DrawableAndPage() : PasteDrawablesCommandArchive_DrawableAndPage(nullptr) {}
  ~PasteDrawablesCommandArchive_DrawableAndPage() override;
  explicit PROTOBUF_CONSTEXPR PasteDrawablesCommandArchive_DrawableAndPage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasteDrawablesCommandArchive_DrawableAndPage(const PasteDrawablesCommandArchive_DrawableAndPage& from);
  PasteDrawablesCommandArchive_DrawableAndPage(PasteDrawablesCommandArchive_DrawableAndPage&& from) noexcept
    : PasteDrawablesCommandArchive_DrawableAndPage() {
    *this = ::std::move(from);
  }

  inline PasteDrawablesCommandArchive_DrawableAndPage& operator=(const PasteDrawablesCommandArchive_DrawableAndPage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasteDrawablesCommandArchive_DrawableAndPage& operator=(PasteDrawablesCommandArchive_DrawableAndPage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasteDrawablesCommandArchive_DrawableAndPage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasteDrawablesCommandArchive_DrawableAndPage* internal_default_instance() {
    return reinterpret_cast<const PasteDrawablesCommandArchive_DrawableAndPage*>(
               &_PasteDrawablesCommandArchive_DrawableAndPage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PasteDrawablesCommandArchive_DrawableAndPage& a, PasteDrawablesCommandArchive_DrawableAndPage& b) {
    a.Swap(&b);
  }
  inline void Swap(PasteDrawablesCommandArchive_DrawableAndPage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasteDrawablesCommandArchive_DrawableAndPage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasteDrawablesCommandArchive_DrawableAndPage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasteDrawablesCommandArchive_DrawableAndPage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasteDrawablesCommandArchive_DrawableAndPage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasteDrawablesCommandArchive_DrawableAndPage& from) {
    PasteDrawablesCommandArchive_DrawableAndPage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasteDrawablesCommandArchive_DrawableAndPage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.PasteDrawablesCommandArchive.DrawableAndPage";
  }
  protected:
  explicit PasteDrawablesCommandArchive_DrawableAndPage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableFieldNumber = 1,
    kPageIndexFieldNumber = 2,
  };
  // optional .TSP.Reference drawable = 1;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional uint32 page_index = 2;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.PasteDrawablesCommandArchive.DrawableAndPage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_;
    uint32_t page_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class PasteDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.PasteDrawablesCommandArchive) */ {
 public:
  inline PasteDrawablesCommandArchive() : PasteDrawablesCommandArchive(nullptr) {}
  ~PasteDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR PasteDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasteDrawablesCommandArchive(const PasteDrawablesCommandArchive& from);
  PasteDrawablesCommandArchive(PasteDrawablesCommandArchive&& from) noexcept
    : PasteDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline PasteDrawablesCommandArchive& operator=(const PasteDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasteDrawablesCommandArchive& operator=(PasteDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasteDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasteDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const PasteDrawablesCommandArchive*>(
               &_PasteDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PasteDrawablesCommandArchive& a, PasteDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PasteDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasteDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasteDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasteDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasteDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasteDrawablesCommandArchive& from) {
    PasteDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasteDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.PasteDrawablesCommandArchive";
  }
  protected:
  explicit PasteDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PasteDrawablesCommandArchive_DrawableAndPage DrawableAndPage;

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablesFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
  int drawables_size() const;
  private:
  int _internal_drawables_size() const;
  public:
  void clear_drawables();
  ::TP::PasteDrawablesCommandArchive_DrawableAndPage* mutable_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >*
      mutable_drawables();
  private:
  const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& _internal_drawables(int index) const;
  ::TP::PasteDrawablesCommandArchive_DrawableAndPage* _internal_add_drawables();
  public:
  const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& drawables(int index) const;
  ::TP::PasteDrawablesCommandArchive_DrawableAndPage* add_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >&
      drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.PasteDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage > drawables_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class PasteAnchoredDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.PasteAnchoredDrawablesCommandArchive) */ {
 public:
  inline PasteAnchoredDrawablesCommandArchive() : PasteAnchoredDrawablesCommandArchive(nullptr) {}
  ~PasteAnchoredDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR PasteAnchoredDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasteAnchoredDrawablesCommandArchive(const PasteAnchoredDrawablesCommandArchive& from);
  PasteAnchoredDrawablesCommandArchive(PasteAnchoredDrawablesCommandArchive&& from) noexcept
    : PasteAnchoredDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline PasteAnchoredDrawablesCommandArchive& operator=(const PasteAnchoredDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasteAnchoredDrawablesCommandArchive& operator=(PasteAnchoredDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasteAnchoredDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasteAnchoredDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const PasteAnchoredDrawablesCommandArchive*>(
               &_PasteAnchoredDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PasteAnchoredDrawablesCommandArchive& a, PasteAnchoredDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PasteAnchoredDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasteAnchoredDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasteAnchoredDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasteAnchoredDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasteAnchoredDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasteAnchoredDrawablesCommandArchive& from) {
    PasteAnchoredDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasteAnchoredDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.PasteAnchoredDrawablesCommandArchive";
  }
  protected:
  explicit PasteAnchoredDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeprecatedSuperFieldNumber = 1,
    kDeprecatedUndoSelectionFieldNumber = 3,
    kSuperFieldNumber = 4,
    kCanvasSelectionFieldNumber = 5,
    kSelectFieldNumber = 2,
  };
  // required .TSK.CommandGroupArchive deprecated_super = 1;
  bool has_deprecated_super() const;
  private:
  bool _internal_has_deprecated_super() const;
  public:
  void clear_deprecated_super();
  const ::TSK::CommandGroupArchive& deprecated_super() const;
  PROTOBUF_NODISCARD ::TSK::CommandGroupArchive* release_deprecated_super();
  ::TSK::CommandGroupArchive* mutable_deprecated_super();
  void set_allocated_deprecated_super(::TSK::CommandGroupArchive* deprecated_super);
  private:
  const ::TSK::CommandGroupArchive& _internal_deprecated_super() const;
  ::TSK::CommandGroupArchive* _internal_mutable_deprecated_super();
  public:
  void unsafe_arena_set_allocated_deprecated_super(
      ::TSK::CommandGroupArchive* deprecated_super);
  ::TSK::CommandGroupArchive* unsafe_arena_release_deprecated_super();

  // optional .TSP.Reference deprecated_undo_selection = 3;
  bool has_deprecated_undo_selection() const;
  private:
  bool _internal_has_deprecated_undo_selection() const;
  public:
  void clear_deprecated_undo_selection();
  const ::TSP::Reference& deprecated_undo_selection() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_deprecated_undo_selection();
  ::TSP::Reference* mutable_deprecated_undo_selection();
  void set_allocated_deprecated_undo_selection(::TSP::Reference* deprecated_undo_selection);
  private:
  const ::TSP::Reference& _internal_deprecated_undo_selection() const;
  ::TSP::Reference* _internal_mutable_deprecated_undo_selection();
  public:
  void unsafe_arena_set_allocated_deprecated_undo_selection(
      ::TSP::Reference* deprecated_undo_selection);
  ::TSP::Reference* unsafe_arena_release_deprecated_undo_selection();

  // optional .TSK.CommandArchive super = 4;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference canvas_selection = 5;
  bool has_canvas_selection() const;
  private:
  bool _internal_has_canvas_selection() const;
  public:
  void clear_canvas_selection();
  const ::TSP::Reference& canvas_selection() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_canvas_selection();
  ::TSP::Reference* mutable_canvas_selection();
  void set_allocated_canvas_selection(::TSP::Reference* canvas_selection);
  private:
  const ::TSP::Reference& _internal_canvas_selection() const;
  ::TSP::Reference* _internal_mutable_canvas_selection();
  public:
  void unsafe_arena_set_allocated_canvas_selection(
      ::TSP::Reference* canvas_selection);
  ::TSP::Reference* unsafe_arena_release_canvas_selection();

  // optional bool select = 2;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  bool select() const;
  void set_select(bool value);
  private:
  bool _internal_select() const;
  void _internal_set_select(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.PasteAnchoredDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandGroupArchive* deprecated_super_;
    ::TSP::Reference* deprecated_undo_selection_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* canvas_selection_;
    bool select_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesPageIndexCommandArchive_Drawable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesPageIndexCommandArchive.Drawable) */ {
 public:
  inline MoveDrawablesPageIndexCommandArchive_Drawable() : MoveDrawablesPageIndexCommandArchive_Drawable(nullptr) {}
  ~MoveDrawablesPageIndexCommandArchive_Drawable() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchive_Drawable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesPageIndexCommandArchive_Drawable(const MoveDrawablesPageIndexCommandArchive_Drawable& from);
  MoveDrawablesPageIndexCommandArchive_Drawable(MoveDrawablesPageIndexCommandArchive_Drawable&& from) noexcept
    : MoveDrawablesPageIndexCommandArchive_Drawable() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesPageIndexCommandArchive_Drawable& operator=(const MoveDrawablesPageIndexCommandArchive_Drawable& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesPageIndexCommandArchive_Drawable& operator=(MoveDrawablesPageIndexCommandArchive_Drawable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesPageIndexCommandArchive_Drawable& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesPageIndexCommandArchive_Drawable* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesPageIndexCommandArchive_Drawable*>(
               &_MoveDrawablesPageIndexCommandArchive_Drawable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MoveDrawablesPageIndexCommandArchive_Drawable& a, MoveDrawablesPageIndexCommandArchive_Drawable& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesPageIndexCommandArchive_Drawable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesPageIndexCommandArchive_Drawable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesPageIndexCommandArchive_Drawable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesPageIndexCommandArchive_Drawable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesPageIndexCommandArchive_Drawable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesPageIndexCommandArchive_Drawable& from) {
    MoveDrawablesPageIndexCommandArchive_Drawable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesPageIndexCommandArchive_Drawable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesPageIndexCommandArchive.Drawable";
  }
  protected:
  explicit MoveDrawablesPageIndexCommandArchive_Drawable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableFieldNumber = 1,
    kZOrderFieldNumber = 2,
  };
  // optional .TSP.Reference drawable = 1;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional uint32 z_order = 2;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  uint32_t z_order() const;
  void set_z_order(uint32_t value);
  private:
  uint32_t _internal_z_order() const;
  void _internal_set_z_order(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesPageIndexCommandArchive.Drawable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_;
    uint32_t z_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesPageIndexCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesPageIndexCommandArchive) */ {
 public:
  inline MoveDrawablesPageIndexCommandArchive() : MoveDrawablesPageIndexCommandArchive(nullptr) {}
  ~MoveDrawablesPageIndexCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesPageIndexCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesPageIndexCommandArchive(const MoveDrawablesPageIndexCommandArchive& from);
  MoveDrawablesPageIndexCommandArchive(MoveDrawablesPageIndexCommandArchive&& from) noexcept
    : MoveDrawablesPageIndexCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesPageIndexCommandArchive& operator=(const MoveDrawablesPageIndexCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesPageIndexCommandArchive& operator=(MoveDrawablesPageIndexCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesPageIndexCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesPageIndexCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesPageIndexCommandArchive*>(
               &_MoveDrawablesPageIndexCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MoveDrawablesPageIndexCommandArchive& a, MoveDrawablesPageIndexCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesPageIndexCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesPageIndexCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesPageIndexCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesPageIndexCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesPageIndexCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesPageIndexCommandArchive& from) {
    MoveDrawablesPageIndexCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesPageIndexCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesPageIndexCommandArchive";
  }
  protected:
  explicit MoveDrawablesPageIndexCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesPageIndexCommandArchive_Drawable Drawable;

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablesFieldNumber = 3,
    kSuperFieldNumber = 1,
    kPageIndexFieldNumber = 2,
  };
  // repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
  int drawables_size() const;
  private:
  int _internal_drawables_size() const;
  public:
  void clear_drawables();
  ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* mutable_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >*
      mutable_drawables();
  private:
  const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& _internal_drawables(int index) const;
  ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* _internal_add_drawables();
  public:
  const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& drawables(int index) const;
  ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* add_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >&
      drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional uint32 page_index = 2;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesPageIndexCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable > drawables_;
    ::TSK::CommandArchive* super_;
    uint32_t page_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertSectionBreakCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.InsertSectionBreakCommandArchive) */ {
 public:
  inline InsertSectionBreakCommandArchive() : InsertSectionBreakCommandArchive(nullptr) {}
  ~InsertSectionBreakCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertSectionBreakCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertSectionBreakCommandArchive(const InsertSectionBreakCommandArchive& from);
  InsertSectionBreakCommandArchive(InsertSectionBreakCommandArchive&& from) noexcept
    : InsertSectionBreakCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertSectionBreakCommandArchive& operator=(const InsertSectionBreakCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertSectionBreakCommandArchive& operator=(InsertSectionBreakCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertSectionBreakCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertSectionBreakCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertSectionBreakCommandArchive*>(
               &_InsertSectionBreakCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InsertSectionBreakCommandArchive& a, InsertSectionBreakCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertSectionBreakCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertSectionBreakCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertSectionBreakCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertSectionBreakCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertSectionBreakCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertSectionBreakCommandArchive& from) {
    InsertSectionBreakCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertSectionBreakCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.InsertSectionBreakCommandArchive";
  }
  protected:
  explicit InsertSectionBreakCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSWP.TextCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::TextCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::TextCommandArchive* release_super();
  ::TSWP::TextCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::TextCommandArchive* super);
  private:
  const ::TSWP::TextCommandArchive& _internal_super() const;
  ::TSWP::TextCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::TextCommandArchive* super);
  ::TSWP::TextCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.InsertSectionBreakCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::TextCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class DeleteSectionCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.DeleteSectionCommandArchive) */ {
 public:
  inline DeleteSectionCommandArchive() : DeleteSectionCommandArchive(nullptr) {}
  ~DeleteSectionCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR DeleteSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSectionCommandArchive(const DeleteSectionCommandArchive& from);
  DeleteSectionCommandArchive(DeleteSectionCommandArchive&& from) noexcept
    : DeleteSectionCommandArchive() {
    *this = ::std::move(from);
  }

  inline DeleteSectionCommandArchive& operator=(const DeleteSectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSectionCommandArchive& operator=(DeleteSectionCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSectionCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSectionCommandArchive* internal_default_instance() {
    return reinterpret_cast<const DeleteSectionCommandArchive*>(
               &_DeleteSectionCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteSectionCommandArchive& a, DeleteSectionCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSectionCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSectionCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSectionCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSectionCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSectionCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSectionCommandArchive& from) {
    DeleteSectionCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSectionCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.DeleteSectionCommandArchive";
  }
  protected:
  explicit DeleteSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.DeleteSectionCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceSectionCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ReplaceSectionCommandArchive) */ {
 public:
  inline ReplaceSectionCommandArchive() : ReplaceSectionCommandArchive(nullptr) {}
  ~ReplaceSectionCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ReplaceSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceSectionCommandArchive(const ReplaceSectionCommandArchive& from);
  ReplaceSectionCommandArchive(ReplaceSectionCommandArchive&& from) noexcept
    : ReplaceSectionCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceSectionCommandArchive& operator=(const ReplaceSectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceSectionCommandArchive& operator=(ReplaceSectionCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceSectionCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceSectionCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceSectionCommandArchive*>(
               &_ReplaceSectionCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReplaceSectionCommandArchive& a, ReplaceSectionCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceSectionCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceSectionCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaceSectionCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaceSectionCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaceSectionCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaceSectionCommandArchive& from) {
    ReplaceSectionCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceSectionCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ReplaceSectionCommandArchive";
  }
  protected:
  explicit ReplaceSectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSWP.TextCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::TextCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::TextCommandArchive* release_super();
  ::TSWP::TextCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::TextCommandArchive* super);
  private:
  const ::TSWP::TextCommandArchive& _internal_super() const;
  ::TSWP::TextCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::TextCommandArchive* super);
  ::TSWP::TextCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.ReplaceSectionCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::TextCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeSectionPropertyCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeSectionPropertyCommandArchive) */ {
 public:
  inline ChangeSectionPropertyCommandArchive() : ChangeSectionPropertyCommandArchive(nullptr) {}
  ~ChangeSectionPropertyCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeSectionPropertyCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeSectionPropertyCommandArchive(const ChangeSectionPropertyCommandArchive& from);
  ChangeSectionPropertyCommandArchive(ChangeSectionPropertyCommandArchive&& from) noexcept
    : ChangeSectionPropertyCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeSectionPropertyCommandArchive& operator=(const ChangeSectionPropertyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeSectionPropertyCommandArchive& operator=(ChangeSectionPropertyCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeSectionPropertyCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeSectionPropertyCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeSectionPropertyCommandArchive*>(
               &_ChangeSectionPropertyCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ChangeSectionPropertyCommandArchive& a, ChangeSectionPropertyCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeSectionPropertyCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeSectionPropertyCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeSectionPropertyCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeSectionPropertyCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeSectionPropertyCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeSectionPropertyCommandArchive& from) {
    ChangeSectionPropertyCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeSectionPropertyCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeSectionPropertyCommandArchive";
  }
  protected:
  explicit ChangeSectionPropertyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectionPropertyFieldNumber = 3,
    kSuperFieldNumber = 1,
    kSectionIndexFieldNumber = 2,
    kSectionValueBoolFieldNumber = 4,
  };
  // optional string section_property = 3;
  bool has_section_property() const;
  private:
  bool _internal_has_section_property() const;
  public:
  void clear_section_property();
  const std::string& section_property() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_section_property(ArgT0&& arg0, ArgT... args);
  std::string* mutable_section_property();
  PROTOBUF_NODISCARD std::string* release_section_property();
  void set_allocated_section_property(std::string* section_property);
  private:
  const std::string& _internal_section_property() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_section_property(const std::string& value);
  std::string* _internal_mutable_section_property();
  public:

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional uint32 section_index = 2;
  bool has_section_index() const;
  private:
  bool _internal_has_section_index() const;
  public:
  void clear_section_index();
  uint32_t section_index() const;
  void set_section_index(uint32_t value);
  private:
  uint32_t _internal_section_index() const;
  void _internal_set_section_index(uint32_t value);
  public:

  // optional bool section_value_bool = 4;
  bool has_section_value_bool() const;
  private:
  bool _internal_has_section_value_bool() const;
  public:
  void clear_section_value_bool();
  bool section_value_bool() const;
  void set_section_value_bool(bool value);
  private:
  bool _internal_section_value_bool() const;
  void _internal_set_section_value_bool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeSectionPropertyCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr section_property_;
    ::TSK::CommandArchive* super_;
    uint32_t section_index_;
    bool section_value_bool_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class SwapDrawableZOrderCommandArchive_SwapPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.SwapDrawableZOrderCommandArchive.SwapPair) */ {
 public:
  inline SwapDrawableZOrderCommandArchive_SwapPair() : SwapDrawableZOrderCommandArchive_SwapPair(nullptr) {}
  ~SwapDrawableZOrderCommandArchive_SwapPair() override;
  explicit PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchive_SwapPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwapDrawableZOrderCommandArchive_SwapPair(const SwapDrawableZOrderCommandArchive_SwapPair& from);
  SwapDrawableZOrderCommandArchive_SwapPair(SwapDrawableZOrderCommandArchive_SwapPair&& from) noexcept
    : SwapDrawableZOrderCommandArchive_SwapPair() {
    *this = ::std::move(from);
  }

  inline SwapDrawableZOrderCommandArchive_SwapPair& operator=(const SwapDrawableZOrderCommandArchive_SwapPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapDrawableZOrderCommandArchive_SwapPair& operator=(SwapDrawableZOrderCommandArchive_SwapPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwapDrawableZOrderCommandArchive_SwapPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwapDrawableZOrderCommandArchive_SwapPair* internal_default_instance() {
    return reinterpret_cast<const SwapDrawableZOrderCommandArchive_SwapPair*>(
               &_SwapDrawableZOrderCommandArchive_SwapPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SwapDrawableZOrderCommandArchive_SwapPair& a, SwapDrawableZOrderCommandArchive_SwapPair& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapDrawableZOrderCommandArchive_SwapPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapDrawableZOrderCommandArchive_SwapPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwapDrawableZOrderCommandArchive_SwapPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwapDrawableZOrderCommandArchive_SwapPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwapDrawableZOrderCommandArchive_SwapPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwapDrawableZOrderCommandArchive_SwapPair& from) {
    SwapDrawableZOrderCommandArchive_SwapPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapDrawableZOrderCommandArchive_SwapPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.SwapDrawableZOrderCommandArchive.SwapPair";
  }
  protected:
  explicit SwapDrawableZOrderCommandArchive_SwapPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZOrder1FieldNumber = 1,
    kZOrder2FieldNumber = 2,
  };
  // required uint32 z_order_1 = 1;
  bool has_z_order_1() const;
  private:
  bool _internal_has_z_order_1() const;
  public:
  void clear_z_order_1();
  uint32_t z_order_1() const;
  void set_z_order_1(uint32_t value);
  private:
  uint32_t _internal_z_order_1() const;
  void _internal_set_z_order_1(uint32_t value);
  public:

  // required uint32 z_order_2 = 2;
  bool has_z_order_2() const;
  private:
  bool _internal_has_z_order_2() const;
  public:
  void clear_z_order_2();
  uint32_t z_order_2() const;
  void set_z_order_2(uint32_t value);
  private:
  uint32_t _internal_z_order_2() const;
  void _internal_set_z_order_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.SwapDrawableZOrderCommandArchive.SwapPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t z_order_1_;
    uint32_t z_order_2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class SwapDrawableZOrderCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.SwapDrawableZOrderCommandArchive) */ {
 public:
  inline SwapDrawableZOrderCommandArchive() : SwapDrawableZOrderCommandArchive(nullptr) {}
  ~SwapDrawableZOrderCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR SwapDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwapDrawableZOrderCommandArchive(const SwapDrawableZOrderCommandArchive& from);
  SwapDrawableZOrderCommandArchive(SwapDrawableZOrderCommandArchive&& from) noexcept
    : SwapDrawableZOrderCommandArchive() {
    *this = ::std::move(from);
  }

  inline SwapDrawableZOrderCommandArchive& operator=(const SwapDrawableZOrderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapDrawableZOrderCommandArchive& operator=(SwapDrawableZOrderCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwapDrawableZOrderCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwapDrawableZOrderCommandArchive* internal_default_instance() {
    return reinterpret_cast<const SwapDrawableZOrderCommandArchive*>(
               &_SwapDrawableZOrderCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SwapDrawableZOrderCommandArchive& a, SwapDrawableZOrderCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapDrawableZOrderCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapDrawableZOrderCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwapDrawableZOrderCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwapDrawableZOrderCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwapDrawableZOrderCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwapDrawableZOrderCommandArchive& from) {
    SwapDrawableZOrderCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapDrawableZOrderCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.SwapDrawableZOrderCommandArchive";
  }
  protected:
  explicit SwapDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SwapDrawableZOrderCommandArchive_SwapPair SwapPair;

  // accessors -------------------------------------------------------

  enum : int {
    kSwapPairsFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
  int swap_pairs_size() const;
  private:
  int _internal_swap_pairs_size() const;
  public:
  void clear_swap_pairs();
  ::TP::SwapDrawableZOrderCommandArchive_SwapPair* mutable_swap_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >*
      mutable_swap_pairs();
  private:
  const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& _internal_swap_pairs(int index) const;
  ::TP::SwapDrawableZOrderCommandArchive_SwapPair* _internal_add_swap_pairs();
  public:
  const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& swap_pairs(int index) const;
  ::TP::SwapDrawableZOrderCommandArchive_SwapPair* add_swap_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >&
      swap_pairs() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.SwapDrawableZOrderCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair > swap_pairs_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveDrawablesCommandArchive_DrawableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.RemoveDrawablesCommandArchive.DrawableInfo) */ {
 public:
  inline RemoveDrawablesCommandArchive_DrawableInfo() : RemoveDrawablesCommandArchive_DrawableInfo(nullptr) {}
  ~RemoveDrawablesCommandArchive_DrawableInfo() override;
  explicit PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchive_DrawableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDrawablesCommandArchive_DrawableInfo(const RemoveDrawablesCommandArchive_DrawableInfo& from);
  RemoveDrawablesCommandArchive_DrawableInfo(RemoveDrawablesCommandArchive_DrawableInfo&& from) noexcept
    : RemoveDrawablesCommandArchive_DrawableInfo() {
    *this = ::std::move(from);
  }

  inline RemoveDrawablesCommandArchive_DrawableInfo& operator=(const RemoveDrawablesCommandArchive_DrawableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDrawablesCommandArchive_DrawableInfo& operator=(RemoveDrawablesCommandArchive_DrawableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDrawablesCommandArchive_DrawableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDrawablesCommandArchive_DrawableInfo* internal_default_instance() {
    return reinterpret_cast<const RemoveDrawablesCommandArchive_DrawableInfo*>(
               &_RemoveDrawablesCommandArchive_DrawableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RemoveDrawablesCommandArchive_DrawableInfo& a, RemoveDrawablesCommandArchive_DrawableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDrawablesCommandArchive_DrawableInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDrawablesCommandArchive_DrawableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDrawablesCommandArchive_DrawableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDrawablesCommandArchive_DrawableInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveDrawablesCommandArchive_DrawableInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveDrawablesCommandArchive_DrawableInfo& from) {
    RemoveDrawablesCommandArchive_DrawableInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveDrawablesCommandArchive_DrawableInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.RemoveDrawablesCommandArchive.DrawableInfo";
  }
  protected:
  explicit RemoveDrawablesCommandArchive_DrawableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableObjectFieldNumber = 3,
    kPageIndexFieldNumber = 1,
    kZOrderFieldNumber = 2,
  };
  // optional .TSP.Reference drawable_object = 3;
  bool has_drawable_object() const;
  private:
  bool _internal_has_drawable_object() const;
  public:
  void clear_drawable_object();
  const ::TSP::Reference& drawable_object() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable_object();
  ::TSP::Reference* mutable_drawable_object();
  void set_allocated_drawable_object(::TSP::Reference* drawable_object);
  private:
  const ::TSP::Reference& _internal_drawable_object() const;
  ::TSP::Reference* _internal_mutable_drawable_object();
  public:
  void unsafe_arena_set_allocated_drawable_object(
      ::TSP::Reference* drawable_object);
  ::TSP::Reference* unsafe_arena_release_drawable_object();

  // optional uint32 page_index = 1;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // optional int32 z_order = 2;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  int32_t z_order() const;
  void set_z_order(int32_t value);
  private:
  int32_t _internal_z_order() const;
  void _internal_set_z_order(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.RemoveDrawablesCommandArchive.DrawableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_object_;
    uint32_t page_index_;
    int32_t z_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.RemoveDrawablesCommandArchive) */ {
 public:
  inline RemoveDrawablesCommandArchive() : RemoveDrawablesCommandArchive(nullptr) {}
  ~RemoveDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveDrawablesCommandArchive(const RemoveDrawablesCommandArchive& from);
  RemoveDrawablesCommandArchive(RemoveDrawablesCommandArchive&& from) noexcept
    : RemoveDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveDrawablesCommandArchive& operator=(const RemoveDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveDrawablesCommandArchive& operator=(RemoveDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveDrawablesCommandArchive*>(
               &_RemoveDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RemoveDrawablesCommandArchive& a, RemoveDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveDrawablesCommandArchive& from) {
    RemoveDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.RemoveDrawablesCommandArchive";
  }
  protected:
  explicit RemoveDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RemoveDrawablesCommandArchive_DrawableInfo DrawableInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablesFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
  int drawables_size() const;
  private:
  int _internal_drawables_size() const;
  public:
  void clear_drawables();
  ::TP::RemoveDrawablesCommandArchive_DrawableInfo* mutable_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >*
      mutable_drawables();
  private:
  const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& _internal_drawables(int index) const;
  ::TP::RemoveDrawablesCommandArchive_DrawableInfo* _internal_add_drawables();
  public:
  const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& drawables(int index) const;
  ::TP::RemoveDrawablesCommandArchive_DrawableInfo* add_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >&
      drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.RemoveDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo > drawables_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class NudgeDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.NudgeDrawablesCommandArchive) */ {
 public:
  inline NudgeDrawablesCommandArchive() : NudgeDrawablesCommandArchive(nullptr) {}
  ~NudgeDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR NudgeDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NudgeDrawablesCommandArchive(const NudgeDrawablesCommandArchive& from);
  NudgeDrawablesCommandArchive(NudgeDrawablesCommandArchive&& from) noexcept
    : NudgeDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline NudgeDrawablesCommandArchive& operator=(const NudgeDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline NudgeDrawablesCommandArchive& operator=(NudgeDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NudgeDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const NudgeDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const NudgeDrawablesCommandArchive*>(
               &_NudgeDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NudgeDrawablesCommandArchive& a, NudgeDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(NudgeDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NudgeDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NudgeDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NudgeDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NudgeDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NudgeDrawablesCommandArchive& from) {
    NudgeDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NudgeDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.NudgeDrawablesCommandArchive";
  }
  protected:
  explicit NudgeDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildCommandsFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // repeated .TSP.Reference child_commands = 2;
  int child_commands_size() const;
  private:
  int _internal_child_commands_size() const;
  public:
  void clear_child_commands();
  ::TSP::Reference* mutable_child_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_child_commands();
  private:
  const ::TSP::Reference& _internal_child_commands(int index) const;
  ::TSP::Reference* _internal_add_child_commands();
  public:
  const ::TSP::Reference& child_commands(int index) const;
  ::TSP::Reference* add_child_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      child_commands() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.NudgeDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > child_commands_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeHeaderFooterVisibilityCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeHeaderFooterVisibilityCommandArchive) */ {
 public:
  inline ChangeHeaderFooterVisibilityCommandArchive() : ChangeHeaderFooterVisibilityCommandArchive(nullptr) {}
  ~ChangeHeaderFooterVisibilityCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeHeaderFooterVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeHeaderFooterVisibilityCommandArchive(const ChangeHeaderFooterVisibilityCommandArchive& from);
  ChangeHeaderFooterVisibilityCommandArchive(ChangeHeaderFooterVisibilityCommandArchive&& from) noexcept
    : ChangeHeaderFooterVisibilityCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeHeaderFooterVisibilityCommandArchive& operator=(const ChangeHeaderFooterVisibilityCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeHeaderFooterVisibilityCommandArchive& operator=(ChangeHeaderFooterVisibilityCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeHeaderFooterVisibilityCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeHeaderFooterVisibilityCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeHeaderFooterVisibilityCommandArchive*>(
               &_ChangeHeaderFooterVisibilityCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ChangeHeaderFooterVisibilityCommandArchive& a, ChangeHeaderFooterVisibilityCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeHeaderFooterVisibilityCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeHeaderFooterVisibilityCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeHeaderFooterVisibilityCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeHeaderFooterVisibilityCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeHeaderFooterVisibilityCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeHeaderFooterVisibilityCommandArchive& from) {
    ChangeHeaderFooterVisibilityCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeHeaderFooterVisibilityCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeHeaderFooterVisibilityCommandArchive";
  }
  protected:
  explicit ChangeHeaderFooterVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType TPHeaderFooterType;
  static constexpr TPHeaderFooterType kTPHeaderType =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPHeaderType;
  static constexpr TPHeaderFooterType kTPFooterType =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_kTPFooterType;
  static inline bool TPHeaderFooterType_IsValid(int value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(value);
  }
  static constexpr TPHeaderFooterType TPHeaderFooterType_MIN =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MIN;
  static constexpr TPHeaderFooterType TPHeaderFooterType_MAX =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_MAX;
  static constexpr int TPHeaderFooterType_ARRAYSIZE =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_TPHeaderFooterType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TPHeaderFooterType_descriptor() {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
  }
  template<typename T>
  static inline const std::string& TPHeaderFooterType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TPHeaderFooterType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TPHeaderFooterType_Name.");
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Name(enum_t_value);
  }
  static inline bool TPHeaderFooterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TPHeaderFooterType* value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_Parse(name, value);
  }

  typedef ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex TPHeaderFragmentIndex;
  static constexpr TPHeaderFragmentIndex kTPHeaderLeft =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderLeft;
  static constexpr TPHeaderFragmentIndex kTPHeaderCenter =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderCenter;
  static constexpr TPHeaderFragmentIndex kTPHeaderRight =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_kTPHeaderRight;
  static inline bool TPHeaderFragmentIndex_IsValid(int value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(value);
  }
  static constexpr TPHeaderFragmentIndex TPHeaderFragmentIndex_MIN =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MIN;
  static constexpr TPHeaderFragmentIndex TPHeaderFragmentIndex_MAX =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_MAX;
  static constexpr int TPHeaderFragmentIndex_ARRAYSIZE =
    ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_TPHeaderFragmentIndex_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TPHeaderFragmentIndex_descriptor() {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
  }
  template<typename T>
  static inline const std::string& TPHeaderFragmentIndex_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TPHeaderFragmentIndex>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TPHeaderFragmentIndex_Name.");
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Name(enum_t_value);
  }
  static inline bool TPHeaderFragmentIndex_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TPHeaderFragmentIndex* value) {
    return ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStoragesFieldNumber = 5,
    kSuperFieldNumber = 1,
    kVisibleFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexToSelectFieldNumber = 4,
  };
  // repeated .TSP.Reference storages = 5;
  int storages_size() const;
  private:
  int _internal_storages_size() const;
  public:
  void clear_storages();
  ::TSP::Reference* mutable_storages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_storages();
  private:
  const ::TSP::Reference& _internal_storages(int index) const;
  ::TSP::Reference* _internal_add_storages();
  public:
  const ::TSP::Reference& storages(int index) const;
  ::TSP::Reference* add_storages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      storages() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool visible = 2;
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType type() const;
  void set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value);
  private:
  ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType _internal_type() const;
  void _internal_set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value);
  public:

  // optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
  bool has_index_to_select() const;
  private:
  bool _internal_has_index_to_select() const;
  public:
  void clear_index_to_select();
  ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex index_to_select() const;
  void set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value);
  private:
  ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex _internal_index_to_select() const;
  void _internal_set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeHeaderFooterVisibilityCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > storages_;
    ::TSK::CommandArchive* super_;
    bool visible_;
    int type_;
    int index_to_select_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeSectionMarginsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeSectionMarginsCommandArchive) */ {
 public:
  inline ChangeSectionMarginsCommandArchive() : ChangeSectionMarginsCommandArchive(nullptr) {}
  ~ChangeSectionMarginsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeSectionMarginsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeSectionMarginsCommandArchive(const ChangeSectionMarginsCommandArchive& from);
  ChangeSectionMarginsCommandArchive(ChangeSectionMarginsCommandArchive&& from) noexcept
    : ChangeSectionMarginsCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeSectionMarginsCommandArchive& operator=(const ChangeSectionMarginsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeSectionMarginsCommandArchive& operator=(ChangeSectionMarginsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeSectionMarginsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeSectionMarginsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeSectionMarginsCommandArchive*>(
               &_ChangeSectionMarginsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChangeSectionMarginsCommandArchive& a, ChangeSectionMarginsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeSectionMarginsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeSectionMarginsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeSectionMarginsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeSectionMarginsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeSectionMarginsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeSectionMarginsCommandArchive& from) {
    ChangeSectionMarginsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeSectionMarginsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeSectionMarginsCommandArchive";
  }
  protected:
  explicit ChangeSectionMarginsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeSectionMarginsCommandArchive_SectionMargin SectionMargin;
  static constexpr SectionMargin kSectionMarginLeft =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginLeft;
  static constexpr SectionMargin kSectionMarginRight =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginRight;
  static constexpr SectionMargin kSectionMarginTop =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginTop;
  static constexpr SectionMargin kSectionMarginBottom =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginBottom;
  static constexpr SectionMargin kSectionMarginHeader =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginHeader;
  static constexpr SectionMargin kSectionMarginFooter =
    ChangeSectionMarginsCommandArchive_SectionMargin_kSectionMarginFooter;
  static inline bool SectionMargin_IsValid(int value) {
    return ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(value);
  }
  static constexpr SectionMargin SectionMargin_MIN =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MIN;
  static constexpr SectionMargin SectionMargin_MAX =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_MAX;
  static constexpr int SectionMargin_ARRAYSIZE =
    ChangeSectionMarginsCommandArchive_SectionMargin_SectionMargin_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SectionMargin_descriptor() {
    return ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
  }
  template<typename T>
  static inline const std::string& SectionMargin_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SectionMargin>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SectionMargin_Name.");
    return ChangeSectionMarginsCommandArchive_SectionMargin_Name(enum_t_value);
  }
  static inline bool SectionMargin_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SectionMargin* value) {
    return ChangeSectionMarginsCommandArchive_SectionMargin_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kSectionFieldNumber = 2,
    kMarginFieldNumber = 3,
    kMarginValueFieldNumber = 4,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference section = 2;
  bool has_section() const;
  private:
  bool _internal_has_section() const;
  public:
  void clear_section();
  const ::TSP::Reference& section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_section();
  ::TSP::Reference* mutable_section();
  void set_allocated_section(::TSP::Reference* section);
  private:
  const ::TSP::Reference& _internal_section() const;
  ::TSP::Reference* _internal_mutable_section();
  public:
  void unsafe_arena_set_allocated_section(
      ::TSP::Reference* section);
  ::TSP::Reference* unsafe_arena_release_section();

  // optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  ::TP::ChangeSectionMarginsCommandArchive_SectionMargin margin() const;
  void set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value);
  private:
  ::TP::ChangeSectionMarginsCommandArchive_SectionMargin _internal_margin() const;
  void _internal_set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value);
  public:

  // optional float margin_value = 4;
  bool has_margin_value() const;
  private:
  bool _internal_has_margin_value() const;
  public:
  void clear_margin_value();
  float margin_value() const;
  void set_margin_value(float value);
  private:
  float _internal_margin_value() const;
  void _internal_set_margin_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeSectionMarginsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* section_;
    int margin_;
    float margin_value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeDocumentPrinterOptionsCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeDocumentPrinterOptionsCommandArchive) */ {
 public:
  inline ChangeDocumentPrinterOptionsCommandArchive() : ChangeDocumentPrinterOptionsCommandArchive(nullptr) {}
  ~ChangeDocumentPrinterOptionsCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeDocumentPrinterOptionsCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeDocumentPrinterOptionsCommandArchive(const ChangeDocumentPrinterOptionsCommandArchive& from);
  ChangeDocumentPrinterOptionsCommandArchive(ChangeDocumentPrinterOptionsCommandArchive&& from) noexcept
    : ChangeDocumentPrinterOptionsCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeDocumentPrinterOptionsCommandArchive& operator=(const ChangeDocumentPrinterOptionsCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeDocumentPrinterOptionsCommandArchive& operator=(ChangeDocumentPrinterOptionsCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeDocumentPrinterOptionsCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeDocumentPrinterOptionsCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeDocumentPrinterOptionsCommandArchive*>(
               &_ChangeDocumentPrinterOptionsCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ChangeDocumentPrinterOptionsCommandArchive& a, ChangeDocumentPrinterOptionsCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeDocumentPrinterOptionsCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeDocumentPrinterOptionsCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeDocumentPrinterOptionsCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeDocumentPrinterOptionsCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeDocumentPrinterOptionsCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeDocumentPrinterOptionsCommandArchive& from) {
    ChangeDocumentPrinterOptionsCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeDocumentPrinterOptionsCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeDocumentPrinterOptionsCommandArchive";
  }
  protected:
  explicit ChangeDocumentPrinterOptionsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrinterIdFieldNumber = 7,
    kPaperIdFieldNumber = 8,
    kSuperFieldNumber = 1,
    kOBSOLETESectionFieldNumber = 2,
    kPaperWidthFieldNumber = 3,
    kPaperHeightFieldNumber = 4,
    kPageScaleFieldNumber = 5,
    kOrientationFieldNumber = 6,
  };
  // optional string printer_id = 7;
  bool has_printer_id() const;
  private:
  bool _internal_has_printer_id() const;
  public:
  void clear_printer_id();
  const std::string& printer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_printer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_printer_id();
  PROTOBUF_NODISCARD std::string* release_printer_id();
  void set_allocated_printer_id(std::string* printer_id);
  private:
  const std::string& _internal_printer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_printer_id(const std::string& value);
  std::string* _internal_mutable_printer_id();
  public:

  // optional string paper_id = 8;
  bool has_paper_id() const;
  private:
  bool _internal_has_paper_id() const;
  public:
  void clear_paper_id();
  const std::string& paper_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paper_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paper_id();
  PROTOBUF_NODISCARD std::string* release_paper_id();
  void set_allocated_paper_id(std::string* paper_id);
  private:
  const std::string& _internal_paper_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paper_id(const std::string& value);
  std::string* _internal_mutable_paper_id();
  public:

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference OBSOLETE_section = 2;
  bool has_obsolete_section() const;
  private:
  bool _internal_has_obsolete_section() const;
  public:
  void clear_obsolete_section();
  const ::TSP::Reference& obsolete_section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_obsolete_section();
  ::TSP::Reference* mutable_obsolete_section();
  void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);
  private:
  const ::TSP::Reference& _internal_obsolete_section() const;
  ::TSP::Reference* _internal_mutable_obsolete_section();
  public:
  void unsafe_arena_set_allocated_obsolete_section(
      ::TSP::Reference* obsolete_section);
  ::TSP::Reference* unsafe_arena_release_obsolete_section();

  // optional float paper_width = 3;
  bool has_paper_width() const;
  private:
  bool _internal_has_paper_width() const;
  public:
  void clear_paper_width();
  float paper_width() const;
  void set_paper_width(float value);
  private:
  float _internal_paper_width() const;
  void _internal_set_paper_width(float value);
  public:

  // optional float paper_height = 4;
  bool has_paper_height() const;
  private:
  bool _internal_has_paper_height() const;
  public:
  void clear_paper_height();
  float paper_height() const;
  void set_paper_height(float value);
  private:
  float _internal_paper_height() const;
  void _internal_set_paper_height(float value);
  public:

  // optional float page_scale = 5;
  bool has_page_scale() const;
  private:
  bool _internal_has_page_scale() const;
  public:
  void clear_page_scale();
  float page_scale() const;
  void set_page_scale(float value);
  private:
  float _internal_page_scale() const;
  void _internal_set_page_scale(float value);
  public:

  // optional uint32 orientation = 6;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  uint32_t orientation() const;
  void set_orientation(uint32_t value);
  private:
  uint32_t _internal_orientation() const;
  void _internal_set_orientation(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeDocumentPrinterOptionsCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr printer_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paper_id_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* obsolete_section_;
    float paper_width_;
    float paper_height_;
    float page_scale_;
    uint32_t orientation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertMasterDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.InsertMasterDrawablesCommandArchive) */ {
 public:
  inline InsertMasterDrawablesCommandArchive() : InsertMasterDrawablesCommandArchive(nullptr) {}
  ~InsertMasterDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertMasterDrawablesCommandArchive(const InsertMasterDrawablesCommandArchive& from);
  InsertMasterDrawablesCommandArchive(InsertMasterDrawablesCommandArchive&& from) noexcept
    : InsertMasterDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertMasterDrawablesCommandArchive& operator=(const InsertMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMasterDrawablesCommandArchive& operator=(InsertMasterDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertMasterDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertMasterDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertMasterDrawablesCommandArchive*>(
               &_InsertMasterDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InsertMasterDrawablesCommandArchive& a, InsertMasterDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMasterDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertMasterDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertMasterDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertMasterDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertMasterDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertMasterDrawablesCommandArchive& from) {
    InsertMasterDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMasterDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.InsertMasterDrawablesCommandArchive";
  }
  protected:
  explicit InsertMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterDrawablesFieldNumber = 3,
    kSuperFieldNumber = 1,
    kOBSOLETESectionFieldNumber = 2,
    kMasterDrawableProviderFieldNumber = 5,
    kDrawableIndexFieldNumber = 4,
  };
  // repeated .TSP.Reference master_drawables = 3;
  int master_drawables_size() const;
  private:
  int _internal_master_drawables_size() const;
  public:
  void clear_master_drawables();
  ::TSP::Reference* mutable_master_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();
  private:
  const ::TSP::Reference& _internal_master_drawables(int index) const;
  ::TSP::Reference* _internal_add_master_drawables();
  public:
  const ::TSP::Reference& master_drawables(int index) const;
  ::TSP::Reference* add_master_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference OBSOLETE_section = 2;
  bool has_obsolete_section() const;
  private:
  bool _internal_has_obsolete_section() const;
  public:
  void clear_obsolete_section();
  const ::TSP::Reference& obsolete_section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_obsolete_section();
  ::TSP::Reference* mutable_obsolete_section();
  void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);
  private:
  const ::TSP::Reference& _internal_obsolete_section() const;
  ::TSP::Reference* _internal_mutable_obsolete_section();
  public:
  void unsafe_arena_set_allocated_obsolete_section(
      ::TSP::Reference* obsolete_section);
  ::TSP::Reference* unsafe_arena_release_obsolete_section();

  // optional .TSP.Reference master_drawable_provider = 5;
  bool has_master_drawable_provider() const;
  private:
  bool _internal_has_master_drawable_provider() const;
  public:
  void clear_master_drawable_provider();
  const ::TSP::Reference& master_drawable_provider() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_master_drawable_provider();
  ::TSP::Reference* mutable_master_drawable_provider();
  void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);
  private:
  const ::TSP::Reference& _internal_master_drawable_provider() const;
  ::TSP::Reference* _internal_mutable_master_drawable_provider();
  public:
  void unsafe_arena_set_allocated_master_drawable_provider(
      ::TSP::Reference* master_drawable_provider);
  ::TSP::Reference* unsafe_arena_release_master_drawable_provider();

  // optional uint32 drawable_index = 4;
  bool has_drawable_index() const;
  private:
  bool _internal_has_drawable_index() const;
  public:
  void clear_drawable_index();
  uint32_t drawable_index() const;
  void set_drawable_index(uint32_t value);
  private:
  uint32_t _internal_drawable_index() const;
  void _internal_set_drawable_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.InsertMasterDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > master_drawables_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* obsolete_section_;
    ::TSP::Reference* master_drawable_provider_;
    uint32_t drawable_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveMasterDrawableZOrderCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveMasterDrawableZOrderCommandArchive) */ {
 public:
  inline MoveMasterDrawableZOrderCommandArchive() : MoveMasterDrawableZOrderCommandArchive(nullptr) {}
  ~MoveMasterDrawableZOrderCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveMasterDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveMasterDrawableZOrderCommandArchive(const MoveMasterDrawableZOrderCommandArchive& from);
  MoveMasterDrawableZOrderCommandArchive(MoveMasterDrawableZOrderCommandArchive&& from) noexcept
    : MoveMasterDrawableZOrderCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveMasterDrawableZOrderCommandArchive& operator=(const MoveMasterDrawableZOrderCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveMasterDrawableZOrderCommandArchive& operator=(MoveMasterDrawableZOrderCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveMasterDrawableZOrderCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveMasterDrawableZOrderCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveMasterDrawableZOrderCommandArchive*>(
               &_MoveMasterDrawableZOrderCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(MoveMasterDrawableZOrderCommandArchive& a, MoveMasterDrawableZOrderCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveMasterDrawableZOrderCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveMasterDrawableZOrderCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveMasterDrawableZOrderCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveMasterDrawableZOrderCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveMasterDrawableZOrderCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveMasterDrawableZOrderCommandArchive& from) {
    MoveMasterDrawableZOrderCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveMasterDrawableZOrderCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveMasterDrawableZOrderCommandArchive";
  }
  protected:
  explicit MoveMasterDrawableZOrderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterDrawablesFieldNumber = 3,
    kIndexesFieldNumber = 4,
    kSuperFieldNumber = 1,
    kOBSOLETESectionFieldNumber = 2,
    kMasterDrawableProviderFieldNumber = 5,
  };
  // repeated .TSP.Reference master_drawables = 3;
  int master_drawables_size() const;
  private:
  int _internal_master_drawables_size() const;
  public:
  void clear_master_drawables();
  ::TSP::Reference* mutable_master_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();
  private:
  const ::TSP::Reference& _internal_master_drawables(int index) const;
  ::TSP::Reference* _internal_add_master_drawables();
  public:
  const ::TSP::Reference& master_drawables(int index) const;
  ::TSP::Reference* add_master_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;

  // repeated uint32 indexes = 4;
  int indexes_size() const;
  private:
  int _internal_indexes_size() const;
  public:
  void clear_indexes();
  private:
  uint32_t _internal_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_indexes() const;
  void _internal_add_indexes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_indexes();
  public:
  uint32_t indexes(int index) const;
  void set_indexes(int index, uint32_t value);
  void add_indexes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_indexes();

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference OBSOLETE_section = 2;
  bool has_obsolete_section() const;
  private:
  bool _internal_has_obsolete_section() const;
  public:
  void clear_obsolete_section();
  const ::TSP::Reference& obsolete_section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_obsolete_section();
  ::TSP::Reference* mutable_obsolete_section();
  void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);
  private:
  const ::TSP::Reference& _internal_obsolete_section() const;
  ::TSP::Reference* _internal_mutable_obsolete_section();
  public:
  void unsafe_arena_set_allocated_obsolete_section(
      ::TSP::Reference* obsolete_section);
  ::TSP::Reference* unsafe_arena_release_obsolete_section();

  // optional .TSP.Reference master_drawable_provider = 5;
  bool has_master_drawable_provider() const;
  private:
  bool _internal_has_master_drawable_provider() const;
  public:
  void clear_master_drawable_provider();
  const ::TSP::Reference& master_drawable_provider() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_master_drawable_provider();
  ::TSP::Reference* mutable_master_drawable_provider();
  void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);
  private:
  const ::TSP::Reference& _internal_master_drawable_provider() const;
  ::TSP::Reference* _internal_mutable_master_drawable_provider();
  public:
  void unsafe_arena_set_allocated_master_drawable_provider(
      ::TSP::Reference* master_drawable_provider);
  ::TSP::Reference* unsafe_arena_release_master_drawable_provider();

  // @@protoc_insertion_point(class_scope:TP.MoveMasterDrawableZOrderCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > master_drawables_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > indexes_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* obsolete_section_;
    ::TSP::Reference* master_drawable_provider_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveMasterDrawablesCommandArchive_MasterDrawable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable) */ {
 public:
  inline RemoveMasterDrawablesCommandArchive_MasterDrawable() : RemoveMasterDrawablesCommandArchive_MasterDrawable(nullptr) {}
  ~RemoveMasterDrawablesCommandArchive_MasterDrawable() override;
  explicit PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchive_MasterDrawable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveMasterDrawablesCommandArchive_MasterDrawable(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from);
  RemoveMasterDrawablesCommandArchive_MasterDrawable(RemoveMasterDrawablesCommandArchive_MasterDrawable&& from) noexcept
    : RemoveMasterDrawablesCommandArchive_MasterDrawable() {
    *this = ::std::move(from);
  }

  inline RemoveMasterDrawablesCommandArchive_MasterDrawable& operator=(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMasterDrawablesCommandArchive_MasterDrawable& operator=(RemoveMasterDrawablesCommandArchive_MasterDrawable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveMasterDrawablesCommandArchive_MasterDrawable& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveMasterDrawablesCommandArchive_MasterDrawable* internal_default_instance() {
    return reinterpret_cast<const RemoveMasterDrawablesCommandArchive_MasterDrawable*>(
               &_RemoveMasterDrawablesCommandArchive_MasterDrawable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RemoveMasterDrawablesCommandArchive_MasterDrawable& a, RemoveMasterDrawablesCommandArchive_MasterDrawable& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMasterDrawablesCommandArchive_MasterDrawable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMasterDrawablesCommandArchive_MasterDrawable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveMasterDrawablesCommandArchive_MasterDrawable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveMasterDrawablesCommandArchive_MasterDrawable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveMasterDrawablesCommandArchive_MasterDrawable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveMasterDrawablesCommandArchive_MasterDrawable& from) {
    RemoveMasterDrawablesCommandArchive_MasterDrawable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMasterDrawablesCommandArchive_MasterDrawable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.RemoveMasterDrawablesCommandArchive.MasterDrawable";
  }
  protected:
  explicit RemoveMasterDrawablesCommandArchive_MasterDrawable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableFieldNumber = 1,
    kDrawableIndexFieldNumber = 2,
  };
  // optional .TSP.Reference drawable = 1;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional uint32 drawable_index = 2;
  bool has_drawable_index() const;
  private:
  bool _internal_has_drawable_index() const;
  public:
  void clear_drawable_index();
  uint32_t drawable_index() const;
  void set_drawable_index(uint32_t value);
  private:
  uint32_t _internal_drawable_index() const;
  void _internal_set_drawable_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_;
    uint32_t drawable_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveMasterDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.RemoveMasterDrawablesCommandArchive) */ {
 public:
  inline RemoveMasterDrawablesCommandArchive() : RemoveMasterDrawablesCommandArchive(nullptr) {}
  ~RemoveMasterDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveMasterDrawablesCommandArchive(const RemoveMasterDrawablesCommandArchive& from);
  RemoveMasterDrawablesCommandArchive(RemoveMasterDrawablesCommandArchive&& from) noexcept
    : RemoveMasterDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveMasterDrawablesCommandArchive& operator=(const RemoveMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveMasterDrawablesCommandArchive& operator=(RemoveMasterDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveMasterDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveMasterDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveMasterDrawablesCommandArchive*>(
               &_RemoveMasterDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RemoveMasterDrawablesCommandArchive& a, RemoveMasterDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveMasterDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveMasterDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveMasterDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveMasterDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveMasterDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveMasterDrawablesCommandArchive& from) {
    RemoveMasterDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveMasterDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.RemoveMasterDrawablesCommandArchive";
  }
  protected:
  explicit RemoveMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RemoveMasterDrawablesCommandArchive_MasterDrawable MasterDrawable;

  // accessors -------------------------------------------------------

  enum : int {
    kMasterDrawablesFieldNumber = 3,
    kSuperFieldNumber = 1,
    kOBSOLETESectionFieldNumber = 2,
    kMasterDrawableProviderFieldNumber = 4,
  };
  // repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
  int master_drawables_size() const;
  private:
  int _internal_master_drawables_size() const;
  public:
  void clear_master_drawables();
  ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* mutable_master_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >*
      mutable_master_drawables();
  private:
  const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& _internal_master_drawables(int index) const;
  ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* _internal_add_master_drawables();
  public:
  const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& master_drawables(int index) const;
  ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* add_master_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >&
      master_drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference OBSOLETE_section = 2;
  bool has_obsolete_section() const;
  private:
  bool _internal_has_obsolete_section() const;
  public:
  void clear_obsolete_section();
  const ::TSP::Reference& obsolete_section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_obsolete_section();
  ::TSP::Reference* mutable_obsolete_section();
  void set_allocated_obsolete_section(::TSP::Reference* obsolete_section);
  private:
  const ::TSP::Reference& _internal_obsolete_section() const;
  ::TSP::Reference* _internal_mutable_obsolete_section();
  public:
  void unsafe_arena_set_allocated_obsolete_section(
      ::TSP::Reference* obsolete_section);
  ::TSP::Reference* unsafe_arena_release_obsolete_section();

  // optional .TSP.Reference master_drawable_provider = 4;
  bool has_master_drawable_provider() const;
  private:
  bool _internal_has_master_drawable_provider() const;
  public:
  void clear_master_drawable_provider();
  const ::TSP::Reference& master_drawable_provider() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_master_drawable_provider();
  ::TSP::Reference* mutable_master_drawable_provider();
  void set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider);
  private:
  const ::TSP::Reference& _internal_master_drawable_provider() const;
  ::TSP::Reference* _internal_mutable_master_drawable_provider();
  public:
  void unsafe_arena_set_allocated_master_drawable_provider(
      ::TSP::Reference* master_drawable_provider);
  ::TSP::Reference* unsafe_arena_release_master_drawable_provider();

  // @@protoc_insertion_point(class_scope:TP.RemoveMasterDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable > master_drawables_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* obsolete_section_;
    ::TSP::Reference* master_drawable_provider_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class PasteMasterDrawablesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.PasteMasterDrawablesCommandArchive) */ {
 public:
  inline PasteMasterDrawablesCommandArchive() : PasteMasterDrawablesCommandArchive(nullptr) {}
  ~PasteMasterDrawablesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR PasteMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasteMasterDrawablesCommandArchive(const PasteMasterDrawablesCommandArchive& from);
  PasteMasterDrawablesCommandArchive(PasteMasterDrawablesCommandArchive&& from) noexcept
    : PasteMasterDrawablesCommandArchive() {
    *this = ::std::move(from);
  }

  inline PasteMasterDrawablesCommandArchive& operator=(const PasteMasterDrawablesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasteMasterDrawablesCommandArchive& operator=(PasteMasterDrawablesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasteMasterDrawablesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasteMasterDrawablesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const PasteMasterDrawablesCommandArchive*>(
               &_PasteMasterDrawablesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PasteMasterDrawablesCommandArchive& a, PasteMasterDrawablesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PasteMasterDrawablesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasteMasterDrawablesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasteMasterDrawablesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasteMasterDrawablesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasteMasterDrawablesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasteMasterDrawablesCommandArchive& from) {
    PasteMasterDrawablesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasteMasterDrawablesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.PasteMasterDrawablesCommandArchive";
  }
  protected:
  explicit PasteMasterDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterDrawablesFieldNumber = 3,
    kSuperFieldNumber = 1,
    kSectionFieldNumber = 2,
    kDrawableIndexFieldNumber = 4,
  };
  // repeated .TSP.Reference master_drawables = 3;
  int master_drawables_size() const;
  private:
  int _internal_master_drawables_size() const;
  public:
  void clear_master_drawables();
  ::TSP::Reference* mutable_master_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_master_drawables();
  private:
  const ::TSP::Reference& _internal_master_drawables(int index) const;
  ::TSP::Reference* _internal_add_master_drawables();
  public:
  const ::TSP::Reference& master_drawables(int index) const;
  ::TSP::Reference* add_master_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      master_drawables() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference section = 2;
  bool has_section() const;
  private:
  bool _internal_has_section() const;
  public:
  void clear_section();
  const ::TSP::Reference& section() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_section();
  ::TSP::Reference* mutable_section();
  void set_allocated_section(::TSP::Reference* section);
  private:
  const ::TSP::Reference& _internal_section() const;
  ::TSP::Reference* _internal_mutable_section();
  public:
  void unsafe_arena_set_allocated_section(
      ::TSP::Reference* section);
  ::TSP::Reference* unsafe_arena_release_section();

  // optional uint32 drawable_index = 4;
  bool has_drawable_index() const;
  private:
  bool _internal_has_drawable_index() const;
  public:
  void clear_drawable_index();
  uint32_t drawable_index() const;
  void set_drawable_index(uint32_t value);
  private:
  uint32_t _internal_drawable_index() const;
  void _internal_set_drawable_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.PasteMasterDrawablesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > master_drawables_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* section_;
    uint32_t drawable_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesAttachedCommandArchive_FloatingUndo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo) */ {
 public:
  inline MoveDrawablesAttachedCommandArchive_FloatingUndo() : MoveDrawablesAttachedCommandArchive_FloatingUndo(nullptr) {}
  ~MoveDrawablesAttachedCommandArchive_FloatingUndo() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchive_FloatingUndo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesAttachedCommandArchive_FloatingUndo(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from);
  MoveDrawablesAttachedCommandArchive_FloatingUndo(MoveDrawablesAttachedCommandArchive_FloatingUndo&& from) noexcept
    : MoveDrawablesAttachedCommandArchive_FloatingUndo() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesAttachedCommandArchive_FloatingUndo& operator=(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesAttachedCommandArchive_FloatingUndo& operator=(MoveDrawablesAttachedCommandArchive_FloatingUndo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesAttachedCommandArchive_FloatingUndo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesAttachedCommandArchive_FloatingUndo* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesAttachedCommandArchive_FloatingUndo*>(
               &_MoveDrawablesAttachedCommandArchive_FloatingUndo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MoveDrawablesAttachedCommandArchive_FloatingUndo& a, MoveDrawablesAttachedCommandArchive_FloatingUndo& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesAttachedCommandArchive_FloatingUndo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesAttachedCommandArchive_FloatingUndo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesAttachedCommandArchive_FloatingUndo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesAttachedCommandArchive_FloatingUndo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesAttachedCommandArchive_FloatingUndo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesAttachedCommandArchive_FloatingUndo& from) {
    MoveDrawablesAttachedCommandArchive_FloatingUndo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesAttachedCommandArchive_FloatingUndo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesAttachedCommandArchive.FloatingUndo";
  }
  protected:
  explicit MoveDrawablesAttachedCommandArchive_FloatingUndo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableFieldNumber = 1,
    kGeometryFieldNumber = 2,
    kAttachmentFieldNumber = 3,
    kWrapTypeFieldNumber = 4,
    kPageIndexFieldNumber = 5,
    kZOrderFieldNumber = 6,
  };
  // optional .TSP.Reference drawable = 1;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional .TSD.GeometryArchive geometry = 2;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_NODISCARD ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference attachment = 3;
  bool has_attachment() const;
  private:
  bool _internal_has_attachment() const;
  public:
  void clear_attachment();
  const ::TSP::Reference& attachment() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_attachment();
  ::TSP::Reference* mutable_attachment();
  void set_allocated_attachment(::TSP::Reference* attachment);
  private:
  const ::TSP::Reference& _internal_attachment() const;
  ::TSP::Reference* _internal_mutable_attachment();
  public:
  void unsafe_arena_set_allocated_attachment(
      ::TSP::Reference* attachment);
  ::TSP::Reference* unsafe_arena_release_attachment();

  // optional uint32 wrap_type = 4;
  bool has_wrap_type() const;
  private:
  bool _internal_has_wrap_type() const;
  public:
  void clear_wrap_type();
  uint32_t wrap_type() const;
  void set_wrap_type(uint32_t value);
  private:
  uint32_t _internal_wrap_type() const;
  void _internal_set_wrap_type(uint32_t value);
  public:

  // optional uint32 page_index = 5;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // optional int32 z_order = 6;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  int32_t z_order() const;
  void set_z_order(int32_t value);
  private:
  int32_t _internal_z_order() const;
  void _internal_set_z_order(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_;
    ::TSD::GeometryArchive* geometry_;
    ::TSP::Reference* attachment_;
    uint32_t wrap_type_;
    uint32_t page_index_;
    int32_t z_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesAttachedCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesAttachedCommandArchive) */ {
 public:
  inline MoveDrawablesAttachedCommandArchive() : MoveDrawablesAttachedCommandArchive(nullptr) {}
  ~MoveDrawablesAttachedCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesAttachedCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesAttachedCommandArchive(const MoveDrawablesAttachedCommandArchive& from);
  MoveDrawablesAttachedCommandArchive(MoveDrawablesAttachedCommandArchive&& from) noexcept
    : MoveDrawablesAttachedCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesAttachedCommandArchive& operator=(const MoveDrawablesAttachedCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesAttachedCommandArchive& operator=(MoveDrawablesAttachedCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesAttachedCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesAttachedCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesAttachedCommandArchive*>(
               &_MoveDrawablesAttachedCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MoveDrawablesAttachedCommandArchive& a, MoveDrawablesAttachedCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesAttachedCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesAttachedCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesAttachedCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesAttachedCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesAttachedCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesAttachedCommandArchive& from) {
    MoveDrawablesAttachedCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesAttachedCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesAttachedCommandArchive";
  }
  protected:
  explicit MoveDrawablesAttachedCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesAttachedCommandArchive_FloatingUndo FloatingUndo;

  // accessors -------------------------------------------------------

  enum : int {
    kFloatingUndoFieldNumber = 3,
    kSuperFieldNumber = 1,
    kUndoTransactionFieldNumber = 2,
    kSelectFieldNumber = 4,
    kMakeInlineFieldNumber = 5,
  };
  // repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
  int floating_undo_size() const;
  private:
  int _internal_floating_undo_size() const;
  public:
  void clear_floating_undo();
  ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* mutable_floating_undo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >*
      mutable_floating_undo();
  private:
  const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& _internal_floating_undo(int index) const;
  ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* _internal_add_floating_undo();
  public:
  const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& floating_undo(int index) const;
  ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* add_floating_undo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >&
      floating_undo() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSWP.UndoTransaction undo_transaction = 2;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional bool select = 4;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  bool select() const;
  void set_select(bool value);
  private:
  bool _internal_select() const;
  void _internal_set_select(bool value);
  public:

  // optional bool make_inline = 5;
  bool has_make_inline() const;
  private:
  bool _internal_has_make_inline() const;
  public:
  void clear_make_inline();
  bool make_inline() const;
  void set_make_inline(bool value);
  private:
  bool _internal_make_inline() const;
  void _internal_set_make_inline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesAttachedCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo > floating_undo_;
    ::TSK::CommandArchive* super_;
    ::TSWP::UndoTransaction* undo_transaction_;
    bool select_;
    bool make_inline_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesFloatingCommandArchive_AttachedUndo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo) */ {
 public:
  inline MoveDrawablesFloatingCommandArchive_AttachedUndo() : MoveDrawablesFloatingCommandArchive_AttachedUndo(nullptr) {}
  ~MoveDrawablesFloatingCommandArchive_AttachedUndo() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchive_AttachedUndo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesFloatingCommandArchive_AttachedUndo(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from);
  MoveDrawablesFloatingCommandArchive_AttachedUndo(MoveDrawablesFloatingCommandArchive_AttachedUndo&& from) noexcept
    : MoveDrawablesFloatingCommandArchive_AttachedUndo() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesFloatingCommandArchive_AttachedUndo& operator=(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesFloatingCommandArchive_AttachedUndo& operator=(MoveDrawablesFloatingCommandArchive_AttachedUndo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesFloatingCommandArchive_AttachedUndo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesFloatingCommandArchive_AttachedUndo* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesFloatingCommandArchive_AttachedUndo*>(
               &_MoveDrawablesFloatingCommandArchive_AttachedUndo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MoveDrawablesFloatingCommandArchive_AttachedUndo& a, MoveDrawablesFloatingCommandArchive_AttachedUndo& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesFloatingCommandArchive_AttachedUndo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesFloatingCommandArchive_AttachedUndo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesFloatingCommandArchive_AttachedUndo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesFloatingCommandArchive_AttachedUndo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesFloatingCommandArchive_AttachedUndo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesFloatingCommandArchive_AttachedUndo& from) {
    MoveDrawablesFloatingCommandArchive_AttachedUndo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesFloatingCommandArchive_AttachedUndo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesFloatingCommandArchive.AttachedUndo";
  }
  protected:
  explicit MoveDrawablesFloatingCommandArchive_AttachedUndo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawableFieldNumber = 1,
    kGeometryFieldNumber = 2,
    kAttachmentFieldNumber = 3,
    kStorageFieldNumber = 11,
    kUndoTransactionFieldNumber = 12,
    kPageIndexFieldNumber = 4,
    kIsHtmlWrapFieldNumber = 5,
    kTypeFieldNumber = 6,
    kDirectionFieldNumber = 7,
    kFitTypeFieldNumber = 8,
    kMarginFieldNumber = 9,
    kAlphaThresholdFieldNumber = 10,
  };
  // optional .TSP.Reference drawable = 1;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional .TSD.GeometryArchive geometry = 2;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_NODISCARD ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference attachment = 3;
  bool has_attachment() const;
  private:
  bool _internal_has_attachment() const;
  public:
  void clear_attachment();
  const ::TSP::Reference& attachment() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_attachment();
  ::TSP::Reference* mutable_attachment();
  void set_allocated_attachment(::TSP::Reference* attachment);
  private:
  const ::TSP::Reference& _internal_attachment() const;
  ::TSP::Reference* _internal_mutable_attachment();
  public:
  void unsafe_arena_set_allocated_attachment(
      ::TSP::Reference* attachment);
  ::TSP::Reference* unsafe_arena_release_attachment();

  // optional .TSP.Reference storage = 11;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSWP.UndoTransaction undo_transaction = 12;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional uint32 page_index = 4;
  bool has_page_index() const;
  private:
  bool _internal_has_page_index() const;
  public:
  void clear_page_index();
  uint32_t page_index() const;
  void set_page_index(uint32_t value);
  private:
  uint32_t _internal_page_index() const;
  void _internal_set_page_index(uint32_t value);
  public:

  // optional bool is_html_wrap = 5;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // optional uint32 type = 6;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 direction = 7;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  uint32_t direction() const;
  void set_direction(uint32_t value);
  private:
  uint32_t _internal_direction() const;
  void _internal_set_direction(uint32_t value);
  public:

  // optional uint32 fit_type = 8;
  bool has_fit_type() const;
  private:
  bool _internal_has_fit_type() const;
  public:
  void clear_fit_type();
  uint32_t fit_type() const;
  void set_fit_type(uint32_t value);
  private:
  uint32_t _internal_fit_type() const;
  void _internal_set_fit_type(uint32_t value);
  public:

  // optional float margin = 9;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  float margin() const;
  void set_margin(float value);
  private:
  float _internal_margin() const;
  void _internal_set_margin(float value);
  public:

  // optional float alpha_threshold = 10;
  bool has_alpha_threshold() const;
  private:
  bool _internal_has_alpha_threshold() const;
  public:
  void clear_alpha_threshold();
  float alpha_threshold() const;
  void set_alpha_threshold(float value);
  private:
  float _internal_alpha_threshold() const;
  void _internal_set_alpha_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* drawable_;
    ::TSD::GeometryArchive* geometry_;
    ::TSP::Reference* attachment_;
    ::TSP::Reference* storage_;
    ::TSWP::UndoTransaction* undo_transaction_;
    uint32_t page_index_;
    bool is_html_wrap_;
    uint32_t type_;
    uint32_t direction_;
    uint32_t fit_type_;
    float margin_;
    float alpha_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveDrawablesFloatingCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveDrawablesFloatingCommandArchive) */ {
 public:
  inline MoveDrawablesFloatingCommandArchive() : MoveDrawablesFloatingCommandArchive(nullptr) {}
  ~MoveDrawablesFloatingCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveDrawablesFloatingCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveDrawablesFloatingCommandArchive(const MoveDrawablesFloatingCommandArchive& from);
  MoveDrawablesFloatingCommandArchive(MoveDrawablesFloatingCommandArchive&& from) noexcept
    : MoveDrawablesFloatingCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveDrawablesFloatingCommandArchive& operator=(const MoveDrawablesFloatingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDrawablesFloatingCommandArchive& operator=(MoveDrawablesFloatingCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDrawablesFloatingCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDrawablesFloatingCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveDrawablesFloatingCommandArchive*>(
               &_MoveDrawablesFloatingCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(MoveDrawablesFloatingCommandArchive& a, MoveDrawablesFloatingCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveDrawablesFloatingCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDrawablesFloatingCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDrawablesFloatingCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveDrawablesFloatingCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveDrawablesFloatingCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveDrawablesFloatingCommandArchive& from) {
    MoveDrawablesFloatingCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveDrawablesFloatingCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveDrawablesFloatingCommandArchive";
  }
  protected:
  explicit MoveDrawablesFloatingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MoveDrawablesFloatingCommandArchive_AttachedUndo AttachedUndo;

  // accessors -------------------------------------------------------

  enum : int {
    kAttachedUndoFieldNumber = 3,
    kSuperFieldNumber = 1,
    kDeprecatedUndoTransactionFieldNumber = 2,
    kSelectFieldNumber = 4,
  };
  // repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
  int attached_undo_size() const;
  private:
  int _internal_attached_undo_size() const;
  public:
  void clear_attached_undo();
  ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* mutable_attached_undo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >*
      mutable_attached_undo();
  private:
  const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& _internal_attached_undo(int index) const;
  ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* _internal_add_attached_undo();
  public:
  const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& attached_undo(int index) const;
  ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* add_attached_undo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >&
      attached_undo() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
  bool has_deprecated_undo_transaction() const;
  private:
  bool _internal_has_deprecated_undo_transaction() const;
  public:
  void clear_deprecated_undo_transaction();
  const ::TSWP::UndoTransaction& deprecated_undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_deprecated_undo_transaction();
  ::TSWP::UndoTransaction* mutable_deprecated_undo_transaction();
  void set_allocated_deprecated_undo_transaction(::TSWP::UndoTransaction* deprecated_undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_deprecated_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_deprecated_undo_transaction();
  public:
  void unsafe_arena_set_allocated_deprecated_undo_transaction(
      ::TSWP::UndoTransaction* deprecated_undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_deprecated_undo_transaction();

  // optional bool select = 4;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  bool select() const;
  void set_select(bool value);
  private:
  bool _internal_select() const;
  void _internal_set_select(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveDrawablesFloatingCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo > attached_undo_;
    ::TSK::CommandArchive* super_;
    ::TSWP::UndoTransaction* deprecated_undo_transaction_;
    bool select_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class RemoveAnchoredDrawableCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.RemoveAnchoredDrawableCommandArchive) */ {
 public:
  inline RemoveAnchoredDrawableCommandArchive() : RemoveAnchoredDrawableCommandArchive(nullptr) {}
  ~RemoveAnchoredDrawableCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR RemoveAnchoredDrawableCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveAnchoredDrawableCommandArchive(const RemoveAnchoredDrawableCommandArchive& from);
  RemoveAnchoredDrawableCommandArchive(RemoveAnchoredDrawableCommandArchive&& from) noexcept
    : RemoveAnchoredDrawableCommandArchive() {
    *this = ::std::move(from);
  }

  inline RemoveAnchoredDrawableCommandArchive& operator=(const RemoveAnchoredDrawableCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveAnchoredDrawableCommandArchive& operator=(RemoveAnchoredDrawableCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveAnchoredDrawableCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveAnchoredDrawableCommandArchive* internal_default_instance() {
    return reinterpret_cast<const RemoveAnchoredDrawableCommandArchive*>(
               &_RemoveAnchoredDrawableCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RemoveAnchoredDrawableCommandArchive& a, RemoveAnchoredDrawableCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveAnchoredDrawableCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveAnchoredDrawableCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveAnchoredDrawableCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveAnchoredDrawableCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveAnchoredDrawableCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveAnchoredDrawableCommandArchive& from) {
    RemoveAnchoredDrawableCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveAnchoredDrawableCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.RemoveAnchoredDrawableCommandArchive";
  }
  protected:
  explicit RemoveAnchoredDrawableCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kCharIndexFieldNumber = 2,
    kZOrderFieldNumber = 3,
  };
  // required .TSWP.TextCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::TextCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::TextCommandArchive* release_super();
  ::TSWP::TextCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::TextCommandArchive* super);
  private:
  const ::TSWP::TextCommandArchive& _internal_super() const;
  ::TSWP::TextCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::TextCommandArchive* super);
  ::TSWP::TextCommandArchive* unsafe_arena_release_super();

  // optional uint32 char_index = 2;
  bool has_char_index() const;
  private:
  bool _internal_has_char_index() const;
  public:
  void clear_char_index();
  uint32_t char_index() const;
  void set_char_index(uint32_t value);
  private:
  uint32_t _internal_char_index() const;
  void _internal_set_char_index(uint32_t value);
  public:

  // optional uint32 z_order = 3;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  uint32_t z_order() const;
  void set_z_order(uint32_t value);
  private:
  uint32_t _internal_z_order() const;
  void _internal_set_z_order(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.RemoveAnchoredDrawableCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::TextCommandArchive* super_;
    uint32_t char_index_;
    uint32_t z_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeFootnoteFormatCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeFootnoteFormatCommandArchive) */ {
 public:
  inline ChangeFootnoteFormatCommandArchive() : ChangeFootnoteFormatCommandArchive(nullptr) {}
  ~ChangeFootnoteFormatCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeFootnoteFormatCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeFootnoteFormatCommandArchive(const ChangeFootnoteFormatCommandArchive& from);
  ChangeFootnoteFormatCommandArchive(ChangeFootnoteFormatCommandArchive&& from) noexcept
    : ChangeFootnoteFormatCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeFootnoteFormatCommandArchive& operator=(const ChangeFootnoteFormatCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeFootnoteFormatCommandArchive& operator=(ChangeFootnoteFormatCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeFootnoteFormatCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeFootnoteFormatCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeFootnoteFormatCommandArchive*>(
               &_ChangeFootnoteFormatCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ChangeFootnoteFormatCommandArchive& a, ChangeFootnoteFormatCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeFootnoteFormatCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeFootnoteFormatCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeFootnoteFormatCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeFootnoteFormatCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeFootnoteFormatCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeFootnoteFormatCommandArchive& from) {
    ChangeFootnoteFormatCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeFootnoteFormatCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeFootnoteFormatCommandArchive";
  }
  protected:
  explicit ChangeFootnoteFormatCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteFormatCommandArchive_FootnoteFormat FootnoteFormat;
  static constexpr FootnoteFormat kFootnoteFormatNumeric =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatNumeric;
  static constexpr FootnoteFormat kFootnoteFormatRoman =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatRoman;
  static constexpr FootnoteFormat kFootnoteFormatSymbolic =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatSymbolic;
  static constexpr FootnoteFormat kFootnoteFormatJapaneseNumeric =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseNumeric;
  static constexpr FootnoteFormat kFootnoteFormatJapaneseIdeographic =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_kFootnoteFormatJapaneseIdeographic;
  static inline bool FootnoteFormat_IsValid(int value) {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(value);
  }
  static constexpr FootnoteFormat FootnoteFormat_MIN =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MIN;
  static constexpr FootnoteFormat FootnoteFormat_MAX =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_MAX;
  static constexpr int FootnoteFormat_ARRAYSIZE =
    ChangeFootnoteFormatCommandArchive_FootnoteFormat_FootnoteFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FootnoteFormat_descriptor() {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& FootnoteFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FootnoteFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FootnoteFormat_Name.");
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_Name(enum_t_value);
  }
  static inline bool FootnoteFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FootnoteFormat* value) {
    return ChangeFootnoteFormatCommandArchive_FootnoteFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kFormatFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat format() const;
  void set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value);
  private:
  ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat _internal_format() const;
  void _internal_set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteFormatCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    int format_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeFootnoteKindCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeFootnoteKindCommandArchive) */ {
 public:
  inline ChangeFootnoteKindCommandArchive() : ChangeFootnoteKindCommandArchive(nullptr) {}
  ~ChangeFootnoteKindCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeFootnoteKindCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeFootnoteKindCommandArchive(const ChangeFootnoteKindCommandArchive& from);
  ChangeFootnoteKindCommandArchive(ChangeFootnoteKindCommandArchive&& from) noexcept
    : ChangeFootnoteKindCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeFootnoteKindCommandArchive& operator=(const ChangeFootnoteKindCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeFootnoteKindCommandArchive& operator=(ChangeFootnoteKindCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeFootnoteKindCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeFootnoteKindCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeFootnoteKindCommandArchive*>(
               &_ChangeFootnoteKindCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ChangeFootnoteKindCommandArchive& a, ChangeFootnoteKindCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeFootnoteKindCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeFootnoteKindCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeFootnoteKindCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeFootnoteKindCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeFootnoteKindCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeFootnoteKindCommandArchive& from) {
    ChangeFootnoteKindCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeFootnoteKindCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeFootnoteKindCommandArchive";
  }
  protected:
  explicit ChangeFootnoteKindCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteKindCommandArchive_FootnoteKind FootnoteKind;
  static constexpr FootnoteKind kFootnoteKindFootnotes =
    ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindFootnotes;
  static constexpr FootnoteKind kFootnoteKindDocumentEndnotes =
    ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindDocumentEndnotes;
  static constexpr FootnoteKind kFootnoteKindSectionEndnotes =
    ChangeFootnoteKindCommandArchive_FootnoteKind_kFootnoteKindSectionEndnotes;
  static inline bool FootnoteKind_IsValid(int value) {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(value);
  }
  static constexpr FootnoteKind FootnoteKind_MIN =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MIN;
  static constexpr FootnoteKind FootnoteKind_MAX =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_MAX;
  static constexpr int FootnoteKind_ARRAYSIZE =
    ChangeFootnoteKindCommandArchive_FootnoteKind_FootnoteKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FootnoteKind_descriptor() {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
  }
  template<typename T>
  static inline const std::string& FootnoteKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FootnoteKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FootnoteKind_Name.");
    return ChangeFootnoteKindCommandArchive_FootnoteKind_Name(enum_t_value);
  }
  static inline bool FootnoteKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FootnoteKind* value) {
    return ChangeFootnoteKindCommandArchive_FootnoteKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kUndoTransactionFieldNumber = 3,
    kKindFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  bool has_undo_transaction() const;
  private:
  bool _internal_has_undo_transaction() const;
  public:
  void clear_undo_transaction();
  const ::TSWP::UndoTransaction& undo_transaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_undo_transaction();
  ::TSWP::UndoTransaction* mutable_undo_transaction();
  void set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction);
  private:
  const ::TSWP::UndoTransaction& _internal_undo_transaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_undo_transaction();
  public:
  void unsafe_arena_set_allocated_undo_transaction(
      ::TSWP::UndoTransaction* undo_transaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_undo_transaction();

  // optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind kind() const;
  void set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value);
  private:
  ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind _internal_kind() const;
  void _internal_set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteKindCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSWP::UndoTransaction* undo_transaction_;
    int kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeFootnoteNumberingCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeFootnoteNumberingCommandArchive) */ {
 public:
  inline ChangeFootnoteNumberingCommandArchive() : ChangeFootnoteNumberingCommandArchive(nullptr) {}
  ~ChangeFootnoteNumberingCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeFootnoteNumberingCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeFootnoteNumberingCommandArchive(const ChangeFootnoteNumberingCommandArchive& from);
  ChangeFootnoteNumberingCommandArchive(ChangeFootnoteNumberingCommandArchive&& from) noexcept
    : ChangeFootnoteNumberingCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeFootnoteNumberingCommandArchive& operator=(const ChangeFootnoteNumberingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeFootnoteNumberingCommandArchive& operator=(ChangeFootnoteNumberingCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeFootnoteNumberingCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeFootnoteNumberingCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeFootnoteNumberingCommandArchive*>(
               &_ChangeFootnoteNumberingCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ChangeFootnoteNumberingCommandArchive& a, ChangeFootnoteNumberingCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeFootnoteNumberingCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeFootnoteNumberingCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeFootnoteNumberingCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeFootnoteNumberingCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeFootnoteNumberingCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeFootnoteNumberingCommandArchive& from) {
    ChangeFootnoteNumberingCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeFootnoteNumberingCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeFootnoteNumberingCommandArchive";
  }
  protected:
  explicit ChangeFootnoteNumberingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeFootnoteNumberingCommandArchive_FootnoteNumbering FootnoteNumbering;
  static constexpr FootnoteNumbering kFootnoteNumberingContinuous =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingContinuous;
  static constexpr FootnoteNumbering kFootnoteNumberingRestartEachPage =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachPage;
  static constexpr FootnoteNumbering kFootnoteNumberingRestartEachSection =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_kFootnoteNumberingRestartEachSection;
  static inline bool FootnoteNumbering_IsValid(int value) {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(value);
  }
  static constexpr FootnoteNumbering FootnoteNumbering_MIN =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MIN;
  static constexpr FootnoteNumbering FootnoteNumbering_MAX =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_MAX;
  static constexpr int FootnoteNumbering_ARRAYSIZE =
    ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_FootnoteNumbering_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FootnoteNumbering_descriptor() {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
  }
  template<typename T>
  static inline const std::string& FootnoteNumbering_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FootnoteNumbering>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FootnoteNumbering_Name.");
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Name(enum_t_value);
  }
  static inline bool FootnoteNumbering_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FootnoteNumbering* value) {
    return ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kNumberingFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
  bool has_numbering() const;
  private:
  bool _internal_has_numbering() const;
  public:
  void clear_numbering();
  ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering numbering() const;
  void set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value);
  private:
  ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering _internal_numbering() const;
  void _internal_set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteNumberingCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    int numbering_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeFootnoteSpacingCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeFootnoteSpacingCommandArchive) */ {
 public:
  inline ChangeFootnoteSpacingCommandArchive() : ChangeFootnoteSpacingCommandArchive(nullptr) {}
  ~ChangeFootnoteSpacingCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeFootnoteSpacingCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeFootnoteSpacingCommandArchive(const ChangeFootnoteSpacingCommandArchive& from);
  ChangeFootnoteSpacingCommandArchive(ChangeFootnoteSpacingCommandArchive&& from) noexcept
    : ChangeFootnoteSpacingCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeFootnoteSpacingCommandArchive& operator=(const ChangeFootnoteSpacingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeFootnoteSpacingCommandArchive& operator=(ChangeFootnoteSpacingCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeFootnoteSpacingCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeFootnoteSpacingCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeFootnoteSpacingCommandArchive*>(
               &_ChangeFootnoteSpacingCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ChangeFootnoteSpacingCommandArchive& a, ChangeFootnoteSpacingCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeFootnoteSpacingCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeFootnoteSpacingCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeFootnoteSpacingCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeFootnoteSpacingCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeFootnoteSpacingCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeFootnoteSpacingCommandArchive& from) {
    ChangeFootnoteSpacingCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeFootnoteSpacingCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeFootnoteSpacingCommandArchive";
  }
  protected:
  explicit ChangeFootnoteSpacingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kFootnoteSpacingFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional int32 footnote_spacing = 2;
  bool has_footnote_spacing() const;
  private:
  bool _internal_has_footnote_spacing() const;
  public:
  void clear_footnote_spacing();
  int32_t footnote_spacing() const;
  void set_footnote_spacing(int32_t value);
  private:
  int32_t _internal_footnote_spacing() const;
  void _internal_set_footnote_spacing(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeFootnoteSpacingCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    int32_t footnote_spacing_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveInlineDrawableAnchoredCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveInlineDrawableAnchoredCommandArchive) */ {
 public:
  inline MoveInlineDrawableAnchoredCommandArchive() : MoveInlineDrawableAnchoredCommandArchive(nullptr) {}
  ~MoveInlineDrawableAnchoredCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveInlineDrawableAnchoredCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveInlineDrawableAnchoredCommandArchive(const MoveInlineDrawableAnchoredCommandArchive& from);
  MoveInlineDrawableAnchoredCommandArchive(MoveInlineDrawableAnchoredCommandArchive&& from) noexcept
    : MoveInlineDrawableAnchoredCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveInlineDrawableAnchoredCommandArchive& operator=(const MoveInlineDrawableAnchoredCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveInlineDrawableAnchoredCommandArchive& operator=(MoveInlineDrawableAnchoredCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveInlineDrawableAnchoredCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveInlineDrawableAnchoredCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveInlineDrawableAnchoredCommandArchive*>(
               &_MoveInlineDrawableAnchoredCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MoveInlineDrawableAnchoredCommandArchive& a, MoveInlineDrawableAnchoredCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveInlineDrawableAnchoredCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveInlineDrawableAnchoredCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveInlineDrawableAnchoredCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveInlineDrawableAnchoredCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveInlineDrawableAnchoredCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveInlineDrawableAnchoredCommandArchive& from) {
    MoveInlineDrawableAnchoredCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveInlineDrawableAnchoredCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveInlineDrawableAnchoredCommandArchive";
  }
  protected:
  explicit MoveInlineDrawableAnchoredCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDrawableFieldNumber = 2,
    kIsHtmlWrapFieldNumber = 3,
    kTypeFieldNumber = 4,
    kDirectionFieldNumber = 5,
    kFitTypeFieldNumber = 6,
    kMarginFieldNumber = 7,
    kAlphaThresholdFieldNumber = 8,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference drawable = 2;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional bool is_html_wrap = 3;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // optional uint32 type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 direction = 5;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  uint32_t direction() const;
  void set_direction(uint32_t value);
  private:
  uint32_t _internal_direction() const;
  void _internal_set_direction(uint32_t value);
  public:

  // optional uint32 fit_type = 6;
  bool has_fit_type() const;
  private:
  bool _internal_has_fit_type() const;
  public:
  void clear_fit_type();
  uint32_t fit_type() const;
  void set_fit_type(uint32_t value);
  private:
  uint32_t _internal_fit_type() const;
  void _internal_set_fit_type(uint32_t value);
  public:

  // optional float margin = 7;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  float margin() const;
  void set_margin(float value);
  private:
  float _internal_margin() const;
  void _internal_set_margin(float value);
  public:

  // optional float alpha_threshold = 8;
  bool has_alpha_threshold() const;
  private:
  bool _internal_has_alpha_threshold() const;
  public:
  void clear_alpha_threshold();
  float alpha_threshold() const;
  void set_alpha_threshold(float value);
  private:
  float _internal_alpha_threshold() const;
  void _internal_set_alpha_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveInlineDrawableAnchoredCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* drawable_;
    bool is_html_wrap_;
    uint32_t type_;
    uint32_t direction_;
    uint32_t fit_type_;
    float margin_;
    float alpha_threshold_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class MoveAnchoredDrawableInlineCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.MoveAnchoredDrawableInlineCommandArchive) */ {
 public:
  inline MoveAnchoredDrawableInlineCommandArchive() : MoveAnchoredDrawableInlineCommandArchive(nullptr) {}
  ~MoveAnchoredDrawableInlineCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR MoveAnchoredDrawableInlineCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveAnchoredDrawableInlineCommandArchive(const MoveAnchoredDrawableInlineCommandArchive& from);
  MoveAnchoredDrawableInlineCommandArchive(MoveAnchoredDrawableInlineCommandArchive&& from) noexcept
    : MoveAnchoredDrawableInlineCommandArchive() {
    *this = ::std::move(from);
  }

  inline MoveAnchoredDrawableInlineCommandArchive& operator=(const MoveAnchoredDrawableInlineCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveAnchoredDrawableInlineCommandArchive& operator=(MoveAnchoredDrawableInlineCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveAnchoredDrawableInlineCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveAnchoredDrawableInlineCommandArchive* internal_default_instance() {
    return reinterpret_cast<const MoveAnchoredDrawableInlineCommandArchive*>(
               &_MoveAnchoredDrawableInlineCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MoveAnchoredDrawableInlineCommandArchive& a, MoveAnchoredDrawableInlineCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveAnchoredDrawableInlineCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveAnchoredDrawableInlineCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveAnchoredDrawableInlineCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveAnchoredDrawableInlineCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveAnchoredDrawableInlineCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveAnchoredDrawableInlineCommandArchive& from) {
    MoveAnchoredDrawableInlineCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveAnchoredDrawableInlineCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.MoveAnchoredDrawableInlineCommandArchive";
  }
  protected:
  explicit MoveAnchoredDrawableInlineCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDrawableFieldNumber = 2,
    kIsHtmlWrapFieldNumber = 3,
    kTypeFieldNumber = 4,
    kDirectionFieldNumber = 5,
    kFitTypeFieldNumber = 6,
    kMarginFieldNumber = 7,
    kAlphaThresholdFieldNumber = 8,
    kZOrderFieldNumber = 9,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference drawable = 2;
  bool has_drawable() const;
  private:
  bool _internal_has_drawable() const;
  public:
  void clear_drawable();
  const ::TSP::Reference& drawable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_drawable();
  ::TSP::Reference* mutable_drawable();
  void set_allocated_drawable(::TSP::Reference* drawable);
  private:
  const ::TSP::Reference& _internal_drawable() const;
  ::TSP::Reference* _internal_mutable_drawable();
  public:
  void unsafe_arena_set_allocated_drawable(
      ::TSP::Reference* drawable);
  ::TSP::Reference* unsafe_arena_release_drawable();

  // optional bool is_html_wrap = 3;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // optional uint32 type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 direction = 5;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  uint32_t direction() const;
  void set_direction(uint32_t value);
  private:
  uint32_t _internal_direction() const;
  void _internal_set_direction(uint32_t value);
  public:

  // optional uint32 fit_type = 6;
  bool has_fit_type() const;
  private:
  bool _internal_has_fit_type() const;
  public:
  void clear_fit_type();
  uint32_t fit_type() const;
  void set_fit_type(uint32_t value);
  private:
  uint32_t _internal_fit_type() const;
  void _internal_set_fit_type(uint32_t value);
  public:

  // optional float margin = 7;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  float margin() const;
  void set_margin(float value);
  private:
  float _internal_margin() const;
  void _internal_set_margin(float value);
  public:

  // optional float alpha_threshold = 8;
  bool has_alpha_threshold() const;
  private:
  bool _internal_has_alpha_threshold() const;
  public:
  void clear_alpha_threshold();
  float alpha_threshold() const;
  void set_alpha_threshold(float value);
  private:
  float _internal_alpha_threshold() const;
  void _internal_set_alpha_threshold(float value);
  public:

  // optional uint32 z_order = 9;
  bool has_z_order() const;
  private:
  bool _internal_has_z_order() const;
  public:
  void clear_z_order();
  uint32_t z_order() const;
  void set_z_order(uint32_t value);
  private:
  uint32_t _internal_z_order() const;
  void _internal_set_z_order(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.MoveAnchoredDrawableInlineCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* drawable_;
    bool is_html_wrap_;
    uint32_t type_;
    uint32_t direction_;
    uint32_t fit_type_;
    float margin_;
    float alpha_threshold_;
    uint32_t z_order_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class InsertFootnoteCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.InsertFootnoteCommandArchive) */ {
 public:
  inline InsertFootnoteCommandArchive() : InsertFootnoteCommandArchive(nullptr) {}
  ~InsertFootnoteCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR InsertFootnoteCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertFootnoteCommandArchive(const InsertFootnoteCommandArchive& from);
  InsertFootnoteCommandArchive(InsertFootnoteCommandArchive&& from) noexcept
    : InsertFootnoteCommandArchive() {
    *this = ::std::move(from);
  }

  inline InsertFootnoteCommandArchive& operator=(const InsertFootnoteCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertFootnoteCommandArchive& operator=(InsertFootnoteCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertFootnoteCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertFootnoteCommandArchive* internal_default_instance() {
    return reinterpret_cast<const InsertFootnoteCommandArchive*>(
               &_InsertFootnoteCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InsertFootnoteCommandArchive& a, InsertFootnoteCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertFootnoteCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertFootnoteCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertFootnoteCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertFootnoteCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertFootnoteCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertFootnoteCommandArchive& from) {
    InsertFootnoteCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertFootnoteCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.InsertFootnoteCommandArchive";
  }
  protected:
  explicit InsertFootnoteCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSWP.TextCommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::TextCommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSWP::TextCommandArchive* release_super();
  ::TSWP::TextCommandArchive* mutable_super();
  void set_allocated_super(::TSWP::TextCommandArchive* super);
  private:
  const ::TSWP::TextCommandArchive& _internal_super() const;
  ::TSWP::TextCommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::TextCommandArchive* super);
  ::TSWP::TextCommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TP.InsertFootnoteCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::TextCommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ToggleBodyLayoutDirectionCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ToggleBodyLayoutDirectionCommandArchive) */ {
 public:
  inline ToggleBodyLayoutDirectionCommandArchive() : ToggleBodyLayoutDirectionCommandArchive(nullptr) {}
  ~ToggleBodyLayoutDirectionCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ToggleBodyLayoutDirectionCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleBodyLayoutDirectionCommandArchive(const ToggleBodyLayoutDirectionCommandArchive& from);
  ToggleBodyLayoutDirectionCommandArchive(ToggleBodyLayoutDirectionCommandArchive&& from) noexcept
    : ToggleBodyLayoutDirectionCommandArchive() {
    *this = ::std::move(from);
  }

  inline ToggleBodyLayoutDirectionCommandArchive& operator=(const ToggleBodyLayoutDirectionCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleBodyLayoutDirectionCommandArchive& operator=(ToggleBodyLayoutDirectionCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleBodyLayoutDirectionCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleBodyLayoutDirectionCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ToggleBodyLayoutDirectionCommandArchive*>(
               &_ToggleBodyLayoutDirectionCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ToggleBodyLayoutDirectionCommandArchive& a, ToggleBodyLayoutDirectionCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleBodyLayoutDirectionCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleBodyLayoutDirectionCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleBodyLayoutDirectionCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleBodyLayoutDirectionCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToggleBodyLayoutDirectionCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToggleBodyLayoutDirectionCommandArchive& from) {
    ToggleBodyLayoutDirectionCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToggleBodyLayoutDirectionCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ToggleBodyLayoutDirectionCommandArchive";
  }
  protected:
  explicit ToggleBodyLayoutDirectionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kNewDirectionIsVerticalFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool new_direction_is_vertical = 2;
  bool has_new_direction_is_vertical() const;
  private:
  bool _internal_has_new_direction_is_vertical() const;
  public:
  void clear_new_direction_is_vertical();
  bool new_direction_is_vertical() const;
  void set_new_direction_is_vertical(bool value);
  private:
  bool _internal_new_direction_is_vertical() const;
  void _internal_set_new_direction_is_vertical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ToggleBodyLayoutDirectionCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool new_direction_is_vertical_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class ChangeCTVisibilityCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.ChangeCTVisibilityCommandArchive) */ {
 public:
  inline ChangeCTVisibilityCommandArchive() : ChangeCTVisibilityCommandArchive(nullptr) {}
  ~ChangeCTVisibilityCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ChangeCTVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeCTVisibilityCommandArchive(const ChangeCTVisibilityCommandArchive& from);
  ChangeCTVisibilityCommandArchive(ChangeCTVisibilityCommandArchive&& from) noexcept
    : ChangeCTVisibilityCommandArchive() {
    *this = ::std::move(from);
  }

  inline ChangeCTVisibilityCommandArchive& operator=(const ChangeCTVisibilityCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeCTVisibilityCommandArchive& operator=(ChangeCTVisibilityCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeCTVisibilityCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeCTVisibilityCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ChangeCTVisibilityCommandArchive*>(
               &_ChangeCTVisibilityCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ChangeCTVisibilityCommandArchive& a, ChangeCTVisibilityCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeCTVisibilityCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeCTVisibilityCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeCTVisibilityCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeCTVisibilityCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeCTVisibilityCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChangeCTVisibilityCommandArchive& from) {
    ChangeCTVisibilityCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeCTVisibilityCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.ChangeCTVisibilityCommandArchive";
  }
  protected:
  explicit ChangeCTVisibilityCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kMarkupVisibleFieldNumber = 2,
    kDeletionsVisibleFieldNumber = 3,
    kSelectionRangeLocationFieldNumber = 4,
    kSelectionRangeLengthFieldNumber = 5,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool markup_visible = 2;
  bool has_markup_visible() const;
  private:
  bool _internal_has_markup_visible() const;
  public:
  void clear_markup_visible();
  bool markup_visible() const;
  void set_markup_visible(bool value);
  private:
  bool _internal_markup_visible() const;
  void _internal_set_markup_visible(bool value);
  public:

  // optional bool deletions_visible = 3;
  bool has_deletions_visible() const;
  private:
  bool _internal_has_deletions_visible() const;
  public:
  void clear_deletions_visible();
  bool deletions_visible() const;
  void set_deletions_visible(bool value);
  private:
  bool _internal_deletions_visible() const;
  void _internal_set_deletions_visible(bool value);
  public:

  // optional uint32 selection_range_location = 4;
  bool has_selection_range_location() const;
  private:
  bool _internal_has_selection_range_location() const;
  public:
  void clear_selection_range_location();
  uint32_t selection_range_location() const;
  void set_selection_range_location(uint32_t value);
  private:
  uint32_t _internal_selection_range_location() const;
  void _internal_set_selection_range_location(uint32_t value);
  public:

  // optional uint32 selection_range_length = 5;
  bool has_selection_range_length() const;
  private:
  bool _internal_has_selection_range_length() const;
  public:
  void clear_selection_range_length();
  uint32_t selection_range_length() const;
  void set_selection_range_length(uint32_t value);
  private:
  uint32_t _internal_selection_range_length() const;
  void _internal_set_selection_range_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TP.ChangeCTVisibilityCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool markup_visible_;
    bool deletions_visible_;
    uint32_t selection_range_location_;
    uint32_t selection_range_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class TrackChangesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.TrackChangesCommandArchive) */ {
 public:
  inline TrackChangesCommandArchive() : TrackChangesCommandArchive(nullptr) {}
  ~TrackChangesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR TrackChangesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackChangesCommandArchive(const TrackChangesCommandArchive& from);
  TrackChangesCommandArchive(TrackChangesCommandArchive&& from) noexcept
    : TrackChangesCommandArchive() {
    *this = ::std::move(from);
  }

  inline TrackChangesCommandArchive& operator=(const TrackChangesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackChangesCommandArchive& operator=(TrackChangesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackChangesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackChangesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const TrackChangesCommandArchive*>(
               &_TrackChangesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TrackChangesCommandArchive& a, TrackChangesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackChangesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackChangesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackChangesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackChangesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackChangesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackChangesCommandArchive& from) {
    TrackChangesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackChangesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.TrackChangesCommandArchive";
  }
  protected:
  explicit TrackChangesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeSessionHistoryFieldNumber = 3,
    kSuperFieldNumber = 1,
    kTrackChangesFieldNumber = 2,
    kPausedFieldNumber = 4,
  };
  // repeated .TSP.Reference change_session_history = 3;
  int change_session_history_size() const;
  private:
  int _internal_change_session_history_size() const;
  public:
  void clear_change_session_history();
  ::TSP::Reference* mutable_change_session_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_change_session_history();
  private:
  const ::TSP::Reference& _internal_change_session_history(int index) const;
  ::TSP::Reference* _internal_add_change_session_history();
  public:
  const ::TSP::Reference& change_session_history(int index) const;
  ::TSP::Reference* add_change_session_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      change_session_history() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool track_changes = 2;
  bool has_track_changes() const;
  private:
  bool _internal_has_track_changes() const;
  public:
  void clear_track_changes();
  bool track_changes() const;
  void set_track_changes(bool value);
  private:
  bool _internal_track_changes() const;
  void _internal_set_track_changes(bool value);
  public:

  // optional bool paused = 4;
  bool has_paused() const;
  private:
  bool _internal_has_paused() const;
  public:
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.TrackChangesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > change_session_history_;
    ::TSK::CommandArchive* super_;
    bool track_changes_;
    bool paused_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class DocumentHyphenationCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.DocumentHyphenationCommandArchive) */ {
 public:
  inline DocumentHyphenationCommandArchive() : DocumentHyphenationCommandArchive(nullptr) {}
  ~DocumentHyphenationCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentHyphenationCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentHyphenationCommandArchive(const DocumentHyphenationCommandArchive& from);
  DocumentHyphenationCommandArchive(DocumentHyphenationCommandArchive&& from) noexcept
    : DocumentHyphenationCommandArchive() {
    *this = ::std::move(from);
  }

  inline DocumentHyphenationCommandArchive& operator=(const DocumentHyphenationCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentHyphenationCommandArchive& operator=(DocumentHyphenationCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentHyphenationCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentHyphenationCommandArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentHyphenationCommandArchive*>(
               &_DocumentHyphenationCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DocumentHyphenationCommandArchive& a, DocumentHyphenationCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentHyphenationCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentHyphenationCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentHyphenationCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentHyphenationCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentHyphenationCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentHyphenationCommandArchive& from) {
    DocumentHyphenationCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentHyphenationCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.DocumentHyphenationCommandArchive";
  }
  protected:
  explicit DocumentHyphenationCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kHyphenateDocumentFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool hyphenate_document = 2;
  bool has_hyphenate_document() const;
  private:
  bool _internal_has_hyphenate_document() const;
  public:
  void clear_hyphenate_document();
  bool hyphenate_document() const;
  void set_hyphenate_document(bool value);
  private:
  bool _internal_hyphenate_document() const;
  void _internal_set_hyphenate_document(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.DocumentHyphenationCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool hyphenate_document_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class DocumentLigaturesCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.DocumentLigaturesCommandArchive) */ {
 public:
  inline DocumentLigaturesCommandArchive() : DocumentLigaturesCommandArchive(nullptr) {}
  ~DocumentLigaturesCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentLigaturesCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentLigaturesCommandArchive(const DocumentLigaturesCommandArchive& from);
  DocumentLigaturesCommandArchive(DocumentLigaturesCommandArchive&& from) noexcept
    : DocumentLigaturesCommandArchive() {
    *this = ::std::move(from);
  }

  inline DocumentLigaturesCommandArchive& operator=(const DocumentLigaturesCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentLigaturesCommandArchive& operator=(DocumentLigaturesCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentLigaturesCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentLigaturesCommandArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentLigaturesCommandArchive*>(
               &_DocumentLigaturesCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DocumentLigaturesCommandArchive& a, DocumentLigaturesCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentLigaturesCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentLigaturesCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentLigaturesCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentLigaturesCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentLigaturesCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentLigaturesCommandArchive& from) {
    DocumentLigaturesCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentLigaturesCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.DocumentLigaturesCommandArchive";
  }
  protected:
  explicit DocumentLigaturesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kUseLigaturesFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool use_ligatures = 2;
  bool has_use_ligatures() const;
  private:
  bool _internal_has_use_ligatures() const;
  public:
  void clear_use_ligatures();
  bool use_ligatures() const;
  void set_use_ligatures(bool value);
  private:
  bool _internal_use_ligatures() const;
  void _internal_set_use_ligatures(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.DocumentLigaturesCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool use_ligatures_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class DocumentHasBodyCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.DocumentHasBodyCommandArchive) */ {
 public:
  inline DocumentHasBodyCommandArchive() : DocumentHasBodyCommandArchive(nullptr) {}
  ~DocumentHasBodyCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentHasBodyCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentHasBodyCommandArchive(const DocumentHasBodyCommandArchive& from);
  DocumentHasBodyCommandArchive(DocumentHasBodyCommandArchive&& from) noexcept
    : DocumentHasBodyCommandArchive() {
    *this = ::std::move(from);
  }

  inline DocumentHasBodyCommandArchive& operator=(const DocumentHasBodyCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentHasBodyCommandArchive& operator=(DocumentHasBodyCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentHasBodyCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentHasBodyCommandArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentHasBodyCommandArchive*>(
               &_DocumentHasBodyCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(DocumentHasBodyCommandArchive& a, DocumentHasBodyCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentHasBodyCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentHasBodyCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentHasBodyCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentHasBodyCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentHasBodyCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentHasBodyCommandArchive& from) {
    DocumentHasBodyCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentHasBodyCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.DocumentHasBodyCommandArchive";
  }
  protected:
  explicit DocumentHasBodyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kHasBodyFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool has_body = 2;
  bool has_has_body() const;
  private:
  bool _internal_has_has_body() const;
  public:
  void clear_has_body();
  bool has_body() const;
  void set_has_body(bool value);
  private:
  bool _internal_has_body() const;
  void _internal_set_has_body(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.DocumentHasBodyCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool has_body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// -------------------------------------------------------------------

class PauseChangeTrackingCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TP.PauseChangeTrackingCommandArchive) */ {
 public:
  inline PauseChangeTrackingCommandArchive() : PauseChangeTrackingCommandArchive(nullptr) {}
  ~PauseChangeTrackingCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR PauseChangeTrackingCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PauseChangeTrackingCommandArchive(const PauseChangeTrackingCommandArchive& from);
  PauseChangeTrackingCommandArchive(PauseChangeTrackingCommandArchive&& from) noexcept
    : PauseChangeTrackingCommandArchive() {
    *this = ::std::move(from);
  }

  inline PauseChangeTrackingCommandArchive& operator=(const PauseChangeTrackingCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseChangeTrackingCommandArchive& operator=(PauseChangeTrackingCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseChangeTrackingCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseChangeTrackingCommandArchive* internal_default_instance() {
    return reinterpret_cast<const PauseChangeTrackingCommandArchive*>(
               &_PauseChangeTrackingCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(PauseChangeTrackingCommandArchive& a, PauseChangeTrackingCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseChangeTrackingCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseChangeTrackingCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseChangeTrackingCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseChangeTrackingCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PauseChangeTrackingCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PauseChangeTrackingCommandArchive& from) {
    PauseChangeTrackingCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseChangeTrackingCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TP.PauseChangeTrackingCommandArchive";
  }
  protected:
  explicit PauseChangeTrackingCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kPausedFieldNumber = 2,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional bool paused = 2;
  bool has_paused() const;
  private:
  bool _internal_has_paused() const;
  public:
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TP.PauseChangeTrackingCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    bool paused_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TPCommandArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InsertDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InsertDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& InsertDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& InsertDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.InsertDrawablesCommandArchive.super)
  return _internal_super();
}
inline void InsertDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.InsertDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* InsertDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.InsertDrawablesCommandArchive.super)
  return _msg;
}
inline void InsertDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertDrawablesCommandArchive.super)
}

// optional uint32 page_index = 2;
inline bool InsertDrawablesCommandArchive::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InsertDrawablesCommandArchive::has_page_index() const {
  return _internal_has_page_index();
}
inline void InsertDrawablesCommandArchive::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t InsertDrawablesCommandArchive::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t InsertDrawablesCommandArchive::page_index() const {
  // @@protoc_insertion_point(field_get:TP.InsertDrawablesCommandArchive.page_index)
  return _internal_page_index();
}
inline void InsertDrawablesCommandArchive::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.page_index_ = value;
}
inline void InsertDrawablesCommandArchive::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.InsertDrawablesCommandArchive.page_index)
}

// optional uint32 z_order = 3;
inline bool InsertDrawablesCommandArchive::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsertDrawablesCommandArchive::has_z_order() const {
  return _internal_has_z_order();
}
inline void InsertDrawablesCommandArchive::clear_z_order() {
  _impl_.z_order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t InsertDrawablesCommandArchive::_internal_z_order() const {
  return _impl_.z_order_;
}
inline uint32_t InsertDrawablesCommandArchive::z_order() const {
  // @@protoc_insertion_point(field_get:TP.InsertDrawablesCommandArchive.z_order)
  return _internal_z_order();
}
inline void InsertDrawablesCommandArchive::_internal_set_z_order(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_order_ = value;
}
inline void InsertDrawablesCommandArchive::set_z_order(uint32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.InsertDrawablesCommandArchive.z_order)
}

// repeated .TSP.Reference drawables = 4;
inline int InsertDrawablesCommandArchive::_internal_drawables_size() const {
  return _impl_.drawables_.size();
}
inline int InsertDrawablesCommandArchive::drawables_size() const {
  return _internal_drawables_size();
}
inline ::TSP::Reference* InsertDrawablesCommandArchive::mutable_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.InsertDrawablesCommandArchive.drawables)
  return _impl_.drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
InsertDrawablesCommandArchive::mutable_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.InsertDrawablesCommandArchive.drawables)
  return &_impl_.drawables_;
}
inline const ::TSP::Reference& InsertDrawablesCommandArchive::_internal_drawables(int index) const {
  return _impl_.drawables_.Get(index);
}
inline const ::TSP::Reference& InsertDrawablesCommandArchive::drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.InsertDrawablesCommandArchive.drawables)
  return _internal_drawables(index);
}
inline ::TSP::Reference* InsertDrawablesCommandArchive::_internal_add_drawables() {
  return _impl_.drawables_.Add();
}
inline ::TSP::Reference* InsertDrawablesCommandArchive::add_drawables() {
  ::TSP::Reference* _add = _internal_add_drawables();
  // @@protoc_insertion_point(field_add:TP.InsertDrawablesCommandArchive.drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
InsertDrawablesCommandArchive::drawables() const {
  // @@protoc_insertion_point(field_list:TP.InsertDrawablesCommandArchive.drawables)
  return _impl_.drawables_;
}

// optional bool forPaste = 5;
inline bool InsertDrawablesCommandArchive::_internal_has_forpaste() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertDrawablesCommandArchive::has_forpaste() const {
  return _internal_has_forpaste();
}
inline void InsertDrawablesCommandArchive::clear_forpaste() {
  _impl_.forpaste_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool InsertDrawablesCommandArchive::_internal_forpaste() const {
  return _impl_.forpaste_;
}
inline bool InsertDrawablesCommandArchive::forpaste() const {
  // @@protoc_insertion_point(field_get:TP.InsertDrawablesCommandArchive.forPaste)
  return _internal_forpaste();
}
inline void InsertDrawablesCommandArchive::_internal_set_forpaste(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.forpaste_ = value;
}
inline void InsertDrawablesCommandArchive::set_forpaste(bool value) {
  _internal_set_forpaste(value);
  // @@protoc_insertion_point(field_set:TP.InsertDrawablesCommandArchive.forPaste)
}

// -------------------------------------------------------------------

// PasteDrawablesCommandArchive_DrawableAndPage

// optional .TSP.Reference drawable = 1;
inline bool PasteDrawablesCommandArchive_DrawableAndPage::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool PasteDrawablesCommandArchive_DrawableAndPage::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& PasteDrawablesCommandArchive_DrawableAndPage::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteDrawablesCommandArchive_DrawableAndPage::drawable() const {
  // @@protoc_insertion_point(field_get:TP.PasteDrawablesCommandArchive.DrawableAndPage.drawable)
  return _internal_drawable();
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteDrawablesCommandArchive.DrawableAndPage.drawable)
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.PasteDrawablesCommandArchive.DrawableAndPage.drawable)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* PasteDrawablesCommandArchive_DrawableAndPage::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.PasteDrawablesCommandArchive.DrawableAndPage.drawable)
  return _msg;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteDrawablesCommandArchive.DrawableAndPage.drawable)
}

// optional uint32 page_index = 2;
inline bool PasteDrawablesCommandArchive_DrawableAndPage::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PasteDrawablesCommandArchive_DrawableAndPage::has_page_index() const {
  return _internal_has_page_index();
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t PasteDrawablesCommandArchive_DrawableAndPage::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t PasteDrawablesCommandArchive_DrawableAndPage::page_index() const {
  // @@protoc_insertion_point(field_get:TP.PasteDrawablesCommandArchive.DrawableAndPage.page_index)
  return _internal_page_index();
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.page_index_ = value;
}
inline void PasteDrawablesCommandArchive_DrawableAndPage::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.PasteDrawablesCommandArchive.DrawableAndPage.page_index)
}

// -------------------------------------------------------------------

// PasteDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PasteDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PasteDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& PasteDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& PasteDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.PasteDrawablesCommandArchive.super)
  return _internal_super();
}
inline void PasteDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.PasteDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* PasteDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.PasteDrawablesCommandArchive.super)
  return _msg;
}
inline void PasteDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteDrawablesCommandArchive.super)
}

// repeated .TP.PasteDrawablesCommandArchive.DrawableAndPage drawables = 2;
inline int PasteDrawablesCommandArchive::_internal_drawables_size() const {
  return _impl_.drawables_.size();
}
inline int PasteDrawablesCommandArchive::drawables_size() const {
  return _internal_drawables_size();
}
inline void PasteDrawablesCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* PasteDrawablesCommandArchive::mutable_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.PasteDrawablesCommandArchive.drawables)
  return _impl_.drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >*
PasteDrawablesCommandArchive::mutable_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.PasteDrawablesCommandArchive.drawables)
  return &_impl_.drawables_;
}
inline const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& PasteDrawablesCommandArchive::_internal_drawables(int index) const {
  return _impl_.drawables_.Get(index);
}
inline const ::TP::PasteDrawablesCommandArchive_DrawableAndPage& PasteDrawablesCommandArchive::drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.PasteDrawablesCommandArchive.drawables)
  return _internal_drawables(index);
}
inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* PasteDrawablesCommandArchive::_internal_add_drawables() {
  return _impl_.drawables_.Add();
}
inline ::TP::PasteDrawablesCommandArchive_DrawableAndPage* PasteDrawablesCommandArchive::add_drawables() {
  ::TP::PasteDrawablesCommandArchive_DrawableAndPage* _add = _internal_add_drawables();
  // @@protoc_insertion_point(field_add:TP.PasteDrawablesCommandArchive.drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::PasteDrawablesCommandArchive_DrawableAndPage >&
PasteDrawablesCommandArchive::drawables() const {
  // @@protoc_insertion_point(field_list:TP.PasteDrawablesCommandArchive.drawables)
  return _impl_.drawables_;
}

// -------------------------------------------------------------------

// PasteAnchoredDrawablesCommandArchive

// required .TSK.CommandGroupArchive deprecated_super = 1;
inline bool PasteAnchoredDrawablesCommandArchive::_internal_has_deprecated_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deprecated_super_ != nullptr);
  return value;
}
inline bool PasteAnchoredDrawablesCommandArchive::has_deprecated_super() const {
  return _internal_has_deprecated_super();
}
inline const ::TSK::CommandGroupArchive& PasteAnchoredDrawablesCommandArchive::_internal_deprecated_super() const {
  const ::TSK::CommandGroupArchive* p = _impl_.deprecated_super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandGroupArchive&>(
      ::TSK::_CommandGroupArchive_default_instance_);
}
inline const ::TSK::CommandGroupArchive& PasteAnchoredDrawablesCommandArchive::deprecated_super() const {
  // @@protoc_insertion_point(field_get:TP.PasteAnchoredDrawablesCommandArchive.deprecated_super)
  return _internal_deprecated_super();
}
inline void PasteAnchoredDrawablesCommandArchive::unsafe_arena_set_allocated_deprecated_super(
    ::TSK::CommandGroupArchive* deprecated_super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_super_);
  }
  _impl_.deprecated_super_ = deprecated_super;
  if (deprecated_super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.deprecated_super)
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::release_deprecated_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandGroupArchive* temp = _impl_.deprecated_super_;
  _impl_.deprecated_super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::unsafe_arena_release_deprecated_super() {
  // @@protoc_insertion_point(field_release:TP.PasteAnchoredDrawablesCommandArchive.deprecated_super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandGroupArchive* temp = _impl_.deprecated_super_;
  _impl_.deprecated_super_ = nullptr;
  return temp;
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::_internal_mutable_deprecated_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.deprecated_super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandGroupArchive>(GetArenaForAllocation());
    _impl_.deprecated_super_ = p;
  }
  return _impl_.deprecated_super_;
}
inline ::TSK::CommandGroupArchive* PasteAnchoredDrawablesCommandArchive::mutable_deprecated_super() {
  ::TSK::CommandGroupArchive* _msg = _internal_mutable_deprecated_super();
  // @@protoc_insertion_point(field_mutable:TP.PasteAnchoredDrawablesCommandArchive.deprecated_super)
  return _msg;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_deprecated_super(::TSK::CommandGroupArchive* deprecated_super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_super_);
  }
  if (deprecated_super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deprecated_super));
    if (message_arena != submessage_arena) {
      deprecated_super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deprecated_super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.deprecated_super_ = deprecated_super;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.deprecated_super)
}

// optional .TSK.CommandArchive super = 4;
inline bool PasteAnchoredDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PasteAnchoredDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& PasteAnchoredDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& PasteAnchoredDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.PasteAnchoredDrawablesCommandArchive.super)
  return _internal_super();
}
inline void PasteAnchoredDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.PasteAnchoredDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* PasteAnchoredDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.PasteAnchoredDrawablesCommandArchive.super)
  return _msg;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.super)
}

// optional bool select = 2;
inline bool PasteAnchoredDrawablesCommandArchive::_internal_has_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PasteAnchoredDrawablesCommandArchive::has_select() const {
  return _internal_has_select();
}
inline void PasteAnchoredDrawablesCommandArchive::clear_select() {
  _impl_.select_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool PasteAnchoredDrawablesCommandArchive::_internal_select() const {
  return _impl_.select_;
}
inline bool PasteAnchoredDrawablesCommandArchive::select() const {
  // @@protoc_insertion_point(field_get:TP.PasteAnchoredDrawablesCommandArchive.select)
  return _internal_select();
}
inline void PasteAnchoredDrawablesCommandArchive::_internal_set_select(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.select_ = value;
}
inline void PasteAnchoredDrawablesCommandArchive::set_select(bool value) {
  _internal_set_select(value);
  // @@protoc_insertion_point(field_set:TP.PasteAnchoredDrawablesCommandArchive.select)
}

// optional .TSP.Reference deprecated_undo_selection = 3;
inline bool PasteAnchoredDrawablesCommandArchive::_internal_has_deprecated_undo_selection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deprecated_undo_selection_ != nullptr);
  return value;
}
inline bool PasteAnchoredDrawablesCommandArchive::has_deprecated_undo_selection() const {
  return _internal_has_deprecated_undo_selection();
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::_internal_deprecated_undo_selection() const {
  const ::TSP::Reference* p = _impl_.deprecated_undo_selection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::deprecated_undo_selection() const {
  // @@protoc_insertion_point(field_get:TP.PasteAnchoredDrawablesCommandArchive.deprecated_undo_selection)
  return _internal_deprecated_undo_selection();
}
inline void PasteAnchoredDrawablesCommandArchive::unsafe_arena_set_allocated_deprecated_undo_selection(
    ::TSP::Reference* deprecated_undo_selection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_undo_selection_);
  }
  _impl_.deprecated_undo_selection_ = deprecated_undo_selection;
  if (deprecated_undo_selection) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.deprecated_undo_selection)
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::release_deprecated_undo_selection() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.deprecated_undo_selection_;
  _impl_.deprecated_undo_selection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::unsafe_arena_release_deprecated_undo_selection() {
  // @@protoc_insertion_point(field_release:TP.PasteAnchoredDrawablesCommandArchive.deprecated_undo_selection)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.deprecated_undo_selection_;
  _impl_.deprecated_undo_selection_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::_internal_mutable_deprecated_undo_selection() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.deprecated_undo_selection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.deprecated_undo_selection_ = p;
  }
  return _impl_.deprecated_undo_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::mutable_deprecated_undo_selection() {
  ::TSP::Reference* _msg = _internal_mutable_deprecated_undo_selection();
  // @@protoc_insertion_point(field_mutable:TP.PasteAnchoredDrawablesCommandArchive.deprecated_undo_selection)
  return _msg;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_deprecated_undo_selection(::TSP::Reference* deprecated_undo_selection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_undo_selection_);
  }
  if (deprecated_undo_selection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deprecated_undo_selection));
    if (message_arena != submessage_arena) {
      deprecated_undo_selection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deprecated_undo_selection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deprecated_undo_selection_ = deprecated_undo_selection;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.deprecated_undo_selection)
}

// optional .TSP.Reference canvas_selection = 5;
inline bool PasteAnchoredDrawablesCommandArchive::_internal_has_canvas_selection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.canvas_selection_ != nullptr);
  return value;
}
inline bool PasteAnchoredDrawablesCommandArchive::has_canvas_selection() const {
  return _internal_has_canvas_selection();
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::_internal_canvas_selection() const {
  const ::TSP::Reference* p = _impl_.canvas_selection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteAnchoredDrawablesCommandArchive::canvas_selection() const {
  // @@protoc_insertion_point(field_get:TP.PasteAnchoredDrawablesCommandArchive.canvas_selection)
  return _internal_canvas_selection();
}
inline void PasteAnchoredDrawablesCommandArchive::unsafe_arena_set_allocated_canvas_selection(
    ::TSP::Reference* canvas_selection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canvas_selection_);
  }
  _impl_.canvas_selection_ = canvas_selection;
  if (canvas_selection) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.canvas_selection)
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::release_canvas_selection() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.canvas_selection_;
  _impl_.canvas_selection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::unsafe_arena_release_canvas_selection() {
  // @@protoc_insertion_point(field_release:TP.PasteAnchoredDrawablesCommandArchive.canvas_selection)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.canvas_selection_;
  _impl_.canvas_selection_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::_internal_mutable_canvas_selection() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.canvas_selection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.canvas_selection_ = p;
  }
  return _impl_.canvas_selection_;
}
inline ::TSP::Reference* PasteAnchoredDrawablesCommandArchive::mutable_canvas_selection() {
  ::TSP::Reference* _msg = _internal_mutable_canvas_selection();
  // @@protoc_insertion_point(field_mutable:TP.PasteAnchoredDrawablesCommandArchive.canvas_selection)
  return _msg;
}
inline void PasteAnchoredDrawablesCommandArchive::set_allocated_canvas_selection(::TSP::Reference* canvas_selection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.canvas_selection_);
  }
  if (canvas_selection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(canvas_selection));
    if (message_arena != submessage_arena) {
      canvas_selection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, canvas_selection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.canvas_selection_ = canvas_selection;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteAnchoredDrawablesCommandArchive.canvas_selection)
}

// -------------------------------------------------------------------

// MoveDrawablesPageIndexCommandArchive_Drawable

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesPageIndexCommandArchive_Drawable::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesPageIndexCommandArchive_Drawable::drawable() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesPageIndexCommandArchive.Drawable.drawable)
  return _internal_drawable();
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesPageIndexCommandArchive.Drawable.drawable)
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesPageIndexCommandArchive.Drawable.drawable)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* MoveDrawablesPageIndexCommandArchive_Drawable::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesPageIndexCommandArchive.Drawable.drawable)
  return _msg;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesPageIndexCommandArchive.Drawable.drawable)
}

// optional uint32 z_order = 2;
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoveDrawablesPageIndexCommandArchive_Drawable::has_z_order() const {
  return _internal_has_z_order();
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::clear_z_order() {
  _impl_.z_order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MoveDrawablesPageIndexCommandArchive_Drawable::_internal_z_order() const {
  return _impl_.z_order_;
}
inline uint32_t MoveDrawablesPageIndexCommandArchive_Drawable::z_order() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesPageIndexCommandArchive.Drawable.z_order)
  return _internal_z_order();
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::_internal_set_z_order(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.z_order_ = value;
}
inline void MoveDrawablesPageIndexCommandArchive_Drawable::set_z_order(uint32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesPageIndexCommandArchive.Drawable.z_order)
}

// -------------------------------------------------------------------

// MoveDrawablesPageIndexCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesPageIndexCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveDrawablesPageIndexCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesPageIndexCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveDrawablesPageIndexCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesPageIndexCommandArchive.super)
  return _internal_super();
}
inline void MoveDrawablesPageIndexCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesPageIndexCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesPageIndexCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveDrawablesPageIndexCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesPageIndexCommandArchive.super)
  return _msg;
}
inline void MoveDrawablesPageIndexCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesPageIndexCommandArchive.super)
}

// optional uint32 page_index = 2;
inline bool MoveDrawablesPageIndexCommandArchive::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MoveDrawablesPageIndexCommandArchive::has_page_index() const {
  return _internal_has_page_index();
}
inline void MoveDrawablesPageIndexCommandArchive::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MoveDrawablesPageIndexCommandArchive::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t MoveDrawablesPageIndexCommandArchive::page_index() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesPageIndexCommandArchive.page_index)
  return _internal_page_index();
}
inline void MoveDrawablesPageIndexCommandArchive::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.page_index_ = value;
}
inline void MoveDrawablesPageIndexCommandArchive::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesPageIndexCommandArchive.page_index)
}

// repeated .TP.MoveDrawablesPageIndexCommandArchive.Drawable drawables = 3;
inline int MoveDrawablesPageIndexCommandArchive::_internal_drawables_size() const {
  return _impl_.drawables_.size();
}
inline int MoveDrawablesPageIndexCommandArchive::drawables_size() const {
  return _internal_drawables_size();
}
inline void MoveDrawablesPageIndexCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* MoveDrawablesPageIndexCommandArchive::mutable_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesPageIndexCommandArchive.drawables)
  return _impl_.drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >*
MoveDrawablesPageIndexCommandArchive::mutable_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.MoveDrawablesPageIndexCommandArchive.drawables)
  return &_impl_.drawables_;
}
inline const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& MoveDrawablesPageIndexCommandArchive::_internal_drawables(int index) const {
  return _impl_.drawables_.Get(index);
}
inline const ::TP::MoveDrawablesPageIndexCommandArchive_Drawable& MoveDrawablesPageIndexCommandArchive::drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesPageIndexCommandArchive.drawables)
  return _internal_drawables(index);
}
inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* MoveDrawablesPageIndexCommandArchive::_internal_add_drawables() {
  return _impl_.drawables_.Add();
}
inline ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* MoveDrawablesPageIndexCommandArchive::add_drawables() {
  ::TP::MoveDrawablesPageIndexCommandArchive_Drawable* _add = _internal_add_drawables();
  // @@protoc_insertion_point(field_add:TP.MoveDrawablesPageIndexCommandArchive.drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesPageIndexCommandArchive_Drawable >&
MoveDrawablesPageIndexCommandArchive::drawables() const {
  // @@protoc_insertion_point(field_list:TP.MoveDrawablesPageIndexCommandArchive.drawables)
  return _impl_.drawables_;
}

// -------------------------------------------------------------------

// InsertSectionBreakCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool InsertSectionBreakCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertSectionBreakCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::TextCommandArchive& InsertSectionBreakCommandArchive::_internal_super() const {
  const ::TSWP::TextCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::TextCommandArchive&>(
      ::TSWP::_TextCommandArchive_default_instance_);
}
inline const ::TSWP::TextCommandArchive& InsertSectionBreakCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.InsertSectionBreakCommandArchive.super)
  return _internal_super();
}
inline void InsertSectionBreakCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::TextCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertSectionBreakCommandArchive.super)
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.InsertSectionBreakCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::TextCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::TextCommandArchive* InsertSectionBreakCommandArchive::mutable_super() {
  ::TSWP::TextCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.InsertSectionBreakCommandArchive.super)
  return _msg;
}
inline void InsertSectionBreakCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertSectionBreakCommandArchive.super)
}

// -------------------------------------------------------------------

// DeleteSectionCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DeleteSectionCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DeleteSectionCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& DeleteSectionCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& DeleteSectionCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.DeleteSectionCommandArchive.super)
  return _internal_super();
}
inline void DeleteSectionCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.DeleteSectionCommandArchive.super)
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.DeleteSectionCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* DeleteSectionCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.DeleteSectionCommandArchive.super)
  return _msg;
}
inline void DeleteSectionCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.DeleteSectionCommandArchive.super)
}

// -------------------------------------------------------------------

// ReplaceSectionCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool ReplaceSectionCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReplaceSectionCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::TextCommandArchive& ReplaceSectionCommandArchive::_internal_super() const {
  const ::TSWP::TextCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::TextCommandArchive&>(
      ::TSWP::_TextCommandArchive_default_instance_);
}
inline const ::TSWP::TextCommandArchive& ReplaceSectionCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ReplaceSectionCommandArchive.super)
  return _internal_super();
}
inline void ReplaceSectionCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::TextCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ReplaceSectionCommandArchive.super)
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ReplaceSectionCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::TextCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::TextCommandArchive* ReplaceSectionCommandArchive::mutable_super() {
  ::TSWP::TextCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ReplaceSectionCommandArchive.super)
  return _msg;
}
inline void ReplaceSectionCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ReplaceSectionCommandArchive.super)
}

// -------------------------------------------------------------------

// ChangeSectionPropertyCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeSectionPropertyCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeSectionPropertyCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeSectionPropertyCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeSectionPropertyCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionPropertyCommandArchive.super)
  return _internal_super();
}
inline void ChangeSectionPropertyCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeSectionPropertyCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeSectionPropertyCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeSectionPropertyCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeSectionPropertyCommandArchive.super)
  return _msg;
}
inline void ChangeSectionPropertyCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeSectionPropertyCommandArchive.super)
}

// optional uint32 section_index = 2;
inline bool ChangeSectionPropertyCommandArchive::_internal_has_section_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeSectionPropertyCommandArchive::has_section_index() const {
  return _internal_has_section_index();
}
inline void ChangeSectionPropertyCommandArchive::clear_section_index() {
  _impl_.section_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ChangeSectionPropertyCommandArchive::_internal_section_index() const {
  return _impl_.section_index_;
}
inline uint32_t ChangeSectionPropertyCommandArchive::section_index() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionPropertyCommandArchive.section_index)
  return _internal_section_index();
}
inline void ChangeSectionPropertyCommandArchive::_internal_set_section_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.section_index_ = value;
}
inline void ChangeSectionPropertyCommandArchive::set_section_index(uint32_t value) {
  _internal_set_section_index(value);
  // @@protoc_insertion_point(field_set:TP.ChangeSectionPropertyCommandArchive.section_index)
}

// optional string section_property = 3;
inline bool ChangeSectionPropertyCommandArchive::_internal_has_section_property() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeSectionPropertyCommandArchive::has_section_property() const {
  return _internal_has_section_property();
}
inline void ChangeSectionPropertyCommandArchive::clear_section_property() {
  _impl_.section_property_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeSectionPropertyCommandArchive::section_property() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionPropertyCommandArchive.section_property)
  return _internal_section_property();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeSectionPropertyCommandArchive::set_section_property(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.section_property_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TP.ChangeSectionPropertyCommandArchive.section_property)
}
inline std::string* ChangeSectionPropertyCommandArchive::mutable_section_property() {
  std::string* _s = _internal_mutable_section_property();
  // @@protoc_insertion_point(field_mutable:TP.ChangeSectionPropertyCommandArchive.section_property)
  return _s;
}
inline const std::string& ChangeSectionPropertyCommandArchive::_internal_section_property() const {
  return _impl_.section_property_.Get();
}
inline void ChangeSectionPropertyCommandArchive::_internal_set_section_property(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.section_property_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeSectionPropertyCommandArchive::_internal_mutable_section_property() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.section_property_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeSectionPropertyCommandArchive::release_section_property() {
  // @@protoc_insertion_point(field_release:TP.ChangeSectionPropertyCommandArchive.section_property)
  if (!_internal_has_section_property()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.section_property_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.section_property_.IsDefault()) {
    _impl_.section_property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeSectionPropertyCommandArchive::set_allocated_section_property(std::string* section_property) {
  if (section_property != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.section_property_.SetAllocated(section_property, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.section_property_.IsDefault()) {
    _impl_.section_property_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeSectionPropertyCommandArchive.section_property)
}

// optional bool section_value_bool = 4;
inline bool ChangeSectionPropertyCommandArchive::_internal_has_section_value_bool() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeSectionPropertyCommandArchive::has_section_value_bool() const {
  return _internal_has_section_value_bool();
}
inline void ChangeSectionPropertyCommandArchive::clear_section_value_bool() {
  _impl_.section_value_bool_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ChangeSectionPropertyCommandArchive::_internal_section_value_bool() const {
  return _impl_.section_value_bool_;
}
inline bool ChangeSectionPropertyCommandArchive::section_value_bool() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionPropertyCommandArchive.section_value_bool)
  return _internal_section_value_bool();
}
inline void ChangeSectionPropertyCommandArchive::_internal_set_section_value_bool(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.section_value_bool_ = value;
}
inline void ChangeSectionPropertyCommandArchive::set_section_value_bool(bool value) {
  _internal_set_section_value_bool(value);
  // @@protoc_insertion_point(field_set:TP.ChangeSectionPropertyCommandArchive.section_value_bool)
}

// -------------------------------------------------------------------

// SwapDrawableZOrderCommandArchive_SwapPair

// required uint32 z_order_1 = 1;
inline bool SwapDrawableZOrderCommandArchive_SwapPair::_internal_has_z_order_1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwapDrawableZOrderCommandArchive_SwapPair::has_z_order_1() const {
  return _internal_has_z_order_1();
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_z_order_1() {
  _impl_.z_order_1_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SwapDrawableZOrderCommandArchive_SwapPair::_internal_z_order_1() const {
  return _impl_.z_order_1_;
}
inline uint32_t SwapDrawableZOrderCommandArchive_SwapPair::z_order_1() const {
  // @@protoc_insertion_point(field_get:TP.SwapDrawableZOrderCommandArchive.SwapPair.z_order_1)
  return _internal_z_order_1();
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::_internal_set_z_order_1(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.z_order_1_ = value;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_z_order_1(uint32_t value) {
  _internal_set_z_order_1(value);
  // @@protoc_insertion_point(field_set:TP.SwapDrawableZOrderCommandArchive.SwapPair.z_order_1)
}

// required uint32 z_order_2 = 2;
inline bool SwapDrawableZOrderCommandArchive_SwapPair::_internal_has_z_order_2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SwapDrawableZOrderCommandArchive_SwapPair::has_z_order_2() const {
  return _internal_has_z_order_2();
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::clear_z_order_2() {
  _impl_.z_order_2_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SwapDrawableZOrderCommandArchive_SwapPair::_internal_z_order_2() const {
  return _impl_.z_order_2_;
}
inline uint32_t SwapDrawableZOrderCommandArchive_SwapPair::z_order_2() const {
  // @@protoc_insertion_point(field_get:TP.SwapDrawableZOrderCommandArchive.SwapPair.z_order_2)
  return _internal_z_order_2();
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::_internal_set_z_order_2(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.z_order_2_ = value;
}
inline void SwapDrawableZOrderCommandArchive_SwapPair::set_z_order_2(uint32_t value) {
  _internal_set_z_order_2(value);
  // @@protoc_insertion_point(field_set:TP.SwapDrawableZOrderCommandArchive.SwapPair.z_order_2)
}

// -------------------------------------------------------------------

// SwapDrawableZOrderCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool SwapDrawableZOrderCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool SwapDrawableZOrderCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& SwapDrawableZOrderCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& SwapDrawableZOrderCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.SwapDrawableZOrderCommandArchive.super)
  return _internal_super();
}
inline void SwapDrawableZOrderCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.SwapDrawableZOrderCommandArchive.super)
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.SwapDrawableZOrderCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* SwapDrawableZOrderCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.SwapDrawableZOrderCommandArchive.super)
  return _msg;
}
inline void SwapDrawableZOrderCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.SwapDrawableZOrderCommandArchive.super)
}

// repeated .TP.SwapDrawableZOrderCommandArchive.SwapPair swap_pairs = 2;
inline int SwapDrawableZOrderCommandArchive::_internal_swap_pairs_size() const {
  return _impl_.swap_pairs_.size();
}
inline int SwapDrawableZOrderCommandArchive::swap_pairs_size() const {
  return _internal_swap_pairs_size();
}
inline void SwapDrawableZOrderCommandArchive::clear_swap_pairs() {
  _impl_.swap_pairs_.Clear();
}
inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* SwapDrawableZOrderCommandArchive::mutable_swap_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:TP.SwapDrawableZOrderCommandArchive.swap_pairs)
  return _impl_.swap_pairs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >*
SwapDrawableZOrderCommandArchive::mutable_swap_pairs() {
  // @@protoc_insertion_point(field_mutable_list:TP.SwapDrawableZOrderCommandArchive.swap_pairs)
  return &_impl_.swap_pairs_;
}
inline const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& SwapDrawableZOrderCommandArchive::_internal_swap_pairs(int index) const {
  return _impl_.swap_pairs_.Get(index);
}
inline const ::TP::SwapDrawableZOrderCommandArchive_SwapPair& SwapDrawableZOrderCommandArchive::swap_pairs(int index) const {
  // @@protoc_insertion_point(field_get:TP.SwapDrawableZOrderCommandArchive.swap_pairs)
  return _internal_swap_pairs(index);
}
inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* SwapDrawableZOrderCommandArchive::_internal_add_swap_pairs() {
  return _impl_.swap_pairs_.Add();
}
inline ::TP::SwapDrawableZOrderCommandArchive_SwapPair* SwapDrawableZOrderCommandArchive::add_swap_pairs() {
  ::TP::SwapDrawableZOrderCommandArchive_SwapPair* _add = _internal_add_swap_pairs();
  // @@protoc_insertion_point(field_add:TP.SwapDrawableZOrderCommandArchive.swap_pairs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::SwapDrawableZOrderCommandArchive_SwapPair >&
SwapDrawableZOrderCommandArchive::swap_pairs() const {
  // @@protoc_insertion_point(field_list:TP.SwapDrawableZOrderCommandArchive.swap_pairs)
  return _impl_.swap_pairs_;
}

// -------------------------------------------------------------------

// RemoveDrawablesCommandArchive_DrawableInfo

// optional uint32 page_index = 1;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_page_index() const {
  return _internal_has_page_index();
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveDrawablesCommandArchive_DrawableInfo::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t RemoveDrawablesCommandArchive_DrawableInfo::page_index() const {
  // @@protoc_insertion_point(field_get:TP.RemoveDrawablesCommandArchive.DrawableInfo.page_index)
  return _internal_page_index();
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.page_index_ = value;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.RemoveDrawablesCommandArchive.DrawableInfo.page_index)
}

// optional int32 z_order = 2;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_z_order() const {
  return _internal_has_z_order();
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::clear_z_order() {
  _impl_.z_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RemoveDrawablesCommandArchive_DrawableInfo::_internal_z_order() const {
  return _impl_.z_order_;
}
inline int32_t RemoveDrawablesCommandArchive_DrawableInfo::z_order() const {
  // @@protoc_insertion_point(field_get:TP.RemoveDrawablesCommandArchive.DrawableInfo.z_order)
  return _internal_z_order();
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::_internal_set_z_order(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_order_ = value;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_z_order(int32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.RemoveDrawablesCommandArchive.DrawableInfo.z_order)
}

// optional .TSP.Reference drawable_object = 3;
inline bool RemoveDrawablesCommandArchive_DrawableInfo::_internal_has_drawable_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_object_ != nullptr);
  return value;
}
inline bool RemoveDrawablesCommandArchive_DrawableInfo::has_drawable_object() const {
  return _internal_has_drawable_object();
}
inline const ::TSP::Reference& RemoveDrawablesCommandArchive_DrawableInfo::_internal_drawable_object() const {
  const ::TSP::Reference* p = _impl_.drawable_object_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveDrawablesCommandArchive_DrawableInfo::drawable_object() const {
  // @@protoc_insertion_point(field_get:TP.RemoveDrawablesCommandArchive.DrawableInfo.drawable_object)
  return _internal_drawable_object();
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::unsafe_arena_set_allocated_drawable_object(
    ::TSP::Reference* drawable_object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_object_);
  }
  _impl_.drawable_object_ = drawable_object;
  if (drawable_object) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveDrawablesCommandArchive.DrawableInfo.drawable_object)
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::release_drawable_object() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_object_;
  _impl_.drawable_object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::unsafe_arena_release_drawable_object() {
  // @@protoc_insertion_point(field_release:TP.RemoveDrawablesCommandArchive.DrawableInfo.drawable_object)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_object_;
  _impl_.drawable_object_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::_internal_mutable_drawable_object() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_object_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_object_ = p;
  }
  return _impl_.drawable_object_;
}
inline ::TSP::Reference* RemoveDrawablesCommandArchive_DrawableInfo::mutable_drawable_object() {
  ::TSP::Reference* _msg = _internal_mutable_drawable_object();
  // @@protoc_insertion_point(field_mutable:TP.RemoveDrawablesCommandArchive.DrawableInfo.drawable_object)
  return _msg;
}
inline void RemoveDrawablesCommandArchive_DrawableInfo::set_allocated_drawable_object(::TSP::Reference* drawable_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_object_);
  }
  if (drawable_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable_object));
    if (message_arena != submessage_arena) {
      drawable_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable_object, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_object_ = drawable_object;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveDrawablesCommandArchive.DrawableInfo.drawable_object)
}

// -------------------------------------------------------------------

// RemoveDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool RemoveDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.RemoveDrawablesCommandArchive.super)
  return _internal_super();
}
inline void RemoveDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.RemoveDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.RemoveDrawablesCommandArchive.super)
  return _msg;
}
inline void RemoveDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveDrawablesCommandArchive.super)
}

// repeated .TP.RemoveDrawablesCommandArchive.DrawableInfo drawables = 2;
inline int RemoveDrawablesCommandArchive::_internal_drawables_size() const {
  return _impl_.drawables_.size();
}
inline int RemoveDrawablesCommandArchive::drawables_size() const {
  return _internal_drawables_size();
}
inline void RemoveDrawablesCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* RemoveDrawablesCommandArchive::mutable_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.RemoveDrawablesCommandArchive.drawables)
  return _impl_.drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >*
RemoveDrawablesCommandArchive::mutable_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.RemoveDrawablesCommandArchive.drawables)
  return &_impl_.drawables_;
}
inline const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& RemoveDrawablesCommandArchive::_internal_drawables(int index) const {
  return _impl_.drawables_.Get(index);
}
inline const ::TP::RemoveDrawablesCommandArchive_DrawableInfo& RemoveDrawablesCommandArchive::drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.RemoveDrawablesCommandArchive.drawables)
  return _internal_drawables(index);
}
inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* RemoveDrawablesCommandArchive::_internal_add_drawables() {
  return _impl_.drawables_.Add();
}
inline ::TP::RemoveDrawablesCommandArchive_DrawableInfo* RemoveDrawablesCommandArchive::add_drawables() {
  ::TP::RemoveDrawablesCommandArchive_DrawableInfo* _add = _internal_add_drawables();
  // @@protoc_insertion_point(field_add:TP.RemoveDrawablesCommandArchive.drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveDrawablesCommandArchive_DrawableInfo >&
RemoveDrawablesCommandArchive::drawables() const {
  // @@protoc_insertion_point(field_list:TP.RemoveDrawablesCommandArchive.drawables)
  return _impl_.drawables_;
}

// -------------------------------------------------------------------

// NudgeDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool NudgeDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool NudgeDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& NudgeDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& NudgeDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.NudgeDrawablesCommandArchive.super)
  return _internal_super();
}
inline void NudgeDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.NudgeDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.NudgeDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* NudgeDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.NudgeDrawablesCommandArchive.super)
  return _msg;
}
inline void NudgeDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.NudgeDrawablesCommandArchive.super)
}

// repeated .TSP.Reference child_commands = 2;
inline int NudgeDrawablesCommandArchive::_internal_child_commands_size() const {
  return _impl_.child_commands_.size();
}
inline int NudgeDrawablesCommandArchive::child_commands_size() const {
  return _internal_child_commands_size();
}
inline ::TSP::Reference* NudgeDrawablesCommandArchive::mutable_child_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TP.NudgeDrawablesCommandArchive.child_commands)
  return _impl_.child_commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
NudgeDrawablesCommandArchive::mutable_child_commands() {
  // @@protoc_insertion_point(field_mutable_list:TP.NudgeDrawablesCommandArchive.child_commands)
  return &_impl_.child_commands_;
}
inline const ::TSP::Reference& NudgeDrawablesCommandArchive::_internal_child_commands(int index) const {
  return _impl_.child_commands_.Get(index);
}
inline const ::TSP::Reference& NudgeDrawablesCommandArchive::child_commands(int index) const {
  // @@protoc_insertion_point(field_get:TP.NudgeDrawablesCommandArchive.child_commands)
  return _internal_child_commands(index);
}
inline ::TSP::Reference* NudgeDrawablesCommandArchive::_internal_add_child_commands() {
  return _impl_.child_commands_.Add();
}
inline ::TSP::Reference* NudgeDrawablesCommandArchive::add_child_commands() {
  ::TSP::Reference* _add = _internal_add_child_commands();
  // @@protoc_insertion_point(field_add:TP.NudgeDrawablesCommandArchive.child_commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
NudgeDrawablesCommandArchive::child_commands() const {
  // @@protoc_insertion_point(field_list:TP.NudgeDrawablesCommandArchive.child_commands)
  return _impl_.child_commands_;
}

// -------------------------------------------------------------------

// ChangeHeaderFooterVisibilityCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeHeaderFooterVisibilityCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeHeaderFooterVisibilityCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeHeaderFooterVisibilityCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeHeaderFooterVisibilityCommandArchive.super)
  return _internal_super();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeHeaderFooterVisibilityCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeHeaderFooterVisibilityCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeHeaderFooterVisibilityCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeHeaderFooterVisibilityCommandArchive.super)
  return _msg;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeHeaderFooterVisibilityCommandArchive.super)
}

// optional bool visible = 2;
inline bool ChangeHeaderFooterVisibilityCommandArchive::_internal_has_visible() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_visible() const {
  return _internal_has_visible();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_visible() {
  _impl_.visible_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::_internal_visible() const {
  return _impl_.visible_;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::visible() const {
  // @@protoc_insertion_point(field_get:TP.ChangeHeaderFooterVisibilityCommandArchive.visible)
  return _internal_visible();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::_internal_set_visible(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.visible_ = value;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:TP.ChangeHeaderFooterVisibilityCommandArchive.visible)
}

// optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFooterType type = 3;
inline bool ChangeHeaderFooterVisibilityCommandArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_type() const {
  return _internal_has_type();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::_internal_type() const {
  return static_cast< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType >(_impl_.type_);
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType ChangeHeaderFooterVisibilityCommandArchive::type() const {
  // @@protoc_insertion_point(field_get:TP.ChangeHeaderFooterVisibilityCommandArchive.type)
  return _internal_type();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::_internal_set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value) {
  assert(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_type(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TP.ChangeHeaderFooterVisibilityCommandArchive.type)
}

// optional .TP.ChangeHeaderFooterVisibilityCommandArchive.TPHeaderFragmentIndex index_to_select = 4;
inline bool ChangeHeaderFooterVisibilityCommandArchive::_internal_has_index_to_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeHeaderFooterVisibilityCommandArchive::has_index_to_select() const {
  return _internal_has_index_to_select();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::clear_index_to_select() {
  _impl_.index_to_select_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::_internal_index_to_select() const {
  return static_cast< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex >(_impl_.index_to_select_);
}
inline ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex ChangeHeaderFooterVisibilityCommandArchive::index_to_select() const {
  // @@protoc_insertion_point(field_get:TP.ChangeHeaderFooterVisibilityCommandArchive.index_to_select)
  return _internal_index_to_select();
}
inline void ChangeHeaderFooterVisibilityCommandArchive::_internal_set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value) {
  assert(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.index_to_select_ = value;
}
inline void ChangeHeaderFooterVisibilityCommandArchive::set_index_to_select(::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex value) {
  _internal_set_index_to_select(value);
  // @@protoc_insertion_point(field_set:TP.ChangeHeaderFooterVisibilityCommandArchive.index_to_select)
}

// repeated .TSP.Reference storages = 5;
inline int ChangeHeaderFooterVisibilityCommandArchive::_internal_storages_size() const {
  return _impl_.storages_.size();
}
inline int ChangeHeaderFooterVisibilityCommandArchive::storages_size() const {
  return _internal_storages_size();
}
inline ::TSP::Reference* ChangeHeaderFooterVisibilityCommandArchive::mutable_storages(int index) {
  // @@protoc_insertion_point(field_mutable:TP.ChangeHeaderFooterVisibilityCommandArchive.storages)
  return _impl_.storages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ChangeHeaderFooterVisibilityCommandArchive::mutable_storages() {
  // @@protoc_insertion_point(field_mutable_list:TP.ChangeHeaderFooterVisibilityCommandArchive.storages)
  return &_impl_.storages_;
}
inline const ::TSP::Reference& ChangeHeaderFooterVisibilityCommandArchive::_internal_storages(int index) const {
  return _impl_.storages_.Get(index);
}
inline const ::TSP::Reference& ChangeHeaderFooterVisibilityCommandArchive::storages(int index) const {
  // @@protoc_insertion_point(field_get:TP.ChangeHeaderFooterVisibilityCommandArchive.storages)
  return _internal_storages(index);
}
inline ::TSP::Reference* ChangeHeaderFooterVisibilityCommandArchive::_internal_add_storages() {
  return _impl_.storages_.Add();
}
inline ::TSP::Reference* ChangeHeaderFooterVisibilityCommandArchive::add_storages() {
  ::TSP::Reference* _add = _internal_add_storages();
  // @@protoc_insertion_point(field_add:TP.ChangeHeaderFooterVisibilityCommandArchive.storages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ChangeHeaderFooterVisibilityCommandArchive::storages() const {
  // @@protoc_insertion_point(field_list:TP.ChangeHeaderFooterVisibilityCommandArchive.storages)
  return _impl_.storages_;
}

// -------------------------------------------------------------------

// ChangeSectionMarginsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeSectionMarginsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeSectionMarginsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeSectionMarginsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeSectionMarginsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionMarginsCommandArchive.super)
  return _internal_super();
}
inline void ChangeSectionMarginsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeSectionMarginsCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeSectionMarginsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeSectionMarginsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeSectionMarginsCommandArchive.super)
  return _msg;
}
inline void ChangeSectionMarginsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeSectionMarginsCommandArchive.super)
}

// optional .TSP.Reference section = 2;
inline bool ChangeSectionMarginsCommandArchive::_internal_has_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.section_ != nullptr);
  return value;
}
inline bool ChangeSectionMarginsCommandArchive::has_section() const {
  return _internal_has_section();
}
inline const ::TSP::Reference& ChangeSectionMarginsCommandArchive::_internal_section() const {
  const ::TSP::Reference* p = _impl_.section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ChangeSectionMarginsCommandArchive::section() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionMarginsCommandArchive.section)
  return _internal_section();
}
inline void ChangeSectionMarginsCommandArchive::unsafe_arena_set_allocated_section(
    ::TSP::Reference* section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_);
  }
  _impl_.section_ = section;
  if (section) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeSectionMarginsCommandArchive.section)
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::release_section() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.section_;
  _impl_.section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::unsafe_arena_release_section() {
  // @@protoc_insertion_point(field_release:TP.ChangeSectionMarginsCommandArchive.section)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.section_;
  _impl_.section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::_internal_mutable_section() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.section_ = p;
  }
  return _impl_.section_;
}
inline ::TSP::Reference* ChangeSectionMarginsCommandArchive::mutable_section() {
  ::TSP::Reference* _msg = _internal_mutable_section();
  // @@protoc_insertion_point(field_mutable:TP.ChangeSectionMarginsCommandArchive.section)
  return _msg;
}
inline void ChangeSectionMarginsCommandArchive::set_allocated_section(::TSP::Reference* section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_);
  }
  if (section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(section));
    if (message_arena != submessage_arena) {
      section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.section_ = section;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeSectionMarginsCommandArchive.section)
}

// optional .TP.ChangeSectionMarginsCommandArchive.SectionMargin margin = 3;
inline bool ChangeSectionMarginsCommandArchive::_internal_has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeSectionMarginsCommandArchive::has_margin() const {
  return _internal_has_margin();
}
inline void ChangeSectionMarginsCommandArchive::clear_margin() {
  _impl_.margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TP::ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::_internal_margin() const {
  return static_cast< ::TP::ChangeSectionMarginsCommandArchive_SectionMargin >(_impl_.margin_);
}
inline ::TP::ChangeSectionMarginsCommandArchive_SectionMargin ChangeSectionMarginsCommandArchive::margin() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionMarginsCommandArchive.margin)
  return _internal_margin();
}
inline void ChangeSectionMarginsCommandArchive::_internal_set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value) {
  assert(::TP::ChangeSectionMarginsCommandArchive_SectionMargin_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.margin_ = value;
}
inline void ChangeSectionMarginsCommandArchive::set_margin(::TP::ChangeSectionMarginsCommandArchive_SectionMargin value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TP.ChangeSectionMarginsCommandArchive.margin)
}

// optional float margin_value = 4;
inline bool ChangeSectionMarginsCommandArchive::_internal_has_margin_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeSectionMarginsCommandArchive::has_margin_value() const {
  return _internal_has_margin_value();
}
inline void ChangeSectionMarginsCommandArchive::clear_margin_value() {
  _impl_.margin_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ChangeSectionMarginsCommandArchive::_internal_margin_value() const {
  return _impl_.margin_value_;
}
inline float ChangeSectionMarginsCommandArchive::margin_value() const {
  // @@protoc_insertion_point(field_get:TP.ChangeSectionMarginsCommandArchive.margin_value)
  return _internal_margin_value();
}
inline void ChangeSectionMarginsCommandArchive::_internal_set_margin_value(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.margin_value_ = value;
}
inline void ChangeSectionMarginsCommandArchive::set_margin_value(float value) {
  _internal_set_margin_value(value);
  // @@protoc_insertion_point(field_set:TP.ChangeSectionMarginsCommandArchive.margin_value)
}

// -------------------------------------------------------------------

// ChangeDocumentPrinterOptionsCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeDocumentPrinterOptionsCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeDocumentPrinterOptionsCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.super)
  return _internal_super();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeDocumentPrinterOptionsCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeDocumentPrinterOptionsCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeDocumentPrinterOptionsCommandArchive.super)
  return _msg;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.super)
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_obsolete_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsolete_section_ != nullptr);
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_obsolete_section() const {
  return _internal_has_obsolete_section();
}
inline const ::TSP::Reference& ChangeDocumentPrinterOptionsCommandArchive::_internal_obsolete_section() const {
  const ::TSP::Reference* p = _impl_.obsolete_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ChangeDocumentPrinterOptionsCommandArchive::obsolete_section() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.OBSOLETE_section)
  return _internal_obsolete_section();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::unsafe_arena_set_allocated_obsolete_section(
    ::TSP::Reference* obsolete_section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  _impl_.obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.OBSOLETE_section)
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::release_obsolete_section() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::unsafe_arena_release_obsolete_section() {
  // @@protoc_insertion_point(field_release:TP.ChangeDocumentPrinterOptionsCommandArchive.OBSOLETE_section)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::_internal_mutable_obsolete_section() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.obsolete_section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.obsolete_section_ = p;
  }
  return _impl_.obsolete_section_;
}
inline ::TSP::Reference* ChangeDocumentPrinterOptionsCommandArchive::mutable_obsolete_section() {
  ::TSP::Reference* _msg = _internal_mutable_obsolete_section();
  // @@protoc_insertion_point(field_mutable:TP.ChangeDocumentPrinterOptionsCommandArchive.OBSOLETE_section)
  return _msg;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  if (obsolete_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obsolete_section));
    if (message_arena != submessage_arena) {
      obsolete_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsolete_section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.obsolete_section_ = obsolete_section;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.OBSOLETE_section)
}

// optional float paper_width = 3;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_paper_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_width() const {
  return _internal_has_paper_width();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_width() {
  _impl_.paper_width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::_internal_paper_width() const {
  return _impl_.paper_width_;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::paper_width() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_width)
  return _internal_paper_width();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_paper_width(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.paper_width_ = value;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_width(float value) {
  _internal_set_paper_width(value);
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_width)
}

// optional float paper_height = 4;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_paper_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_height() const {
  return _internal_has_paper_height();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_height() {
  _impl_.paper_height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::_internal_paper_height() const {
  return _impl_.paper_height_;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::paper_height() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_height)
  return _internal_paper_height();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_paper_height(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.paper_height_ = value;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_paper_height(float value) {
  _internal_set_paper_height(value);
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_height)
}

// optional float page_scale = 5;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_page_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_page_scale() const {
  return _internal_has_page_scale();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_page_scale() {
  _impl_.page_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::_internal_page_scale() const {
  return _impl_.page_scale_;
}
inline float ChangeDocumentPrinterOptionsCommandArchive::page_scale() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.page_scale)
  return _internal_page_scale();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_page_scale(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.page_scale_ = value;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_page_scale(float value) {
  _internal_set_page_scale(value);
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.page_scale)
}

// optional uint32 orientation = 6;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_orientation() const {
  return _internal_has_orientation();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_orientation() {
  _impl_.orientation_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t ChangeDocumentPrinterOptionsCommandArchive::_internal_orientation() const {
  return _impl_.orientation_;
}
inline uint32_t ChangeDocumentPrinterOptionsCommandArchive::orientation() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.orientation)
  return _internal_orientation();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_orientation(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.orientation_ = value;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_orientation(uint32_t value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.orientation)
}

// optional string printer_id = 7;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_printer_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_printer_id() const {
  return _internal_has_printer_id();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_printer_id() {
  _impl_.printer_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeDocumentPrinterOptionsCommandArchive::printer_id() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id)
  return _internal_printer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeDocumentPrinterOptionsCommandArchive::set_printer_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.printer_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id)
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::mutable_printer_id() {
  std::string* _s = _internal_mutable_printer_id();
  // @@protoc_insertion_point(field_mutable:TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id)
  return _s;
}
inline const std::string& ChangeDocumentPrinterOptionsCommandArchive::_internal_printer_id() const {
  return _impl_.printer_id_.Get();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_printer_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.printer_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::_internal_mutable_printer_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.printer_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::release_printer_id() {
  // @@protoc_insertion_point(field_release:TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id)
  if (!_internal_has_printer_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.printer_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.printer_id_.IsDefault()) {
    _impl_.printer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_printer_id(std::string* printer_id) {
  if (printer_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.printer_id_.SetAllocated(printer_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.printer_id_.IsDefault()) {
    _impl_.printer_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.printer_id)
}

// optional string paper_id = 8;
inline bool ChangeDocumentPrinterOptionsCommandArchive::_internal_has_paper_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeDocumentPrinterOptionsCommandArchive::has_paper_id() const {
  return _internal_has_paper_id();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::clear_paper_id() {
  _impl_.paper_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChangeDocumentPrinterOptionsCommandArchive::paper_id() const {
  // @@protoc_insertion_point(field_get:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id)
  return _internal_paper_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeDocumentPrinterOptionsCommandArchive::set_paper_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.paper_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id)
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::mutable_paper_id() {
  std::string* _s = _internal_mutable_paper_id();
  // @@protoc_insertion_point(field_mutable:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id)
  return _s;
}
inline const std::string& ChangeDocumentPrinterOptionsCommandArchive::_internal_paper_id() const {
  return _impl_.paper_id_.Get();
}
inline void ChangeDocumentPrinterOptionsCommandArchive::_internal_set_paper_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.paper_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::_internal_mutable_paper_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.paper_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeDocumentPrinterOptionsCommandArchive::release_paper_id() {
  // @@protoc_insertion_point(field_release:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id)
  if (!_internal_has_paper_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.paper_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paper_id_.IsDefault()) {
    _impl_.paper_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChangeDocumentPrinterOptionsCommandArchive::set_allocated_paper_id(std::string* paper_id) {
  if (paper_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.paper_id_.SetAllocated(paper_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paper_id_.IsDefault()) {
    _impl_.paper_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeDocumentPrinterOptionsCommandArchive.paper_id)
}

// -------------------------------------------------------------------

// InsertMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool InsertMasterDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertMasterDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& InsertMasterDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& InsertMasterDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.InsertMasterDrawablesCommandArchive.super)
  return _internal_super();
}
inline void InsertMasterDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertMasterDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.InsertMasterDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* InsertMasterDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.InsertMasterDrawablesCommandArchive.super)
  return _msg;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertMasterDrawablesCommandArchive.super)
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool InsertMasterDrawablesCommandArchive::_internal_has_obsolete_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsolete_section_ != nullptr);
  return value;
}
inline bool InsertMasterDrawablesCommandArchive::has_obsolete_section() const {
  return _internal_has_obsolete_section();
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::_internal_obsolete_section() const {
  const ::TSP::Reference* p = _impl_.obsolete_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::obsolete_section() const {
  // @@protoc_insertion_point(field_get:TP.InsertMasterDrawablesCommandArchive.OBSOLETE_section)
  return _internal_obsolete_section();
}
inline void InsertMasterDrawablesCommandArchive::unsafe_arena_set_allocated_obsolete_section(
    ::TSP::Reference* obsolete_section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  _impl_.obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertMasterDrawablesCommandArchive.OBSOLETE_section)
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::release_obsolete_section() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::unsafe_arena_release_obsolete_section() {
  // @@protoc_insertion_point(field_release:TP.InsertMasterDrawablesCommandArchive.OBSOLETE_section)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::_internal_mutable_obsolete_section() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.obsolete_section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.obsolete_section_ = p;
  }
  return _impl_.obsolete_section_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_obsolete_section() {
  ::TSP::Reference* _msg = _internal_mutable_obsolete_section();
  // @@protoc_insertion_point(field_mutable:TP.InsertMasterDrawablesCommandArchive.OBSOLETE_section)
  return _msg;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  if (obsolete_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obsolete_section));
    if (message_arena != submessage_arena) {
      obsolete_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsolete_section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsolete_section_ = obsolete_section;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertMasterDrawablesCommandArchive.OBSOLETE_section)
}

// repeated .TSP.Reference master_drawables = 3;
inline int InsertMasterDrawablesCommandArchive::_internal_master_drawables_size() const {
  return _impl_.master_drawables_.size();
}
inline int InsertMasterDrawablesCommandArchive::master_drawables_size() const {
  return _internal_master_drawables_size();
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.InsertMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
InsertMasterDrawablesCommandArchive::mutable_master_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.InsertMasterDrawablesCommandArchive.master_drawables)
  return &_impl_.master_drawables_;
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::_internal_master_drawables(int index) const {
  return _impl_.master_drawables_.Get(index);
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::master_drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.InsertMasterDrawablesCommandArchive.master_drawables)
  return _internal_master_drawables(index);
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::_internal_add_master_drawables() {
  return _impl_.master_drawables_.Add();
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::add_master_drawables() {
  ::TSP::Reference* _add = _internal_add_master_drawables();
  // @@protoc_insertion_point(field_add:TP.InsertMasterDrawablesCommandArchive.master_drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
InsertMasterDrawablesCommandArchive::master_drawables() const {
  // @@protoc_insertion_point(field_list:TP.InsertMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_;
}

// optional uint32 drawable_index = 4;
inline bool InsertMasterDrawablesCommandArchive::_internal_has_drawable_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertMasterDrawablesCommandArchive::has_drawable_index() const {
  return _internal_has_drawable_index();
}
inline void InsertMasterDrawablesCommandArchive::clear_drawable_index() {
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t InsertMasterDrawablesCommandArchive::_internal_drawable_index() const {
  return _impl_.drawable_index_;
}
inline uint32_t InsertMasterDrawablesCommandArchive::drawable_index() const {
  // @@protoc_insertion_point(field_get:TP.InsertMasterDrawablesCommandArchive.drawable_index)
  return _internal_drawable_index();
}
inline void InsertMasterDrawablesCommandArchive::_internal_set_drawable_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.drawable_index_ = value;
}
inline void InsertMasterDrawablesCommandArchive::set_drawable_index(uint32_t value) {
  _internal_set_drawable_index(value);
  // @@protoc_insertion_point(field_set:TP.InsertMasterDrawablesCommandArchive.drawable_index)
}

// optional .TSP.Reference master_drawable_provider = 5;
inline bool InsertMasterDrawablesCommandArchive::_internal_has_master_drawable_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.master_drawable_provider_ != nullptr);
  return value;
}
inline bool InsertMasterDrawablesCommandArchive::has_master_drawable_provider() const {
  return _internal_has_master_drawable_provider();
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::_internal_master_drawable_provider() const {
  const ::TSP::Reference* p = _impl_.master_drawable_provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& InsertMasterDrawablesCommandArchive::master_drawable_provider() const {
  // @@protoc_insertion_point(field_get:TP.InsertMasterDrawablesCommandArchive.master_drawable_provider)
  return _internal_master_drawable_provider();
}
inline void InsertMasterDrawablesCommandArchive::unsafe_arena_set_allocated_master_drawable_provider(
    ::TSP::Reference* master_drawable_provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertMasterDrawablesCommandArchive.master_drawable_provider)
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::release_master_drawable_provider() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::unsafe_arena_release_master_drawable_provider() {
  // @@protoc_insertion_point(field_release:TP.InsertMasterDrawablesCommandArchive.master_drawable_provider)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
  return temp;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::_internal_mutable_master_drawable_provider() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.master_drawable_provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.master_drawable_provider_ = p;
  }
  return _impl_.master_drawable_provider_;
}
inline ::TSP::Reference* InsertMasterDrawablesCommandArchive::mutable_master_drawable_provider() {
  ::TSP::Reference* _msg = _internal_mutable_master_drawable_provider();
  // @@protoc_insertion_point(field_mutable:TP.InsertMasterDrawablesCommandArchive.master_drawable_provider)
  return _msg;
}
inline void InsertMasterDrawablesCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  if (master_drawable_provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_drawable_provider));
    if (message_arena != submessage_arena) {
      master_drawable_provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master_drawable_provider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertMasterDrawablesCommandArchive.master_drawable_provider)
}

// -------------------------------------------------------------------

// MoveMasterDrawableZOrderCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveMasterDrawableZOrderCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveMasterDrawableZOrderCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveMasterDrawableZOrderCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveMasterDrawableZOrderCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveMasterDrawableZOrderCommandArchive.super)
  return _internal_super();
}
inline void MoveMasterDrawableZOrderCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveMasterDrawableZOrderCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveMasterDrawableZOrderCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveMasterDrawableZOrderCommandArchive.super)
  return _msg;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.super)
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool MoveMasterDrawableZOrderCommandArchive::_internal_has_obsolete_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsolete_section_ != nullptr);
  return value;
}
inline bool MoveMasterDrawableZOrderCommandArchive::has_obsolete_section() const {
  return _internal_has_obsolete_section();
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::_internal_obsolete_section() const {
  const ::TSP::Reference* p = _impl_.obsolete_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::obsolete_section() const {
  // @@protoc_insertion_point(field_get:TP.MoveMasterDrawableZOrderCommandArchive.OBSOLETE_section)
  return _internal_obsolete_section();
}
inline void MoveMasterDrawableZOrderCommandArchive::unsafe_arena_set_allocated_obsolete_section(
    ::TSP::Reference* obsolete_section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  _impl_.obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.OBSOLETE_section)
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::release_obsolete_section() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::unsafe_arena_release_obsolete_section() {
  // @@protoc_insertion_point(field_release:TP.MoveMasterDrawableZOrderCommandArchive.OBSOLETE_section)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::_internal_mutable_obsolete_section() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.obsolete_section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.obsolete_section_ = p;
  }
  return _impl_.obsolete_section_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_obsolete_section() {
  ::TSP::Reference* _msg = _internal_mutable_obsolete_section();
  // @@protoc_insertion_point(field_mutable:TP.MoveMasterDrawableZOrderCommandArchive.OBSOLETE_section)
  return _msg;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  if (obsolete_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obsolete_section));
    if (message_arena != submessage_arena) {
      obsolete_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsolete_section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsolete_section_ = obsolete_section;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.OBSOLETE_section)
}

// repeated .TSP.Reference master_drawables = 3;
inline int MoveMasterDrawableZOrderCommandArchive::_internal_master_drawables_size() const {
  return _impl_.master_drawables_.size();
}
inline int MoveMasterDrawableZOrderCommandArchive::master_drawables_size() const {
  return _internal_master_drawables_size();
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_master_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.MoveMasterDrawableZOrderCommandArchive.master_drawables)
  return _impl_.master_drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
MoveMasterDrawableZOrderCommandArchive::mutable_master_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.MoveMasterDrawableZOrderCommandArchive.master_drawables)
  return &_impl_.master_drawables_;
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::_internal_master_drawables(int index) const {
  return _impl_.master_drawables_.Get(index);
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::master_drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.MoveMasterDrawableZOrderCommandArchive.master_drawables)
  return _internal_master_drawables(index);
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::_internal_add_master_drawables() {
  return _impl_.master_drawables_.Add();
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::add_master_drawables() {
  ::TSP::Reference* _add = _internal_add_master_drawables();
  // @@protoc_insertion_point(field_add:TP.MoveMasterDrawableZOrderCommandArchive.master_drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
MoveMasterDrawableZOrderCommandArchive::master_drawables() const {
  // @@protoc_insertion_point(field_list:TP.MoveMasterDrawableZOrderCommandArchive.master_drawables)
  return _impl_.master_drawables_;
}

// repeated uint32 indexes = 4;
inline int MoveMasterDrawableZOrderCommandArchive::_internal_indexes_size() const {
  return _impl_.indexes_.size();
}
inline int MoveMasterDrawableZOrderCommandArchive::indexes_size() const {
  return _internal_indexes_size();
}
inline void MoveMasterDrawableZOrderCommandArchive::clear_indexes() {
  _impl_.indexes_.Clear();
}
inline uint32_t MoveMasterDrawableZOrderCommandArchive::_internal_indexes(int index) const {
  return _impl_.indexes_.Get(index);
}
inline uint32_t MoveMasterDrawableZOrderCommandArchive::indexes(int index) const {
  // @@protoc_insertion_point(field_get:TP.MoveMasterDrawableZOrderCommandArchive.indexes)
  return _internal_indexes(index);
}
inline void MoveMasterDrawableZOrderCommandArchive::set_indexes(int index, uint32_t value) {
  _impl_.indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:TP.MoveMasterDrawableZOrderCommandArchive.indexes)
}
inline void MoveMasterDrawableZOrderCommandArchive::_internal_add_indexes(uint32_t value) {
  _impl_.indexes_.Add(value);
}
inline void MoveMasterDrawableZOrderCommandArchive::add_indexes(uint32_t value) {
  _internal_add_indexes(value);
  // @@protoc_insertion_point(field_add:TP.MoveMasterDrawableZOrderCommandArchive.indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoveMasterDrawableZOrderCommandArchive::_internal_indexes() const {
  return _impl_.indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MoveMasterDrawableZOrderCommandArchive::indexes() const {
  // @@protoc_insertion_point(field_list:TP.MoveMasterDrawableZOrderCommandArchive.indexes)
  return _internal_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoveMasterDrawableZOrderCommandArchive::_internal_mutable_indexes() {
  return &_impl_.indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MoveMasterDrawableZOrderCommandArchive::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:TP.MoveMasterDrawableZOrderCommandArchive.indexes)
  return _internal_mutable_indexes();
}

// optional .TSP.Reference master_drawable_provider = 5;
inline bool MoveMasterDrawableZOrderCommandArchive::_internal_has_master_drawable_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.master_drawable_provider_ != nullptr);
  return value;
}
inline bool MoveMasterDrawableZOrderCommandArchive::has_master_drawable_provider() const {
  return _internal_has_master_drawable_provider();
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::_internal_master_drawable_provider() const {
  const ::TSP::Reference* p = _impl_.master_drawable_provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveMasterDrawableZOrderCommandArchive::master_drawable_provider() const {
  // @@protoc_insertion_point(field_get:TP.MoveMasterDrawableZOrderCommandArchive.master_drawable_provider)
  return _internal_master_drawable_provider();
}
inline void MoveMasterDrawableZOrderCommandArchive::unsafe_arena_set_allocated_master_drawable_provider(
    ::TSP::Reference* master_drawable_provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.master_drawable_provider)
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::release_master_drawable_provider() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::unsafe_arena_release_master_drawable_provider() {
  // @@protoc_insertion_point(field_release:TP.MoveMasterDrawableZOrderCommandArchive.master_drawable_provider)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::_internal_mutable_master_drawable_provider() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.master_drawable_provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.master_drawable_provider_ = p;
  }
  return _impl_.master_drawable_provider_;
}
inline ::TSP::Reference* MoveMasterDrawableZOrderCommandArchive::mutable_master_drawable_provider() {
  ::TSP::Reference* _msg = _internal_mutable_master_drawable_provider();
  // @@protoc_insertion_point(field_mutable:TP.MoveMasterDrawableZOrderCommandArchive.master_drawable_provider)
  return _msg;
}
inline void MoveMasterDrawableZOrderCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  if (master_drawable_provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_drawable_provider));
    if (message_arena != submessage_arena) {
      master_drawable_provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master_drawable_provider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveMasterDrawableZOrderCommandArchive.master_drawable_provider)
}

// -------------------------------------------------------------------

// RemoveMasterDrawablesCommandArchive_MasterDrawable

// optional .TSP.Reference drawable = 1;
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive_MasterDrawable::drawable() const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable)
  return _internal_drawable();
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable)
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive_MasterDrawable::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable)
  return _msg;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable)
}

// optional uint32 drawable_index = 2;
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_has_drawable_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveMasterDrawablesCommandArchive_MasterDrawable::has_drawable_index() const {
  return _internal_has_drawable_index();
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::clear_drawable_index() {
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_drawable_index() const {
  return _impl_.drawable_index_;
}
inline uint32_t RemoveMasterDrawablesCommandArchive_MasterDrawable::drawable_index() const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable_index)
  return _internal_drawable_index();
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::_internal_set_drawable_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.drawable_index_ = value;
}
inline void RemoveMasterDrawablesCommandArchive_MasterDrawable::set_drawable_index(uint32_t value) {
  _internal_set_drawable_index(value);
  // @@protoc_insertion_point(field_set:TP.RemoveMasterDrawablesCommandArchive.MasterDrawable.drawable_index)
}

// -------------------------------------------------------------------

// RemoveMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool RemoveMasterDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveMasterDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& RemoveMasterDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& RemoveMasterDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.super)
  return _internal_super();
}
inline void RemoveMasterDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveMasterDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.RemoveMasterDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* RemoveMasterDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.RemoveMasterDrawablesCommandArchive.super)
  return _msg;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveMasterDrawablesCommandArchive.super)
}

// optional .TSP.Reference OBSOLETE_section = 2;
inline bool RemoveMasterDrawablesCommandArchive::_internal_has_obsolete_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsolete_section_ != nullptr);
  return value;
}
inline bool RemoveMasterDrawablesCommandArchive::has_obsolete_section() const {
  return _internal_has_obsolete_section();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::_internal_obsolete_section() const {
  const ::TSP::Reference* p = _impl_.obsolete_section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::obsolete_section() const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.OBSOLETE_section)
  return _internal_obsolete_section();
}
inline void RemoveMasterDrawablesCommandArchive::unsafe_arena_set_allocated_obsolete_section(
    ::TSP::Reference* obsolete_section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  _impl_.obsolete_section_ = obsolete_section;
  if (obsolete_section) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveMasterDrawablesCommandArchive.OBSOLETE_section)
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::release_obsolete_section() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::unsafe_arena_release_obsolete_section() {
  // @@protoc_insertion_point(field_release:TP.RemoveMasterDrawablesCommandArchive.OBSOLETE_section)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.obsolete_section_;
  _impl_.obsolete_section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::_internal_mutable_obsolete_section() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.obsolete_section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.obsolete_section_ = p;
  }
  return _impl_.obsolete_section_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::mutable_obsolete_section() {
  ::TSP::Reference* _msg = _internal_mutable_obsolete_section();
  // @@protoc_insertion_point(field_mutable:TP.RemoveMasterDrawablesCommandArchive.OBSOLETE_section)
  return _msg;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_obsolete_section(::TSP::Reference* obsolete_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsolete_section_);
  }
  if (obsolete_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obsolete_section));
    if (message_arena != submessage_arena) {
      obsolete_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsolete_section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsolete_section_ = obsolete_section;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveMasterDrawablesCommandArchive.OBSOLETE_section)
}

// repeated .TP.RemoveMasterDrawablesCommandArchive.MasterDrawable master_drawables = 3;
inline int RemoveMasterDrawablesCommandArchive::_internal_master_drawables_size() const {
  return _impl_.master_drawables_.size();
}
inline int RemoveMasterDrawablesCommandArchive::master_drawables_size() const {
  return _internal_master_drawables_size();
}
inline void RemoveMasterDrawablesCommandArchive::clear_master_drawables() {
  _impl_.master_drawables_.Clear();
}
inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* RemoveMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.RemoveMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >*
RemoveMasterDrawablesCommandArchive::mutable_master_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.RemoveMasterDrawablesCommandArchive.master_drawables)
  return &_impl_.master_drawables_;
}
inline const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& RemoveMasterDrawablesCommandArchive::_internal_master_drawables(int index) const {
  return _impl_.master_drawables_.Get(index);
}
inline const ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable& RemoveMasterDrawablesCommandArchive::master_drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.master_drawables)
  return _internal_master_drawables(index);
}
inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* RemoveMasterDrawablesCommandArchive::_internal_add_master_drawables() {
  return _impl_.master_drawables_.Add();
}
inline ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* RemoveMasterDrawablesCommandArchive::add_master_drawables() {
  ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable* _add = _internal_add_master_drawables();
  // @@protoc_insertion_point(field_add:TP.RemoveMasterDrawablesCommandArchive.master_drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::RemoveMasterDrawablesCommandArchive_MasterDrawable >&
RemoveMasterDrawablesCommandArchive::master_drawables() const {
  // @@protoc_insertion_point(field_list:TP.RemoveMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_;
}

// optional .TSP.Reference master_drawable_provider = 4;
inline bool RemoveMasterDrawablesCommandArchive::_internal_has_master_drawable_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.master_drawable_provider_ != nullptr);
  return value;
}
inline bool RemoveMasterDrawablesCommandArchive::has_master_drawable_provider() const {
  return _internal_has_master_drawable_provider();
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::_internal_master_drawable_provider() const {
  const ::TSP::Reference* p = _impl_.master_drawable_provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RemoveMasterDrawablesCommandArchive::master_drawable_provider() const {
  // @@protoc_insertion_point(field_get:TP.RemoveMasterDrawablesCommandArchive.master_drawable_provider)
  return _internal_master_drawable_provider();
}
inline void RemoveMasterDrawablesCommandArchive::unsafe_arena_set_allocated_master_drawable_provider(
    ::TSP::Reference* master_drawable_provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  if (master_drawable_provider) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveMasterDrawablesCommandArchive.master_drawable_provider)
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::release_master_drawable_provider() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::unsafe_arena_release_master_drawable_provider() {
  // @@protoc_insertion_point(field_release:TP.RemoveMasterDrawablesCommandArchive.master_drawable_provider)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.master_drawable_provider_;
  _impl_.master_drawable_provider_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::_internal_mutable_master_drawable_provider() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.master_drawable_provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.master_drawable_provider_ = p;
  }
  return _impl_.master_drawable_provider_;
}
inline ::TSP::Reference* RemoveMasterDrawablesCommandArchive::mutable_master_drawable_provider() {
  ::TSP::Reference* _msg = _internal_mutable_master_drawable_provider();
  // @@protoc_insertion_point(field_mutable:TP.RemoveMasterDrawablesCommandArchive.master_drawable_provider)
  return _msg;
}
inline void RemoveMasterDrawablesCommandArchive::set_allocated_master_drawable_provider(::TSP::Reference* master_drawable_provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.master_drawable_provider_);
  }
  if (master_drawable_provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_drawable_provider));
    if (message_arena != submessage_arena) {
      master_drawable_provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master_drawable_provider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.master_drawable_provider_ = master_drawable_provider;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveMasterDrawablesCommandArchive.master_drawable_provider)
}

// -------------------------------------------------------------------

// PasteMasterDrawablesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PasteMasterDrawablesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PasteMasterDrawablesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& PasteMasterDrawablesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& PasteMasterDrawablesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.PasteMasterDrawablesCommandArchive.super)
  return _internal_super();
}
inline void PasteMasterDrawablesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteMasterDrawablesCommandArchive.super)
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.PasteMasterDrawablesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* PasteMasterDrawablesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.PasteMasterDrawablesCommandArchive.super)
  return _msg;
}
inline void PasteMasterDrawablesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteMasterDrawablesCommandArchive.super)
}

// optional .TSP.Reference section = 2;
inline bool PasteMasterDrawablesCommandArchive::_internal_has_section() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.section_ != nullptr);
  return value;
}
inline bool PasteMasterDrawablesCommandArchive::has_section() const {
  return _internal_has_section();
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::_internal_section() const {
  const ::TSP::Reference* p = _impl_.section_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::section() const {
  // @@protoc_insertion_point(field_get:TP.PasteMasterDrawablesCommandArchive.section)
  return _internal_section();
}
inline void PasteMasterDrawablesCommandArchive::unsafe_arena_set_allocated_section(
    ::TSP::Reference* section) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_);
  }
  _impl_.section_ = section;
  if (section) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PasteMasterDrawablesCommandArchive.section)
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::release_section() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.section_;
  _impl_.section_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::unsafe_arena_release_section() {
  // @@protoc_insertion_point(field_release:TP.PasteMasterDrawablesCommandArchive.section)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.section_;
  _impl_.section_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::_internal_mutable_section() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.section_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.section_ = p;
  }
  return _impl_.section_;
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::mutable_section() {
  ::TSP::Reference* _msg = _internal_mutable_section();
  // @@protoc_insertion_point(field_mutable:TP.PasteMasterDrawablesCommandArchive.section)
  return _msg;
}
inline void PasteMasterDrawablesCommandArchive::set_allocated_section(::TSP::Reference* section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.section_);
  }
  if (section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(section));
    if (message_arena != submessage_arena) {
      section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, section, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.section_ = section;
  // @@protoc_insertion_point(field_set_allocated:TP.PasteMasterDrawablesCommandArchive.section)
}

// repeated .TSP.Reference master_drawables = 3;
inline int PasteMasterDrawablesCommandArchive::_internal_master_drawables_size() const {
  return _impl_.master_drawables_.size();
}
inline int PasteMasterDrawablesCommandArchive::master_drawables_size() const {
  return _internal_master_drawables_size();
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::mutable_master_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TP.PasteMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
PasteMasterDrawablesCommandArchive::mutable_master_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TP.PasteMasterDrawablesCommandArchive.master_drawables)
  return &_impl_.master_drawables_;
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::_internal_master_drawables(int index) const {
  return _impl_.master_drawables_.Get(index);
}
inline const ::TSP::Reference& PasteMasterDrawablesCommandArchive::master_drawables(int index) const {
  // @@protoc_insertion_point(field_get:TP.PasteMasterDrawablesCommandArchive.master_drawables)
  return _internal_master_drawables(index);
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::_internal_add_master_drawables() {
  return _impl_.master_drawables_.Add();
}
inline ::TSP::Reference* PasteMasterDrawablesCommandArchive::add_master_drawables() {
  ::TSP::Reference* _add = _internal_add_master_drawables();
  // @@protoc_insertion_point(field_add:TP.PasteMasterDrawablesCommandArchive.master_drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
PasteMasterDrawablesCommandArchive::master_drawables() const {
  // @@protoc_insertion_point(field_list:TP.PasteMasterDrawablesCommandArchive.master_drawables)
  return _impl_.master_drawables_;
}

// optional uint32 drawable_index = 4;
inline bool PasteMasterDrawablesCommandArchive::_internal_has_drawable_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PasteMasterDrawablesCommandArchive::has_drawable_index() const {
  return _internal_has_drawable_index();
}
inline void PasteMasterDrawablesCommandArchive::clear_drawable_index() {
  _impl_.drawable_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t PasteMasterDrawablesCommandArchive::_internal_drawable_index() const {
  return _impl_.drawable_index_;
}
inline uint32_t PasteMasterDrawablesCommandArchive::drawable_index() const {
  // @@protoc_insertion_point(field_get:TP.PasteMasterDrawablesCommandArchive.drawable_index)
  return _internal_drawable_index();
}
inline void PasteMasterDrawablesCommandArchive::_internal_set_drawable_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.drawable_index_ = value;
}
inline void PasteMasterDrawablesCommandArchive::set_drawable_index(uint32_t value) {
  _internal_set_drawable_index(value);
  // @@protoc_insertion_point(field_set:TP.PasteMasterDrawablesCommandArchive.drawable_index)
}

// -------------------------------------------------------------------

// MoveDrawablesAttachedCommandArchive_FloatingUndo

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::drawable() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.drawable)
  return _internal_drawable();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.drawable)
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.drawable)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.drawable)
  return _msg;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.drawable)
}

// optional .TSD.GeometryArchive geometry = 2;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_geometry() const {
  return _internal_has_geometry();
}
inline const ::TSD::GeometryArchive& MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& MoveDrawablesAttachedCommandArchive_FloatingUndo::geometry() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.geometry)
  return _internal_geometry();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.geometry)
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_geometry() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.geometry)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_mutable_geometry() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_geometry() {
  ::TSD::GeometryArchive* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.geometry)
  return _msg;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry));
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.geometry)
}

// optional .TSP.Reference attachment = 3;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_attachment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attachment_ != nullptr);
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_attachment() const {
  return _internal_has_attachment();
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_attachment() const {
  const ::TSP::Reference* p = _impl_.attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesAttachedCommandArchive_FloatingUndo::attachment() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.attachment)
  return _internal_attachment();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_set_allocated_attachment(
    ::TSP::Reference* attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  _impl_.attachment_ = attachment;
  if (attachment) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.attachment)
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::release_attachment() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::unsafe_arena_release_attachment() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.attachment)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_mutable_attachment() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.attachment_ = p;
  }
  return _impl_.attachment_;
}
inline ::TSP::Reference* MoveDrawablesAttachedCommandArchive_FloatingUndo::mutable_attachment() {
  ::TSP::Reference* _msg = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.attachment)
  return _msg;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_allocated_attachment(::TSP::Reference* attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  if (attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attachment));
    if (message_arena != submessage_arena) {
      attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attachment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attachment_ = attachment;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.attachment)
}

// optional uint32 wrap_type = 4;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_wrap_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_wrap_type() const {
  return _internal_has_wrap_type();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_wrap_type() {
  _impl_.wrap_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_wrap_type() const {
  return _impl_.wrap_type_;
}
inline uint32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::wrap_type() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.wrap_type)
  return _internal_wrap_type();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_set_wrap_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.wrap_type_ = value;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_wrap_type(uint32_t value) {
  _internal_set_wrap_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.wrap_type)
}

// optional uint32 page_index = 5;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_page_index() const {
  return _internal_has_page_index();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::page_index() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.page_index)
  return _internal_page_index();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.page_index_ = value;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.page_index)
}

// optional int32 z_order = 6;
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive_FloatingUndo::has_z_order() const {
  return _internal_has_z_order();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::clear_z_order() {
  _impl_.z_order_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_z_order() const {
  return _impl_.z_order_;
}
inline int32_t MoveDrawablesAttachedCommandArchive_FloatingUndo::z_order() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.z_order)
  return _internal_z_order();
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::_internal_set_z_order(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.z_order_ = value;
}
inline void MoveDrawablesAttachedCommandArchive_FloatingUndo::set_z_order(int32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesAttachedCommandArchive.FloatingUndo.z_order)
}

// -------------------------------------------------------------------

// MoveDrawablesAttachedCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesAttachedCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesAttachedCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveDrawablesAttachedCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.super)
  return _internal_super();
}
inline void MoveDrawablesAttachedCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesAttachedCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesAttachedCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveDrawablesAttachedCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.super)
  return _msg;
}
inline void MoveDrawablesAttachedCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesAttachedCommandArchive.super)
}

// optional .TSWP.UndoTransaction undo_transaction = 2;
inline bool MoveDrawablesAttachedCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesAttachedCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MoveDrawablesAttachedCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void MoveDrawablesAttachedCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesAttachedCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesAttachedCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesAttachedCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.undo_transaction)
  return _msg;
}
inline void MoveDrawablesAttachedCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesAttachedCommandArchive.undo_transaction)
}

// repeated .TP.MoveDrawablesAttachedCommandArchive.FloatingUndo floating_undo = 3;
inline int MoveDrawablesAttachedCommandArchive::_internal_floating_undo_size() const {
  return _impl_.floating_undo_.size();
}
inline int MoveDrawablesAttachedCommandArchive::floating_undo_size() const {
  return _internal_floating_undo_size();
}
inline void MoveDrawablesAttachedCommandArchive::clear_floating_undo() {
  _impl_.floating_undo_.Clear();
}
inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* MoveDrawablesAttachedCommandArchive::mutable_floating_undo(int index) {
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesAttachedCommandArchive.floating_undo)
  return _impl_.floating_undo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >*
MoveDrawablesAttachedCommandArchive::mutable_floating_undo() {
  // @@protoc_insertion_point(field_mutable_list:TP.MoveDrawablesAttachedCommandArchive.floating_undo)
  return &_impl_.floating_undo_;
}
inline const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& MoveDrawablesAttachedCommandArchive::_internal_floating_undo(int index) const {
  return _impl_.floating_undo_.Get(index);
}
inline const ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo& MoveDrawablesAttachedCommandArchive::floating_undo(int index) const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.floating_undo)
  return _internal_floating_undo(index);
}
inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* MoveDrawablesAttachedCommandArchive::_internal_add_floating_undo() {
  return _impl_.floating_undo_.Add();
}
inline ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* MoveDrawablesAttachedCommandArchive::add_floating_undo() {
  ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo* _add = _internal_add_floating_undo();
  // @@protoc_insertion_point(field_add:TP.MoveDrawablesAttachedCommandArchive.floating_undo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesAttachedCommandArchive_FloatingUndo >&
MoveDrawablesAttachedCommandArchive::floating_undo() const {
  // @@protoc_insertion_point(field_list:TP.MoveDrawablesAttachedCommandArchive.floating_undo)
  return _impl_.floating_undo_;
}

// optional bool select = 4;
inline bool MoveDrawablesAttachedCommandArchive::_internal_has_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive::has_select() const {
  return _internal_has_select();
}
inline void MoveDrawablesAttachedCommandArchive::clear_select() {
  _impl_.select_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MoveDrawablesAttachedCommandArchive::_internal_select() const {
  return _impl_.select_;
}
inline bool MoveDrawablesAttachedCommandArchive::select() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.select)
  return _internal_select();
}
inline void MoveDrawablesAttachedCommandArchive::_internal_set_select(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.select_ = value;
}
inline void MoveDrawablesAttachedCommandArchive::set_select(bool value) {
  _internal_set_select(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesAttachedCommandArchive.select)
}

// optional bool make_inline = 5;
inline bool MoveDrawablesAttachedCommandArchive::_internal_has_make_inline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveDrawablesAttachedCommandArchive::has_make_inline() const {
  return _internal_has_make_inline();
}
inline void MoveDrawablesAttachedCommandArchive::clear_make_inline() {
  _impl_.make_inline_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool MoveDrawablesAttachedCommandArchive::_internal_make_inline() const {
  return _impl_.make_inline_;
}
inline bool MoveDrawablesAttachedCommandArchive::make_inline() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesAttachedCommandArchive.make_inline)
  return _internal_make_inline();
}
inline void MoveDrawablesAttachedCommandArchive::_internal_set_make_inline(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.make_inline_ = value;
}
inline void MoveDrawablesAttachedCommandArchive::set_make_inline(bool value) {
  _internal_set_make_inline(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesAttachedCommandArchive.make_inline)
}

// -------------------------------------------------------------------

// MoveDrawablesFloatingCommandArchive_AttachedUndo

// optional .TSP.Reference drawable = 1;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::drawable() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.drawable)
  return _internal_drawable();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.drawable)
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.drawable)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.drawable)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.drawable)
}

// optional .TSD.GeometryArchive geometry = 2;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_geometry() const {
  return _internal_has_geometry();
}
inline const ::TSD::GeometryArchive& MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& MoveDrawablesFloatingCommandArchive_AttachedUndo::geometry() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.geometry)
  return _internal_geometry();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.geometry)
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_geometry() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.geometry)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_mutable_geometry() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::TSD::GeometryArchive* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_geometry() {
  ::TSD::GeometryArchive* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.geometry)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry));
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.geometry)
}

// optional .TSP.Reference attachment = 3;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_attachment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attachment_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_attachment() const {
  return _internal_has_attachment();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_attachment() const {
  const ::TSP::Reference* p = _impl_.attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::attachment() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.attachment)
  return _internal_attachment();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_set_allocated_attachment(
    ::TSP::Reference* attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  _impl_.attachment_ = attachment;
  if (attachment) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.attachment)
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_attachment() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_release_attachment() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.attachment)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.attachment_;
  _impl_.attachment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_mutable_attachment() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.attachment_ = p;
  }
  return _impl_.attachment_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_attachment() {
  ::TSP::Reference* _msg = _internal_mutable_attachment();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.attachment)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_attachment(::TSP::Reference* attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attachment_);
  }
  if (attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attachment));
    if (message_arena != submessage_arena) {
      attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attachment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attachment_ = attachment;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.attachment)
}

// optional uint32 page_index = 4;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_page_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_page_index() const {
  return _internal_has_page_index();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_page_index() {
  _impl_.page_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_page_index() const {
  return _impl_.page_index_;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::page_index() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.page_index)
  return _internal_page_index();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_page_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.page_index_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_page_index(uint32_t value) {
  _internal_set_page_index(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.page_index)
}

// optional bool is_html_wrap = 5;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_is_html_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_is_html_wrap() {
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_is_html_wrap() const {
  return _impl_.is_html_wrap_;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_is_html_wrap(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_html_wrap_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.is_html_wrap)
}

// optional uint32 type = 6;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_type() const {
  return _internal_has_type();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::type() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.type)
  return _internal_type();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.type_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.type)
}

// optional uint32 direction = 7;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_direction() const {
  return _internal_has_direction();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_direction() {
  _impl_.direction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_direction() const {
  return _impl_.direction_;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::direction() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.direction)
  return _internal_direction();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_direction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.direction_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_direction(uint32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.direction)
}

// optional uint32 fit_type = 8;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_fit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_fit_type() const {
  return _internal_has_fit_type();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_fit_type() {
  _impl_.fit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_fit_type() const {
  return _impl_.fit_type_;
}
inline uint32_t MoveDrawablesFloatingCommandArchive_AttachedUndo::fit_type() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.fit_type)
  return _internal_fit_type();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_fit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.fit_type_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_fit_type(uint32_t value) {
  _internal_set_fit_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.fit_type)
}

// optional float margin = 9;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_margin() const {
  return _internal_has_margin();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_margin() {
  _impl_.margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_margin() const {
  return _impl_.margin_;
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::margin() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.margin)
  return _internal_margin();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_margin(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.margin_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_margin(float value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.margin)
}

// optional float alpha_threshold = 10;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_alpha_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_alpha_threshold() const {
  return _internal_has_alpha_threshold();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::clear_alpha_threshold() {
  _impl_.alpha_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_alpha_threshold() const {
  return _impl_.alpha_threshold_;
}
inline float MoveDrawablesFloatingCommandArchive_AttachedUndo::alpha_threshold() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.alpha_threshold)
  return _internal_alpha_threshold();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_set_alpha_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.alpha_threshold_ = value;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_alpha_threshold(float value) {
  _internal_set_alpha_threshold(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.alpha_threshold)
}

// optional .TSP.Reference storage = 11;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveDrawablesFloatingCommandArchive_AttachedUndo::storage() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.storage)
  return _internal_storage();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.storage)
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.storage)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.storage)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.storage)
}

// optional .TSWP.UndoTransaction undo_transaction = 12;
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive_AttachedUndo::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive_AttachedUndo::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.undo_transaction)
  return _internal_undo_transaction();
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.undo_transaction)
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive_AttachedUndo::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.undo_transaction)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive_AttachedUndo::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.AttachedUndo.undo_transaction)
}

// -------------------------------------------------------------------

// MoveDrawablesFloatingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveDrawablesFloatingCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveDrawablesFloatingCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveDrawablesFloatingCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.super)
  return _internal_super();
}
inline void MoveDrawablesFloatingCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveDrawablesFloatingCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.super)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.super)
}

// optional .TSWP.UndoTransaction deprecated_undo_transaction = 2;
inline bool MoveDrawablesFloatingCommandArchive::_internal_has_deprecated_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deprecated_undo_transaction_ != nullptr);
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive::has_deprecated_undo_transaction() const {
  return _internal_has_deprecated_undo_transaction();
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive::_internal_deprecated_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.deprecated_undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& MoveDrawablesFloatingCommandArchive::deprecated_undo_transaction() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.deprecated_undo_transaction)
  return _internal_deprecated_undo_transaction();
}
inline void MoveDrawablesFloatingCommandArchive::unsafe_arena_set_allocated_deprecated_undo_transaction(
    ::TSWP::UndoTransaction* deprecated_undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_undo_transaction_);
  }
  _impl_.deprecated_undo_transaction_ = deprecated_undo_transaction;
  if (deprecated_undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveDrawablesFloatingCommandArchive.deprecated_undo_transaction)
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::release_deprecated_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.deprecated_undo_transaction_;
  _impl_.deprecated_undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::unsafe_arena_release_deprecated_undo_transaction() {
  // @@protoc_insertion_point(field_release:TP.MoveDrawablesFloatingCommandArchive.deprecated_undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.deprecated_undo_transaction_;
  _impl_.deprecated_undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::_internal_mutable_deprecated_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.deprecated_undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.deprecated_undo_transaction_ = p;
  }
  return _impl_.deprecated_undo_transaction_;
}
inline ::TSWP::UndoTransaction* MoveDrawablesFloatingCommandArchive::mutable_deprecated_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_deprecated_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.deprecated_undo_transaction)
  return _msg;
}
inline void MoveDrawablesFloatingCommandArchive::set_allocated_deprecated_undo_transaction(::TSWP::UndoTransaction* deprecated_undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_undo_transaction_);
  }
  if (deprecated_undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deprecated_undo_transaction));
    if (message_arena != submessage_arena) {
      deprecated_undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deprecated_undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deprecated_undo_transaction_ = deprecated_undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveDrawablesFloatingCommandArchive.deprecated_undo_transaction)
}

// repeated .TP.MoveDrawablesFloatingCommandArchive.AttachedUndo attached_undo = 3;
inline int MoveDrawablesFloatingCommandArchive::_internal_attached_undo_size() const {
  return _impl_.attached_undo_.size();
}
inline int MoveDrawablesFloatingCommandArchive::attached_undo_size() const {
  return _internal_attached_undo_size();
}
inline void MoveDrawablesFloatingCommandArchive::clear_attached_undo() {
  _impl_.attached_undo_.Clear();
}
inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* MoveDrawablesFloatingCommandArchive::mutable_attached_undo(int index) {
  // @@protoc_insertion_point(field_mutable:TP.MoveDrawablesFloatingCommandArchive.attached_undo)
  return _impl_.attached_undo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >*
MoveDrawablesFloatingCommandArchive::mutable_attached_undo() {
  // @@protoc_insertion_point(field_mutable_list:TP.MoveDrawablesFloatingCommandArchive.attached_undo)
  return &_impl_.attached_undo_;
}
inline const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& MoveDrawablesFloatingCommandArchive::_internal_attached_undo(int index) const {
  return _impl_.attached_undo_.Get(index);
}
inline const ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo& MoveDrawablesFloatingCommandArchive::attached_undo(int index) const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.attached_undo)
  return _internal_attached_undo(index);
}
inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* MoveDrawablesFloatingCommandArchive::_internal_add_attached_undo() {
  return _impl_.attached_undo_.Add();
}
inline ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* MoveDrawablesFloatingCommandArchive::add_attached_undo() {
  ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo* _add = _internal_add_attached_undo();
  // @@protoc_insertion_point(field_add:TP.MoveDrawablesFloatingCommandArchive.attached_undo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TP::MoveDrawablesFloatingCommandArchive_AttachedUndo >&
MoveDrawablesFloatingCommandArchive::attached_undo() const {
  // @@protoc_insertion_point(field_list:TP.MoveDrawablesFloatingCommandArchive.attached_undo)
  return _impl_.attached_undo_;
}

// optional bool select = 4;
inline bool MoveDrawablesFloatingCommandArchive::_internal_has_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoveDrawablesFloatingCommandArchive::has_select() const {
  return _internal_has_select();
}
inline void MoveDrawablesFloatingCommandArchive::clear_select() {
  _impl_.select_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MoveDrawablesFloatingCommandArchive::_internal_select() const {
  return _impl_.select_;
}
inline bool MoveDrawablesFloatingCommandArchive::select() const {
  // @@protoc_insertion_point(field_get:TP.MoveDrawablesFloatingCommandArchive.select)
  return _internal_select();
}
inline void MoveDrawablesFloatingCommandArchive::_internal_set_select(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.select_ = value;
}
inline void MoveDrawablesFloatingCommandArchive::set_select(bool value) {
  _internal_set_select(value);
  // @@protoc_insertion_point(field_set:TP.MoveDrawablesFloatingCommandArchive.select)
}

// -------------------------------------------------------------------

// RemoveAnchoredDrawableCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool RemoveAnchoredDrawableCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool RemoveAnchoredDrawableCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::TextCommandArchive& RemoveAnchoredDrawableCommandArchive::_internal_super() const {
  const ::TSWP::TextCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::TextCommandArchive&>(
      ::TSWP::_TextCommandArchive_default_instance_);
}
inline const ::TSWP::TextCommandArchive& RemoveAnchoredDrawableCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.RemoveAnchoredDrawableCommandArchive.super)
  return _internal_super();
}
inline void RemoveAnchoredDrawableCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::TextCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.RemoveAnchoredDrawableCommandArchive.super)
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.RemoveAnchoredDrawableCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::TextCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::TextCommandArchive* RemoveAnchoredDrawableCommandArchive::mutable_super() {
  ::TSWP::TextCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.RemoveAnchoredDrawableCommandArchive.super)
  return _msg;
}
inline void RemoveAnchoredDrawableCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.RemoveAnchoredDrawableCommandArchive.super)
}

// optional uint32 char_index = 2;
inline bool RemoveAnchoredDrawableCommandArchive::_internal_has_char_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveAnchoredDrawableCommandArchive::has_char_index() const {
  return _internal_has_char_index();
}
inline void RemoveAnchoredDrawableCommandArchive::clear_char_index() {
  _impl_.char_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RemoveAnchoredDrawableCommandArchive::_internal_char_index() const {
  return _impl_.char_index_;
}
inline uint32_t RemoveAnchoredDrawableCommandArchive::char_index() const {
  // @@protoc_insertion_point(field_get:TP.RemoveAnchoredDrawableCommandArchive.char_index)
  return _internal_char_index();
}
inline void RemoveAnchoredDrawableCommandArchive::_internal_set_char_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.char_index_ = value;
}
inline void RemoveAnchoredDrawableCommandArchive::set_char_index(uint32_t value) {
  _internal_set_char_index(value);
  // @@protoc_insertion_point(field_set:TP.RemoveAnchoredDrawableCommandArchive.char_index)
}

// optional uint32 z_order = 3;
inline bool RemoveAnchoredDrawableCommandArchive::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveAnchoredDrawableCommandArchive::has_z_order() const {
  return _internal_has_z_order();
}
inline void RemoveAnchoredDrawableCommandArchive::clear_z_order() {
  _impl_.z_order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RemoveAnchoredDrawableCommandArchive::_internal_z_order() const {
  return _impl_.z_order_;
}
inline uint32_t RemoveAnchoredDrawableCommandArchive::z_order() const {
  // @@protoc_insertion_point(field_get:TP.RemoveAnchoredDrawableCommandArchive.z_order)
  return _internal_z_order();
}
inline void RemoveAnchoredDrawableCommandArchive::_internal_set_z_order(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_order_ = value;
}
inline void RemoveAnchoredDrawableCommandArchive::set_z_order(uint32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.RemoveAnchoredDrawableCommandArchive.z_order)
}

// -------------------------------------------------------------------

// ChangeFootnoteFormatCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteFormatCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeFootnoteFormatCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteFormatCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeFootnoteFormatCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteFormatCommandArchive.super)
  return _internal_super();
}
inline void ChangeFootnoteFormatCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeFootnoteFormatCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeFootnoteFormatCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteFormatCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeFootnoteFormatCommandArchive.super)
  return _msg;
}
inline void ChangeFootnoteFormatCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeFootnoteFormatCommandArchive.super)
}

// optional .TP.ChangeFootnoteFormatCommandArchive.FootnoteFormat format = 2;
inline bool ChangeFootnoteFormatCommandArchive::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeFootnoteFormatCommandArchive::has_format() const {
  return _internal_has_format();
}
inline void ChangeFootnoteFormatCommandArchive::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::_internal_format() const {
  return static_cast< ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat >(_impl_.format_);
}
inline ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat ChangeFootnoteFormatCommandArchive::format() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteFormatCommandArchive.format)
  return _internal_format();
}
inline void ChangeFootnoteFormatCommandArchive::_internal_set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value) {
  assert(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.format_ = value;
}
inline void ChangeFootnoteFormatCommandArchive::set_format(::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:TP.ChangeFootnoteFormatCommandArchive.format)
}

// -------------------------------------------------------------------

// ChangeFootnoteKindCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteKindCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeFootnoteKindCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteKindCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeFootnoteKindCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteKindCommandArchive.super)
  return _internal_super();
}
inline void ChangeFootnoteKindCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeFootnoteKindCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeFootnoteKindCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteKindCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeFootnoteKindCommandArchive.super)
  return _msg;
}
inline void ChangeFootnoteKindCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeFootnoteKindCommandArchive.super)
}

// optional .TP.ChangeFootnoteKindCommandArchive.FootnoteKind kind = 2;
inline bool ChangeFootnoteKindCommandArchive::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeFootnoteKindCommandArchive::has_kind() const {
  return _internal_has_kind();
}
inline void ChangeFootnoteKindCommandArchive::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::_internal_kind() const {
  return static_cast< ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind >(_impl_.kind_);
}
inline ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind ChangeFootnoteKindCommandArchive::kind() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteKindCommandArchive.kind)
  return _internal_kind();
}
inline void ChangeFootnoteKindCommandArchive::_internal_set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value) {
  assert(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.kind_ = value;
}
inline void ChangeFootnoteKindCommandArchive::set_kind(::TP::ChangeFootnoteKindCommandArchive_FootnoteKind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:TP.ChangeFootnoteKindCommandArchive.kind)
}

// optional .TSWP.UndoTransaction undo_transaction = 3;
inline bool ChangeFootnoteKindCommandArchive::_internal_has_undo_transaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_transaction_ != nullptr);
  return value;
}
inline bool ChangeFootnoteKindCommandArchive::has_undo_transaction() const {
  return _internal_has_undo_transaction();
}
inline const ::TSWP::UndoTransaction& ChangeFootnoteKindCommandArchive::_internal_undo_transaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.undo_transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& ChangeFootnoteKindCommandArchive::undo_transaction() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteKindCommandArchive.undo_transaction)
  return _internal_undo_transaction();
}
inline void ChangeFootnoteKindCommandArchive::unsafe_arena_set_allocated_undo_transaction(
    ::TSWP::UndoTransaction* undo_transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  _impl_.undo_transaction_ = undo_transaction;
  if (undo_transaction) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeFootnoteKindCommandArchive.undo_transaction)
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::release_undo_transaction() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::unsafe_arena_release_undo_transaction() {
  // @@protoc_insertion_point(field_release:TP.ChangeFootnoteKindCommandArchive.undo_transaction)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSWP::UndoTransaction* temp = _impl_.undo_transaction_;
  _impl_.undo_transaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::_internal_mutable_undo_transaction() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.undo_transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.undo_transaction_ = p;
  }
  return _impl_.undo_transaction_;
}
inline ::TSWP::UndoTransaction* ChangeFootnoteKindCommandArchive::mutable_undo_transaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_undo_transaction();
  // @@protoc_insertion_point(field_mutable:TP.ChangeFootnoteKindCommandArchive.undo_transaction)
  return _msg;
}
inline void ChangeFootnoteKindCommandArchive::set_allocated_undo_transaction(::TSWP::UndoTransaction* undo_transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_transaction_);
  }
  if (undo_transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_transaction));
    if (message_arena != submessage_arena) {
      undo_transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_transaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.undo_transaction_ = undo_transaction;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeFootnoteKindCommandArchive.undo_transaction)
}

// -------------------------------------------------------------------

// ChangeFootnoteNumberingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteNumberingCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeFootnoteNumberingCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteNumberingCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeFootnoteNumberingCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteNumberingCommandArchive.super)
  return _internal_super();
}
inline void ChangeFootnoteNumberingCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeFootnoteNumberingCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeFootnoteNumberingCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteNumberingCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeFootnoteNumberingCommandArchive.super)
  return _msg;
}
inline void ChangeFootnoteNumberingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeFootnoteNumberingCommandArchive.super)
}

// optional .TP.ChangeFootnoteNumberingCommandArchive.FootnoteNumbering numbering = 2;
inline bool ChangeFootnoteNumberingCommandArchive::_internal_has_numbering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeFootnoteNumberingCommandArchive::has_numbering() const {
  return _internal_has_numbering();
}
inline void ChangeFootnoteNumberingCommandArchive::clear_numbering() {
  _impl_.numbering_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::_internal_numbering() const {
  return static_cast< ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering >(_impl_.numbering_);
}
inline ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering ChangeFootnoteNumberingCommandArchive::numbering() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteNumberingCommandArchive.numbering)
  return _internal_numbering();
}
inline void ChangeFootnoteNumberingCommandArchive::_internal_set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value) {
  assert(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.numbering_ = value;
}
inline void ChangeFootnoteNumberingCommandArchive::set_numbering(::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering value) {
  _internal_set_numbering(value);
  // @@protoc_insertion_point(field_set:TP.ChangeFootnoteNumberingCommandArchive.numbering)
}

// -------------------------------------------------------------------

// ChangeFootnoteSpacingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeFootnoteSpacingCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeFootnoteSpacingCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeFootnoteSpacingCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeFootnoteSpacingCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteSpacingCommandArchive.super)
  return _internal_super();
}
inline void ChangeFootnoteSpacingCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeFootnoteSpacingCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeFootnoteSpacingCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeFootnoteSpacingCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeFootnoteSpacingCommandArchive.super)
  return _msg;
}
inline void ChangeFootnoteSpacingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeFootnoteSpacingCommandArchive.super)
}

// optional int32 footnote_spacing = 2;
inline bool ChangeFootnoteSpacingCommandArchive::_internal_has_footnote_spacing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeFootnoteSpacingCommandArchive::has_footnote_spacing() const {
  return _internal_has_footnote_spacing();
}
inline void ChangeFootnoteSpacingCommandArchive::clear_footnote_spacing() {
  _impl_.footnote_spacing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ChangeFootnoteSpacingCommandArchive::_internal_footnote_spacing() const {
  return _impl_.footnote_spacing_;
}
inline int32_t ChangeFootnoteSpacingCommandArchive::footnote_spacing() const {
  // @@protoc_insertion_point(field_get:TP.ChangeFootnoteSpacingCommandArchive.footnote_spacing)
  return _internal_footnote_spacing();
}
inline void ChangeFootnoteSpacingCommandArchive::_internal_set_footnote_spacing(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.footnote_spacing_ = value;
}
inline void ChangeFootnoteSpacingCommandArchive::set_footnote_spacing(int32_t value) {
  _internal_set_footnote_spacing(value);
  // @@protoc_insertion_point(field_set:TP.ChangeFootnoteSpacingCommandArchive.footnote_spacing)
}

// -------------------------------------------------------------------

// MoveInlineDrawableAnchoredCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveInlineDrawableAnchoredCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveInlineDrawableAnchoredCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.super)
  return _internal_super();
}
inline void MoveInlineDrawableAnchoredCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveInlineDrawableAnchoredCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveInlineDrawableAnchoredCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveInlineDrawableAnchoredCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveInlineDrawableAnchoredCommandArchive.super)
  return _msg;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveInlineDrawableAnchoredCommandArchive.super)
}

// optional .TSP.Reference drawable = 2;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& MoveInlineDrawableAnchoredCommandArchive::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveInlineDrawableAnchoredCommandArchive::drawable() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.drawable)
  return _internal_drawable();
}
inline void MoveInlineDrawableAnchoredCommandArchive::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveInlineDrawableAnchoredCommandArchive.drawable)
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.MoveInlineDrawableAnchoredCommandArchive.drawable)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* MoveInlineDrawableAnchoredCommandArchive::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.MoveInlineDrawableAnchoredCommandArchive.drawable)
  return _msg;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveInlineDrawableAnchoredCommandArchive.drawable)
}

// optional bool is_html_wrap = 3;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_is_html_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_is_html_wrap() {
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_is_html_wrap() const {
  return _impl_.is_html_wrap_;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_is_html_wrap(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_html_wrap_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.is_html_wrap)
}

// optional uint32 type = 4;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_type() const {
  return _internal_has_type();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::type() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.type)
  return _internal_type();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.type)
}

// optional uint32 direction = 5;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_direction() const {
  return _internal_has_direction();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_direction() {
  _impl_.direction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::_internal_direction() const {
  return _impl_.direction_;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::direction() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.direction)
  return _internal_direction();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_direction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.direction_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_direction(uint32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.direction)
}

// optional uint32 fit_type = 6;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_fit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_fit_type() const {
  return _internal_has_fit_type();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_fit_type() {
  _impl_.fit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::_internal_fit_type() const {
  return _impl_.fit_type_;
}
inline uint32_t MoveInlineDrawableAnchoredCommandArchive::fit_type() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.fit_type)
  return _internal_fit_type();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_fit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fit_type_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_fit_type(uint32_t value) {
  _internal_set_fit_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.fit_type)
}

// optional float margin = 7;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_margin() const {
  return _internal_has_margin();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_margin() {
  _impl_.margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float MoveInlineDrawableAnchoredCommandArchive::_internal_margin() const {
  return _impl_.margin_;
}
inline float MoveInlineDrawableAnchoredCommandArchive::margin() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.margin)
  return _internal_margin();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_margin(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.margin_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_margin(float value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.margin)
}

// optional float alpha_threshold = 8;
inline bool MoveInlineDrawableAnchoredCommandArchive::_internal_has_alpha_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoveInlineDrawableAnchoredCommandArchive::has_alpha_threshold() const {
  return _internal_has_alpha_threshold();
}
inline void MoveInlineDrawableAnchoredCommandArchive::clear_alpha_threshold() {
  _impl_.alpha_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MoveInlineDrawableAnchoredCommandArchive::_internal_alpha_threshold() const {
  return _impl_.alpha_threshold_;
}
inline float MoveInlineDrawableAnchoredCommandArchive::alpha_threshold() const {
  // @@protoc_insertion_point(field_get:TP.MoveInlineDrawableAnchoredCommandArchive.alpha_threshold)
  return _internal_alpha_threshold();
}
inline void MoveInlineDrawableAnchoredCommandArchive::_internal_set_alpha_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.alpha_threshold_ = value;
}
inline void MoveInlineDrawableAnchoredCommandArchive::set_alpha_threshold(float value) {
  _internal_set_alpha_threshold(value);
  // @@protoc_insertion_point(field_set:TP.MoveInlineDrawableAnchoredCommandArchive.alpha_threshold)
}

// -------------------------------------------------------------------

// MoveAnchoredDrawableInlineCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& MoveAnchoredDrawableInlineCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& MoveAnchoredDrawableInlineCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.super)
  return _internal_super();
}
inline void MoveAnchoredDrawableInlineCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveAnchoredDrawableInlineCommandArchive.super)
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.MoveAnchoredDrawableInlineCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* MoveAnchoredDrawableInlineCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.MoveAnchoredDrawableInlineCommandArchive.super)
  return _msg;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveAnchoredDrawableInlineCommandArchive.super)
}

// optional .TSP.Reference drawable = 2;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_drawable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.drawable_ != nullptr);
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_drawable() const {
  return _internal_has_drawable();
}
inline const ::TSP::Reference& MoveAnchoredDrawableInlineCommandArchive::_internal_drawable() const {
  const ::TSP::Reference* p = _impl_.drawable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MoveAnchoredDrawableInlineCommandArchive::drawable() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.drawable)
  return _internal_drawable();
}
inline void MoveAnchoredDrawableInlineCommandArchive::unsafe_arena_set_allocated_drawable(
    ::TSP::Reference* drawable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  _impl_.drawable_ = drawable;
  if (drawable) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.MoveAnchoredDrawableInlineCommandArchive.drawable)
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::release_drawable() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::unsafe_arena_release_drawable() {
  // @@protoc_insertion_point(field_release:TP.MoveAnchoredDrawableInlineCommandArchive.drawable)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.drawable_;
  _impl_.drawable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::_internal_mutable_drawable() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.drawable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.drawable_ = p;
  }
  return _impl_.drawable_;
}
inline ::TSP::Reference* MoveAnchoredDrawableInlineCommandArchive::mutable_drawable() {
  ::TSP::Reference* _msg = _internal_mutable_drawable();
  // @@protoc_insertion_point(field_mutable:TP.MoveAnchoredDrawableInlineCommandArchive.drawable)
  return _msg;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_allocated_drawable(::TSP::Reference* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.drawable_);
  }
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.drawable_ = drawable;
  // @@protoc_insertion_point(field_set_allocated:TP.MoveAnchoredDrawableInlineCommandArchive.drawable)
}

// optional bool is_html_wrap = 3;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_is_html_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_is_html_wrap() {
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_is_html_wrap() const {
  return _impl_.is_html_wrap_;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_is_html_wrap(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_html_wrap_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.is_html_wrap)
}

// optional uint32 type = 4;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_type() const {
  return _internal_has_type();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::type() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.type)
  return _internal_type();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.type)
}

// optional uint32 direction = 5;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_direction() const {
  return _internal_has_direction();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_direction() {
  _impl_.direction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::_internal_direction() const {
  return _impl_.direction_;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::direction() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.direction)
  return _internal_direction();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_direction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.direction_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_direction(uint32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.direction)
}

// optional uint32 fit_type = 6;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_fit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_fit_type() const {
  return _internal_has_fit_type();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_fit_type() {
  _impl_.fit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::_internal_fit_type() const {
  return _impl_.fit_type_;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::fit_type() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.fit_type)
  return _internal_fit_type();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_fit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fit_type_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_fit_type(uint32_t value) {
  _internal_set_fit_type(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.fit_type)
}

// optional float margin = 7;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_margin() const {
  return _internal_has_margin();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_margin() {
  _impl_.margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float MoveAnchoredDrawableInlineCommandArchive::_internal_margin() const {
  return _impl_.margin_;
}
inline float MoveAnchoredDrawableInlineCommandArchive::margin() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.margin)
  return _internal_margin();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_margin(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.margin_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_margin(float value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.margin)
}

// optional float alpha_threshold = 8;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_alpha_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_alpha_threshold() const {
  return _internal_has_alpha_threshold();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_alpha_threshold() {
  _impl_.alpha_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float MoveAnchoredDrawableInlineCommandArchive::_internal_alpha_threshold() const {
  return _impl_.alpha_threshold_;
}
inline float MoveAnchoredDrawableInlineCommandArchive::alpha_threshold() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.alpha_threshold)
  return _internal_alpha_threshold();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_alpha_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.alpha_threshold_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_alpha_threshold(float value) {
  _internal_set_alpha_threshold(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.alpha_threshold)
}

// optional uint32 z_order = 9;
inline bool MoveAnchoredDrawableInlineCommandArchive::_internal_has_z_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MoveAnchoredDrawableInlineCommandArchive::has_z_order() const {
  return _internal_has_z_order();
}
inline void MoveAnchoredDrawableInlineCommandArchive::clear_z_order() {
  _impl_.z_order_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::_internal_z_order() const {
  return _impl_.z_order_;
}
inline uint32_t MoveAnchoredDrawableInlineCommandArchive::z_order() const {
  // @@protoc_insertion_point(field_get:TP.MoveAnchoredDrawableInlineCommandArchive.z_order)
  return _internal_z_order();
}
inline void MoveAnchoredDrawableInlineCommandArchive::_internal_set_z_order(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.z_order_ = value;
}
inline void MoveAnchoredDrawableInlineCommandArchive::set_z_order(uint32_t value) {
  _internal_set_z_order(value);
  // @@protoc_insertion_point(field_set:TP.MoveAnchoredDrawableInlineCommandArchive.z_order)
}

// -------------------------------------------------------------------

// InsertFootnoteCommandArchive

// required .TSWP.TextCommandArchive super = 1;
inline bool InsertFootnoteCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool InsertFootnoteCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::TextCommandArchive& InsertFootnoteCommandArchive::_internal_super() const {
  const ::TSWP::TextCommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::TextCommandArchive&>(
      ::TSWP::_TextCommandArchive_default_instance_);
}
inline const ::TSWP::TextCommandArchive& InsertFootnoteCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.InsertFootnoteCommandArchive.super)
  return _internal_super();
}
inline void InsertFootnoteCommandArchive::unsafe_arena_set_allocated_super(
    ::TSWP::TextCommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.InsertFootnoteCommandArchive.super)
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.InsertFootnoteCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::TextCommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::TextCommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::TextCommandArchive* InsertFootnoteCommandArchive::mutable_super() {
  ::TSWP::TextCommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.InsertFootnoteCommandArchive.super)
  return _msg;
}
inline void InsertFootnoteCommandArchive::set_allocated_super(::TSWP::TextCommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.InsertFootnoteCommandArchive.super)
}

// -------------------------------------------------------------------

// ToggleBodyLayoutDirectionCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ToggleBodyLayoutDirectionCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ToggleBodyLayoutDirectionCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ToggleBodyLayoutDirectionCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ToggleBodyLayoutDirectionCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ToggleBodyLayoutDirectionCommandArchive.super)
  return _internal_super();
}
inline void ToggleBodyLayoutDirectionCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ToggleBodyLayoutDirectionCommandArchive.super)
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ToggleBodyLayoutDirectionCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ToggleBodyLayoutDirectionCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ToggleBodyLayoutDirectionCommandArchive.super)
  return _msg;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ToggleBodyLayoutDirectionCommandArchive.super)
}

// optional bool new_direction_is_vertical = 2;
inline bool ToggleBodyLayoutDirectionCommandArchive::_internal_has_new_direction_is_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ToggleBodyLayoutDirectionCommandArchive::has_new_direction_is_vertical() const {
  return _internal_has_new_direction_is_vertical();
}
inline void ToggleBodyLayoutDirectionCommandArchive::clear_new_direction_is_vertical() {
  _impl_.new_direction_is_vertical_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ToggleBodyLayoutDirectionCommandArchive::_internal_new_direction_is_vertical() const {
  return _impl_.new_direction_is_vertical_;
}
inline bool ToggleBodyLayoutDirectionCommandArchive::new_direction_is_vertical() const {
  // @@protoc_insertion_point(field_get:TP.ToggleBodyLayoutDirectionCommandArchive.new_direction_is_vertical)
  return _internal_new_direction_is_vertical();
}
inline void ToggleBodyLayoutDirectionCommandArchive::_internal_set_new_direction_is_vertical(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.new_direction_is_vertical_ = value;
}
inline void ToggleBodyLayoutDirectionCommandArchive::set_new_direction_is_vertical(bool value) {
  _internal_set_new_direction_is_vertical(value);
  // @@protoc_insertion_point(field_set:TP.ToggleBodyLayoutDirectionCommandArchive.new_direction_is_vertical)
}

// -------------------------------------------------------------------

// ChangeCTVisibilityCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ChangeCTVisibilityCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChangeCTVisibilityCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ChangeCTVisibilityCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ChangeCTVisibilityCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.ChangeCTVisibilityCommandArchive.super)
  return _internal_super();
}
inline void ChangeCTVisibilityCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.ChangeCTVisibilityCommandArchive.super)
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.ChangeCTVisibilityCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ChangeCTVisibilityCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.ChangeCTVisibilityCommandArchive.super)
  return _msg;
}
inline void ChangeCTVisibilityCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.ChangeCTVisibilityCommandArchive.super)
}

// optional bool markup_visible = 2;
inline bool ChangeCTVisibilityCommandArchive::_internal_has_markup_visible() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeCTVisibilityCommandArchive::has_markup_visible() const {
  return _internal_has_markup_visible();
}
inline void ChangeCTVisibilityCommandArchive::clear_markup_visible() {
  _impl_.markup_visible_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ChangeCTVisibilityCommandArchive::_internal_markup_visible() const {
  return _impl_.markup_visible_;
}
inline bool ChangeCTVisibilityCommandArchive::markup_visible() const {
  // @@protoc_insertion_point(field_get:TP.ChangeCTVisibilityCommandArchive.markup_visible)
  return _internal_markup_visible();
}
inline void ChangeCTVisibilityCommandArchive::_internal_set_markup_visible(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.markup_visible_ = value;
}
inline void ChangeCTVisibilityCommandArchive::set_markup_visible(bool value) {
  _internal_set_markup_visible(value);
  // @@protoc_insertion_point(field_set:TP.ChangeCTVisibilityCommandArchive.markup_visible)
}

// optional bool deletions_visible = 3;
inline bool ChangeCTVisibilityCommandArchive::_internal_has_deletions_visible() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChangeCTVisibilityCommandArchive::has_deletions_visible() const {
  return _internal_has_deletions_visible();
}
inline void ChangeCTVisibilityCommandArchive::clear_deletions_visible() {
  _impl_.deletions_visible_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ChangeCTVisibilityCommandArchive::_internal_deletions_visible() const {
  return _impl_.deletions_visible_;
}
inline bool ChangeCTVisibilityCommandArchive::deletions_visible() const {
  // @@protoc_insertion_point(field_get:TP.ChangeCTVisibilityCommandArchive.deletions_visible)
  return _internal_deletions_visible();
}
inline void ChangeCTVisibilityCommandArchive::_internal_set_deletions_visible(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.deletions_visible_ = value;
}
inline void ChangeCTVisibilityCommandArchive::set_deletions_visible(bool value) {
  _internal_set_deletions_visible(value);
  // @@protoc_insertion_point(field_set:TP.ChangeCTVisibilityCommandArchive.deletions_visible)
}

// optional uint32 selection_range_location = 4;
inline bool ChangeCTVisibilityCommandArchive::_internal_has_selection_range_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChangeCTVisibilityCommandArchive::has_selection_range_location() const {
  return _internal_has_selection_range_location();
}
inline void ChangeCTVisibilityCommandArchive::clear_selection_range_location() {
  _impl_.selection_range_location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ChangeCTVisibilityCommandArchive::_internal_selection_range_location() const {
  return _impl_.selection_range_location_;
}
inline uint32_t ChangeCTVisibilityCommandArchive::selection_range_location() const {
  // @@protoc_insertion_point(field_get:TP.ChangeCTVisibilityCommandArchive.selection_range_location)
  return _internal_selection_range_location();
}
inline void ChangeCTVisibilityCommandArchive::_internal_set_selection_range_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_range_location_ = value;
}
inline void ChangeCTVisibilityCommandArchive::set_selection_range_location(uint32_t value) {
  _internal_set_selection_range_location(value);
  // @@protoc_insertion_point(field_set:TP.ChangeCTVisibilityCommandArchive.selection_range_location)
}

// optional uint32 selection_range_length = 5;
inline bool ChangeCTVisibilityCommandArchive::_internal_has_selection_range_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChangeCTVisibilityCommandArchive::has_selection_range_length() const {
  return _internal_has_selection_range_length();
}
inline void ChangeCTVisibilityCommandArchive::clear_selection_range_length() {
  _impl_.selection_range_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ChangeCTVisibilityCommandArchive::_internal_selection_range_length() const {
  return _impl_.selection_range_length_;
}
inline uint32_t ChangeCTVisibilityCommandArchive::selection_range_length() const {
  // @@protoc_insertion_point(field_get:TP.ChangeCTVisibilityCommandArchive.selection_range_length)
  return _internal_selection_range_length();
}
inline void ChangeCTVisibilityCommandArchive::_internal_set_selection_range_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.selection_range_length_ = value;
}
inline void ChangeCTVisibilityCommandArchive::set_selection_range_length(uint32_t value) {
  _internal_set_selection_range_length(value);
  // @@protoc_insertion_point(field_set:TP.ChangeCTVisibilityCommandArchive.selection_range_length)
}

// -------------------------------------------------------------------

// TrackChangesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool TrackChangesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TrackChangesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& TrackChangesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& TrackChangesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.TrackChangesCommandArchive.super)
  return _internal_super();
}
inline void TrackChangesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.TrackChangesCommandArchive.super)
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.TrackChangesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* TrackChangesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.TrackChangesCommandArchive.super)
  return _msg;
}
inline void TrackChangesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.TrackChangesCommandArchive.super)
}

// optional bool track_changes = 2;
inline bool TrackChangesCommandArchive::_internal_has_track_changes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackChangesCommandArchive::has_track_changes() const {
  return _internal_has_track_changes();
}
inline void TrackChangesCommandArchive::clear_track_changes() {
  _impl_.track_changes_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TrackChangesCommandArchive::_internal_track_changes() const {
  return _impl_.track_changes_;
}
inline bool TrackChangesCommandArchive::track_changes() const {
  // @@protoc_insertion_point(field_get:TP.TrackChangesCommandArchive.track_changes)
  return _internal_track_changes();
}
inline void TrackChangesCommandArchive::_internal_set_track_changes(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.track_changes_ = value;
}
inline void TrackChangesCommandArchive::set_track_changes(bool value) {
  _internal_set_track_changes(value);
  // @@protoc_insertion_point(field_set:TP.TrackChangesCommandArchive.track_changes)
}

// repeated .TSP.Reference change_session_history = 3;
inline int TrackChangesCommandArchive::_internal_change_session_history_size() const {
  return _impl_.change_session_history_.size();
}
inline int TrackChangesCommandArchive::change_session_history_size() const {
  return _internal_change_session_history_size();
}
inline ::TSP::Reference* TrackChangesCommandArchive::mutable_change_session_history(int index) {
  // @@protoc_insertion_point(field_mutable:TP.TrackChangesCommandArchive.change_session_history)
  return _impl_.change_session_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
TrackChangesCommandArchive::mutable_change_session_history() {
  // @@protoc_insertion_point(field_mutable_list:TP.TrackChangesCommandArchive.change_session_history)
  return &_impl_.change_session_history_;
}
inline const ::TSP::Reference& TrackChangesCommandArchive::_internal_change_session_history(int index) const {
  return _impl_.change_session_history_.Get(index);
}
inline const ::TSP::Reference& TrackChangesCommandArchive::change_session_history(int index) const {
  // @@protoc_insertion_point(field_get:TP.TrackChangesCommandArchive.change_session_history)
  return _internal_change_session_history(index);
}
inline ::TSP::Reference* TrackChangesCommandArchive::_internal_add_change_session_history() {
  return _impl_.change_session_history_.Add();
}
inline ::TSP::Reference* TrackChangesCommandArchive::add_change_session_history() {
  ::TSP::Reference* _add = _internal_add_change_session_history();
  // @@protoc_insertion_point(field_add:TP.TrackChangesCommandArchive.change_session_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
TrackChangesCommandArchive::change_session_history() const {
  // @@protoc_insertion_point(field_list:TP.TrackChangesCommandArchive.change_session_history)
  return _impl_.change_session_history_;
}

// optional bool paused = 4;
inline bool TrackChangesCommandArchive::_internal_has_paused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackChangesCommandArchive::has_paused() const {
  return _internal_has_paused();
}
inline void TrackChangesCommandArchive::clear_paused() {
  _impl_.paused_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TrackChangesCommandArchive::_internal_paused() const {
  return _impl_.paused_;
}
inline bool TrackChangesCommandArchive::paused() const {
  // @@protoc_insertion_point(field_get:TP.TrackChangesCommandArchive.paused)
  return _internal_paused();
}
inline void TrackChangesCommandArchive::_internal_set_paused(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.paused_ = value;
}
inline void TrackChangesCommandArchive::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:TP.TrackChangesCommandArchive.paused)
}

// -------------------------------------------------------------------

// DocumentHyphenationCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentHyphenationCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DocumentHyphenationCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& DocumentHyphenationCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& DocumentHyphenationCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.DocumentHyphenationCommandArchive.super)
  return _internal_super();
}
inline void DocumentHyphenationCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.DocumentHyphenationCommandArchive.super)
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.DocumentHyphenationCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* DocumentHyphenationCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.DocumentHyphenationCommandArchive.super)
  return _msg;
}
inline void DocumentHyphenationCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.DocumentHyphenationCommandArchive.super)
}

// optional bool hyphenate_document = 2;
inline bool DocumentHyphenationCommandArchive::_internal_has_hyphenate_document() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentHyphenationCommandArchive::has_hyphenate_document() const {
  return _internal_has_hyphenate_document();
}
inline void DocumentHyphenationCommandArchive::clear_hyphenate_document() {
  _impl_.hyphenate_document_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DocumentHyphenationCommandArchive::_internal_hyphenate_document() const {
  return _impl_.hyphenate_document_;
}
inline bool DocumentHyphenationCommandArchive::hyphenate_document() const {
  // @@protoc_insertion_point(field_get:TP.DocumentHyphenationCommandArchive.hyphenate_document)
  return _internal_hyphenate_document();
}
inline void DocumentHyphenationCommandArchive::_internal_set_hyphenate_document(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hyphenate_document_ = value;
}
inline void DocumentHyphenationCommandArchive::set_hyphenate_document(bool value) {
  _internal_set_hyphenate_document(value);
  // @@protoc_insertion_point(field_set:TP.DocumentHyphenationCommandArchive.hyphenate_document)
}

// -------------------------------------------------------------------

// DocumentLigaturesCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentLigaturesCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DocumentLigaturesCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& DocumentLigaturesCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& DocumentLigaturesCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.DocumentLigaturesCommandArchive.super)
  return _internal_super();
}
inline void DocumentLigaturesCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.DocumentLigaturesCommandArchive.super)
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.DocumentLigaturesCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* DocumentLigaturesCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.DocumentLigaturesCommandArchive.super)
  return _msg;
}
inline void DocumentLigaturesCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.DocumentLigaturesCommandArchive.super)
}

// optional bool use_ligatures = 2;
inline bool DocumentLigaturesCommandArchive::_internal_has_use_ligatures() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentLigaturesCommandArchive::has_use_ligatures() const {
  return _internal_has_use_ligatures();
}
inline void DocumentLigaturesCommandArchive::clear_use_ligatures() {
  _impl_.use_ligatures_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DocumentLigaturesCommandArchive::_internal_use_ligatures() const {
  return _impl_.use_ligatures_;
}
inline bool DocumentLigaturesCommandArchive::use_ligatures() const {
  // @@protoc_insertion_point(field_get:TP.DocumentLigaturesCommandArchive.use_ligatures)
  return _internal_use_ligatures();
}
inline void DocumentLigaturesCommandArchive::_internal_set_use_ligatures(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_ligatures_ = value;
}
inline void DocumentLigaturesCommandArchive::set_use_ligatures(bool value) {
  _internal_set_use_ligatures(value);
  // @@protoc_insertion_point(field_set:TP.DocumentLigaturesCommandArchive.use_ligatures)
}

// -------------------------------------------------------------------

// DocumentHasBodyCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool DocumentHasBodyCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DocumentHasBodyCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& DocumentHasBodyCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& DocumentHasBodyCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.DocumentHasBodyCommandArchive.super)
  return _internal_super();
}
inline void DocumentHasBodyCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.DocumentHasBodyCommandArchive.super)
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.DocumentHasBodyCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* DocumentHasBodyCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.DocumentHasBodyCommandArchive.super)
  return _msg;
}
inline void DocumentHasBodyCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.DocumentHasBodyCommandArchive.super)
}

// optional bool has_body = 2;
inline bool DocumentHasBodyCommandArchive::_internal_has_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentHasBodyCommandArchive::has_has_body() const {
  return _internal_has_has_body();
}
inline void DocumentHasBodyCommandArchive::clear_has_body() {
  _impl_.has_body_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DocumentHasBodyCommandArchive::_internal_has_body() const {
  return _impl_.has_body_;
}
inline bool DocumentHasBodyCommandArchive::has_body() const {
  // @@protoc_insertion_point(field_get:TP.DocumentHasBodyCommandArchive.has_body)
  return _internal_has_body();
}
inline void DocumentHasBodyCommandArchive::_internal_set_has_body(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.has_body_ = value;
}
inline void DocumentHasBodyCommandArchive::set_has_body(bool value) {
  _internal_set_has_body(value);
  // @@protoc_insertion_point(field_set:TP.DocumentHasBodyCommandArchive.has_body)
}

// -------------------------------------------------------------------

// PauseChangeTrackingCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PauseChangeTrackingCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PauseChangeTrackingCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& PauseChangeTrackingCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& PauseChangeTrackingCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TP.PauseChangeTrackingCommandArchive.super)
  return _internal_super();
}
inline void PauseChangeTrackingCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TP.PauseChangeTrackingCommandArchive.super)
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TP.PauseChangeTrackingCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* PauseChangeTrackingCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TP.PauseChangeTrackingCommandArchive.super)
  return _msg;
}
inline void PauseChangeTrackingCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TP.PauseChangeTrackingCommandArchive.super)
}

// optional bool paused = 2;
inline bool PauseChangeTrackingCommandArchive::_internal_has_paused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PauseChangeTrackingCommandArchive::has_paused() const {
  return _internal_has_paused();
}
inline void PauseChangeTrackingCommandArchive::clear_paused() {
  _impl_.paused_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PauseChangeTrackingCommandArchive::_internal_paused() const {
  return _impl_.paused_;
}
inline bool PauseChangeTrackingCommandArchive::paused() const {
  // @@protoc_insertion_point(field_get:TP.PauseChangeTrackingCommandArchive.paused)
  return _internal_paused();
}
inline void PauseChangeTrackingCommandArchive::_internal_set_paused(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.paused_ = value;
}
inline void PauseChangeTrackingCommandArchive::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:TP.PauseChangeTrackingCommandArchive.paused)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TP

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType>() {
  return ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFooterType_descriptor();
}
template <> struct is_proto_enum< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex>() {
  return ::TP::ChangeHeaderFooterVisibilityCommandArchive_TPHeaderFragmentIndex_descriptor();
}
template <> struct is_proto_enum< ::TP::ChangeSectionMarginsCommandArchive_SectionMargin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeSectionMarginsCommandArchive_SectionMargin>() {
  return ::TP::ChangeSectionMarginsCommandArchive_SectionMargin_descriptor();
}
template <> struct is_proto_enum< ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat>() {
  return ::TP::ChangeFootnoteFormatCommandArchive_FootnoteFormat_descriptor();
}
template <> struct is_proto_enum< ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind>() {
  return ::TP::ChangeFootnoteKindCommandArchive_FootnoteKind_descriptor();
}
template <> struct is_proto_enum< ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering>() {
  return ::TP::ChangeFootnoteNumberingCommandArchive_FootnoteNumbering_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TPCommandArchives_2eproto
