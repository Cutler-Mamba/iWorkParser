// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSAArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSAArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSAArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "TSKArchives.pb.h"
#include "TSPMessages.pb.h"
#include "TSWPArchives.pb.h"
#include "TSSArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSAArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSAArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSAArchives_2eproto;
namespace TSA {
class DocumentArchive;
struct DocumentArchiveDefaultTypeInternal;
extern DocumentArchiveDefaultTypeInternal _DocumentArchive_default_instance_;
class FunctionBrowserStateArchive;
struct FunctionBrowserStateArchiveDefaultTypeInternal;
extern FunctionBrowserStateArchiveDefaultTypeInternal _FunctionBrowserStateArchive_default_instance_;
class PropagatePresetCommandArchive;
struct PropagatePresetCommandArchiveDefaultTypeInternal;
extern PropagatePresetCommandArchiveDefaultTypeInternal _PropagatePresetCommandArchive_default_instance_;
class TestDocumentArchive;
struct TestDocumentArchiveDefaultTypeInternal;
extern TestDocumentArchiveDefaultTypeInternal _TestDocumentArchive_default_instance_;
}  // namespace TSA
PROTOBUF_NAMESPACE_OPEN
template<> ::TSA::DocumentArchive* Arena::CreateMaybeMessage<::TSA::DocumentArchive>(Arena*);
template<> ::TSA::FunctionBrowserStateArchive* Arena::CreateMaybeMessage<::TSA::FunctionBrowserStateArchive>(Arena*);
template<> ::TSA::PropagatePresetCommandArchive* Arena::CreateMaybeMessage<::TSA::PropagatePresetCommandArchive>(Arena*);
template<> ::TSA::TestDocumentArchive* Arena::CreateMaybeMessage<::TSA::TestDocumentArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSA {

// ===================================================================

class DocumentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSA.DocumentArchive) */ {
 public:
  inline DocumentArchive() : DocumentArchive(nullptr) {}
  ~DocumentArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentArchive(const DocumentArchive& from);
  DocumentArchive(DocumentArchive&& from) noexcept
    : DocumentArchive() {
    *this = ::std::move(from);
  }

  inline DocumentArchive& operator=(const DocumentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentArchive& operator=(DocumentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentArchive*>(
               &_DocumentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DocumentArchive& a, DocumentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentArchive& from) {
    DocumentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSA.DocumentArchive";
  }
  protected:
  explicit DocumentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextPresetDisplayItemsFieldNumber = 2,
    kCreationLanguageFieldNumber = 3,
    kTemplateIdentifierFieldNumber = 9,
    kSuperFieldNumber = 1,
    kCalculationEngineFieldNumber = 4,
    kViewStateFieldNumber = 5,
    kFunctionBrowserStateFieldNumber = 6,
    kTablesCustomFormatListFieldNumber = 7,
    kNeedsMovieCompatibilityUpgradeFieldNumber = 8,
  };
  // repeated .TSWP.TextPresetDisplayItemArchive text_preset_display_items = 2;
  int text_preset_display_items_size() const;
  private:
  int _internal_text_preset_display_items_size() const;
  public:
  void clear_text_preset_display_items();
  ::TSWP::TextPresetDisplayItemArchive* mutable_text_preset_display_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSWP::TextPresetDisplayItemArchive >*
      mutable_text_preset_display_items();
  private:
  const ::TSWP::TextPresetDisplayItemArchive& _internal_text_preset_display_items(int index) const;
  ::TSWP::TextPresetDisplayItemArchive* _internal_add_text_preset_display_items();
  public:
  const ::TSWP::TextPresetDisplayItemArchive& text_preset_display_items(int index) const;
  ::TSWP::TextPresetDisplayItemArchive* add_text_preset_display_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSWP::TextPresetDisplayItemArchive >&
      text_preset_display_items() const;

  // optional string creation_language = 3;
  bool has_creation_language() const;
  private:
  bool _internal_has_creation_language() const;
  public:
  void clear_creation_language();
  const std::string& creation_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creation_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creation_language();
  PROTOBUF_NODISCARD std::string* release_creation_language();
  void set_allocated_creation_language(std::string* creation_language);
  private:
  const std::string& _internal_creation_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creation_language(const std::string& value);
  std::string* _internal_mutable_creation_language();
  public:

  // optional string template_identifier = 9;
  bool has_template_identifier() const;
  private:
  bool _internal_has_template_identifier() const;
  public:
  void clear_template_identifier();
  const std::string& template_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_template_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_template_identifier();
  PROTOBUF_NODISCARD std::string* release_template_identifier();
  void set_allocated_template_identifier(std::string* template_identifier);
  private:
  const std::string& _internal_template_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_template_identifier(const std::string& value);
  std::string* _internal_mutable_template_identifier();
  public:

  // required .TSK.DocumentArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::DocumentArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::DocumentArchive* release_super();
  ::TSK::DocumentArchive* mutable_super();
  void set_allocated_super(::TSK::DocumentArchive* super);
  private:
  const ::TSK::DocumentArchive& _internal_super() const;
  ::TSK::DocumentArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::DocumentArchive* super);
  ::TSK::DocumentArchive* unsafe_arena_release_super();

  // optional .TSP.Reference calculation_engine = 4;
  bool has_calculation_engine() const;
  private:
  bool _internal_has_calculation_engine() const;
  public:
  void clear_calculation_engine();
  const ::TSP::Reference& calculation_engine() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_calculation_engine();
  ::TSP::Reference* mutable_calculation_engine();
  void set_allocated_calculation_engine(::TSP::Reference* calculation_engine);
  private:
  const ::TSP::Reference& _internal_calculation_engine() const;
  ::TSP::Reference* _internal_mutable_calculation_engine();
  public:
  void unsafe_arena_set_allocated_calculation_engine(
      ::TSP::Reference* calculation_engine);
  ::TSP::Reference* unsafe_arena_release_calculation_engine();

  // optional .TSP.Reference view_state = 5;
  bool has_view_state() const;
  private:
  bool _internal_has_view_state() const;
  public:
  void clear_view_state();
  const ::TSP::Reference& view_state() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_view_state();
  ::TSP::Reference* mutable_view_state();
  void set_allocated_view_state(::TSP::Reference* view_state);
  private:
  const ::TSP::Reference& _internal_view_state() const;
  ::TSP::Reference* _internal_mutable_view_state();
  public:
  void unsafe_arena_set_allocated_view_state(
      ::TSP::Reference* view_state);
  ::TSP::Reference* unsafe_arena_release_view_state();

  // optional .TSP.Reference function_browser_state = 6;
  bool has_function_browser_state() const;
  private:
  bool _internal_has_function_browser_state() const;
  public:
  void clear_function_browser_state();
  const ::TSP::Reference& function_browser_state() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_function_browser_state();
  ::TSP::Reference* mutable_function_browser_state();
  void set_allocated_function_browser_state(::TSP::Reference* function_browser_state);
  private:
  const ::TSP::Reference& _internal_function_browser_state() const;
  ::TSP::Reference* _internal_mutable_function_browser_state();
  public:
  void unsafe_arena_set_allocated_function_browser_state(
      ::TSP::Reference* function_browser_state);
  ::TSP::Reference* unsafe_arena_release_function_browser_state();

  // optional .TSP.Reference tables_custom_format_list = 7;
  bool has_tables_custom_format_list() const;
  private:
  bool _internal_has_tables_custom_format_list() const;
  public:
  void clear_tables_custom_format_list();
  const ::TSP::Reference& tables_custom_format_list() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_tables_custom_format_list();
  ::TSP::Reference* mutable_tables_custom_format_list();
  void set_allocated_tables_custom_format_list(::TSP::Reference* tables_custom_format_list);
  private:
  const ::TSP::Reference& _internal_tables_custom_format_list() const;
  ::TSP::Reference* _internal_mutable_tables_custom_format_list();
  public:
  void unsafe_arena_set_allocated_tables_custom_format_list(
      ::TSP::Reference* tables_custom_format_list);
  ::TSP::Reference* unsafe_arena_release_tables_custom_format_list();

  // optional bool needs_movie_compatibility_upgrade = 8;
  bool has_needs_movie_compatibility_upgrade() const;
  private:
  bool _internal_has_needs_movie_compatibility_upgrade() const;
  public:
  void clear_needs_movie_compatibility_upgrade();
  bool needs_movie_compatibility_upgrade() const;
  void set_needs_movie_compatibility_upgrade(bool value);
  private:
  bool _internal_needs_movie_compatibility_upgrade() const;
  void _internal_set_needs_movie_compatibility_upgrade(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSA.DocumentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSWP::TextPresetDisplayItemArchive > text_preset_display_items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creation_language_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr template_identifier_;
    ::TSK::DocumentArchive* super_;
    ::TSP::Reference* calculation_engine_;
    ::TSP::Reference* view_state_;
    ::TSP::Reference* function_browser_state_;
    ::TSP::Reference* tables_custom_format_list_;
    bool needs_movie_compatibility_upgrade_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSAArchives_2eproto;
};
// -------------------------------------------------------------------

class FunctionBrowserStateArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSA.FunctionBrowserStateArchive) */ {
 public:
  inline FunctionBrowserStateArchive() : FunctionBrowserStateArchive(nullptr) {}
  ~FunctionBrowserStateArchive() override;
  explicit PROTOBUF_CONSTEXPR FunctionBrowserStateArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionBrowserStateArchive(const FunctionBrowserStateArchive& from);
  FunctionBrowserStateArchive(FunctionBrowserStateArchive&& from) noexcept
    : FunctionBrowserStateArchive() {
    *this = ::std::move(from);
  }

  inline FunctionBrowserStateArchive& operator=(const FunctionBrowserStateArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionBrowserStateArchive& operator=(FunctionBrowserStateArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionBrowserStateArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionBrowserStateArchive* internal_default_instance() {
    return reinterpret_cast<const FunctionBrowserStateArchive*>(
               &_FunctionBrowserStateArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FunctionBrowserStateArchive& a, FunctionBrowserStateArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionBrowserStateArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionBrowserStateArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionBrowserStateArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionBrowserStateArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionBrowserStateArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionBrowserStateArchive& from) {
    FunctionBrowserStateArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionBrowserStateArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSA.FunctionBrowserStateArchive";
  }
  protected:
  explicit FunctionBrowserStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecentFunctionsFieldNumber = 1,
    kBackFunctionsFieldNumber = 2,
    kForwardFunctionsFieldNumber = 3,
    kCurrentFunctionFieldNumber = 4,
  };
  // repeated uint32 recent_functions = 1;
  int recent_functions_size() const;
  private:
  int _internal_recent_functions_size() const;
  public:
  void clear_recent_functions();
  private:
  uint32_t _internal_recent_functions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_recent_functions() const;
  void _internal_add_recent_functions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_recent_functions();
  public:
  uint32_t recent_functions(int index) const;
  void set_recent_functions(int index, uint32_t value);
  void add_recent_functions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      recent_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_recent_functions();

  // repeated uint32 back_functions = 2;
  int back_functions_size() const;
  private:
  int _internal_back_functions_size() const;
  public:
  void clear_back_functions();
  private:
  uint32_t _internal_back_functions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_back_functions() const;
  void _internal_add_back_functions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_back_functions();
  public:
  uint32_t back_functions(int index) const;
  void set_back_functions(int index, uint32_t value);
  void add_back_functions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      back_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_back_functions();

  // repeated uint32 forward_functions = 3;
  int forward_functions_size() const;
  private:
  int _internal_forward_functions_size() const;
  public:
  void clear_forward_functions();
  private:
  uint32_t _internal_forward_functions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_forward_functions() const;
  void _internal_add_forward_functions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_forward_functions();
  public:
  uint32_t forward_functions(int index) const;
  void set_forward_functions(int index, uint32_t value);
  void add_forward_functions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      forward_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_forward_functions();

  // optional uint32 current_function = 4;
  bool has_current_function() const;
  private:
  bool _internal_has_current_function() const;
  public:
  void clear_current_function();
  uint32_t current_function() const;
  void set_current_function(uint32_t value);
  private:
  uint32_t _internal_current_function() const;
  void _internal_set_current_function(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSA.FunctionBrowserStateArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > recent_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > back_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > forward_functions_;
    uint32_t current_function_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSAArchives_2eproto;
};
// -------------------------------------------------------------------

class TestDocumentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSA.TestDocumentArchive) */ {
 public:
  inline TestDocumentArchive() : TestDocumentArchive(nullptr) {}
  ~TestDocumentArchive() override;
  explicit PROTOBUF_CONSTEXPR TestDocumentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestDocumentArchive(const TestDocumentArchive& from);
  TestDocumentArchive(TestDocumentArchive&& from) noexcept
    : TestDocumentArchive() {
    *this = ::std::move(from);
  }

  inline TestDocumentArchive& operator=(const TestDocumentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDocumentArchive& operator=(TestDocumentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDocumentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDocumentArchive* internal_default_instance() {
    return reinterpret_cast<const TestDocumentArchive*>(
               &_TestDocumentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TestDocumentArchive& a, TestDocumentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDocumentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDocumentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDocumentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDocumentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestDocumentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestDocumentArchive& from) {
    TestDocumentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDocumentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSA.TestDocumentArchive";
  }
  protected:
  explicit TestDocumentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required .TSA.DocumentArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSA::DocumentArchive& super() const;
  PROTOBUF_NODISCARD ::TSA::DocumentArchive* release_super();
  ::TSA::DocumentArchive* mutable_super();
  void set_allocated_super(::TSA::DocumentArchive* super);
  private:
  const ::TSA::DocumentArchive& _internal_super() const;
  ::TSA::DocumentArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSA::DocumentArchive* super);
  ::TSA::DocumentArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSA.TestDocumentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::TSA::DocumentArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSAArchives_2eproto;
};
// -------------------------------------------------------------------

class PropagatePresetCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSA.PropagatePresetCommandArchive) */ {
 public:
  inline PropagatePresetCommandArchive() : PropagatePresetCommandArchive(nullptr) {}
  ~PropagatePresetCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR PropagatePresetCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PropagatePresetCommandArchive(const PropagatePresetCommandArchive& from);
  PropagatePresetCommandArchive(PropagatePresetCommandArchive&& from) noexcept
    : PropagatePresetCommandArchive() {
    *this = ::std::move(from);
  }

  inline PropagatePresetCommandArchive& operator=(const PropagatePresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropagatePresetCommandArchive& operator=(PropagatePresetCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropagatePresetCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropagatePresetCommandArchive* internal_default_instance() {
    return reinterpret_cast<const PropagatePresetCommandArchive*>(
               &_PropagatePresetCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PropagatePresetCommandArchive& a, PropagatePresetCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PropagatePresetCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropagatePresetCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropagatePresetCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PropagatePresetCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PropagatePresetCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PropagatePresetCommandArchive& from) {
    PropagatePresetCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropagatePresetCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSA.PropagatePresetCommandArchive";
  }
  protected:
  explicit PropagatePresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSA.PropagatePresetCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSAArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DocumentArchive

// required .TSK.DocumentArchive super = 1;
inline bool DocumentArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::DocumentArchive& DocumentArchive::_internal_super() const {
  const ::TSK::DocumentArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::DocumentArchive&>(
      ::TSK::_DocumentArchive_default_instance_);
}
inline const ::TSK::DocumentArchive& DocumentArchive::super() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.super)
  return _internal_super();
}
inline void DocumentArchive::unsafe_arena_set_allocated_super(
    ::TSK::DocumentArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.DocumentArchive.super)
}
inline ::TSK::DocumentArchive* DocumentArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::DocumentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::DocumentArchive* DocumentArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::DocumentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::DocumentArchive* DocumentArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::DocumentArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::DocumentArchive* DocumentArchive::mutable_super() {
  ::TSK::DocumentArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.super)
  return _msg;
}
inline void DocumentArchive::set_allocated_super(::TSK::DocumentArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.super)
}

// repeated .TSWP.TextPresetDisplayItemArchive text_preset_display_items = 2;
inline int DocumentArchive::_internal_text_preset_display_items_size() const {
  return _impl_.text_preset_display_items_.size();
}
inline int DocumentArchive::text_preset_display_items_size() const {
  return _internal_text_preset_display_items_size();
}
inline ::TSWP::TextPresetDisplayItemArchive* DocumentArchive::mutable_text_preset_display_items(int index) {
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.text_preset_display_items)
  return _impl_.text_preset_display_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSWP::TextPresetDisplayItemArchive >*
DocumentArchive::mutable_text_preset_display_items() {
  // @@protoc_insertion_point(field_mutable_list:TSA.DocumentArchive.text_preset_display_items)
  return &_impl_.text_preset_display_items_;
}
inline const ::TSWP::TextPresetDisplayItemArchive& DocumentArchive::_internal_text_preset_display_items(int index) const {
  return _impl_.text_preset_display_items_.Get(index);
}
inline const ::TSWP::TextPresetDisplayItemArchive& DocumentArchive::text_preset_display_items(int index) const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.text_preset_display_items)
  return _internal_text_preset_display_items(index);
}
inline ::TSWP::TextPresetDisplayItemArchive* DocumentArchive::_internal_add_text_preset_display_items() {
  return _impl_.text_preset_display_items_.Add();
}
inline ::TSWP::TextPresetDisplayItemArchive* DocumentArchive::add_text_preset_display_items() {
  ::TSWP::TextPresetDisplayItemArchive* _add = _internal_add_text_preset_display_items();
  // @@protoc_insertion_point(field_add:TSA.DocumentArchive.text_preset_display_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSWP::TextPresetDisplayItemArchive >&
DocumentArchive::text_preset_display_items() const {
  // @@protoc_insertion_point(field_list:TSA.DocumentArchive.text_preset_display_items)
  return _impl_.text_preset_display_items_;
}

// optional string creation_language = 3;
inline bool DocumentArchive::_internal_has_creation_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentArchive::has_creation_language() const {
  return _internal_has_creation_language();
}
inline void DocumentArchive::clear_creation_language() {
  _impl_.creation_language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentArchive::creation_language() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.creation_language)
  return _internal_creation_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentArchive::set_creation_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.creation_language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSA.DocumentArchive.creation_language)
}
inline std::string* DocumentArchive::mutable_creation_language() {
  std::string* _s = _internal_mutable_creation_language();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.creation_language)
  return _s;
}
inline const std::string& DocumentArchive::_internal_creation_language() const {
  return _impl_.creation_language_.Get();
}
inline void DocumentArchive::_internal_set_creation_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.creation_language_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentArchive::_internal_mutable_creation_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.creation_language_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentArchive::release_creation_language() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.creation_language)
  if (!_internal_has_creation_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.creation_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creation_language_.IsDefault()) {
    _impl_.creation_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentArchive::set_allocated_creation_language(std::string* creation_language) {
  if (creation_language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.creation_language_.SetAllocated(creation_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creation_language_.IsDefault()) {
    _impl_.creation_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.creation_language)
}

// optional .TSP.Reference calculation_engine = 4;
inline bool DocumentArchive::_internal_has_calculation_engine() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.calculation_engine_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_calculation_engine() const {
  return _internal_has_calculation_engine();
}
inline const ::TSP::Reference& DocumentArchive::_internal_calculation_engine() const {
  const ::TSP::Reference* p = _impl_.calculation_engine_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentArchive::calculation_engine() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.calculation_engine)
  return _internal_calculation_engine();
}
inline void DocumentArchive::unsafe_arena_set_allocated_calculation_engine(
    ::TSP::Reference* calculation_engine) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.calculation_engine_);
  }
  _impl_.calculation_engine_ = calculation_engine;
  if (calculation_engine) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.DocumentArchive.calculation_engine)
}
inline ::TSP::Reference* DocumentArchive::release_calculation_engine() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.calculation_engine_;
  _impl_.calculation_engine_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentArchive::unsafe_arena_release_calculation_engine() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.calculation_engine)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.calculation_engine_;
  _impl_.calculation_engine_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentArchive::_internal_mutable_calculation_engine() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.calculation_engine_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.calculation_engine_ = p;
  }
  return _impl_.calculation_engine_;
}
inline ::TSP::Reference* DocumentArchive::mutable_calculation_engine() {
  ::TSP::Reference* _msg = _internal_mutable_calculation_engine();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.calculation_engine)
  return _msg;
}
inline void DocumentArchive::set_allocated_calculation_engine(::TSP::Reference* calculation_engine) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.calculation_engine_);
  }
  if (calculation_engine) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(calculation_engine));
    if (message_arena != submessage_arena) {
      calculation_engine = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, calculation_engine, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.calculation_engine_ = calculation_engine;
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.calculation_engine)
}

// optional .TSP.Reference view_state = 5;
inline bool DocumentArchive::_internal_has_view_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.view_state_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_view_state() const {
  return _internal_has_view_state();
}
inline const ::TSP::Reference& DocumentArchive::_internal_view_state() const {
  const ::TSP::Reference* p = _impl_.view_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentArchive::view_state() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.view_state)
  return _internal_view_state();
}
inline void DocumentArchive::unsafe_arena_set_allocated_view_state(
    ::TSP::Reference* view_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_state_);
  }
  _impl_.view_state_ = view_state;
  if (view_state) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.DocumentArchive.view_state)
}
inline ::TSP::Reference* DocumentArchive::release_view_state() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.view_state_;
  _impl_.view_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentArchive::unsafe_arena_release_view_state() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.view_state)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.view_state_;
  _impl_.view_state_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentArchive::_internal_mutable_view_state() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.view_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.view_state_ = p;
  }
  return _impl_.view_state_;
}
inline ::TSP::Reference* DocumentArchive::mutable_view_state() {
  ::TSP::Reference* _msg = _internal_mutable_view_state();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.view_state)
  return _msg;
}
inline void DocumentArchive::set_allocated_view_state(::TSP::Reference* view_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_state_);
  }
  if (view_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(view_state));
    if (message_arena != submessage_arena) {
      view_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.view_state_ = view_state;
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.view_state)
}

// optional .TSP.Reference function_browser_state = 6;
inline bool DocumentArchive::_internal_has_function_browser_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.function_browser_state_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_function_browser_state() const {
  return _internal_has_function_browser_state();
}
inline const ::TSP::Reference& DocumentArchive::_internal_function_browser_state() const {
  const ::TSP::Reference* p = _impl_.function_browser_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentArchive::function_browser_state() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.function_browser_state)
  return _internal_function_browser_state();
}
inline void DocumentArchive::unsafe_arena_set_allocated_function_browser_state(
    ::TSP::Reference* function_browser_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_browser_state_);
  }
  _impl_.function_browser_state_ = function_browser_state;
  if (function_browser_state) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.DocumentArchive.function_browser_state)
}
inline ::TSP::Reference* DocumentArchive::release_function_browser_state() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.function_browser_state_;
  _impl_.function_browser_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentArchive::unsafe_arena_release_function_browser_state() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.function_browser_state)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.function_browser_state_;
  _impl_.function_browser_state_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentArchive::_internal_mutable_function_browser_state() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.function_browser_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.function_browser_state_ = p;
  }
  return _impl_.function_browser_state_;
}
inline ::TSP::Reference* DocumentArchive::mutable_function_browser_state() {
  ::TSP::Reference* _msg = _internal_mutable_function_browser_state();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.function_browser_state)
  return _msg;
}
inline void DocumentArchive::set_allocated_function_browser_state(::TSP::Reference* function_browser_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.function_browser_state_);
  }
  if (function_browser_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(function_browser_state));
    if (message_arena != submessage_arena) {
      function_browser_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, function_browser_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.function_browser_state_ = function_browser_state;
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.function_browser_state)
}

// optional .TSP.Reference tables_custom_format_list = 7;
inline bool DocumentArchive::_internal_has_tables_custom_format_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tables_custom_format_list_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_tables_custom_format_list() const {
  return _internal_has_tables_custom_format_list();
}
inline const ::TSP::Reference& DocumentArchive::_internal_tables_custom_format_list() const {
  const ::TSP::Reference* p = _impl_.tables_custom_format_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentArchive::tables_custom_format_list() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.tables_custom_format_list)
  return _internal_tables_custom_format_list();
}
inline void DocumentArchive::unsafe_arena_set_allocated_tables_custom_format_list(
    ::TSP::Reference* tables_custom_format_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tables_custom_format_list_);
  }
  _impl_.tables_custom_format_list_ = tables_custom_format_list;
  if (tables_custom_format_list) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.DocumentArchive.tables_custom_format_list)
}
inline ::TSP::Reference* DocumentArchive::release_tables_custom_format_list() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.tables_custom_format_list_;
  _impl_.tables_custom_format_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentArchive::unsafe_arena_release_tables_custom_format_list() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.tables_custom_format_list)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.tables_custom_format_list_;
  _impl_.tables_custom_format_list_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentArchive::_internal_mutable_tables_custom_format_list() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.tables_custom_format_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.tables_custom_format_list_ = p;
  }
  return _impl_.tables_custom_format_list_;
}
inline ::TSP::Reference* DocumentArchive::mutable_tables_custom_format_list() {
  ::TSP::Reference* _msg = _internal_mutable_tables_custom_format_list();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.tables_custom_format_list)
  return _msg;
}
inline void DocumentArchive::set_allocated_tables_custom_format_list(::TSP::Reference* tables_custom_format_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tables_custom_format_list_);
  }
  if (tables_custom_format_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tables_custom_format_list));
    if (message_arena != submessage_arena) {
      tables_custom_format_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tables_custom_format_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.tables_custom_format_list_ = tables_custom_format_list;
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.tables_custom_format_list)
}

// optional bool needs_movie_compatibility_upgrade = 8;
inline bool DocumentArchive::_internal_has_needs_movie_compatibility_upgrade() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DocumentArchive::has_needs_movie_compatibility_upgrade() const {
  return _internal_has_needs_movie_compatibility_upgrade();
}
inline void DocumentArchive::clear_needs_movie_compatibility_upgrade() {
  _impl_.needs_movie_compatibility_upgrade_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool DocumentArchive::_internal_needs_movie_compatibility_upgrade() const {
  return _impl_.needs_movie_compatibility_upgrade_;
}
inline bool DocumentArchive::needs_movie_compatibility_upgrade() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.needs_movie_compatibility_upgrade)
  return _internal_needs_movie_compatibility_upgrade();
}
inline void DocumentArchive::_internal_set_needs_movie_compatibility_upgrade(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.needs_movie_compatibility_upgrade_ = value;
}
inline void DocumentArchive::set_needs_movie_compatibility_upgrade(bool value) {
  _internal_set_needs_movie_compatibility_upgrade(value);
  // @@protoc_insertion_point(field_set:TSA.DocumentArchive.needs_movie_compatibility_upgrade)
}

// optional string template_identifier = 9;
inline bool DocumentArchive::_internal_has_template_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentArchive::has_template_identifier() const {
  return _internal_has_template_identifier();
}
inline void DocumentArchive::clear_template_identifier() {
  _impl_.template_identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DocumentArchive::template_identifier() const {
  // @@protoc_insertion_point(field_get:TSA.DocumentArchive.template_identifier)
  return _internal_template_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentArchive::set_template_identifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.template_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSA.DocumentArchive.template_identifier)
}
inline std::string* DocumentArchive::mutable_template_identifier() {
  std::string* _s = _internal_mutable_template_identifier();
  // @@protoc_insertion_point(field_mutable:TSA.DocumentArchive.template_identifier)
  return _s;
}
inline const std::string& DocumentArchive::_internal_template_identifier() const {
  return _impl_.template_identifier_.Get();
}
inline void DocumentArchive::_internal_set_template_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.template_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentArchive::_internal_mutable_template_identifier() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.template_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentArchive::release_template_identifier() {
  // @@protoc_insertion_point(field_release:TSA.DocumentArchive.template_identifier)
  if (!_internal_has_template_identifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.template_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.template_identifier_.IsDefault()) {
    _impl_.template_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentArchive::set_allocated_template_identifier(std::string* template_identifier) {
  if (template_identifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.template_identifier_.SetAllocated(template_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.template_identifier_.IsDefault()) {
    _impl_.template_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSA.DocumentArchive.template_identifier)
}

// -------------------------------------------------------------------

// FunctionBrowserStateArchive

// repeated uint32 recent_functions = 1;
inline int FunctionBrowserStateArchive::_internal_recent_functions_size() const {
  return _impl_.recent_functions_.size();
}
inline int FunctionBrowserStateArchive::recent_functions_size() const {
  return _internal_recent_functions_size();
}
inline void FunctionBrowserStateArchive::clear_recent_functions() {
  _impl_.recent_functions_.Clear();
}
inline uint32_t FunctionBrowserStateArchive::_internal_recent_functions(int index) const {
  return _impl_.recent_functions_.Get(index);
}
inline uint32_t FunctionBrowserStateArchive::recent_functions(int index) const {
  // @@protoc_insertion_point(field_get:TSA.FunctionBrowserStateArchive.recent_functions)
  return _internal_recent_functions(index);
}
inline void FunctionBrowserStateArchive::set_recent_functions(int index, uint32_t value) {
  _impl_.recent_functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSA.FunctionBrowserStateArchive.recent_functions)
}
inline void FunctionBrowserStateArchive::_internal_add_recent_functions(uint32_t value) {
  _impl_.recent_functions_.Add(value);
}
inline void FunctionBrowserStateArchive::add_recent_functions(uint32_t value) {
  _internal_add_recent_functions(value);
  // @@protoc_insertion_point(field_add:TSA.FunctionBrowserStateArchive.recent_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::_internal_recent_functions() const {
  return _impl_.recent_functions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::recent_functions() const {
  // @@protoc_insertion_point(field_list:TSA.FunctionBrowserStateArchive.recent_functions)
  return _internal_recent_functions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::_internal_mutable_recent_functions() {
  return &_impl_.recent_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::mutable_recent_functions() {
  // @@protoc_insertion_point(field_mutable_list:TSA.FunctionBrowserStateArchive.recent_functions)
  return _internal_mutable_recent_functions();
}

// repeated uint32 back_functions = 2;
inline int FunctionBrowserStateArchive::_internal_back_functions_size() const {
  return _impl_.back_functions_.size();
}
inline int FunctionBrowserStateArchive::back_functions_size() const {
  return _internal_back_functions_size();
}
inline void FunctionBrowserStateArchive::clear_back_functions() {
  _impl_.back_functions_.Clear();
}
inline uint32_t FunctionBrowserStateArchive::_internal_back_functions(int index) const {
  return _impl_.back_functions_.Get(index);
}
inline uint32_t FunctionBrowserStateArchive::back_functions(int index) const {
  // @@protoc_insertion_point(field_get:TSA.FunctionBrowserStateArchive.back_functions)
  return _internal_back_functions(index);
}
inline void FunctionBrowserStateArchive::set_back_functions(int index, uint32_t value) {
  _impl_.back_functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSA.FunctionBrowserStateArchive.back_functions)
}
inline void FunctionBrowserStateArchive::_internal_add_back_functions(uint32_t value) {
  _impl_.back_functions_.Add(value);
}
inline void FunctionBrowserStateArchive::add_back_functions(uint32_t value) {
  _internal_add_back_functions(value);
  // @@protoc_insertion_point(field_add:TSA.FunctionBrowserStateArchive.back_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::_internal_back_functions() const {
  return _impl_.back_functions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::back_functions() const {
  // @@protoc_insertion_point(field_list:TSA.FunctionBrowserStateArchive.back_functions)
  return _internal_back_functions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::_internal_mutable_back_functions() {
  return &_impl_.back_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::mutable_back_functions() {
  // @@protoc_insertion_point(field_mutable_list:TSA.FunctionBrowserStateArchive.back_functions)
  return _internal_mutable_back_functions();
}

// repeated uint32 forward_functions = 3;
inline int FunctionBrowserStateArchive::_internal_forward_functions_size() const {
  return _impl_.forward_functions_.size();
}
inline int FunctionBrowserStateArchive::forward_functions_size() const {
  return _internal_forward_functions_size();
}
inline void FunctionBrowserStateArchive::clear_forward_functions() {
  _impl_.forward_functions_.Clear();
}
inline uint32_t FunctionBrowserStateArchive::_internal_forward_functions(int index) const {
  return _impl_.forward_functions_.Get(index);
}
inline uint32_t FunctionBrowserStateArchive::forward_functions(int index) const {
  // @@protoc_insertion_point(field_get:TSA.FunctionBrowserStateArchive.forward_functions)
  return _internal_forward_functions(index);
}
inline void FunctionBrowserStateArchive::set_forward_functions(int index, uint32_t value) {
  _impl_.forward_functions_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSA.FunctionBrowserStateArchive.forward_functions)
}
inline void FunctionBrowserStateArchive::_internal_add_forward_functions(uint32_t value) {
  _impl_.forward_functions_.Add(value);
}
inline void FunctionBrowserStateArchive::add_forward_functions(uint32_t value) {
  _internal_add_forward_functions(value);
  // @@protoc_insertion_point(field_add:TSA.FunctionBrowserStateArchive.forward_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::_internal_forward_functions() const {
  return _impl_.forward_functions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FunctionBrowserStateArchive::forward_functions() const {
  // @@protoc_insertion_point(field_list:TSA.FunctionBrowserStateArchive.forward_functions)
  return _internal_forward_functions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::_internal_mutable_forward_functions() {
  return &_impl_.forward_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FunctionBrowserStateArchive::mutable_forward_functions() {
  // @@protoc_insertion_point(field_mutable_list:TSA.FunctionBrowserStateArchive.forward_functions)
  return _internal_mutable_forward_functions();
}

// optional uint32 current_function = 4;
inline bool FunctionBrowserStateArchive::_internal_has_current_function() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunctionBrowserStateArchive::has_current_function() const {
  return _internal_has_current_function();
}
inline void FunctionBrowserStateArchive::clear_current_function() {
  _impl_.current_function_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FunctionBrowserStateArchive::_internal_current_function() const {
  return _impl_.current_function_;
}
inline uint32_t FunctionBrowserStateArchive::current_function() const {
  // @@protoc_insertion_point(field_get:TSA.FunctionBrowserStateArchive.current_function)
  return _internal_current_function();
}
inline void FunctionBrowserStateArchive::_internal_set_current_function(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.current_function_ = value;
}
inline void FunctionBrowserStateArchive::set_current_function(uint32_t value) {
  _internal_set_current_function(value);
  // @@protoc_insertion_point(field_set:TSA.FunctionBrowserStateArchive.current_function)
}

// -------------------------------------------------------------------

// TestDocumentArchive

// required .TSA.DocumentArchive super = 1;
inline bool TestDocumentArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TestDocumentArchive::has_super() const {
  return _internal_has_super();
}
inline void TestDocumentArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSA::DocumentArchive& TestDocumentArchive::_internal_super() const {
  const ::TSA::DocumentArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSA::DocumentArchive&>(
      ::TSA::_DocumentArchive_default_instance_);
}
inline const ::TSA::DocumentArchive& TestDocumentArchive::super() const {
  // @@protoc_insertion_point(field_get:TSA.TestDocumentArchive.super)
  return _internal_super();
}
inline void TestDocumentArchive::unsafe_arena_set_allocated_super(
    ::TSA::DocumentArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.TestDocumentArchive.super)
}
inline ::TSA::DocumentArchive* TestDocumentArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSA::DocumentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSA::DocumentArchive* TestDocumentArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSA.TestDocumentArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSA::DocumentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSA::DocumentArchive* TestDocumentArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSA::DocumentArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSA::DocumentArchive* TestDocumentArchive::mutable_super() {
  ::TSA::DocumentArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSA.TestDocumentArchive.super)
  return _msg;
}
inline void TestDocumentArchive::set_allocated_super(::TSA::DocumentArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSA.TestDocumentArchive.super)
}

// optional string value = 2;
inline bool TestDocumentArchive::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestDocumentArchive::has_value() const {
  return _internal_has_value();
}
inline void TestDocumentArchive::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TestDocumentArchive::value() const {
  // @@protoc_insertion_point(field_get:TSA.TestDocumentArchive.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestDocumentArchive::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSA.TestDocumentArchive.value)
}
inline std::string* TestDocumentArchive::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TSA.TestDocumentArchive.value)
  return _s;
}
inline const std::string& TestDocumentArchive::_internal_value() const {
  return _impl_.value_.Get();
}
inline void TestDocumentArchive::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* TestDocumentArchive::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* TestDocumentArchive::release_value() {
  // @@protoc_insertion_point(field_release:TSA.TestDocumentArchive.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TestDocumentArchive::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSA.TestDocumentArchive.value)
}

// -------------------------------------------------------------------

// PropagatePresetCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool PropagatePresetCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PropagatePresetCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& PropagatePresetCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& PropagatePresetCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSA.PropagatePresetCommandArchive.super)
  return _internal_super();
}
inline void PropagatePresetCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSA.PropagatePresetCommandArchive.super)
}
inline ::TSK::CommandArchive* PropagatePresetCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* PropagatePresetCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSA.PropagatePresetCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* PropagatePresetCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* PropagatePresetCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSA.PropagatePresetCommandArchive.super)
  return _msg;
}
inline void PropagatePresetCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSA.PropagatePresetCommandArchive.super)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSA

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSAArchives_2eproto
