// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSCHArchives.Common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSCHArchives_2eCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSCHArchives_2eCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSDArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSCH3DArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSCHArchives_2eCommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSCHArchives_2eCommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSCHArchives_2eCommon_2eproto;
namespace TSCH {
class ChartAxisNonStyleArchive;
struct ChartAxisNonStyleArchiveDefaultTypeInternal;
extern ChartAxisNonStyleArchiveDefaultTypeInternal _ChartAxisNonStyleArchive_default_instance_;
class ChartAxisStyleArchive;
struct ChartAxisStyleArchiveDefaultTypeInternal;
extern ChartAxisStyleArchiveDefaultTypeInternal _ChartAxisStyleArchive_default_instance_;
class ChartNonStyleArchive;
struct ChartNonStyleArchiveDefaultTypeInternal;
extern ChartNonStyleArchiveDefaultTypeInternal _ChartNonStyleArchive_default_instance_;
class ChartSeriesNonStyleArchive;
struct ChartSeriesNonStyleArchiveDefaultTypeInternal;
extern ChartSeriesNonStyleArchiveDefaultTypeInternal _ChartSeriesNonStyleArchive_default_instance_;
class ChartSeriesStyleArchive;
struct ChartSeriesStyleArchiveDefaultTypeInternal;
extern ChartSeriesStyleArchiveDefaultTypeInternal _ChartSeriesStyleArchive_default_instance_;
class ChartStyleArchive;
struct ChartStyleArchiveDefaultTypeInternal;
extern ChartStyleArchiveDefaultTypeInternal _ChartStyleArchive_default_instance_;
class ChartsNSArrayOfNSNumberDoubleArchive;
struct ChartsNSArrayOfNSNumberDoubleArchiveDefaultTypeInternal;
extern ChartsNSArrayOfNSNumberDoubleArchiveDefaultTypeInternal _ChartsNSArrayOfNSNumberDoubleArchive_default_instance_;
class ChartsNSNumberDoubleArchive;
struct ChartsNSNumberDoubleArchiveDefaultTypeInternal;
extern ChartsNSNumberDoubleArchiveDefaultTypeInternal _ChartsNSNumberDoubleArchive_default_instance_;
class DEPRECATEDChart3DFillArchive;
struct DEPRECATEDChart3DFillArchiveDefaultTypeInternal;
extern DEPRECATEDChart3DFillArchiveDefaultTypeInternal _DEPRECATEDChart3DFillArchive_default_instance_;
class LegendNonStyleArchive;
struct LegendNonStyleArchiveDefaultTypeInternal;
extern LegendNonStyleArchiveDefaultTypeInternal _LegendNonStyleArchive_default_instance_;
class LegendStyleArchive;
struct LegendStyleArchiveDefaultTypeInternal;
extern LegendStyleArchiveDefaultTypeInternal _LegendStyleArchive_default_instance_;
class RectArchive;
struct RectArchiveDefaultTypeInternal;
extern RectArchiveDefaultTypeInternal _RectArchive_default_instance_;
class SparseReferenceArrayArchive;
struct SparseReferenceArrayArchiveDefaultTypeInternal;
extern SparseReferenceArrayArchiveDefaultTypeInternal _SparseReferenceArrayArchive_default_instance_;
class SparseReferenceArrayArchive_Entry;
struct SparseReferenceArrayArchive_EntryDefaultTypeInternal;
extern SparseReferenceArrayArchive_EntryDefaultTypeInternal _SparseReferenceArrayArchive_Entry_default_instance_;
}  // namespace TSCH
PROTOBUF_NAMESPACE_OPEN
template<> ::TSCH::ChartAxisNonStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartAxisNonStyleArchive>(Arena*);
template<> ::TSCH::ChartAxisStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartAxisStyleArchive>(Arena*);
template<> ::TSCH::ChartNonStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartNonStyleArchive>(Arena*);
template<> ::TSCH::ChartSeriesNonStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartSeriesNonStyleArchive>(Arena*);
template<> ::TSCH::ChartSeriesStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartSeriesStyleArchive>(Arena*);
template<> ::TSCH::ChartStyleArchive* Arena::CreateMaybeMessage<::TSCH::ChartStyleArchive>(Arena*);
template<> ::TSCH::ChartsNSArrayOfNSNumberDoubleArchive* Arena::CreateMaybeMessage<::TSCH::ChartsNSArrayOfNSNumberDoubleArchive>(Arena*);
template<> ::TSCH::ChartsNSNumberDoubleArchive* Arena::CreateMaybeMessage<::TSCH::ChartsNSNumberDoubleArchive>(Arena*);
template<> ::TSCH::DEPRECATEDChart3DFillArchive* Arena::CreateMaybeMessage<::TSCH::DEPRECATEDChart3DFillArchive>(Arena*);
template<> ::TSCH::LegendNonStyleArchive* Arena::CreateMaybeMessage<::TSCH::LegendNonStyleArchive>(Arena*);
template<> ::TSCH::LegendStyleArchive* Arena::CreateMaybeMessage<::TSCH::LegendStyleArchive>(Arena*);
template<> ::TSCH::RectArchive* Arena::CreateMaybeMessage<::TSCH::RectArchive>(Arena*);
template<> ::TSCH::SparseReferenceArrayArchive* Arena::CreateMaybeMessage<::TSCH::SparseReferenceArrayArchive>(Arena*);
template<> ::TSCH::SparseReferenceArrayArchive_Entry* Arena::CreateMaybeMessage<::TSCH::SparseReferenceArrayArchive_Entry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSCH {

enum ChartType : int {
  undefinedChartType = 0,
  columnChartType2D = 1,
  barChartType2D = 2,
  lineChartType2D = 3,
  areaChartType2D = 4,
  pieChartType2D = 5,
  stackedColumnChartType2D = 6,
  stackedBarChartType2D = 7,
  stackedAreaChartType2D = 8,
  scatterChartType2D = 9,
  mixedChartType2D = 10,
  twoAxisChartType2D = 11,
  columnChartType3D = 12,
  barChartType3D = 13,
  lineChartType3D = 14,
  areaChartType3D = 15,
  pieChartType3D = 16,
  stackedColumnChartType3D = 17,
  stackedBarChartType3D = 18,
  stackedAreaChartType3D = 19,
  multiDataColumnChartType2D = 20,
  multiDataBarChartType2D = 21,
  bubbleChartType2D = 22,
  multiDataScatterChartType2D = 23,
  multiDataBubbleChartType2D = 24
};
bool ChartType_IsValid(int value);
constexpr ChartType ChartType_MIN = undefinedChartType;
constexpr ChartType ChartType_MAX = multiDataBubbleChartType2D;
constexpr int ChartType_ARRAYSIZE = ChartType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChartType_descriptor();
template<typename T>
inline const std::string& ChartType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChartType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChartType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChartType_descriptor(), enum_t_value);
}
inline bool ChartType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChartType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChartType>(
    ChartType_descriptor(), name, value);
}
enum AxisType : int {
  axis_type_unknown = 0,
  axis_type_x = 1,
  axis_type_y = 2,
  axis_type_pie = 3,
  axis_type_size = 4
};
bool AxisType_IsValid(int value);
constexpr AxisType AxisType_MIN = axis_type_unknown;
constexpr AxisType AxisType_MAX = axis_type_size;
constexpr int AxisType_ARRAYSIZE = AxisType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AxisType_descriptor();
template<typename T>
inline const std::string& AxisType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AxisType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AxisType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AxisType_descriptor(), enum_t_value);
}
inline bool AxisType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AxisType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AxisType>(
    AxisType_descriptor(), name, value);
}
enum ScatterFormat : int {
  scatter_format_unknown = 0,
  scatter_format_separate_x = 1,
  scatter_format_shared_x = 2
};
bool ScatterFormat_IsValid(int value);
constexpr ScatterFormat ScatterFormat_MIN = scatter_format_unknown;
constexpr ScatterFormat ScatterFormat_MAX = scatter_format_shared_x;
constexpr int ScatterFormat_ARRAYSIZE = ScatterFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScatterFormat_descriptor();
template<typename T>
inline const std::string& ScatterFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScatterFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScatterFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScatterFormat_descriptor(), enum_t_value);
}
inline bool ScatterFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScatterFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScatterFormat>(
    ScatterFormat_descriptor(), name, value);
}
enum SeriesDirection : int {
  series_direction_unknown = 0,
  series_direction_by_row = 1,
  series_direction_by_column = 2
};
bool SeriesDirection_IsValid(int value);
constexpr SeriesDirection SeriesDirection_MIN = series_direction_unknown;
constexpr SeriesDirection SeriesDirection_MAX = series_direction_by_column;
constexpr int SeriesDirection_ARRAYSIZE = SeriesDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SeriesDirection_descriptor();
template<typename T>
inline const std::string& SeriesDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SeriesDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SeriesDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SeriesDirection_descriptor(), enum_t_value);
}
inline bool SeriesDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SeriesDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SeriesDirection>(
    SeriesDirection_descriptor(), name, value);
}
enum NumberValueType : int {
  numberValueTypeDecimal = 0,
  numberValueTypeCurrency = 1,
  numberValueTypePercentage = 2,
  numberValueTypeScientific = 3,
  numberValueTypeFraction = 4,
  numberValueTypeBase = 5,
  numberValueTypeUnknown = -999
};
bool NumberValueType_IsValid(int value);
constexpr NumberValueType NumberValueType_MIN = numberValueTypeUnknown;
constexpr NumberValueType NumberValueType_MAX = numberValueTypeBase;
constexpr int NumberValueType_ARRAYSIZE = NumberValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NumberValueType_descriptor();
template<typename T>
inline const std::string& NumberValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NumberValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NumberValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NumberValueType_descriptor(), enum_t_value);
}
inline bool NumberValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NumberValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NumberValueType>(
    NumberValueType_descriptor(), name, value);
}
enum NegativeNumberStyle : int {
  negativeNumberStyleMinus = 0,
  negativeNumberStyleRed = 1,
  negativeNumberStyleParentheses = 2,
  negativeNumberStyleRedAndParentheses = 3,
  negativeNumberStyleNone = 4
};
bool NegativeNumberStyle_IsValid(int value);
constexpr NegativeNumberStyle NegativeNumberStyle_MIN = negativeNumberStyleMinus;
constexpr NegativeNumberStyle NegativeNumberStyle_MAX = negativeNumberStyleNone;
constexpr int NegativeNumberStyle_ARRAYSIZE = NegativeNumberStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NegativeNumberStyle_descriptor();
template<typename T>
inline const std::string& NegativeNumberStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NegativeNumberStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NegativeNumberStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NegativeNumberStyle_descriptor(), enum_t_value);
}
inline bool NegativeNumberStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NegativeNumberStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NegativeNumberStyle>(
    NegativeNumberStyle_descriptor(), name, value);
}
enum FractionAccuracy : int {
  fractionAccuracyConflicting = 0,
  fractionAccuracyUpToOneDigit = -1,
  fractionAccuracyUpToTwoDigits = -2,
  fractionAccuracyUpToThreeDigits = -3,
  fractionAccuracyHalves = 2,
  fractionAccuracyQuarters = 4,
  fractionAccuracyEighths = 8,
  fractionAccuracySixteenths = 16,
  fractionAccuracyTenths = 10,
  fractionAccuracyHundredths = 100
};
bool FractionAccuracy_IsValid(int value);
constexpr FractionAccuracy FractionAccuracy_MIN = fractionAccuracyUpToThreeDigits;
constexpr FractionAccuracy FractionAccuracy_MAX = fractionAccuracyHundredths;
constexpr int FractionAccuracy_ARRAYSIZE = FractionAccuracy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FractionAccuracy_descriptor();
template<typename T>
inline const std::string& FractionAccuracy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FractionAccuracy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FractionAccuracy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FractionAccuracy_descriptor(), enum_t_value);
}
inline bool FractionAccuracy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FractionAccuracy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FractionAccuracy>(
    FractionAccuracy_descriptor(), name, value);
}
// ===================================================================

class SparseReferenceArrayArchive_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.SparseReferenceArrayArchive.Entry) */ {
 public:
  inline SparseReferenceArrayArchive_Entry() : SparseReferenceArrayArchive_Entry(nullptr) {}
  ~SparseReferenceArrayArchive_Entry() override;
  explicit PROTOBUF_CONSTEXPR SparseReferenceArrayArchive_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SparseReferenceArrayArchive_Entry(const SparseReferenceArrayArchive_Entry& from);
  SparseReferenceArrayArchive_Entry(SparseReferenceArrayArchive_Entry&& from) noexcept
    : SparseReferenceArrayArchive_Entry() {
    *this = ::std::move(from);
  }

  inline SparseReferenceArrayArchive_Entry& operator=(const SparseReferenceArrayArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseReferenceArrayArchive_Entry& operator=(SparseReferenceArrayArchive_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseReferenceArrayArchive_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const SparseReferenceArrayArchive_Entry* internal_default_instance() {
    return reinterpret_cast<const SparseReferenceArrayArchive_Entry*>(
               &_SparseReferenceArrayArchive_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SparseReferenceArrayArchive_Entry& a, SparseReferenceArrayArchive_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(SparseReferenceArrayArchive_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseReferenceArrayArchive_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseReferenceArrayArchive_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SparseReferenceArrayArchive_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SparseReferenceArrayArchive_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SparseReferenceArrayArchive_Entry& from) {
    SparseReferenceArrayArchive_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseReferenceArrayArchive_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.SparseReferenceArrayArchive.Entry";
  }
  protected:
  explicit SparseReferenceArrayArchive_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // required .TSP.Reference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::TSP::Reference& value() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_value();
  ::TSP::Reference* mutable_value();
  void set_allocated_value(::TSP::Reference* value);
  private:
  const ::TSP::Reference& _internal_value() const;
  ::TSP::Reference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::TSP::Reference* value);
  ::TSP::Reference* unsafe_arena_release_value();

  // required uint32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSCH.SparseReferenceArrayArchive.Entry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* value_;
    uint32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class SparseReferenceArrayArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.SparseReferenceArrayArchive) */ {
 public:
  inline SparseReferenceArrayArchive() : SparseReferenceArrayArchive(nullptr) {}
  ~SparseReferenceArrayArchive() override;
  explicit PROTOBUF_CONSTEXPR SparseReferenceArrayArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SparseReferenceArrayArchive(const SparseReferenceArrayArchive& from);
  SparseReferenceArrayArchive(SparseReferenceArrayArchive&& from) noexcept
    : SparseReferenceArrayArchive() {
    *this = ::std::move(from);
  }

  inline SparseReferenceArrayArchive& operator=(const SparseReferenceArrayArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseReferenceArrayArchive& operator=(SparseReferenceArrayArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SparseReferenceArrayArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SparseReferenceArrayArchive* internal_default_instance() {
    return reinterpret_cast<const SparseReferenceArrayArchive*>(
               &_SparseReferenceArrayArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SparseReferenceArrayArchive& a, SparseReferenceArrayArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SparseReferenceArrayArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseReferenceArrayArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SparseReferenceArrayArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SparseReferenceArrayArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SparseReferenceArrayArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SparseReferenceArrayArchive& from) {
    SparseReferenceArrayArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseReferenceArrayArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.SparseReferenceArrayArchive";
  }
  protected:
  explicit SparseReferenceArrayArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SparseReferenceArrayArchive_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
    kNumEntriesFieldNumber = 1,
  };
  // repeated .TSCH.SparseReferenceArrayArchive.Entry entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::TSCH::SparseReferenceArrayArchive_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >*
      mutable_entries();
  private:
  const ::TSCH::SparseReferenceArrayArchive_Entry& _internal_entries(int index) const;
  ::TSCH::SparseReferenceArrayArchive_Entry* _internal_add_entries();
  public:
  const ::TSCH::SparseReferenceArrayArchive_Entry& entries(int index) const;
  ::TSCH::SparseReferenceArrayArchive_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >&
      entries() const;

  // required uint32 num_entries = 1;
  bool has_num_entries() const;
  private:
  bool _internal_has_num_entries() const;
  public:
  void clear_num_entries();
  uint32_t num_entries() const;
  void set_num_entries(uint32_t value);
  private:
  uint32_t _internal_num_entries() const;
  void _internal_set_num_entries(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSCH.SparseReferenceArrayArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry > entries_;
    uint32_t num_entries_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class RectArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.RectArchive) */ {
 public:
  inline RectArchive() : RectArchive(nullptr) {}
  ~RectArchive() override;
  explicit PROTOBUF_CONSTEXPR RectArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RectArchive(const RectArchive& from);
  RectArchive(RectArchive&& from) noexcept
    : RectArchive() {
    *this = ::std::move(from);
  }

  inline RectArchive& operator=(const RectArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectArchive& operator=(RectArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectArchive* internal_default_instance() {
    return reinterpret_cast<const RectArchive*>(
               &_RectArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RectArchive& a, RectArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RectArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RectArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RectArchive& from) {
    RectArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.RectArchive";
  }
  protected:
  explicit RectArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required .TSP.Point origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::TSP::Point& origin() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_origin();
  ::TSP::Point* mutable_origin();
  void set_allocated_origin(::TSP::Point* origin);
  private:
  const ::TSP::Point& _internal_origin() const;
  ::TSP::Point* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::TSP::Point* origin);
  ::TSP::Point* unsafe_arena_release_origin();

  // required .TSP.Size size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::TSP::Size& size() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_size();
  ::TSP::Size* mutable_size();
  void set_allocated_size(::TSP::Size* size);
  private:
  const ::TSP::Size& _internal_size() const;
  ::TSP::Size* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::TSP::Size* size);
  ::TSP::Size* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:TSCH.RectArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Point* origin_;
    ::TSP::Size* size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartsNSNumberDoubleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartsNSNumberDoubleArchive) */ {
 public:
  inline ChartsNSNumberDoubleArchive() : ChartsNSNumberDoubleArchive(nullptr) {}
  ~ChartsNSNumberDoubleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartsNSNumberDoubleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartsNSNumberDoubleArchive(const ChartsNSNumberDoubleArchive& from);
  ChartsNSNumberDoubleArchive(ChartsNSNumberDoubleArchive&& from) noexcept
    : ChartsNSNumberDoubleArchive() {
    *this = ::std::move(from);
  }

  inline ChartsNSNumberDoubleArchive& operator=(const ChartsNSNumberDoubleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartsNSNumberDoubleArchive& operator=(ChartsNSNumberDoubleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartsNSNumberDoubleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartsNSNumberDoubleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartsNSNumberDoubleArchive*>(
               &_ChartsNSNumberDoubleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChartsNSNumberDoubleArchive& a, ChartsNSNumberDoubleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartsNSNumberDoubleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartsNSNumberDoubleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartsNSNumberDoubleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartsNSNumberDoubleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartsNSNumberDoubleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartsNSNumberDoubleArchive& from) {
    ChartsNSNumberDoubleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartsNSNumberDoubleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartsNSNumberDoubleArchive";
  }
  protected:
  explicit ChartsNSNumberDoubleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberArchiveFieldNumber = 1,
  };
  // optional double number_archive = 1;
  bool has_number_archive() const;
  private:
  bool _internal_has_number_archive() const;
  public:
  void clear_number_archive();
  double number_archive() const;
  void set_number_archive(double value);
  private:
  double _internal_number_archive() const;
  void _internal_set_number_archive(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSCH.ChartsNSNumberDoubleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double number_archive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartsNSArrayOfNSNumberDoubleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartsNSArrayOfNSNumberDoubleArchive) */ {
 public:
  inline ChartsNSArrayOfNSNumberDoubleArchive() : ChartsNSArrayOfNSNumberDoubleArchive(nullptr) {}
  ~ChartsNSArrayOfNSNumberDoubleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartsNSArrayOfNSNumberDoubleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartsNSArrayOfNSNumberDoubleArchive(const ChartsNSArrayOfNSNumberDoubleArchive& from);
  ChartsNSArrayOfNSNumberDoubleArchive(ChartsNSArrayOfNSNumberDoubleArchive&& from) noexcept
    : ChartsNSArrayOfNSNumberDoubleArchive() {
    *this = ::std::move(from);
  }

  inline ChartsNSArrayOfNSNumberDoubleArchive& operator=(const ChartsNSArrayOfNSNumberDoubleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartsNSArrayOfNSNumberDoubleArchive& operator=(ChartsNSArrayOfNSNumberDoubleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartsNSArrayOfNSNumberDoubleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartsNSArrayOfNSNumberDoubleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartsNSArrayOfNSNumberDoubleArchive*>(
               &_ChartsNSArrayOfNSNumberDoubleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChartsNSArrayOfNSNumberDoubleArchive& a, ChartsNSArrayOfNSNumberDoubleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartsNSArrayOfNSNumberDoubleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartsNSArrayOfNSNumberDoubleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartsNSArrayOfNSNumberDoubleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartsNSArrayOfNSNumberDoubleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartsNSArrayOfNSNumberDoubleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartsNSArrayOfNSNumberDoubleArchive& from) {
    ChartsNSArrayOfNSNumberDoubleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartsNSArrayOfNSNumberDoubleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartsNSArrayOfNSNumberDoubleArchive";
  }
  protected:
  explicit ChartsNSArrayOfNSNumberDoubleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumbersFieldNumber = 1,
  };
  // repeated double numbers = 1;
  int numbers_size() const;
  private:
  int _internal_numbers_size() const;
  public:
  void clear_numbers();
  private:
  double _internal_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_numbers() const;
  void _internal_add_numbers(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_numbers();
  public:
  double numbers(int index) const;
  void set_numbers(int index, double value);
  void add_numbers(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_numbers();

  // @@protoc_insertion_point(class_scope:TSCH.ChartsNSArrayOfNSNumberDoubleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > numbers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class DEPRECATEDChart3DFillArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.DEPRECATEDChart3DFillArchive) */ {
 public:
  inline DEPRECATEDChart3DFillArchive() : DEPRECATEDChart3DFillArchive(nullptr) {}
  ~DEPRECATEDChart3DFillArchive() override;
  explicit PROTOBUF_CONSTEXPR DEPRECATEDChart3DFillArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DEPRECATEDChart3DFillArchive(const DEPRECATEDChart3DFillArchive& from);
  DEPRECATEDChart3DFillArchive(DEPRECATEDChart3DFillArchive&& from) noexcept
    : DEPRECATEDChart3DFillArchive() {
    *this = ::std::move(from);
  }

  inline DEPRECATEDChart3DFillArchive& operator=(const DEPRECATEDChart3DFillArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DEPRECATEDChart3DFillArchive& operator=(DEPRECATEDChart3DFillArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DEPRECATEDChart3DFillArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DEPRECATEDChart3DFillArchive* internal_default_instance() {
    return reinterpret_cast<const DEPRECATEDChart3DFillArchive*>(
               &_DEPRECATEDChart3DFillArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DEPRECATEDChart3DFillArchive& a, DEPRECATEDChart3DFillArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DEPRECATEDChart3DFillArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DEPRECATEDChart3DFillArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DEPRECATEDChart3DFillArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DEPRECATEDChart3DFillArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DEPRECATEDChart3DFillArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DEPRECATEDChart3DFillArchive& from) {
    DEPRECATEDChart3DFillArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DEPRECATEDChart3DFillArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.DEPRECATEDChart3DFillArchive";
  }
  protected:
  explicit DEPRECATEDChart3DFillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTexturesetIdFieldNumber = 3,
    kFillFieldNumber = 1,
    kLightingmodelFieldNumber = 2,
    kFillTypeFieldNumber = 4,
    kSeriesIndexFieldNumber = 5,
  };
  // optional string textureset_id = 3;
  bool has_textureset_id() const;
  private:
  bool _internal_has_textureset_id() const;
  public:
  void clear_textureset_id();
  const std::string& textureset_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_textureset_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_textureset_id();
  PROTOBUF_NODISCARD std::string* release_textureset_id();
  void set_allocated_textureset_id(std::string* textureset_id);
  private:
  const std::string& _internal_textureset_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_textureset_id(const std::string& value);
  std::string* _internal_mutable_textureset_id();
  public:

  // optional .TSD.FillArchive fill = 1;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::TSD::FillArchive& fill() const;
  PROTOBUF_NODISCARD ::TSD::FillArchive* release_fill();
  ::TSD::FillArchive* mutable_fill();
  void set_allocated_fill(::TSD::FillArchive* fill);
  private:
  const ::TSD::FillArchive& _internal_fill() const;
  ::TSD::FillArchive* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::TSD::FillArchive* fill);
  ::TSD::FillArchive* unsafe_arena_release_fill();

  // optional .TSCH.Chart3DLightingModelArchive lightingmodel = 2;
  bool has_lightingmodel() const;
  private:
  bool _internal_has_lightingmodel() const;
  public:
  void clear_lightingmodel();
  const ::TSCH::Chart3DLightingModelArchive& lightingmodel() const;
  PROTOBUF_NODISCARD ::TSCH::Chart3DLightingModelArchive* release_lightingmodel();
  ::TSCH::Chart3DLightingModelArchive* mutable_lightingmodel();
  void set_allocated_lightingmodel(::TSCH::Chart3DLightingModelArchive* lightingmodel);
  private:
  const ::TSCH::Chart3DLightingModelArchive& _internal_lightingmodel() const;
  ::TSCH::Chart3DLightingModelArchive* _internal_mutable_lightingmodel();
  public:
  void unsafe_arena_set_allocated_lightingmodel(
      ::TSCH::Chart3DLightingModelArchive* lightingmodel);
  ::TSCH::Chart3DLightingModelArchive* unsafe_arena_release_lightingmodel();

  // optional .TSCH.FillPropertyType fill_type = 4;
  bool has_fill_type() const;
  private:
  bool _internal_has_fill_type() const;
  public:
  void clear_fill_type();
  ::TSCH::FillPropertyType fill_type() const;
  void set_fill_type(::TSCH::FillPropertyType value);
  private:
  ::TSCH::FillPropertyType _internal_fill_type() const;
  void _internal_set_fill_type(::TSCH::FillPropertyType value);
  public:

  // optional uint32 series_index = 5;
  bool has_series_index() const;
  private:
  bool _internal_has_series_index() const;
  public:
  void clear_series_index();
  uint32_t series_index() const;
  void set_series_index(uint32_t value);
  private:
  uint32_t _internal_series_index() const;
  void _internal_set_series_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSCH.DEPRECATEDChart3DFillArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textureset_id_;
    ::TSD::FillArchive* fill_;
    ::TSCH::Chart3DLightingModelArchive* lightingmodel_;
    int fill_type_;
    uint32_t series_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartStyleArchive) */ {
 public:
  inline ChartStyleArchive() : ChartStyleArchive(nullptr) {}
  ~ChartStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartStyleArchive(const ChartStyleArchive& from);
  ChartStyleArchive(ChartStyleArchive&& from) noexcept
    : ChartStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartStyleArchive& operator=(const ChartStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartStyleArchive& operator=(ChartStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartStyleArchive*>(
               &_ChartStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChartStyleArchive& a, ChartStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartStyleArchive& from) {
    ChartStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartStyleArchive";
  }
  protected:
  explicit ChartStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartNonStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartNonStyleArchive) */ {
 public:
  inline ChartNonStyleArchive() : ChartNonStyleArchive(nullptr) {}
  ~ChartNonStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartNonStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartNonStyleArchive(const ChartNonStyleArchive& from);
  ChartNonStyleArchive(ChartNonStyleArchive&& from) noexcept
    : ChartNonStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartNonStyleArchive& operator=(const ChartNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartNonStyleArchive& operator=(ChartNonStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartNonStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartNonStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartNonStyleArchive*>(
               &_ChartNonStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChartNonStyleArchive& a, ChartNonStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartNonStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartNonStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartNonStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartNonStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartNonStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartNonStyleArchive& from) {
    ChartNonStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartNonStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartNonStyleArchive";
  }
  protected:
  explicit ChartNonStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartNonStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class LegendStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.LegendStyleArchive) */ {
 public:
  inline LegendStyleArchive() : LegendStyleArchive(nullptr) {}
  ~LegendStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR LegendStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LegendStyleArchive(const LegendStyleArchive& from);
  LegendStyleArchive(LegendStyleArchive&& from) noexcept
    : LegendStyleArchive() {
    *this = ::std::move(from);
  }

  inline LegendStyleArchive& operator=(const LegendStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegendStyleArchive& operator=(LegendStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegendStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegendStyleArchive* internal_default_instance() {
    return reinterpret_cast<const LegendStyleArchive*>(
               &_LegendStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LegendStyleArchive& a, LegendStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(LegendStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegendStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegendStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegendStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LegendStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LegendStyleArchive& from) {
    LegendStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegendStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.LegendStyleArchive";
  }
  protected:
  explicit LegendStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.LegendStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class LegendNonStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.LegendNonStyleArchive) */ {
 public:
  inline LegendNonStyleArchive() : LegendNonStyleArchive(nullptr) {}
  ~LegendNonStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR LegendNonStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LegendNonStyleArchive(const LegendNonStyleArchive& from);
  LegendNonStyleArchive(LegendNonStyleArchive&& from) noexcept
    : LegendNonStyleArchive() {
    *this = ::std::move(from);
  }

  inline LegendNonStyleArchive& operator=(const LegendNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegendNonStyleArchive& operator=(LegendNonStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LegendNonStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LegendNonStyleArchive* internal_default_instance() {
    return reinterpret_cast<const LegendNonStyleArchive*>(
               &_LegendNonStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LegendNonStyleArchive& a, LegendNonStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(LegendNonStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegendNonStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LegendNonStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LegendNonStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LegendNonStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LegendNonStyleArchive& from) {
    LegendNonStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegendNonStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.LegendNonStyleArchive";
  }
  protected:
  explicit LegendNonStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          LegendNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.LegendNonStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartAxisStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartAxisStyleArchive) */ {
 public:
  inline ChartAxisStyleArchive() : ChartAxisStyleArchive(nullptr) {}
  ~ChartAxisStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartAxisStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartAxisStyleArchive(const ChartAxisStyleArchive& from);
  ChartAxisStyleArchive(ChartAxisStyleArchive&& from) noexcept
    : ChartAxisStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartAxisStyleArchive& operator=(const ChartAxisStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxisStyleArchive& operator=(ChartAxisStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxisStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxisStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartAxisStyleArchive*>(
               &_ChartAxisStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChartAxisStyleArchive& a, ChartAxisStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxisStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxisStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxisStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxisStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartAxisStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartAxisStyleArchive& from) {
    ChartAxisStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartAxisStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartAxisStyleArchive";
  }
  protected:
  explicit ChartAxisStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartAxisStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartAxisNonStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartAxisNonStyleArchive) */ {
 public:
  inline ChartAxisNonStyleArchive() : ChartAxisNonStyleArchive(nullptr) {}
  ~ChartAxisNonStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartAxisNonStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartAxisNonStyleArchive(const ChartAxisNonStyleArchive& from);
  ChartAxisNonStyleArchive(ChartAxisNonStyleArchive&& from) noexcept
    : ChartAxisNonStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartAxisNonStyleArchive& operator=(const ChartAxisNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartAxisNonStyleArchive& operator=(ChartAxisNonStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartAxisNonStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartAxisNonStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartAxisNonStyleArchive*>(
               &_ChartAxisNonStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChartAxisNonStyleArchive& a, ChartAxisNonStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartAxisNonStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartAxisNonStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartAxisNonStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartAxisNonStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartAxisNonStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartAxisNonStyleArchive& from) {
    ChartAxisNonStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartAxisNonStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartAxisNonStyleArchive";
  }
  protected:
  explicit ChartAxisNonStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartAxisNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartAxisNonStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartSeriesStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartSeriesStyleArchive) */ {
 public:
  inline ChartSeriesStyleArchive() : ChartSeriesStyleArchive(nullptr) {}
  ~ChartSeriesStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartSeriesStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartSeriesStyleArchive(const ChartSeriesStyleArchive& from);
  ChartSeriesStyleArchive(ChartSeriesStyleArchive&& from) noexcept
    : ChartSeriesStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartSeriesStyleArchive& operator=(const ChartSeriesStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartSeriesStyleArchive& operator=(ChartSeriesStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartSeriesStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartSeriesStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartSeriesStyleArchive*>(
               &_ChartSeriesStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChartSeriesStyleArchive& a, ChartSeriesStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartSeriesStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartSeriesStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartSeriesStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartSeriesStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartSeriesStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartSeriesStyleArchive& from) {
    ChartSeriesStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartSeriesStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartSeriesStyleArchive";
  }
  protected:
  explicit ChartSeriesStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartSeriesStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class ChartSeriesNonStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSCH.ChartSeriesNonStyleArchive) */ {
 public:
  inline ChartSeriesNonStyleArchive() : ChartSeriesNonStyleArchive(nullptr) {}
  ~ChartSeriesNonStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ChartSeriesNonStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChartSeriesNonStyleArchive(const ChartSeriesNonStyleArchive& from);
  ChartSeriesNonStyleArchive(ChartSeriesNonStyleArchive&& from) noexcept
    : ChartSeriesNonStyleArchive() {
    *this = ::std::move(from);
  }

  inline ChartSeriesNonStyleArchive& operator=(const ChartSeriesNonStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChartSeriesNonStyleArchive& operator=(ChartSeriesNonStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChartSeriesNonStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChartSeriesNonStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ChartSeriesNonStyleArchive*>(
               &_ChartSeriesNonStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChartSeriesNonStyleArchive& a, ChartSeriesNonStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ChartSeriesNonStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChartSeriesNonStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChartSeriesNonStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChartSeriesNonStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChartSeriesNonStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChartSeriesNonStyleArchive& from) {
    ChartSeriesNonStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChartSeriesNonStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSCH.ChartSeriesNonStyleArchive";
  }
  protected:
  explicit ChartSeriesNonStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // optional .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          ChartSeriesNonStyleArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSCH.ChartSeriesNonStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSCHArchives_2eCommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SparseReferenceArrayArchive_Entry

// required uint32 index = 1;
inline bool SparseReferenceArrayArchive_Entry::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SparseReferenceArrayArchive_Entry::has_index() const {
  return _internal_has_index();
}
inline void SparseReferenceArrayArchive_Entry::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SparseReferenceArrayArchive_Entry::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t SparseReferenceArrayArchive_Entry::index() const {
  // @@protoc_insertion_point(field_get:TSCH.SparseReferenceArrayArchive.Entry.index)
  return _internal_index();
}
inline void SparseReferenceArrayArchive_Entry::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.index_ = value;
}
inline void SparseReferenceArrayArchive_Entry::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:TSCH.SparseReferenceArrayArchive.Entry.index)
}

// required .TSP.Reference value = 2;
inline bool SparseReferenceArrayArchive_Entry::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool SparseReferenceArrayArchive_Entry::has_value() const {
  return _internal_has_value();
}
inline const ::TSP::Reference& SparseReferenceArrayArchive_Entry::_internal_value() const {
  const ::TSP::Reference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& SparseReferenceArrayArchive_Entry::value() const {
  // @@protoc_insertion_point(field_get:TSCH.SparseReferenceArrayArchive.Entry.value)
  return _internal_value();
}
inline void SparseReferenceArrayArchive_Entry::unsafe_arena_set_allocated_value(
    ::TSP::Reference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.SparseReferenceArrayArchive.Entry.value)
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::release_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:TSCH.SparseReferenceArrayArchive.Entry.value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::TSP::Reference* SparseReferenceArrayArchive_Entry::mutable_value() {
  ::TSP::Reference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TSCH.SparseReferenceArrayArchive.Entry.value)
  return _msg;
}
inline void SparseReferenceArrayArchive_Entry::set_allocated_value(::TSP::Reference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:TSCH.SparseReferenceArrayArchive.Entry.value)
}

// -------------------------------------------------------------------

// SparseReferenceArrayArchive

// required uint32 num_entries = 1;
inline bool SparseReferenceArrayArchive::_internal_has_num_entries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SparseReferenceArrayArchive::has_num_entries() const {
  return _internal_has_num_entries();
}
inline void SparseReferenceArrayArchive::clear_num_entries() {
  _impl_.num_entries_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SparseReferenceArrayArchive::_internal_num_entries() const {
  return _impl_.num_entries_;
}
inline uint32_t SparseReferenceArrayArchive::num_entries() const {
  // @@protoc_insertion_point(field_get:TSCH.SparseReferenceArrayArchive.num_entries)
  return _internal_num_entries();
}
inline void SparseReferenceArrayArchive::_internal_set_num_entries(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.num_entries_ = value;
}
inline void SparseReferenceArrayArchive::set_num_entries(uint32_t value) {
  _internal_set_num_entries(value);
  // @@protoc_insertion_point(field_set:TSCH.SparseReferenceArrayArchive.num_entries)
}

// repeated .TSCH.SparseReferenceArrayArchive.Entry entries = 2;
inline int SparseReferenceArrayArchive::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int SparseReferenceArrayArchive::entries_size() const {
  return _internal_entries_size();
}
inline void SparseReferenceArrayArchive::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::TSCH::SparseReferenceArrayArchive_Entry* SparseReferenceArrayArchive::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TSCH.SparseReferenceArrayArchive.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >*
SparseReferenceArrayArchive::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TSCH.SparseReferenceArrayArchive.entries)
  return &_impl_.entries_;
}
inline const ::TSCH::SparseReferenceArrayArchive_Entry& SparseReferenceArrayArchive::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::TSCH::SparseReferenceArrayArchive_Entry& SparseReferenceArrayArchive::entries(int index) const {
  // @@protoc_insertion_point(field_get:TSCH.SparseReferenceArrayArchive.entries)
  return _internal_entries(index);
}
inline ::TSCH::SparseReferenceArrayArchive_Entry* SparseReferenceArrayArchive::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::TSCH::SparseReferenceArrayArchive_Entry* SparseReferenceArrayArchive::add_entries() {
  ::TSCH::SparseReferenceArrayArchive_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:TSCH.SparseReferenceArrayArchive.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCH::SparseReferenceArrayArchive_Entry >&
SparseReferenceArrayArchive::entries() const {
  // @@protoc_insertion_point(field_list:TSCH.SparseReferenceArrayArchive.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// RectArchive

// required .TSP.Point origin = 1;
inline bool RectArchive::_internal_has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline bool RectArchive::has_origin() const {
  return _internal_has_origin();
}
inline const ::TSP::Point& RectArchive::_internal_origin() const {
  const ::TSP::Point* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& RectArchive::origin() const {
  // @@protoc_insertion_point(field_get:TSCH.RectArchive.origin)
  return _internal_origin();
}
inline void RectArchive::unsafe_arena_set_allocated_origin(
    ::TSP::Point* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = origin;
  if (origin) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.RectArchive.origin)
}
inline ::TSP::Point* RectArchive::release_origin() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* RectArchive::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:TSCH.RectArchive.origin)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::TSP::Point* RectArchive::_internal_mutable_origin() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.origin_ = p;
  }
  return _impl_.origin_;
}
inline ::TSP::Point* RectArchive::mutable_origin() {
  ::TSP::Point* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:TSCH.RectArchive.origin)
  return _msg;
}
inline void RectArchive::set_allocated_origin(::TSP::Point* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin));
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:TSCH.RectArchive.origin)
}

// required .TSP.Size size = 2;
inline bool RectArchive::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_ != nullptr);
  return value;
}
inline bool RectArchive::has_size() const {
  return _internal_has_size();
}
inline const ::TSP::Size& RectArchive::_internal_size() const {
  const ::TSP::Size* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& RectArchive::size() const {
  // @@protoc_insertion_point(field_get:TSCH.RectArchive.size)
  return _internal_size();
}
inline void RectArchive::unsafe_arena_set_allocated_size(
    ::TSP::Size* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.RectArchive.size)
}
inline ::TSP::Size* RectArchive::release_size() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* RectArchive::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:TSCH.RectArchive.size)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::TSP::Size* RectArchive::_internal_mutable_size() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::TSP::Size* RectArchive::mutable_size() {
  ::TSP::Size* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:TSCH.RectArchive.size)
  return _msg;
}
inline void RectArchive::set_allocated_size(::TSP::Size* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size));
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:TSCH.RectArchive.size)
}

// -------------------------------------------------------------------

// ChartsNSNumberDoubleArchive

// optional double number_archive = 1;
inline bool ChartsNSNumberDoubleArchive::_internal_has_number_archive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChartsNSNumberDoubleArchive::has_number_archive() const {
  return _internal_has_number_archive();
}
inline void ChartsNSNumberDoubleArchive::clear_number_archive() {
  _impl_.number_archive_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double ChartsNSNumberDoubleArchive::_internal_number_archive() const {
  return _impl_.number_archive_;
}
inline double ChartsNSNumberDoubleArchive::number_archive() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartsNSNumberDoubleArchive.number_archive)
  return _internal_number_archive();
}
inline void ChartsNSNumberDoubleArchive::_internal_set_number_archive(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.number_archive_ = value;
}
inline void ChartsNSNumberDoubleArchive::set_number_archive(double value) {
  _internal_set_number_archive(value);
  // @@protoc_insertion_point(field_set:TSCH.ChartsNSNumberDoubleArchive.number_archive)
}

// -------------------------------------------------------------------

// ChartsNSArrayOfNSNumberDoubleArchive

// repeated double numbers = 1;
inline int ChartsNSArrayOfNSNumberDoubleArchive::_internal_numbers_size() const {
  return _impl_.numbers_.size();
}
inline int ChartsNSArrayOfNSNumberDoubleArchive::numbers_size() const {
  return _internal_numbers_size();
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::clear_numbers() {
  _impl_.numbers_.Clear();
}
inline double ChartsNSArrayOfNSNumberDoubleArchive::_internal_numbers(int index) const {
  return _impl_.numbers_.Get(index);
}
inline double ChartsNSArrayOfNSNumberDoubleArchive::numbers(int index) const {
  // @@protoc_insertion_point(field_get:TSCH.ChartsNSArrayOfNSNumberDoubleArchive.numbers)
  return _internal_numbers(index);
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::set_numbers(int index, double value) {
  _impl_.numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSCH.ChartsNSArrayOfNSNumberDoubleArchive.numbers)
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::_internal_add_numbers(double value) {
  _impl_.numbers_.Add(value);
}
inline void ChartsNSArrayOfNSNumberDoubleArchive::add_numbers(double value) {
  _internal_add_numbers(value);
  // @@protoc_insertion_point(field_add:TSCH.ChartsNSArrayOfNSNumberDoubleArchive.numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ChartsNSArrayOfNSNumberDoubleArchive::_internal_numbers() const {
  return _impl_.numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ChartsNSArrayOfNSNumberDoubleArchive::numbers() const {
  // @@protoc_insertion_point(field_list:TSCH.ChartsNSArrayOfNSNumberDoubleArchive.numbers)
  return _internal_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ChartsNSArrayOfNSNumberDoubleArchive::_internal_mutable_numbers() {
  return &_impl_.numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ChartsNSArrayOfNSNumberDoubleArchive::mutable_numbers() {
  // @@protoc_insertion_point(field_mutable_list:TSCH.ChartsNSArrayOfNSNumberDoubleArchive.numbers)
  return _internal_mutable_numbers();
}

// -------------------------------------------------------------------

// DEPRECATEDChart3DFillArchive

// optional .TSD.FillArchive fill = 1;
inline bool DEPRECATEDChart3DFillArchive::_internal_has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline bool DEPRECATEDChart3DFillArchive::has_fill() const {
  return _internal_has_fill();
}
inline const ::TSD::FillArchive& DEPRECATEDChart3DFillArchive::_internal_fill() const {
  const ::TSD::FillArchive* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& DEPRECATEDChart3DFillArchive::fill() const {
  // @@protoc_insertion_point(field_get:TSCH.DEPRECATEDChart3DFillArchive.fill)
  return _internal_fill();
}
inline void DEPRECATEDChart3DFillArchive::unsafe_arena_set_allocated_fill(
    ::TSD::FillArchive* fill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = fill;
  if (fill) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.DEPRECATEDChart3DFillArchive.fill)
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::release_fill() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:TSCH.DEPRECATEDChart3DFillArchive.fill)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::_internal_mutable_fill() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArenaForAllocation());
    _impl_.fill_ = p;
  }
  return _impl_.fill_;
}
inline ::TSD::FillArchive* DEPRECATEDChart3DFillArchive::mutable_fill() {
  ::TSD::FillArchive* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:TSCH.DEPRECATEDChart3DFillArchive.fill)
  return _msg;
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fill_);
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fill));
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:TSCH.DEPRECATEDChart3DFillArchive.fill)
}

// optional .TSCH.Chart3DLightingModelArchive lightingmodel = 2;
inline bool DEPRECATEDChart3DFillArchive::_internal_has_lightingmodel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lightingmodel_ != nullptr);
  return value;
}
inline bool DEPRECATEDChart3DFillArchive::has_lightingmodel() const {
  return _internal_has_lightingmodel();
}
inline const ::TSCH::Chart3DLightingModelArchive& DEPRECATEDChart3DFillArchive::_internal_lightingmodel() const {
  const ::TSCH::Chart3DLightingModelArchive* p = _impl_.lightingmodel_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCH::Chart3DLightingModelArchive&>(
      ::TSCH::_Chart3DLightingModelArchive_default_instance_);
}
inline const ::TSCH::Chart3DLightingModelArchive& DEPRECATEDChart3DFillArchive::lightingmodel() const {
  // @@protoc_insertion_point(field_get:TSCH.DEPRECATEDChart3DFillArchive.lightingmodel)
  return _internal_lightingmodel();
}
inline void DEPRECATEDChart3DFillArchive::unsafe_arena_set_allocated_lightingmodel(
    ::TSCH::Chart3DLightingModelArchive* lightingmodel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lightingmodel_);
  }
  _impl_.lightingmodel_ = lightingmodel;
  if (lightingmodel) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.DEPRECATEDChart3DFillArchive.lightingmodel)
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::release_lightingmodel() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCH::Chart3DLightingModelArchive* temp = _impl_.lightingmodel_;
  _impl_.lightingmodel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::unsafe_arena_release_lightingmodel() {
  // @@protoc_insertion_point(field_release:TSCH.DEPRECATEDChart3DFillArchive.lightingmodel)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCH::Chart3DLightingModelArchive* temp = _impl_.lightingmodel_;
  _impl_.lightingmodel_ = nullptr;
  return temp;
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::_internal_mutable_lightingmodel() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.lightingmodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCH::Chart3DLightingModelArchive>(GetArenaForAllocation());
    _impl_.lightingmodel_ = p;
  }
  return _impl_.lightingmodel_;
}
inline ::TSCH::Chart3DLightingModelArchive* DEPRECATEDChart3DFillArchive::mutable_lightingmodel() {
  ::TSCH::Chart3DLightingModelArchive* _msg = _internal_mutable_lightingmodel();
  // @@protoc_insertion_point(field_mutable:TSCH.DEPRECATEDChart3DFillArchive.lightingmodel)
  return _msg;
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_lightingmodel(::TSCH::Chart3DLightingModelArchive* lightingmodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lightingmodel_);
  }
  if (lightingmodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lightingmodel));
    if (message_arena != submessage_arena) {
      lightingmodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lightingmodel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.lightingmodel_ = lightingmodel;
  // @@protoc_insertion_point(field_set_allocated:TSCH.DEPRECATEDChart3DFillArchive.lightingmodel)
}

// optional string textureset_id = 3;
inline bool DEPRECATEDChart3DFillArchive::_internal_has_textureset_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DEPRECATEDChart3DFillArchive::has_textureset_id() const {
  return _internal_has_textureset_id();
}
inline void DEPRECATEDChart3DFillArchive::clear_textureset_id() {
  _impl_.textureset_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DEPRECATEDChart3DFillArchive::textureset_id() const {
  // @@protoc_insertion_point(field_get:TSCH.DEPRECATEDChart3DFillArchive.textureset_id)
  return _internal_textureset_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DEPRECATEDChart3DFillArchive::set_textureset_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.textureset_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSCH.DEPRECATEDChart3DFillArchive.textureset_id)
}
inline std::string* DEPRECATEDChart3DFillArchive::mutable_textureset_id() {
  std::string* _s = _internal_mutable_textureset_id();
  // @@protoc_insertion_point(field_mutable:TSCH.DEPRECATEDChart3DFillArchive.textureset_id)
  return _s;
}
inline const std::string& DEPRECATEDChart3DFillArchive::_internal_textureset_id() const {
  return _impl_.textureset_id_.Get();
}
inline void DEPRECATEDChart3DFillArchive::_internal_set_textureset_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.textureset_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DEPRECATEDChart3DFillArchive::_internal_mutable_textureset_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.textureset_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DEPRECATEDChart3DFillArchive::release_textureset_id() {
  // @@protoc_insertion_point(field_release:TSCH.DEPRECATEDChart3DFillArchive.textureset_id)
  if (!_internal_has_textureset_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.textureset_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textureset_id_.IsDefault()) {
    _impl_.textureset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DEPRECATEDChart3DFillArchive::set_allocated_textureset_id(std::string* textureset_id) {
  if (textureset_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.textureset_id_.SetAllocated(textureset_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textureset_id_.IsDefault()) {
    _impl_.textureset_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSCH.DEPRECATEDChart3DFillArchive.textureset_id)
}

// optional .TSCH.FillPropertyType fill_type = 4;
inline bool DEPRECATEDChart3DFillArchive::_internal_has_fill_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DEPRECATEDChart3DFillArchive::has_fill_type() const {
  return _internal_has_fill_type();
}
inline void DEPRECATEDChart3DFillArchive::clear_fill_type() {
  _impl_.fill_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TSCH::FillPropertyType DEPRECATEDChart3DFillArchive::_internal_fill_type() const {
  return static_cast< ::TSCH::FillPropertyType >(_impl_.fill_type_);
}
inline ::TSCH::FillPropertyType DEPRECATEDChart3DFillArchive::fill_type() const {
  // @@protoc_insertion_point(field_get:TSCH.DEPRECATEDChart3DFillArchive.fill_type)
  return _internal_fill_type();
}
inline void DEPRECATEDChart3DFillArchive::_internal_set_fill_type(::TSCH::FillPropertyType value) {
  assert(::TSCH::FillPropertyType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fill_type_ = value;
}
inline void DEPRECATEDChart3DFillArchive::set_fill_type(::TSCH::FillPropertyType value) {
  _internal_set_fill_type(value);
  // @@protoc_insertion_point(field_set:TSCH.DEPRECATEDChart3DFillArchive.fill_type)
}

// optional uint32 series_index = 5;
inline bool DEPRECATEDChart3DFillArchive::_internal_has_series_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DEPRECATEDChart3DFillArchive::has_series_index() const {
  return _internal_has_series_index();
}
inline void DEPRECATEDChart3DFillArchive::clear_series_index() {
  _impl_.series_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DEPRECATEDChart3DFillArchive::_internal_series_index() const {
  return _impl_.series_index_;
}
inline uint32_t DEPRECATEDChart3DFillArchive::series_index() const {
  // @@protoc_insertion_point(field_get:TSCH.DEPRECATEDChart3DFillArchive.series_index)
  return _internal_series_index();
}
inline void DEPRECATEDChart3DFillArchive::_internal_set_series_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.series_index_ = value;
}
inline void DEPRECATEDChart3DFillArchive::set_series_index(uint32_t value) {
  _internal_set_series_index(value);
  // @@protoc_insertion_point(field_set:TSCH.DEPRECATEDChart3DFillArchive.series_index)
}

// -------------------------------------------------------------------

// ChartStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartStyleArchive.super)
  return _internal_super();
}
inline void ChartStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartStyleArchive.super)
  return _msg;
}
inline void ChartStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartStyleArchive.super)
}

// -------------------------------------------------------------------

// ChartNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartNonStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartNonStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartNonStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartNonStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartNonStyleArchive.super)
  return _internal_super();
}
inline void ChartNonStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartNonStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartNonStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartNonStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartNonStyleArchive.super)
  return _msg;
}
inline void ChartNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartNonStyleArchive.super)
}

// -------------------------------------------------------------------

// LegendStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool LegendStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool LegendStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& LegendStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& LegendStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.LegendStyleArchive.super)
  return _internal_super();
}
inline void LegendStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.LegendStyleArchive.super)
}
inline ::TSS::StyleArchive* LegendStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* LegendStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.LegendStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* LegendStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* LegendStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.LegendStyleArchive.super)
  return _msg;
}
inline void LegendStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.LegendStyleArchive.super)
}

// -------------------------------------------------------------------

// LegendNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool LegendNonStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool LegendNonStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& LegendNonStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& LegendNonStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.LegendNonStyleArchive.super)
  return _internal_super();
}
inline void LegendNonStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.LegendNonStyleArchive.super)
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.LegendNonStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* LegendNonStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.LegendNonStyleArchive.super)
  return _msg;
}
inline void LegendNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.LegendNonStyleArchive.super)
}

// -------------------------------------------------------------------

// ChartAxisStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartAxisStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartAxisStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartAxisStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartAxisStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartAxisStyleArchive.super)
  return _internal_super();
}
inline void ChartAxisStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartAxisStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartAxisStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartAxisStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartAxisStyleArchive.super)
  return _msg;
}
inline void ChartAxisStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartAxisStyleArchive.super)
}

// -------------------------------------------------------------------

// ChartAxisNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartAxisNonStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartAxisNonStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartAxisNonStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartAxisNonStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartAxisNonStyleArchive.super)
  return _internal_super();
}
inline void ChartAxisNonStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartAxisNonStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartAxisNonStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartAxisNonStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartAxisNonStyleArchive.super)
  return _msg;
}
inline void ChartAxisNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartAxisNonStyleArchive.super)
}

// -------------------------------------------------------------------

// ChartSeriesStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartSeriesStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartSeriesStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartSeriesStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartSeriesStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartSeriesStyleArchive.super)
  return _internal_super();
}
inline void ChartSeriesStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartSeriesStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartSeriesStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartSeriesStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartSeriesStyleArchive.super)
  return _msg;
}
inline void ChartSeriesStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartSeriesStyleArchive.super)
}

// -------------------------------------------------------------------

// ChartSeriesNonStyleArchive

// optional .TSS.StyleArchive super = 1;
inline bool ChartSeriesNonStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ChartSeriesNonStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ChartSeriesNonStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ChartSeriesNonStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSCH.ChartSeriesNonStyleArchive.super)
  return _internal_super();
}
inline void ChartSeriesNonStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSCH.ChartSeriesNonStyleArchive.super)
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSCH.ChartSeriesNonStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ChartSeriesNonStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSCH.ChartSeriesNonStyleArchive.super)
  return _msg;
}
inline void ChartSeriesNonStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSCH.ChartSeriesNonStyleArchive.super)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSCH

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TSCH::ChartType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::ChartType>() {
  return ::TSCH::ChartType_descriptor();
}
template <> struct is_proto_enum< ::TSCH::AxisType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::AxisType>() {
  return ::TSCH::AxisType_descriptor();
}
template <> struct is_proto_enum< ::TSCH::ScatterFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::ScatterFormat>() {
  return ::TSCH::ScatterFormat_descriptor();
}
template <> struct is_proto_enum< ::TSCH::SeriesDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::SeriesDirection>() {
  return ::TSCH::SeriesDirection_descriptor();
}
template <> struct is_proto_enum< ::TSCH::NumberValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::NumberValueType>() {
  return ::TSCH::NumberValueType_descriptor();
}
template <> struct is_proto_enum< ::TSCH::NegativeNumberStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::NegativeNumberStyle>() {
  return ::TSCH::NegativeNumberStyle_descriptor();
}
template <> struct is_proto_enum< ::TSCH::FractionAccuracy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSCH::FractionAccuracy>() {
  return ::TSCH::FractionAccuracy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSCHArchives_2eCommon_2eproto
