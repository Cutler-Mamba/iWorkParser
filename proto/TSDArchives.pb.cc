// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDArchives.proto

#include "TSDArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSD {
PROTOBUF_CONSTEXPR EdgeInsetsArchive::EdgeInsetsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.top_)*/0
  , /*decltype(_impl_.left_)*/0
  , /*decltype(_impl_.bottom_)*/0
  , /*decltype(_impl_.right_)*/0} {}
struct EdgeInsetsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeInsetsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeInsetsArchiveDefaultTypeInternal() {}
  union {
    EdgeInsetsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeInsetsArchiveDefaultTypeInternal _EdgeInsetsArchive_default_instance_;
PROTOBUF_CONSTEXPR GeometryArchive::GeometryArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.angle_)*/0} {}
struct GeometryArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeometryArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeometryArchiveDefaultTypeInternal() {}
  union {
    GeometryArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeometryArchiveDefaultTypeInternal _GeometryArchive_default_instance_;
PROTOBUF_CONSTEXPR PointPathSourceArchive::PointPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.type_)*/0} {}
struct PointPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointPathSourceArchiveDefaultTypeInternal() {}
  union {
    PointPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointPathSourceArchiveDefaultTypeInternal _PointPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR ScalarPathSourceArchive::ScalarPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.scalar_)*/0} {}
struct ScalarPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScalarPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScalarPathSourceArchiveDefaultTypeInternal() {}
  union {
    ScalarPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScalarPathSourceArchiveDefaultTypeInternal _ScalarPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR BezierPathSourceArchive::BezierPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.path_)*/nullptr} {}
struct BezierPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BezierPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BezierPathSourceArchiveDefaultTypeInternal() {}
  union {
    BezierPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BezierPathSourceArchiveDefaultTypeInternal _BezierPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR CalloutPathSourceArchive::CalloutPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.natural_size_)*/nullptr
  , /*decltype(_impl_.tail_position_)*/nullptr
  , /*decltype(_impl_.tail_size_)*/0
  , /*decltype(_impl_.corner_radius_)*/0
  , /*decltype(_impl_.center_tail_)*/false} {}
struct CalloutPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CalloutPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CalloutPathSourceArchiveDefaultTypeInternal() {}
  union {
    CalloutPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CalloutPathSourceArchiveDefaultTypeInternal _CalloutPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.outset_from_)*/0
  , /*decltype(_impl_.outset_to_)*/0} {}
struct ConnectionLinePathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionLinePathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionLinePathSourceArchiveDefaultTypeInternal() {}
  union {
    ConnectionLinePathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionLinePathSourceArchiveDefaultTypeInternal _ConnectionLinePathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.incontrolpoint_)*/nullptr
  , /*decltype(_impl_.nodepoint_)*/nullptr
  , /*decltype(_impl_.outcontrolpoint_)*/nullptr
  , /*decltype(_impl_.type_)*/1} {}
struct EditableBezierPathSourceArchive_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchive_NodeDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchive_NodeDefaultTypeInternal _EditableBezierPathSourceArchive_Node_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_.closed_)*/false} {}
struct EditableBezierPathSourceArchive_SubpathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_SubpathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchive_SubpathDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive_Subpath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchive_SubpathDefaultTypeInternal _EditableBezierPathSourceArchive_Subpath_default_instance_;
PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subpaths_)*/{}
  , /*decltype(_impl_.naturalsize_)*/nullptr} {}
struct EditableBezierPathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditableBezierPathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditableBezierPathSourceArchiveDefaultTypeInternal() {}
  union {
    EditableBezierPathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditableBezierPathSourceArchiveDefaultTypeInternal _EditableBezierPathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR PathSourceArchive::PathSourceArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.point_path_source_)*/nullptr
  , /*decltype(_impl_.scalar_path_source_)*/nullptr
  , /*decltype(_impl_.bezier_path_source_)*/nullptr
  , /*decltype(_impl_.callout_path_source_)*/nullptr
  , /*decltype(_impl_.connection_line_path_source_)*/nullptr
  , /*decltype(_impl_.editable_bezier_path_source_)*/nullptr
  , /*decltype(_impl_.horizontalflip_)*/false
  , /*decltype(_impl_.verticalflip_)*/false} {}
struct PathSourceArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathSourceArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathSourceArchiveDefaultTypeInternal() {}
  union {
    PathSourceArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathSourceArchiveDefaultTypeInternal _PathSourceArchive_default_instance_;
PROTOBUF_CONSTEXPR AngleGradientArchive::AngleGradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gradientangle_)*/0} {}
struct AngleGradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AngleGradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AngleGradientArchiveDefaultTypeInternal() {}
  union {
    AngleGradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AngleGradientArchiveDefaultTypeInternal _AngleGradientArchive_default_instance_;
PROTOBUF_CONSTEXPR TransformGradientArchive::TransformGradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.basenaturalsize_)*/nullptr} {}
struct TransformGradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransformGradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransformGradientArchiveDefaultTypeInternal() {}
  union {
    TransformGradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransformGradientArchiveDefaultTypeInternal _TransformGradientArchive_default_instance_;
PROTOBUF_CONSTEXPR GradientArchive_GradientStop::GradientArchive_GradientStop(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.fraction_)*/0
  , /*decltype(_impl_.inflection_)*/0} {}
struct GradientArchive_GradientStopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GradientArchive_GradientStopDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GradientArchive_GradientStopDefaultTypeInternal() {}
  union {
    GradientArchive_GradientStop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GradientArchive_GradientStopDefaultTypeInternal _GradientArchive_GradientStop_default_instance_;
PROTOBUF_CONSTEXPR GradientArchive::GradientArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stops_)*/{}
  , /*decltype(_impl_.anglegradient_)*/nullptr
  , /*decltype(_impl_.transformgradient_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.opacity_)*/0
  , /*decltype(_impl_.advancedgradient_)*/false} {}
struct GradientArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GradientArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GradientArchiveDefaultTypeInternal() {}
  union {
    GradientArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GradientArchiveDefaultTypeInternal _GradientArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageFillArchive::ImageFillArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.database_imagedata_)*/nullptr
  , /*decltype(_impl_.tint_)*/nullptr
  , /*decltype(_impl_.fillsize_)*/nullptr
  , /*decltype(_impl_.database_originalimagedata_)*/nullptr
  , /*decltype(_impl_.imagedata_)*/nullptr
  , /*decltype(_impl_.originalimagedata_)*/nullptr
  , /*decltype(_impl_.technique_)*/0
  , /*decltype(_impl_.interpretsuntaggedimagedataasgeneric_)*/false} {}
struct ImageFillArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageFillArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageFillArchiveDefaultTypeInternal() {}
  union {
    ImageFillArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageFillArchiveDefaultTypeInternal _ImageFillArchive_default_instance_;
PROTOBUF_CONSTEXPR FillArchive::FillArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.gradient_)*/nullptr
  , /*decltype(_impl_.image_)*/nullptr} {}
struct FillArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FillArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FillArchiveDefaultTypeInternal() {}
  union {
    FillArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FillArchiveDefaultTypeInternal _FillArchive_default_instance_;
PROTOBUF_CONSTEXPR StrokePatternArchive::StrokePatternArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pattern_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.phase_)*/0
  , /*decltype(_impl_.count_)*/0u} {}
struct StrokePatternArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StrokePatternArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StrokePatternArchiveDefaultTypeInternal() {}
  union {
    StrokePatternArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StrokePatternArchiveDefaultTypeInternal _StrokePatternArchive_default_instance_;
PROTOBUF_CONSTEXPR StrokeArchive::StrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.pattern_)*/nullptr
  , /*decltype(_impl_.smartstroke_)*/nullptr
  , /*decltype(_impl_.frame_)*/nullptr
  , /*decltype(_impl_.patterned_stroke_)*/nullptr
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.cap_)*/0
  , /*decltype(_impl_.join_)*/0
  , /*decltype(_impl_.miterlimit_)*/0} {}
struct StrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StrokeArchiveDefaultTypeInternal() {}
  union {
    StrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StrokeArchiveDefaultTypeInternal _StrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR SmartStrokeArchive::SmartStrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.strokename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.parametervalues_)*/nullptr
  , /*decltype(_impl_.randomseed_)*/0} {}
struct SmartStrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SmartStrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SmartStrokeArchiveDefaultTypeInternal() {}
  union {
    SmartStrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SmartStrokeArchiveDefaultTypeInternal _SmartStrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR FrameArchive::FrameArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.framename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.assetscale_)*/0} {}
struct FrameArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameArchiveDefaultTypeInternal() {}
  union {
    FrameArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameArchiveDefaultTypeInternal _FrameArchive_default_instance_;
PROTOBUF_CONSTEXPR PatternedStrokeArchive::PatternedStrokeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pattern_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PatternedStrokeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PatternedStrokeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PatternedStrokeArchiveDefaultTypeInternal() {}
  union {
    PatternedStrokeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PatternedStrokeArchiveDefaultTypeInternal _PatternedStrokeArchive_default_instance_;
PROTOBUF_CONSTEXPR LineEndArchive::LineEndArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.end_point_)*/nullptr
  , /*decltype(_impl_.line_join_)*/0
  , /*decltype(_impl_.is_filled_)*/false} {}
struct LineEndArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LineEndArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LineEndArchiveDefaultTypeInternal() {}
  union {
    LineEndArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LineEndArchiveDefaultTypeInternal _LineEndArchive_default_instance_;
PROTOBUF_CONSTEXPR ShadowArchive::ShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.color_)*/nullptr
  , /*decltype(_impl_.dropshadow_)*/nullptr
  , /*decltype(_impl_.contactshadow_)*/nullptr
  , /*decltype(_impl_.curvedshadow_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.is_enabled_)*/true
  , /*decltype(_impl_.angle_)*/315
  , /*decltype(_impl_.offset_)*/5
  , /*decltype(_impl_.radius_)*/1
  , /*decltype(_impl_.opacity_)*/1} {}
struct ShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShadowArchiveDefaultTypeInternal() {}
  union {
    ShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShadowArchiveDefaultTypeInternal _ShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR DropShadowArchive::DropShadowArchive(
    ::_pbi::ConstantInitialized) {}
struct DropShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DropShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DropShadowArchiveDefaultTypeInternal() {}
  union {
    DropShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DropShadowArchiveDefaultTypeInternal _DropShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR ContactShadowArchive::ContactShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.height_)*/0.2f} {}
struct ContactShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactShadowArchiveDefaultTypeInternal() {}
  union {
    ContactShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactShadowArchiveDefaultTypeInternal _ContactShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR CurvedShadowArchive::CurvedShadowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.curve_)*/0.6f} {}
struct CurvedShadowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurvedShadowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurvedShadowArchiveDefaultTypeInternal() {}
  union {
    CurvedShadowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurvedShadowArchiveDefaultTypeInternal _CurvedShadowArchive_default_instance_;
PROTOBUF_CONSTEXPR ReflectionArchive::ReflectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.opacity_)*/0.5f} {}
struct ReflectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReflectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReflectionArchiveDefaultTypeInternal() {}
  union {
    ReflectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReflectionArchiveDefaultTypeInternal _ReflectionArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageAdjustmentsArchive::ImageAdjustmentsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.exposure_)*/0
  , /*decltype(_impl_.saturation_)*/0
  , /*decltype(_impl_.contrast_)*/0
  , /*decltype(_impl_.highlights_)*/0
  , /*decltype(_impl_.shadows_)*/0
  , /*decltype(_impl_.sharpness_)*/0
  , /*decltype(_impl_.denoise_)*/0
  , /*decltype(_impl_.temperature_)*/0
  , /*decltype(_impl_.tint_)*/0
  , /*decltype(_impl_.bottom_level_)*/0
  , /*decltype(_impl_.gamma_)*/0
  , /*decltype(_impl_.enhance_)*/false
  , /*decltype(_impl_.represents_sage_adjustments_)*/false
  , /*decltype(_impl_.top_level_)*/1} {}
struct ImageAdjustmentsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageAdjustmentsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageAdjustmentsArchiveDefaultTypeInternal() {}
  union {
    ImageAdjustmentsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageAdjustmentsArchiveDefaultTypeInternal _ImageAdjustmentsArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fill_)*/nullptr
  , /*decltype(_impl_.stroke_)*/nullptr
  , /*decltype(_impl_.shadow_)*/nullptr
  , /*decltype(_impl_.reflection_)*/nullptr
  , /*decltype(_impl_.opacity_)*/0} {}
struct ShapeStylePropertiesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStylePropertiesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStylePropertiesArchiveDefaultTypeInternal() {}
  union {
    ShapeStylePropertiesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStylePropertiesArchiveDefaultTypeInternal _ShapeStylePropertiesArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStyleArchive::ShapeStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.shape_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct ShapeStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStyleArchiveDefaultTypeInternal() {}
  union {
    ShapeStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStyleArchiveDefaultTypeInternal _ShapeStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaStylePropertiesArchive::MediaStylePropertiesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stroke_)*/nullptr
  , /*decltype(_impl_.shadow_)*/nullptr
  , /*decltype(_impl_.reflection_)*/nullptr
  , /*decltype(_impl_.opacity_)*/0} {}
struct MediaStylePropertiesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaStylePropertiesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaStylePropertiesArchiveDefaultTypeInternal() {}
  union {
    MediaStylePropertiesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaStylePropertiesArchiveDefaultTypeInternal _MediaStylePropertiesArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaStyleArchive::MediaStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.media_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct MediaStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaStyleArchiveDefaultTypeInternal() {}
  union {
    MediaStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaStyleArchiveDefaultTypeInternal _MediaStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR ThemePresetsArchive::ThemePresetsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gradient_fill_presets_)*/{}
  , /*decltype(_impl_.image_fill_presets_)*/{}
  , /*decltype(_impl_.shadow_presets_)*/{}
  , /*decltype(_impl_.line_style_presets_)*/{}
  , /*decltype(_impl_.shape_style_presets_)*/{}
  , /*decltype(_impl_.textbox_style_presets_)*/{}
  , /*decltype(_impl_.image_style_presets_)*/{}
  , /*decltype(_impl_.movie_style_presets_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThemePresetsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThemePresetsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThemePresetsArchiveDefaultTypeInternal() {}
  union {
    ThemePresetsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThemePresetsArchiveDefaultTypeInternal _ThemePresetsArchive_default_instance_;
PROTOBUF_CONSTEXPR ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.fill_)*/nullptr
  , /*decltype(_impl_.old_fill_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal() {}
  union {
    ThemeReplaceFillPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal _ThemeReplaceFillPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableArchive::DrawableArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hyperlink_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.accessibility_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.exterior_text_wrap_)*/nullptr
  , /*decltype(_impl_.comment_)*/nullptr
  , /*decltype(_impl_.locked_)*/false
  , /*decltype(_impl_.aspect_ratio_locked_)*/false} {}
struct DrawableArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableArchiveDefaultTypeInternal() {}
  union {
    DrawableArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableArchiveDefaultTypeInternal _DrawableArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainerArchive::ContainerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.geometry_)*/nullptr
  , /*decltype(_impl_.parent_)*/nullptr} {}
struct ContainerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerArchiveDefaultTypeInternal() {}
  union {
    ContainerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerArchiveDefaultTypeInternal _ContainerArchive_default_instance_;
PROTOBUF_CONSTEXPR GroupArchive::GroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct GroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupArchiveDefaultTypeInternal() {}
  union {
    GroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupArchiveDefaultTypeInternal _GroupArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeArchive::ShapeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.pathsource_)*/nullptr
  , /*decltype(_impl_.head_line_end_)*/nullptr
  , /*decltype(_impl_.tail_line_end_)*/nullptr} {}
struct ShapeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeArchiveDefaultTypeInternal() {}
  union {
    ShapeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeArchiveDefaultTypeInternal _ShapeArchive_default_instance_;
PROTOBUF_CONSTEXPR ConnectionLineArchive::ConnectionLineArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.connected_from_)*/nullptr
  , /*decltype(_impl_.connected_to_)*/nullptr} {}
struct ConnectionLineArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionLineArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionLineArchiveDefaultTypeInternal() {}
  union {
    ConnectionLineArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionLineArchiveDefaultTypeInternal _ConnectionLineArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageArchive::ImageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.database_data_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.originalsize_)*/nullptr
  , /*decltype(_impl_.mask_)*/nullptr
  , /*decltype(_impl_.database_thumbnaildata_)*/nullptr
  , /*decltype(_impl_.database_originaldata_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.instantalphapath_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_.thumbnaildata_)*/nullptr
  , /*decltype(_impl_.originaldata_)*/nullptr
  , /*decltype(_impl_.imageadjustments_)*/nullptr
  , /*decltype(_impl_.adjustedimagedata_)*/nullptr
  , /*decltype(_impl_.thumbnailadjustedimagedata_)*/nullptr
  , /*decltype(_impl_.enhancedimagedata_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.interpretsuntaggedimagedataasgeneric_)*/false} {}
struct ImageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageArchiveDefaultTypeInternal() {}
  union {
    ImageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageArchiveDefaultTypeInternal _ImageArchive_default_instance_;
PROTOBUF_CONSTEXPR MaskArchive::MaskArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.pathsource_)*/nullptr} {}
struct MaskArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MaskArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MaskArchiveDefaultTypeInternal() {}
  union {
    MaskArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MaskArchiveDefaultTypeInternal _MaskArchive_default_instance_;
PROTOBUF_CONSTEXPR MovieArchive::MovieArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.movieremoteurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.database_moviedata_)*/nullptr
  , /*decltype(_impl_.database_posterimagedata_)*/nullptr
  , /*decltype(_impl_.database_audioonlyimagedata_)*/nullptr
  , /*decltype(_impl_.moviedata_)*/nullptr
  , /*decltype(_impl_.posterimagedata_)*/nullptr
  , /*decltype(_impl_.audioonlyimagedata_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.originalsize_)*/nullptr
  , /*decltype(_impl_.naturalsize_)*/nullptr
  , /*decltype(_impl_.importedauxiliarymoviedata_)*/nullptr
  , /*decltype(_impl_.starttime_)*/0
  , /*decltype(_impl_.endtime_)*/0
  , /*decltype(_impl_.postertime_)*/0
  , /*decltype(_impl_.loopoption_)*/0u
  , /*decltype(_impl_.volume_)*/0
  , /*decltype(_impl_.autoplay_)*/false
  , /*decltype(_impl_.audioonly_)*/false
  , /*decltype(_impl_.streaming_)*/false
  , /*decltype(_impl_.playablestate_)*/0u
  , /*decltype(_impl_.flags_)*/0u} {}
struct MovieArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieArchiveDefaultTypeInternal() {}
  union {
    MovieArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieArchiveDefaultTypeInternal _MovieArchive_default_instance_;
PROTOBUF_CONSTEXPR ExteriorTextWrapArchive::ExteriorTextWrapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.direction_)*/0u
  , /*decltype(_impl_.fit_type_)*/0u
  , /*decltype(_impl_.margin_)*/0
  , /*decltype(_impl_.alpha_threshold_)*/0
  , /*decltype(_impl_.is_html_wrap_)*/false} {}
struct ExteriorTextWrapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExteriorTextWrapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExteriorTextWrapArchiveDefaultTypeInternal() {}
  union {
    ExteriorTextWrapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExteriorTextWrapArchiveDefaultTypeInternal _ExteriorTextWrapArchive_default_instance_;
PROTOBUF_CONSTEXPR GuideArchive::GuideArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.offset_)*/0
  , /*decltype(_impl_.start_)*/0
  , /*decltype(_impl_.end_)*/0
  , /*decltype(_impl_.dynamic_)*/false
  , /*decltype(_impl_.infinite_)*/false} {}
struct GuideArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuideArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuideArchiveDefaultTypeInternal() {}
  union {
    GuideArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuideArchiveDefaultTypeInternal _GuideArchive_default_instance_;
PROTOBUF_CONSTEXPR UserDefinedGuideArchive::UserDefinedGuideArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.position_)*/0} {}
struct UserDefinedGuideArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserDefinedGuideArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserDefinedGuideArchiveDefaultTypeInternal() {}
  union {
    UserDefinedGuideArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDefinedGuideArchiveDefaultTypeInternal _UserDefinedGuideArchive_default_instance_;
PROTOBUF_CONSTEXPR GuideStorageArchive::GuideStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.userdefinedguides_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GuideStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuideStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuideStorageArchiveDefaultTypeInternal() {}
  union {
    GuideStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuideStorageArchiveDefaultTypeInternal _GuideStorageArchive_default_instance_;
PROTOBUF_CONSTEXPR CanvasSelectionArchive::CanvasSelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.infos_)*/{}
  , /*decltype(_impl_.container_)*/nullptr} {}
struct CanvasSelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CanvasSelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CanvasSelectionArchiveDefaultTypeInternal() {}
  union {
    CanvasSelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CanvasSelectionArchiveDefaultTypeInternal _CanvasSelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR CommentStorageArchive::CommentStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.creation_date_)*/nullptr
  , /*decltype(_impl_.author_)*/nullptr} {}
struct CommentStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommentStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommentStorageArchiveDefaultTypeInternal() {}
  union {
    CommentStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommentStorageArchiveDefaultTypeInternal _CommentStorageArchive_default_instance_;
}  // namespace TSD
static ::_pb::Metadata file_level_metadata_TSDArchives_2eproto[49];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSDArchives_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSDArchives_2eproto = nullptr;

const uint32_t TableStruct_TSDArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.top_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.bottom_),
  PROTOBUF_FIELD_OFFSET(::TSD::EdgeInsetsArchive, _impl_.right_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::GeometryArchive, _impl_.angle_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.point_),
  PROTOBUF_FIELD_OFFSET(::TSD::PointPathSourceArchive, _impl_.naturalsize_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.scalar_),
  PROTOBUF_FIELD_OFFSET(::TSD::ScalarPathSourceArchive, _impl_.naturalsize_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.path_string_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::BezierPathSourceArchive, _impl_.path_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.natural_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.tail_position_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.tail_size_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.corner_radius_),
  PROTOBUF_FIELD_OFFSET(::TSD::CalloutPathSourceArchive, _impl_.center_tail_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.outset_from_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLinePathSourceArchive, _impl_.outset_to_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.incontrolpoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.nodepoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.outcontrolpoint_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Node, _impl_.type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive_Subpath, _impl_.closed_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_.subpaths_),
  PROTOBUF_FIELD_OFFSET(::TSD::EditableBezierPathSourceArchive, _impl_.naturalsize_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.horizontalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.verticalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.point_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.scalar_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.bezier_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.callout_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.connection_line_path_source_),
  PROTOBUF_FIELD_OFFSET(::TSD::PathSourceArchive, _impl_.editable_bezier_path_source_),
  6,
  7,
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::AngleGradientArchive, _impl_.gradientangle_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::TSD::TransformGradientArchive, _impl_.basenaturalsize_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.fraction_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive_GradientStop, _impl_.inflection_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.stops_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.advancedgradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.anglegradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::GradientArchive, _impl_.transformgradient_),
  2,
  ~0u,
  3,
  4,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.imagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.technique_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.tint_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.fillsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.originalimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.interpretsuntaggedimagedataasgeneric_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.database_imagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageFillArchive, _impl_.database_originalimagedata_),
  4,
  6,
  1,
  2,
  5,
  7,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.gradient_),
  PROTOBUF_FIELD_OFFSET(::TSD::FillArchive, _impl_.image_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.phase_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokePatternArchive, _impl_.pattern_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.cap_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.join_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.miterlimit_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.pattern_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.smartstroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.frame_),
  PROTOBUF_FIELD_OFFSET(::TSD::StrokeArchive, _impl_.patterned_stroke_),
  0,
  5,
  6,
  7,
  8,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.strokename_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.randomseed_),
  PROTOBUF_FIELD_OFFSET(::TSD::SmartStrokeArchive, _impl_.parametervalues_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_.framename_),
  PROTOBUF_FIELD_OFFSET(::TSD::FrameArchive, _impl_.assetscale_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PatternedStrokeArchive, _impl_.pattern_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.line_join_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.end_point_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.is_filled_),
  PROTOBUF_FIELD_OFFSET(::TSD::LineEndArchive, _impl_.identifier_),
  1,
  3,
  2,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.angle_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.is_enabled_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.dropshadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.contactshadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShadowArchive, _impl_.curvedshadow_),
  0,
  6,
  7,
  8,
  9,
  5,
  4,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::DropShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContactShadowArchive, _impl_.offset_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CurvedShadowArchive, _impl_.curve_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ReflectionArchive, _impl_.opacity_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.exposure_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.saturation_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.contrast_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.highlights_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.shadows_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.sharpness_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.denoise_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.temperature_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.tint_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.bottom_level_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.top_level_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.gamma_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.enhance_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsArchive, _impl_.represents_sage_adjustments_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  13,
  10,
  11,
  12,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.stroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.shadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStylePropertiesArchive, _impl_.reflection_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleArchive, _impl_.shape_properties_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.stroke_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.opacity_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.shadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStylePropertiesArchive, _impl_.reflection_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleArchive, _impl_.media_properties_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.gradient_fill_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.image_fill_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.shadow_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.line_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.shape_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.textbox_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.image_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemePresetsArchive, _impl_.movie_style_presets_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.old_fill_),
  PROTOBUF_FIELD_OFFSET(::TSD::ThemeReplaceFillPresetCommandArchive, _impl_.index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.exterior_text_wrap_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.hyperlink_url_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.locked_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.aspect_ratio_locked_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableArchive, _impl_.accessibility_description_),
  2,
  3,
  4,
  0,
  6,
  5,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.geometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerArchive, _impl_.children_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupArchive, _impl_.children_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.pathsource_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.head_line_end_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeArchive, _impl_.tail_line_end_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_from_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineArchive, _impl_.connected_to_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.originalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.mask_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.thumbnaildata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.originaldata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.naturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.instantalphapath_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.imageadjustments_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.enhancedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.adjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.thumbnailadjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.interpretsuntaggedimagedataasgeneric_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_data_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_thumbnaildata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageArchive, _impl_.database_originaldata_),
  0,
  9,
  2,
  3,
  4,
  10,
  16,
  11,
  7,
  8,
  12,
  15,
  13,
  14,
  17,
  1,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MaskArchive, _impl_.pathsource_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.moviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.importedauxiliarymoviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.movieremoteurl_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.endtime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.postertime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.loopoption_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.autoplay_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.audioonly_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.streaming_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.posterimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.audioonlyimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.playablestate_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_moviedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_posterimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.database_audioonlyimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.originalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieArchive, _impl_.naturalsize_),
  1,
  5,
  11,
  0,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  6,
  7,
  20,
  21,
  2,
  3,
  4,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.fit_type_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.margin_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.alpha_threshold_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapArchive, _impl_.is_html_wrap_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.dynamic_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideArchive, _impl_.infinite_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::UserDefinedGuideArchive, _impl_.position_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideStorageArchive, _impl_.userdefinedguides_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_.infos_),
  PROTOBUF_FIELD_OFFSET(::TSD::CanvasSelectionArchive, _impl_.container_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.text_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.creation_date_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageArchive, _impl_.author_),
  0,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::TSD::EdgeInsetsArchive)},
  { 14, 24, -1, sizeof(::TSD::GeometryArchive)},
  { 28, 37, -1, sizeof(::TSD::PointPathSourceArchive)},
  { 40, 49, -1, sizeof(::TSD::ScalarPathSourceArchive)},
  { 52, 61, -1, sizeof(::TSD::BezierPathSourceArchive)},
  { 64, 75, -1, sizeof(::TSD::CalloutPathSourceArchive)},
  { 80, 90, -1, sizeof(::TSD::ConnectionLinePathSourceArchive)},
  { 94, 104, -1, sizeof(::TSD::EditableBezierPathSourceArchive_Node)},
  { 108, 116, -1, sizeof(::TSD::EditableBezierPathSourceArchive_Subpath)},
  { 118, 126, -1, sizeof(::TSD::EditableBezierPathSourceArchive)},
  { 128, 142, -1, sizeof(::TSD::PathSourceArchive)},
  { 150, 157, -1, sizeof(::TSD::AngleGradientArchive)},
  { 158, 167, -1, sizeof(::TSD::TransformGradientArchive)},
  { 170, 179, -1, sizeof(::TSD::GradientArchive_GradientStop)},
  { 182, 194, -1, sizeof(::TSD::GradientArchive)},
  { 200, 214, -1, sizeof(::TSD::ImageFillArchive)},
  { 222, 231, -1, sizeof(::TSD::FillArchive)},
  { 234, 244, -1, sizeof(::TSD::StrokePatternArchive)},
  { 248, 263, -1, sizeof(::TSD::StrokeArchive)},
  { 272, 281, -1, sizeof(::TSD::SmartStrokeArchive)},
  { 284, 292, -1, sizeof(::TSD::FrameArchive)},
  { 294, 301, -1, sizeof(::TSD::PatternedStrokeArchive)},
  { 302, 313, -1, sizeof(::TSD::LineEndArchive)},
  { 318, 334, -1, sizeof(::TSD::ShadowArchive)},
  { 344, -1, -1, sizeof(::TSD::DropShadowArchive)},
  { 350, 358, -1, sizeof(::TSD::ContactShadowArchive)},
  { 360, 367, -1, sizeof(::TSD::CurvedShadowArchive)},
  { 368, 375, -1, sizeof(::TSD::ReflectionArchive)},
  { 376, 396, -1, sizeof(::TSD::ImageAdjustmentsArchive)},
  { 410, 421, -1, sizeof(::TSD::ShapeStylePropertiesArchive)},
  { 426, 435, -1, sizeof(::TSD::ShapeStyleArchive)},
  { 438, 448, -1, sizeof(::TSD::MediaStylePropertiesArchive)},
  { 452, 461, -1, sizeof(::TSD::MediaStyleArchive)},
  { 464, -1, -1, sizeof(::TSD::ThemePresetsArchive)},
  { 478, 489, -1, sizeof(::TSD::ThemeReplaceFillPresetCommandArchive)},
  { 494, 508, -1, sizeof(::TSD::DrawableArchive)},
  { 516, 525, -1, sizeof(::TSD::ContainerArchive)},
  { 528, 536, -1, sizeof(::TSD::GroupArchive)},
  { 538, 549, -1, sizeof(::TSD::ShapeArchive)},
  { 554, 563, -1, sizeof(::TSD::ConnectionLineArchive)},
  { 566, 590, -1, sizeof(::TSD::ImageArchive)},
  { 608, 616, -1, sizeof(::TSD::MaskArchive)},
  { 618, 646, -1, sizeof(::TSD::MovieArchive)},
  { 668, 680, -1, sizeof(::TSD::ExteriorTextWrapArchive)},
  { 686, 698, -1, sizeof(::TSD::GuideArchive)},
  { 704, 712, -1, sizeof(::TSD::UserDefinedGuideArchive)},
  { 714, -1, -1, sizeof(::TSD::GuideStorageArchive)},
  { 721, 729, -1, sizeof(::TSD::CanvasSelectionArchive)},
  { 731, 740, -1, sizeof(::TSD::CommentStorageArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSD::_EdgeInsetsArchive_default_instance_._instance,
  &::TSD::_GeometryArchive_default_instance_._instance,
  &::TSD::_PointPathSourceArchive_default_instance_._instance,
  &::TSD::_ScalarPathSourceArchive_default_instance_._instance,
  &::TSD::_BezierPathSourceArchive_default_instance_._instance,
  &::TSD::_CalloutPathSourceArchive_default_instance_._instance,
  &::TSD::_ConnectionLinePathSourceArchive_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_Node_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_Subpath_default_instance_._instance,
  &::TSD::_EditableBezierPathSourceArchive_default_instance_._instance,
  &::TSD::_PathSourceArchive_default_instance_._instance,
  &::TSD::_AngleGradientArchive_default_instance_._instance,
  &::TSD::_TransformGradientArchive_default_instance_._instance,
  &::TSD::_GradientArchive_GradientStop_default_instance_._instance,
  &::TSD::_GradientArchive_default_instance_._instance,
  &::TSD::_ImageFillArchive_default_instance_._instance,
  &::TSD::_FillArchive_default_instance_._instance,
  &::TSD::_StrokePatternArchive_default_instance_._instance,
  &::TSD::_StrokeArchive_default_instance_._instance,
  &::TSD::_SmartStrokeArchive_default_instance_._instance,
  &::TSD::_FrameArchive_default_instance_._instance,
  &::TSD::_PatternedStrokeArchive_default_instance_._instance,
  &::TSD::_LineEndArchive_default_instance_._instance,
  &::TSD::_ShadowArchive_default_instance_._instance,
  &::TSD::_DropShadowArchive_default_instance_._instance,
  &::TSD::_ContactShadowArchive_default_instance_._instance,
  &::TSD::_CurvedShadowArchive_default_instance_._instance,
  &::TSD::_ReflectionArchive_default_instance_._instance,
  &::TSD::_ImageAdjustmentsArchive_default_instance_._instance,
  &::TSD::_ShapeStylePropertiesArchive_default_instance_._instance,
  &::TSD::_ShapeStyleArchive_default_instance_._instance,
  &::TSD::_MediaStylePropertiesArchive_default_instance_._instance,
  &::TSD::_MediaStyleArchive_default_instance_._instance,
  &::TSD::_ThemePresetsArchive_default_instance_._instance,
  &::TSD::_ThemeReplaceFillPresetCommandArchive_default_instance_._instance,
  &::TSD::_DrawableArchive_default_instance_._instance,
  &::TSD::_ContainerArchive_default_instance_._instance,
  &::TSD::_GroupArchive_default_instance_._instance,
  &::TSD::_ShapeArchive_default_instance_._instance,
  &::TSD::_ConnectionLineArchive_default_instance_._instance,
  &::TSD::_ImageArchive_default_instance_._instance,
  &::TSD::_MaskArchive_default_instance_._instance,
  &::TSD::_MovieArchive_default_instance_._instance,
  &::TSD::_ExteriorTextWrapArchive_default_instance_._instance,
  &::TSD::_GuideArchive_default_instance_._instance,
  &::TSD::_UserDefinedGuideArchive_default_instance_._instance,
  &::TSD::_GuideStorageArchive_default_instance_._instance,
  &::TSD::_CanvasSelectionArchive_default_instance_._instance,
  &::TSD::_CommentStorageArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSDArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021TSDArchives.proto\022\003TSD\032\021TSPMessages.pr"
  "oto\032\021TSKArchives.proto\032\021TSSArchives.prot"
  "o\"M\n\021EdgeInsetsArchive\022\013\n\003top\030\001 \002(\002\022\014\n\004l"
  "eft\030\002 \002(\002\022\016\n\006bottom\030\003 \002(\002\022\r\n\005right\030\004 \002(\002"
  "\"f\n\017GeometryArchive\022\034\n\010position\030\001 \001(\0132\n."
  "TSP.Point\022\027\n\004size\030\002 \001(\0132\t.TSP.Size\022\r\n\005fl"
  "ags\030\003 \001(\r\022\r\n\005angle\030\004 \001(\002\"\216\002\n\026PointPathSo"
  "urceArchive\022=\n\004type\030\001 \001(\0162/.TSD.PointPat"
  "hSourceArchive.PointPathSourceType\022\031\n\005po"
  "int\030\002 \001(\0132\n.TSP.Point\022\036\n\013naturalSize\030\003 \001"
  "(\0132\t.TSP.Size\"z\n\023PointPathSourceType\022\027\n\023"
  "kTSDLeftSingleArrow\020\000\022\030\n\024kTSDRightSingle"
  "Arrow\020\001\022\023\n\017kTSDDoubleArrow\020\n\022\014\n\010kTSDStar"
  "\020d\022\r\n\010kTSDPlus\020\310\001\"\345\001\n\027ScalarPathSourceAr"
  "chive\022\?\n\004type\030\001 \001(\01621.TSD.ScalarPathSour"
  "ceArchive.ScalarPathSourceType\022\016\n\006scalar"
  "\030\002 \001(\002\022\036\n\013naturalSize\030\003 \001(\0132\t.TSP.Size\"Y"
  "\n\024ScalarPathSourceType\022\030\n\024kTSDRoundedRec"
  "tangle\020\000\022\026\n\022kTSDRegularPolygon\020\001\022\017\n\013kTSD"
  "Chevron\020\002\"k\n\027BezierPathSourceArchive\022\027\n\013"
  "path_string\030\001 \001(\tB\002\030\001\022\036\n\013naturalSize\030\002 \001"
  "(\0132\t.TSP.Size\022\027\n\004path\030\003 \001(\0132\t.TSP.Path\"\235"
  "\001\n\030CalloutPathSourceArchive\022\037\n\014natural_s"
  "ize\030\001 \001(\0132\t.TSP.Size\022!\n\rtail_position\030\002 "
  "\001(\0132\n.TSP.Point\022\021\n\ttail_size\030\003 \001(\002\022\025\n\rco"
  "rner_radius\030\004 \001(\002\022\023\n\013center_tail\030\005 \001(\010\"\262"
  "\002\n\037ConnectionLinePathSourceArchive\022+\n\005su"
  "per\030\001 \002(\0132\034.TSD.BezierPathSourceArchive\022"
  "O\n\004type\030\002 \001(\0162A.TSD.ConnectionLinePathSo"
  "urceArchive.ConnectionLinePathSourceType"
  "\022\023\n\013outset_from\030\003 \001(\002\022\021\n\toutset_to\030\004 \001(\002"
  "\"i\n\034ConnectionLinePathSourceType\022#\n\037kTSD"
  "ConnectionLineTypeQuadratic\020\000\022$\n kTSDCon"
  "nectionLineTypeOrthogonal\020\001\"\263\003\n\037Editable"
  "BezierPathSourceArchive\022>\n\010subpaths\030\001 \003("
  "\0132,.TSD.EditableBezierPathSourceArchive."
  "Subpath\022\036\n\013naturalSize\030\002 \001(\0132\t.TSP.Size\032"
  "\253\001\n\004Node\022\"\n\016inControlPoint\030\001 \002(\0132\n.TSP.P"
  "oint\022\035\n\tnodePoint\030\002 \002(\0132\n.TSP.Point\022#\n\017o"
  "utControlPoint\030\003 \002(\0132\n.TSP.Point\022;\n\004type"
  "\030\004 \002(\0162-.TSD.EditableBezierPathSourceArc"
  "hive.NodeType\032S\n\007Subpath\0228\n\005nodes\030\001 \003(\0132"
  ").TSD.EditableBezierPathSourceArchive.No"
  "de\022\016\n\006closed\030\002 \002(\010\"-\n\010NodeType\022\t\n\005sharp\020"
  "\001\022\n\n\006bezier\020\002\022\n\n\006smooth\020\003\"\277\003\n\021PathSource"
  "Archive\022\026\n\016horizontalFlip\030\001 \001(\010\022\024\n\014verti"
  "calFlip\030\002 \001(\010\0226\n\021point_path_source\030\003 \001(\013"
  "2\033.TSD.PointPathSourceArchive\0228\n\022scalar_"
  "path_source\030\004 \001(\0132\034.TSD.ScalarPathSource"
  "Archive\0228\n\022bezier_path_source\030\005 \001(\0132\034.TS"
  "D.BezierPathSourceArchive\022:\n\023callout_pat"
  "h_source\030\006 \001(\0132\035.TSD.CalloutPathSourceAr"
  "chive\022I\n\033connection_line_path_source\030\007 \001"
  "(\0132$.TSD.ConnectionLinePathSourceArchive"
  "\022I\n\033editable_bezier_path_source\030\010 \001(\0132$."
  "TSD.EditableBezierPathSourceArchive\"-\n\024A"
  "ngleGradientArchive\022\025\n\rgradientangle\030\002 \001"
  "(\002\"r\n\030TransformGradientArchive\022\031\n\005start\030"
  "\001 \001(\0132\n.TSP.Point\022\027\n\003end\030\002 \001(\0132\n.TSP.Poi"
  "nt\022\"\n\017baseNaturalSize\030\003 \001(\0132\t.TSP.Size\"\204"
  "\003\n\017GradientArchive\022/\n\004type\030\001 \001(\0162!.TSD.G"
  "radientArchive.GradientType\0220\n\005stops\030\002 \003"
  "(\0132!.TSD.GradientArchive.GradientStop\022\017\n"
  "\007opacity\030\003 \001(\002\022\030\n\020advancedGradient\030\004 \001(\010"
  "\0220\n\ranglegradient\030\005 \001(\0132\031.TSD.AngleGradi"
  "entArchive\0228\n\021transformgradient\030\006 \001(\0132\035."
  "TSD.TransformGradientArchive\032O\n\014Gradient"
  "Stop\022\031\n\005color\030\001 \001(\0132\n.TSP.Color\022\020\n\010fract"
  "ion\030\002 \001(\002\022\022\n\ninflection\030\003 \001(\002\"&\n\014Gradien"
  "tType\022\n\n\006Linear\020\000\022\n\n\006Radial\020\001\"\326\003\n\020ImageF"
  "illArchive\022%\n\timagedata\030\006 \001(\0132\022.TSP.Data"
  "Reference\022H\n\ttechnique\030\002 \001(\0162(.TSD.Image"
  "FillArchive.ImageFillTechnique:\013NaturalS"
  "ize\022\030\n\004tint\030\003 \001(\0132\n.TSP.Color\022\033\n\010fillsiz"
  "e\030\004 \001(\0132\t.TSP.Size\022-\n\021originalimagedata\030"
  "\007 \001(\0132\022.TSP.DataReference\022,\n$interpretsU"
  "ntaggedImageDataAsGeneric\030\010 \001(\010\022*\n\022datab"
  "ase_imagedata\030\001 \001(\0132\016.TSP.Reference\0222\n\032d"
  "atabase_originalimagedata\030\005 \001(\0132\016.TSP.Re"
  "ference\"]\n\022ImageFillTechnique\022\017\n\013Natural"
  "Size\020\000\022\013\n\007Stretch\020\001\022\010\n\004Tile\020\002\022\017\n\013ScaleTo"
  "Fill\020\003\022\016\n\nScaleToFit\020\004\"\200\001\n\013FillArchive\022\031"
  "\n\005color\030\001 \001(\0132\n.TSP.Color\022&\n\010gradient\030\002 "
  "\001(\0132\024.TSD.GradientArchive\022$\n\005image\030\003 \001(\013"
  "2\025.TSD.ImageFillArchive*\010\010d\020\200\200\200\200\002\"\317\001\n\024St"
  "rokePatternArchive\0229\n\004type\030\001 \001(\0162+.TSD.S"
  "trokePatternArchive.StrokePatternType\022\r\n"
  "\005phase\030\002 \001(\002\022\r\n\005count\030\003 \001(\r\022\017\n\007pattern\030\004"
  " \003(\002\"M\n\021StrokePatternType\022\016\n\nTSDPattern\020"
  "\000\022\023\n\017TSDSolidPattern\020\001\022\023\n\017TSDEmptyPatter"
  "n\020\002\"\373\002\n\rStrokeArchive\022\031\n\005color\030\001 \001(\0132\n.T"
  "SP.Color\022\r\n\005width\030\002 \001(\002\022\'\n\003cap\030\003 \001(\0162\032.T"
  "SD.StrokeArchive.LineCap\022\033\n\004join\030\004 \001(\0162\r"
  ".TSD.LineJoin\022\022\n\nmiterLimit\030\005 \001(\002\022*\n\007pat"
  "tern\030\006 \001(\0132\031.TSD.StrokePatternArchive\022,\n"
  "\013smartStroke\030\007 \001(\0132\027.TSD.SmartStrokeArch"
  "ive\022 \n\005frame\030\010 \001(\0132\021.TSD.FrameArchive\0225\n"
  "\020patterned_stroke\030\t \001(\0132\033.TSD.PatternedS"
  "trokeArchive\"3\n\007LineCap\022\013\n\007ButtCap\020\000\022\014\n\010"
  "RoundCap\020\001\022\r\n\tSquareCap\020\002\"o\n\022SmartStroke"
  "Archive\022\022\n\nstrokeName\030\002 \001(\t\022\022\n\nrandomSee"
  "d\030\003 \001(\005\0221\n\017parameterValues\030\004 \001(\0132\030.TSP.R"
  "eferenceDictionary\"5\n\014FrameArchive\022\021\n\tfr"
  "ameName\030\002 \001(\t\022\022\n\nassetScale\030\003 \001(\002\".\n\026Pat"
  "ternedStrokeArchive\022\024\n\014pattern_name\030\002 \001("
  "\t\"\234\001\n\016LineEndArchive\022\027\n\004path\030\001 \001(\0132\t.TSP"
  ".Path\022+\n\tline_join\030\002 \001(\0162\r.TSD.LineJoin:"
  "\tMiterJoin\022\035\n\tend_point\030\003 \001(\0132\n.TSP.Poin"
  "t\022\021\n\tis_filled\030\004 \001(\010\022\022\n\nidentifier\030\005 \001(\t"
  "\"\250\003\n\rShadowArchive\022\031\n\005color\030\001 \001(\0132\n.TSP."
  "Color\022\022\n\005angle\030\002 \001(\002:\003315\022\021\n\006offset\030\003 \001("
  "\002:\0015\022\021\n\006radius\030\004 \001(\005:\0011\022\022\n\007opacity\030\005 \001(\002"
  ":\0011\022\030\n\nis_enabled\030\006 \001(\010:\004true\022:\n\004type\030\007 "
  "\001(\0162\035.TSD.ShadowArchive.ShadowType:\rTSDD"
  "ropShadow\022*\n\ndropShadow\030\010 \001(\0132\026.TSD.Drop"
  "ShadowArchive\0220\n\rcontactShadow\030\t \001(\0132\031.T"
  "SD.ContactShadowArchive\022.\n\014curvedShadow\030"
  "\n \001(\0132\030.TSD.CurvedShadowArchive\"J\n\nShado"
  "wType\022\021\n\rTSDDropShadow\020\000\022\024\n\020TSDContactSh"
  "adow\020\001\022\023\n\017TSDCurvedShadow\020\002\"\023\n\021DropShado"
  "wArchive\">\n\024ContactShadowArchive\022\023\n\006heig"
  "ht\030\002 \001(\002:\0030.2\022\021\n\006offset\030\004 \001(\002:\0010\")\n\023Curv"
  "edShadowArchive\022\022\n\005curve\030\001 \001(\002:\0030.6\")\n\021R"
  "eflectionArchive\022\024\n\007opacity\030\001 \001(\002:\0030.5\"\274"
  "\002\n\027ImageAdjustmentsArchive\022\020\n\010exposure\030\001"
  " \001(\002\022\022\n\nsaturation\030\002 \001(\002\022\020\n\010contrast\030\003 \001"
  "(\002\022\022\n\nhighlights\030\004 \001(\002\022\017\n\007shadows\030\005 \001(\002\022"
  "\021\n\tsharpness\030\006 \001(\002\022\017\n\007denoise\030\007 \001(\002\022\023\n\013t"
  "emperature\030\010 \001(\002\022\014\n\004tint\030\t \001(\002\022\024\n\014bottom"
  "_level\030\n \001(\002\022\024\n\ttop_level\030\013 \001(\002:\0011\022\r\n\005ga"
  "mma\030\014 \001(\002\022\026\n\007enhance\030\r \001(\010:\005false\022*\n\033rep"
  "resents_sage_adjustments\030\016 \001(\010:\005false\"\302\001"
  "\n\033ShapeStylePropertiesArchive\022\036\n\004fill\030\001 "
  "\001(\0132\020.TSD.FillArchive\022\"\n\006stroke\030\002 \001(\0132\022."
  "TSD.StrokeArchive\022\017\n\007opacity\030\003 \001(\002\022\"\n\006sh"
  "adow\030\004 \001(\0132\022.TSD.ShadowArchive\022*\n\nreflec"
  "tion\030\005 \001(\0132\026.TSD.ReflectionArchive\"\214\001\n\021S"
  "hapeStyleArchive\022 \n\005super\030\001 \002(\0132\021.TSS.St"
  "yleArchive\022\031\n\016override_count\030\n \001(\r:\0010\022:\n"
  "\020shape_properties\030\013 \001(\0132 .TSD.ShapeStyle"
  "PropertiesArchive\"\242\001\n\033MediaStyleProperti"
  "esArchive\022\"\n\006stroke\030\001 \001(\0132\022.TSD.StrokeAr"
  "chive\022\017\n\007opacity\030\002 \001(\002\022\"\n\006shadow\030\003 \001(\0132\022"
  ".TSD.ShadowArchive\022*\n\nreflection\030\004 \001(\0132\026"
  ".TSD.ReflectionArchive\"\214\001\n\021MediaStyleArc"
  "hive\022 \n\005super\030\001 \002(\0132\021.TSS.StyleArchive\022\031"
  "\n\016override_count\030\n \001(\r:\0010\022:\n\020media_prope"
  "rties\030\013 \001(\0132 .TSD.MediaStylePropertiesAr"
  "chive\"\302\003\n\023ThemePresetsArchive\022/\n\025gradien"
  "t_fill_presets\030\001 \003(\0132\020.TSD.FillArchive\022,"
  "\n\022image_fill_presets\030\002 \003(\0132\020.TSD.FillArc"
  "hive\022*\n\016shadow_presets\030\003 \003(\0132\022.TSD.Shado"
  "wArchive\022*\n\022line_style_presets\030\004 \003(\0132\016.T"
  "SP.Reference\022+\n\023shape_style_presets\030\005 \003("
  "\0132\016.TSP.Reference\022-\n\025textbox_style_prese"
  "ts\030\006 \003(\0132\016.TSP.Reference\022+\n\023image_style_"
  "presets\030\007 \003(\0132\016.TSP.Reference\022+\n\023movie_s"
  "tyle_presets\030\010 \003(\0132\016.TSP.Reference2>\n\tex"
  "tension\022\021.TSS.ThemeArchive\030d \001(\0132\030.TSD.T"
  "hemePresetsArchive\"\274\001\n$ThemeReplaceFillP"
  "resetCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK"
  ".CommandArchive\022\035\n\005theme\030\002 \002(\0132\016.TSP.Ref"
  "erence\022\036\n\004fill\030\003 \002(\0132\020.TSD.FillArchive\022\""
  "\n\010old_fill\030\004 \002(\0132\020.TSD.FillArchive\022\r\n\005in"
  "dex\030\005 \002(\r\"\233\002\n\017DrawableArchive\022&\n\010geometr"
  "y\030\001 \001(\0132\024.TSD.GeometryArchive\022\036\n\006parent\030"
  "\002 \001(\0132\016.TSP.Reference\0228\n\022exterior_text_w"
  "rap\030\003 \001(\0132\034.TSD.ExteriorTextWrapArchive\022"
  "\025\n\rhyperlink_url\030\004 \001(\t\022\016\n\006locked\030\005 \001(\010\022\037"
  "\n\007comment\030\006 \001(\0132\016.TSP.Reference\022\033\n\023aspec"
  "t_ratio_locked\030\007 \001(\010\022!\n\031accessibility_de"
  "scription\030\010 \001(\t\"|\n\020ContainerArchive\022&\n\010g"
  "eometry\030\001 \001(\0132\024.TSD.GeometryArchive\022\036\n\006p"
  "arent\030\002 \001(\0132\016.TSP.Reference\022 \n\010children\030"
  "\003 \003(\0132\016.TSP.Reference\"U\n\014GroupArchive\022#\n"
  "\005super\030\001 \002(\0132\024.TSD.DrawableArchive\022 \n\010ch"
  "ildren\030\002 \003(\0132\016.TSP.Reference\"\326\001\n\014ShapeAr"
  "chive\022#\n\005super\030\001 \002(\0132\024.TSD.DrawableArchi"
  "ve\022\035\n\005style\030\002 \001(\0132\016.TSP.Reference\022*\n\npat"
  "hsource\030\003 \001(\0132\026.TSD.PathSourceArchive\022*\n"
  "\rhead_line_end\030\004 \001(\0132\023.TSD.LineEndArchiv"
  "e\022*\n\rtail_line_end\030\005 \001(\0132\023.TSD.LineEndAr"
  "chive\"\207\001\n\025ConnectionLineArchive\022 \n\005super"
  "\030\001 \002(\0132\021.TSD.ShapeArchive\022&\n\016connected_f"
  "rom\030\002 \001(\0132\016.TSP.Reference\022$\n\014connected_t"
  "o\030\003 \001(\0132\016.TSP.Reference\"\336\005\n\014ImageArchive"
  "\022#\n\005super\030\001 \002(\0132\024.TSD.DrawableArchive\022 \n"
  "\004data\030\013 \001(\0132\022.TSP.DataReference\022\035\n\005style"
  "\030\003 \001(\0132\016.TSP.Reference\022\037\n\014originalSize\030\004"
  " \001(\0132\t.TSP.Size\022\034\n\004mask\030\005 \001(\0132\016.TSP.Refe"
  "rence\022)\n\rthumbnailData\030\014 \001(\0132\022.TSP.DataR"
  "eference\022\r\n\005flags\030\007 \001(\r\022(\n\014originalData\030"
  "\r \001(\0132\022.TSP.DataReference\022\036\n\013naturalSize"
  "\030\t \001(\0132\t.TSP.Size\022#\n\020instantAlphaPath\030\n "
  "\001(\0132\t.TSP.Path\0226\n\020imageAdjustments\030\016 \001(\013"
  "2\034.TSD.ImageAdjustmentsArchive\022-\n\021enhanc"
  "edImageData\030\021 \001(\0132\022.TSP.DataReference\022-\n"
  "\021adjustedImageData\030\017 \001(\0132\022.TSP.DataRefer"
  "ence\0226\n\032thumbnailAdjustedImageData\030\020 \001(\013"
  "2\022.TSP.DataReference\022,\n$interpretsUntagg"
  "edImageDataAsGeneric\030\022 \001(\010\022%\n\rdatabase_d"
  "ata\030\002 \001(\0132\016.TSP.Reference\022.\n\026database_th"
  "umbnailData\030\006 \001(\0132\016.TSP.Reference\022-\n\025dat"
  "abase_originalData\030\010 \001(\0132\016.TSP.Reference"
  "\"^\n\013MaskArchive\022#\n\005super\030\001 \002(\0132\024.TSD.Dra"
  "wableArchive\022*\n\npathsource\030\002 \001(\0132\026.TSD.P"
  "athSourceArchive\"\270\005\n\014MovieArchive\022#\n\005sup"
  "er\030\001 \002(\0132\024.TSD.DrawableArchive\022%\n\tmovieD"
  "ata\030\016 \001(\0132\022.TSP.DataReference\0226\n\032importe"
  "dAuxiliaryMovieData\030\026 \001(\0132\022.TSP.DataRefe"
  "rence\022\026\n\016movieRemoteURL\030\021 \001(\t\022\021\n\tstartTi"
  "me\030\003 \001(\002\022\017\n\007endTime\030\004 \001(\002\022\022\n\nposterTime\030"
  "\005 \001(\002\022\022\n\nloopOption\030\006 \001(\r\022\016\n\006volume\030\007 \001("
  "\002\022\024\n\010autoPlay\030\010 \001(\010B\002\030\001\022\021\n\taudioOnly\030\t \001"
  "(\010\022\021\n\tstreaming\030\022 \001(\010\022+\n\017posterImageData"
  "\030\017 \001(\0132\022.TSP.DataReference\022.\n\022audioOnlyI"
  "mageData\030\020 \001(\0132\022.TSP.DataReference\022\025\n\rpl"
  "ayableState\030\014 \001(\r\022\r\n\005flags\030\r \001(\r\022*\n\022data"
  "base_movieData\030\002 \001(\0132\016.TSP.Reference\0220\n\030"
  "database_posterImageData\030\n \001(\0132\016.TSP.Ref"
  "erence\0223\n\033database_audioOnlyImageData\030\013 "
  "\001(\0132\016.TSP.Reference\022\035\n\005style\030\023 \001(\0132\016.TSP"
  ".Reference\022\037\n\014originalSize\030\024 \001(\0132\t.TSP.S"
  "ize\022\036\n\013naturalSize\030\025 \001(\0132\t.TSP.Size\"\213\001\n\027"
  "ExteriorTextWrapArchive\022\014\n\004type\030\001 \001(\r\022\021\n"
  "\tdirection\030\002 \001(\r\022\020\n\010fit_type\030\003 \001(\r\022\016\n\006ma"
  "rgin\030\004 \001(\002\022\027\n\017alpha_threshold\030\005 \001(\002\022\024\n\014i"
  "s_html_wrap\030\006 \001(\010\"\263\001\n\014GuideArchive\022)\n\004ty"
  "pe\030\001 \001(\0162\033.TSD.GuideArchive.GuideType\022\016\n"
  "\006offset\030\002 \001(\002\022\r\n\005start\030\003 \001(\002\022\013\n\003end\030\004 \001("
  "\002\022\017\n\007dynamic\030\005 \001(\010\022\020\n\010infinite\030\006 \001(\010\")\n\t"
  "GuideType\022\016\n\nHorizontal\020\000\022\014\n\010Vertical\020\001\""
  "\214\001\n\027UserDefinedGuideArchive\0224\n\004type\030\001 \001("
  "\0162&.TSD.UserDefinedGuideArchive.GuideTyp"
  "e\022\020\n\010position\030\002 \001(\002\")\n\tGuideType\022\016\n\nHori"
  "zontal\020\000\022\014\n\010Vertical\020\001\"N\n\023GuideStorageAr"
  "chive\0227\n\021userDefinedGuides\030\001 \003(\0132\034.TSD.U"
  "serDefinedGuideArchive\"Z\n\026CanvasSelectio"
  "nArchive\022\035\n\005infos\030\001 \003(\0132\016.TSP.Reference\022"
  "!\n\tcontainer\030\002 \001(\0132\016.TSP.Reference\"g\n\025Co"
  "mmentStorageArchive\022\014\n\004text\030\001 \001(\t\022 \n\rcre"
  "ation_date\030\002 \001(\0132\t.TSP.Date\022\036\n\006author\030\003 "
  "\001(\0132\016.TSP.Reference*7\n\010LineJoin\022\r\n\tMiter"
  "Join\020\000\022\r\n\tRoundJoin\020\001\022\r\n\tBevelJoin\020\002"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSDArchives_2eproto_deps[3] = {
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSDArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSDArchives_2eproto = {
    false, false, 9756, descriptor_table_protodef_TSDArchives_2eproto,
    "TSDArchives.proto",
    &descriptor_table_TSDArchives_2eproto_once, descriptor_table_TSDArchives_2eproto_deps, 3, 49,
    schemas, file_default_instances, TableStruct_TSDArchives_2eproto::offsets,
    file_level_metadata_TSDArchives_2eproto, file_level_enum_descriptors_TSDArchives_2eproto,
    file_level_service_descriptors_TSDArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSDArchives_2eproto_getter() {
  return &descriptor_table_TSDArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSDArchives_2eproto(&descriptor_table_TSDArchives_2eproto);
namespace TSD {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PointPathSourceArchive_PointPathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[0];
}
bool PointPathSourceArchive_PointPathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 10:
    case 100:
    case 200:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDLeftSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDRightSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDDoubleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDStar;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::kTSDPlus;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::PointPathSourceType_MIN;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::PointPathSourceType_MAX;
constexpr int PointPathSourceArchive::PointPathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalarPathSourceArchive_ScalarPathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[1];
}
bool ScalarPathSourceArchive_ScalarPathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDRoundedRectangle;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDRegularPolygon;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::kTSDChevron;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::ScalarPathSourceType_MIN;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::ScalarPathSourceType_MAX;
constexpr int ScalarPathSourceArchive::ScalarPathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[2];
}
bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::kTSDConnectionLineTypeQuadratic;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::kTSDConnectionLineTypeOrthogonal;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_MIN;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_MAX;
constexpr int ConnectionLinePathSourceArchive::ConnectionLinePathSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EditableBezierPathSourceArchive_NodeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[3];
}
bool EditableBezierPathSourceArchive_NodeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::sharp;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::bezier;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::smooth;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::NodeType_MIN;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive::NodeType_MAX;
constexpr int EditableBezierPathSourceArchive::NodeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GradientArchive_GradientType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[4];
}
bool GradientArchive_GradientType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GradientArchive_GradientType GradientArchive::Linear;
constexpr GradientArchive_GradientType GradientArchive::Radial;
constexpr GradientArchive_GradientType GradientArchive::GradientType_MIN;
constexpr GradientArchive_GradientType GradientArchive::GradientType_MAX;
constexpr int GradientArchive::GradientType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFillArchive_ImageFillTechnique_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[5];
}
bool ImageFillArchive_ImageFillTechnique_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::NaturalSize;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::Stretch;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::Tile;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ScaleToFill;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ScaleToFit;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ImageFillTechnique_MIN;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive::ImageFillTechnique_MAX;
constexpr int ImageFillArchive::ImageFillTechnique_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokePatternArchive_StrokePatternType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[6];
}
bool StrokePatternArchive_StrokePatternType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDSolidPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::TSDEmptyPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::StrokePatternType_MIN;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive::StrokePatternType_MAX;
constexpr int StrokePatternArchive::StrokePatternType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokeArchive_LineCap_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[7];
}
bool StrokeArchive_LineCap_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StrokeArchive_LineCap StrokeArchive::ButtCap;
constexpr StrokeArchive_LineCap StrokeArchive::RoundCap;
constexpr StrokeArchive_LineCap StrokeArchive::SquareCap;
constexpr StrokeArchive_LineCap StrokeArchive::LineCap_MIN;
constexpr StrokeArchive_LineCap StrokeArchive::LineCap_MAX;
constexpr int StrokeArchive::LineCap_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShadowArchive_ShadowType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[8];
}
bool ShadowArchive_ShadowType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShadowArchive_ShadowType ShadowArchive::TSDDropShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::TSDContactShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::TSDCurvedShadow;
constexpr ShadowArchive_ShadowType ShadowArchive::ShadowType_MIN;
constexpr ShadowArchive_ShadowType ShadowArchive::ShadowType_MAX;
constexpr int ShadowArchive::ShadowType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideArchive_GuideType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[9];
}
bool GuideArchive_GuideType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GuideArchive_GuideType GuideArchive::Horizontal;
constexpr GuideArchive_GuideType GuideArchive::Vertical;
constexpr GuideArchive_GuideType GuideArchive::GuideType_MIN;
constexpr GuideArchive_GuideType GuideArchive::GuideType_MAX;
constexpr int GuideArchive::GuideType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserDefinedGuideArchive_GuideType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[10];
}
bool UserDefinedGuideArchive_GuideType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::Horizontal;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::Vertical;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::GuideType_MIN;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::GuideType_MAX;
constexpr int UserDefinedGuideArchive::GuideType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineJoin_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDArchives_2eproto);
  return file_level_enum_descriptors_TSDArchives_2eproto[11];
}
bool LineJoin_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class EdgeInsetsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EdgeInsetsArchive>()._impl_._has_bits_);
  static void set_has_top(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_left(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_right(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

EdgeInsetsArchive::EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EdgeInsetsArchive)
}
EdgeInsetsArchive::EdgeInsetsArchive(const EdgeInsetsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EdgeInsetsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_){}
    , decltype(_impl_.left_){}
    , decltype(_impl_.bottom_){}
    , decltype(_impl_.right_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.top_, &from._impl_.top_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) -
    reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
  // @@protoc_insertion_point(copy_constructor:TSD.EdgeInsetsArchive)
}

inline void EdgeInsetsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.top_){0}
    , decltype(_impl_.left_){0}
    , decltype(_impl_.bottom_){0}
    , decltype(_impl_.right_){0}
  };
}

EdgeInsetsArchive::~EdgeInsetsArchive() {
  // @@protoc_insertion_point(destructor:TSD.EdgeInsetsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeInsetsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EdgeInsetsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EdgeInsetsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EdgeInsetsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.top_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.right_) -
        reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EdgeInsetsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float top = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_top(&has_bits);
          _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float left = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_left(&has_bits);
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float bottom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_bottom(&has_bits);
          _impl_.bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float right = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_right(&has_bits);
          _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeInsetsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EdgeInsetsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float top = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_top(), target);
  }

  // required float left = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_left(), target);
  }

  // required float bottom = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_bottom(), target);
  }

  // required float right = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EdgeInsetsArchive)
  return target;
}

size_t EdgeInsetsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.EdgeInsetsArchive)
  size_t total_size = 0;

  if (_internal_has_top()) {
    // required float top = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_left()) {
    // required float left = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_bottom()) {
    // required float bottom = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_right()) {
    // required float right = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t EdgeInsetsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EdgeInsetsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float top = 1;
    total_size += 1 + 4;

    // required float left = 2;
    total_size += 1 + 4;

    // required float bottom = 3;
    total_size += 1 + 4;

    // required float right = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EdgeInsetsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EdgeInsetsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EdgeInsetsArchive::GetClassData() const { return &_class_data_; }


void EdgeInsetsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EdgeInsetsArchive*>(&to_msg);
  auto& from = static_cast<const EdgeInsetsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EdgeInsetsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.top_ = from._impl_.top_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.left_ = from._impl_.left_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bottom_ = from._impl_.bottom_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.right_ = from._impl_.right_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EdgeInsetsArchive::CopyFrom(const EdgeInsetsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EdgeInsetsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeInsetsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void EdgeInsetsArchive::InternalSwap(EdgeInsetsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeInsetsArchive, _impl_.right_)
      + sizeof(EdgeInsetsArchive::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(EdgeInsetsArchive, _impl_.top_)>(
          reinterpret_cast<char*>(&_impl_.top_),
          reinterpret_cast<char*>(&other->_impl_.top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EdgeInsetsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[0]);
}

// ===================================================================

class GeometryArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GeometryArchive>()._impl_._has_bits_);
  static const ::TSP::Point& position(const GeometryArchive* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& size(const GeometryArchive* msg);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Point&
GeometryArchive::_Internal::position(const GeometryArchive* msg) {
  return *msg->_impl_.position_;
}
const ::TSP::Size&
GeometryArchive::_Internal::size(const GeometryArchive* msg) {
  return *msg->_impl_.size_;
}
void GeometryArchive::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GeometryArchive::clear_size() {
  if (_impl_.size_ != nullptr) _impl_.size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GeometryArchive::GeometryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GeometryArchive)
}
GeometryArchive::GeometryArchive(const GeometryArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GeometryArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.angle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::TSP::Point(*from._impl_.position_);
  }
  if (from._internal_has_size()) {
    _this->_impl_.size_ = new ::TSP::Size(*from._impl_.size_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.angle_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.angle_));
  // @@protoc_insertion_point(copy_constructor:TSD.GeometryArchive)
}

inline void GeometryArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.angle_){0}
  };
}

GeometryArchive::~GeometryArchive() {
  // @@protoc_insertion_point(destructor:TSD.GeometryArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeometryArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.size_;
}

void GeometryArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GeometryArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GeometryArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.size_ != nullptr);
      _impl_.size_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.angle_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.angle_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GeometryArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Point position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float angle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeometryArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GeometryArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Point position = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional float angle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_angle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GeometryArchive)
  return target;
}

size_t GeometryArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GeometryArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSP.Point position = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .TSP.Size size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.size_);
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional float angle = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GeometryArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GeometryArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GeometryArchive::GetClassData() const { return &_class_data_; }


void GeometryArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GeometryArchive*>(&to_msg);
  auto& from = static_cast<const GeometryArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GeometryArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::TSP::Point::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_size()->::TSP::Size::MergeFrom(
          from._internal_size());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.angle_ = from._impl_.angle_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GeometryArchive::CopyFrom(const GeometryArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GeometryArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeometryArchive::IsInitialized() const {
  if (_internal_has_position()) {
    if (!_impl_.position_->IsInitialized()) return false;
  }
  if (_internal_has_size()) {
    if (!_impl_.size_->IsInitialized()) return false;
  }
  return true;
}

void GeometryArchive::InternalSwap(GeometryArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GeometryArchive, _impl_.angle_)
      + sizeof(GeometryArchive::_impl_.angle_)
      - PROTOBUF_FIELD_OFFSET(GeometryArchive, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GeometryArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[1]);
}

// ===================================================================

class PointPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PointPathSourceArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Point& point(const PointPathSourceArchive* msg);
  static void set_has_point(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& naturalsize(const PointPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Point&
PointPathSourceArchive::_Internal::point(const PointPathSourceArchive* msg) {
  return *msg->_impl_.point_;
}
const ::TSP::Size&
PointPathSourceArchive::_Internal::naturalsize(const PointPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void PointPathSourceArchive::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PointPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PointPathSourceArchive::PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PointPathSourceArchive)
}
PointPathSourceArchive::PointPathSourceArchive(const PointPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    _this->_impl_.point_ = new ::TSP::Point(*from._impl_.point_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSD.PointPathSourceArchive)
}

inline void PointPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){0}
  };
}

PointPathSourceArchive::~PointPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.PointPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void PointPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PointPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.point_ != nullptr);
      _impl_.point_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::PointPathSourceArchive_PointPathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::PointPathSourceArchive_PointPathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PointPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .TSP.Point point = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PointPathSourceArchive)
  return target;
}

size_t PointPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PointPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Point point = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_);
    }

    // optional .TSP.Size naturalSize = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointPathSourceArchive::GetClassData() const { return &_class_data_; }


void PointPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const PointPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PointPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point()->::TSP::Point::MergeFrom(
          from._internal_point());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointPathSourceArchive::CopyFrom(const PointPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PointPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointPathSourceArchive::IsInitialized() const {
  if (_internal_has_point()) {
    if (!_impl_.point_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void PointPathSourceArchive::InternalSwap(PointPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointPathSourceArchive, _impl_.type_)
      + sizeof(PointPathSourceArchive::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(PointPathSourceArchive, _impl_.point_)>(
          reinterpret_cast<char*>(&_impl_.point_),
          reinterpret_cast<char*>(&other->_impl_.point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[2]);
}

// ===================================================================

class ScalarPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ScalarPathSourceArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scalar(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Size& naturalsize(const ScalarPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Size&
ScalarPathSourceArchive::_Internal::naturalsize(const ScalarPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void ScalarPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ScalarPathSourceArchive::ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ScalarPathSourceArchive)
}
ScalarPathSourceArchive::ScalarPathSourceArchive(const ScalarPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScalarPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.scalar_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scalar_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.scalar_));
  // @@protoc_insertion_point(copy_constructor:TSD.ScalarPathSourceArchive)
}

inline void ScalarPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.scalar_){0}
  };
}

ScalarPathSourceArchive::~ScalarPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.ScalarPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScalarPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void ScalarPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScalarPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ScalarPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
    _impl_.naturalsize_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scalar_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.scalar_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScalarPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ScalarPathSourceArchive_ScalarPathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ScalarPathSourceArchive_ScalarPathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float scalar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_scalar(&has_bits);
          _impl_.scalar_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScalarPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ScalarPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float scalar = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_scalar(), target);
  }

  // optional .TSP.Size naturalSize = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ScalarPathSourceArchive)
  return target;
}

size_t ScalarPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ScalarPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Size naturalSize = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float scalar = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScalarPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScalarPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScalarPathSourceArchive::GetClassData() const { return &_class_data_; }


void ScalarPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScalarPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const ScalarPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ScalarPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scalar_ = from._impl_.scalar_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScalarPathSourceArchive::CopyFrom(const ScalarPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ScalarPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScalarPathSourceArchive::IsInitialized() const {
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void ScalarPathSourceArchive::InternalSwap(ScalarPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScalarPathSourceArchive, _impl_.scalar_)
      + sizeof(ScalarPathSourceArchive::_impl_.scalar_)
      - PROTOBUF_FIELD_OFFSET(ScalarPathSourceArchive, _impl_.naturalsize_)>(
          reinterpret_cast<char*>(&_impl_.naturalsize_),
          reinterpret_cast<char*>(&other->_impl_.naturalsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ScalarPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[3]);
}

// ===================================================================

class BezierPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<BezierPathSourceArchive>()._impl_._has_bits_);
  static void set_has_path_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& naturalsize(const BezierPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Path& path(const BezierPathSourceArchive* msg);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Size&
BezierPathSourceArchive::_Internal::naturalsize(const BezierPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
const ::TSP::Path&
BezierPathSourceArchive::_Internal::path(const BezierPathSourceArchive* msg) {
  return *msg->_impl_.path_;
}
void BezierPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void BezierPathSourceArchive::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
BezierPathSourceArchive::BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.BezierPathSourceArchive)
}
BezierPathSourceArchive::BezierPathSourceArchive(const BezierPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BezierPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_string_){}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.path_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path_string()) {
    _this->_impl_.path_string_.Set(from._internal_path_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::TSP::Path(*from._impl_.path_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.BezierPathSourceArchive)
}

inline void BezierPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_string_){}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.path_){nullptr}
  };
  _impl_.path_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BezierPathSourceArchive::~BezierPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.BezierPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BezierPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.path_;
}

void BezierPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BezierPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.BezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.path_ != nullptr);
      _impl_.path_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BezierPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path_string = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.BezierPathSourceArchive.path_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BezierPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.BezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string path_string = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path_string().data(), static_cast<int>(this->_internal_path_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.BezierPathSourceArchive.path_string");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path_string(), target);
  }

  // optional .TSP.Size naturalSize = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path path = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.BezierPathSourceArchive)
  return target;
}

size_t BezierPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.BezierPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string path_string = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path_string());
    }

    // optional .TSP.Size naturalSize = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSP.Path path = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BezierPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BezierPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BezierPathSourceArchive::GetClassData() const { return &_class_data_; }


void BezierPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BezierPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const BezierPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.BezierPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path_string(from._internal_path_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_path()->::TSP::Path::MergeFrom(
          from._internal_path());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BezierPathSourceArchive::CopyFrom(const BezierPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.BezierPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BezierPathSourceArchive::IsInitialized() const {
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_path()) {
    if (!_impl_.path_->IsInitialized()) return false;
  }
  return true;
}

void BezierPathSourceArchive::InternalSwap(BezierPathSourceArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_string_, lhs_arena,
      &other->_impl_.path_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BezierPathSourceArchive, _impl_.path_)
      + sizeof(BezierPathSourceArchive::_impl_.path_)
      - PROTOBUF_FIELD_OFFSET(BezierPathSourceArchive, _impl_.naturalsize_)>(
          reinterpret_cast<char*>(&_impl_.naturalsize_),
          reinterpret_cast<char*>(&other->_impl_.naturalsize_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BezierPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[4]);
}

// ===================================================================

class CalloutPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CalloutPathSourceArchive>()._impl_._has_bits_);
  static const ::TSP::Size& natural_size(const CalloutPathSourceArchive* msg);
  static void set_has_natural_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& tail_position(const CalloutPathSourceArchive* msg);
  static void set_has_tail_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tail_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_corner_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_center_tail(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Size&
CalloutPathSourceArchive::_Internal::natural_size(const CalloutPathSourceArchive* msg) {
  return *msg->_impl_.natural_size_;
}
const ::TSP::Point&
CalloutPathSourceArchive::_Internal::tail_position(const CalloutPathSourceArchive* msg) {
  return *msg->_impl_.tail_position_;
}
void CalloutPathSourceArchive::clear_natural_size() {
  if (_impl_.natural_size_ != nullptr) _impl_.natural_size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CalloutPathSourceArchive::clear_tail_position() {
  if (_impl_.tail_position_ != nullptr) _impl_.tail_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CalloutPathSourceArchive::CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CalloutPathSourceArchive)
}
CalloutPathSourceArchive::CalloutPathSourceArchive(const CalloutPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CalloutPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.tail_position_){nullptr}
    , decltype(_impl_.tail_size_){}
    , decltype(_impl_.corner_radius_){}
    , decltype(_impl_.center_tail_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_natural_size()) {
    _this->_impl_.natural_size_ = new ::TSP::Size(*from._impl_.natural_size_);
  }
  if (from._internal_has_tail_position()) {
    _this->_impl_.tail_position_ = new ::TSP::Point(*from._impl_.tail_position_);
  }
  ::memcpy(&_impl_.tail_size_, &from._impl_.tail_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.center_tail_) -
    reinterpret_cast<char*>(&_impl_.tail_size_)) + sizeof(_impl_.center_tail_));
  // @@protoc_insertion_point(copy_constructor:TSD.CalloutPathSourceArchive)
}

inline void CalloutPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.natural_size_){nullptr}
    , decltype(_impl_.tail_position_){nullptr}
    , decltype(_impl_.tail_size_){0}
    , decltype(_impl_.corner_radius_){0}
    , decltype(_impl_.center_tail_){false}
  };
}

CalloutPathSourceArchive::~CalloutPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.CalloutPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CalloutPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.natural_size_;
  if (this != internal_default_instance()) delete _impl_.tail_position_;
}

void CalloutPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CalloutPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CalloutPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.natural_size_ != nullptr);
      _impl_.natural_size_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tail_position_ != nullptr);
      _impl_.tail_position_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.tail_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.center_tail_) -
        reinterpret_cast<char*>(&_impl_.tail_size_)) + sizeof(_impl_.center_tail_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CalloutPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Size natural_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_natural_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point tail_position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float tail_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_tail_size(&has_bits);
          _impl_.tail_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float corner_radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_corner_radius(&has_bits);
          _impl_.corner_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool center_tail = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_center_tail(&has_bits);
          _impl_.center_tail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CalloutPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CalloutPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Size natural_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::natural_size(this),
        _Internal::natural_size(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point tail_position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tail_position(this),
        _Internal::tail_position(this).GetCachedSize(), target, stream);
  }

  // optional float tail_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_tail_size(), target);
  }

  // optional float corner_radius = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_corner_radius(), target);
  }

  // optional bool center_tail = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_center_tail(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CalloutPathSourceArchive)
  return target;
}

size_t CalloutPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CalloutPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSP.Size natural_size = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.natural_size_);
    }

    // optional .TSP.Point tail_position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tail_position_);
    }

    // optional float tail_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float corner_radius = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool center_tail = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CalloutPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CalloutPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CalloutPathSourceArchive::GetClassData() const { return &_class_data_; }


void CalloutPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CalloutPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const CalloutPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CalloutPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_natural_size()->::TSP::Size::MergeFrom(
          from._internal_natural_size());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tail_position()->::TSP::Point::MergeFrom(
          from._internal_tail_position());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tail_size_ = from._impl_.tail_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.corner_radius_ = from._impl_.corner_radius_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.center_tail_ = from._impl_.center_tail_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CalloutPathSourceArchive::CopyFrom(const CalloutPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CalloutPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CalloutPathSourceArchive::IsInitialized() const {
  if (_internal_has_natural_size()) {
    if (!_impl_.natural_size_->IsInitialized()) return false;
  }
  if (_internal_has_tail_position()) {
    if (!_impl_.tail_position_->IsInitialized()) return false;
  }
  return true;
}

void CalloutPathSourceArchive::InternalSwap(CalloutPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CalloutPathSourceArchive, _impl_.center_tail_)
      + sizeof(CalloutPathSourceArchive::_impl_.center_tail_)
      - PROTOBUF_FIELD_OFFSET(CalloutPathSourceArchive, _impl_.natural_size_)>(
          reinterpret_cast<char*>(&_impl_.natural_size_),
          reinterpret_cast<char*>(&other->_impl_.natural_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CalloutPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[5]);
}

// ===================================================================

class ConnectionLinePathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionLinePathSourceArchive>()._impl_._has_bits_);
  static const ::TSD::BezierPathSourceArchive& super(const ConnectionLinePathSourceArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_outset_from(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_outset_to(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::BezierPathSourceArchive&
ConnectionLinePathSourceArchive::_Internal::super(const ConnectionLinePathSourceArchive* msg) {
  return *msg->_impl_.super_;
}
ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ConnectionLinePathSourceArchive)
}
ConnectionLinePathSourceArchive::ConnectionLinePathSourceArchive(const ConnectionLinePathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectionLinePathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.outset_from_){}
    , decltype(_impl_.outset_to_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::BezierPathSourceArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.outset_to_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.outset_to_));
  // @@protoc_insertion_point(copy_constructor:TSD.ConnectionLinePathSourceArchive)
}

inline void ConnectionLinePathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.outset_from_){0}
    , decltype(_impl_.outset_to_){0}
  };
}

ConnectionLinePathSourceArchive::~ConnectionLinePathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.ConnectionLinePathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionLinePathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ConnectionLinePathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionLinePathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ConnectionLinePathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.outset_to_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.outset_to_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectionLinePathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.BezierPathSourceArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float outset_from = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_outset_from(&has_bits);
          _impl_.outset_from_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float outset_to = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_outset_to(&has_bits);
          _impl_.outset_to_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionLinePathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ConnectionLinePathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.BezierPathSourceArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional float outset_from = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_outset_from(), target);
  }

  // optional float outset_to = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_outset_to(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ConnectionLinePathSourceArchive)
  return target;
}

size_t ConnectionLinePathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ConnectionLinePathSourceArchive)
  size_t total_size = 0;

  // required .TSD.BezierPathSourceArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float outset_from = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float outset_to = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectionLinePathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectionLinePathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectionLinePathSourceArchive::GetClassData() const { return &_class_data_; }


void ConnectionLinePathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectionLinePathSourceArchive*>(&to_msg);
  auto& from = static_cast<const ConnectionLinePathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ConnectionLinePathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::BezierPathSourceArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.outset_from_ = from._impl_.outset_from_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.outset_to_ = from._impl_.outset_to_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectionLinePathSourceArchive::CopyFrom(const ConnectionLinePathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ConnectionLinePathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionLinePathSourceArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ConnectionLinePathSourceArchive::InternalSwap(ConnectionLinePathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionLinePathSourceArchive, _impl_.outset_to_)
      + sizeof(ConnectionLinePathSourceArchive::_impl_.outset_to_)
      - PROTOBUF_FIELD_OFFSET(ConnectionLinePathSourceArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectionLinePathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[6]);
}

// ===================================================================

class EditableBezierPathSourceArchive_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive_Node>()._impl_._has_bits_);
  static const ::TSP::Point& incontrolpoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_incontrolpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& nodepoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_nodepoint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Point& outcontrolpoint(const EditableBezierPathSourceArchive_Node* msg);
  static void set_has_outcontrolpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::incontrolpoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.incontrolpoint_;
}
const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::nodepoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.nodepoint_;
}
const ::TSP::Point&
EditableBezierPathSourceArchive_Node::_Internal::outcontrolpoint(const EditableBezierPathSourceArchive_Node* msg) {
  return *msg->_impl_.outcontrolpoint_;
}
void EditableBezierPathSourceArchive_Node::clear_incontrolpoint() {
  if (_impl_.incontrolpoint_ != nullptr) _impl_.incontrolpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EditableBezierPathSourceArchive_Node::clear_nodepoint() {
  if (_impl_.nodepoint_ != nullptr) _impl_.nodepoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void EditableBezierPathSourceArchive_Node::clear_outcontrolpoint() {
  if (_impl_.outcontrolpoint_ != nullptr) _impl_.outcontrolpoint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive.Node)
}
EditableBezierPathSourceArchive_Node::EditableBezierPathSourceArchive_Node(const EditableBezierPathSourceArchive_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incontrolpoint_){nullptr}
    , decltype(_impl_.nodepoint_){nullptr}
    , decltype(_impl_.outcontrolpoint_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_incontrolpoint()) {
    _this->_impl_.incontrolpoint_ = new ::TSP::Point(*from._impl_.incontrolpoint_);
  }
  if (from._internal_has_nodepoint()) {
    _this->_impl_.nodepoint_ = new ::TSP::Point(*from._impl_.nodepoint_);
  }
  if (from._internal_has_outcontrolpoint()) {
    _this->_impl_.outcontrolpoint_ = new ::TSP::Point(*from._impl_.outcontrolpoint_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive.Node)
}

inline void EditableBezierPathSourceArchive_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.incontrolpoint_){nullptr}
    , decltype(_impl_.nodepoint_){nullptr}
    , decltype(_impl_.outcontrolpoint_){nullptr}
    , decltype(_impl_.type_){1}
  };
}

EditableBezierPathSourceArchive_Node::~EditableBezierPathSourceArchive_Node() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.incontrolpoint_;
  if (this != internal_default_instance()) delete _impl_.nodepoint_;
  if (this != internal_default_instance()) delete _impl_.outcontrolpoint_;
}

void EditableBezierPathSourceArchive_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.incontrolpoint_ != nullptr);
      _impl_.incontrolpoint_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.nodepoint_ != nullptr);
      _impl_.nodepoint_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.outcontrolpoint_ != nullptr);
      _impl_.outcontrolpoint_->Clear();
    }
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Point inControlPoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_incontrolpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Point nodePoint = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nodepoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Point outControlPoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_outcontrolpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::EditableBezierPathSourceArchive_NodeType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::EditableBezierPathSourceArchive_NodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Point inControlPoint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::incontrolpoint(this),
        _Internal::incontrolpoint(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Point nodePoint = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nodepoint(this),
        _Internal::nodepoint(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Point outControlPoint = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::outcontrolpoint(this),
        _Internal::outcontrolpoint(this).GetCachedSize(), target, stream);
  }

  // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive.Node)
  return target;
}

size_t EditableBezierPathSourceArchive_Node::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.EditableBezierPathSourceArchive.Node)
  size_t total_size = 0;

  if (_internal_has_incontrolpoint()) {
    // required .TSP.Point inControlPoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.incontrolpoint_);
  }

  if (_internal_has_nodepoint()) {
    // required .TSP.Point nodePoint = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodepoint_);
  }

  if (_internal_has_outcontrolpoint()) {
    // required .TSP.Point outControlPoint = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outcontrolpoint_);
  }

  if (_internal_has_type()) {
    // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t EditableBezierPathSourceArchive_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive.Node)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TSP.Point inControlPoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.incontrolpoint_);

    // required .TSP.Point nodePoint = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.nodepoint_);

    // required .TSP.Point outControlPoint = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outcontrolpoint_);

    // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive_Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive_Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive_Node::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive_Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive_Node*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive_Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_incontrolpoint()->::TSP::Point::MergeFrom(
          from._internal_incontrolpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_nodepoint()->::TSP::Point::MergeFrom(
          from._internal_nodepoint());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_outcontrolpoint()->::TSP::Point::MergeFrom(
          from._internal_outcontrolpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive_Node::CopyFrom(const EditableBezierPathSourceArchive_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive_Node::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_incontrolpoint()) {
    if (!_impl_.incontrolpoint_->IsInitialized()) return false;
  }
  if (_internal_has_nodepoint()) {
    if (!_impl_.nodepoint_->IsInitialized()) return false;
  }
  if (_internal_has_outcontrolpoint()) {
    if (!_impl_.outcontrolpoint_->IsInitialized()) return false;
  }
  return true;
}

void EditableBezierPathSourceArchive_Node::InternalSwap(EditableBezierPathSourceArchive_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EditableBezierPathSourceArchive_Node, _impl_.outcontrolpoint_)
      + sizeof(EditableBezierPathSourceArchive_Node::_impl_.outcontrolpoint_)
      - PROTOBUF_FIELD_OFFSET(EditableBezierPathSourceArchive_Node, _impl_.incontrolpoint_)>(
          reinterpret_cast<char*>(&_impl_.incontrolpoint_),
          reinterpret_cast<char*>(&other->_impl_.incontrolpoint_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive_Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[7]);
}

// ===================================================================

class EditableBezierPathSourceArchive_Subpath::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive_Subpath>()._impl_._has_bits_);
  static void set_has_closed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive.Subpath)
}
EditableBezierPathSourceArchive_Subpath::EditableBezierPathSourceArchive_Subpath(const EditableBezierPathSourceArchive_Subpath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive_Subpath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){from._impl_.nodes_}
    , decltype(_impl_.closed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.closed_ = from._impl_.closed_;
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive.Subpath)
}

inline void EditableBezierPathSourceArchive_Subpath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.nodes_){arena}
    , decltype(_impl_.closed_){false}
  };
}

EditableBezierPathSourceArchive_Subpath::~EditableBezierPathSourceArchive_Subpath() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive.Subpath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive_Subpath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void EditableBezierPathSourceArchive_Subpath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive_Subpath::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive.Subpath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _impl_.closed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive_Subpath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required bool closed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_closed(&has_bits);
          _impl_.closed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive_Subpath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive.Subpath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required bool closed = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_closed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive.Subpath)
  return target;
}

size_t EditableBezierPathSourceArchive_Subpath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive.Subpath)
  size_t total_size = 0;

  // required bool closed = 2;
  if (_internal_has_closed()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive_Subpath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive_Subpath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive_Subpath::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive_Subpath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive_Subpath*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive_Subpath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive.Subpath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  if (from._internal_has_closed()) {
    _this->_internal_set_closed(from._internal_closed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive_Subpath::CopyFrom(const EditableBezierPathSourceArchive_Subpath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive.Subpath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive_Subpath::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.nodes_))
    return false;
  return true;
}

void EditableBezierPathSourceArchive_Subpath::InternalSwap(EditableBezierPathSourceArchive_Subpath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
  swap(_impl_.closed_, other->_impl_.closed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive_Subpath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[8]);
}

// ===================================================================

class EditableBezierPathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EditableBezierPathSourceArchive>()._impl_._has_bits_);
  static const ::TSP::Size& naturalsize(const EditableBezierPathSourceArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Size&
EditableBezierPathSourceArchive::_Internal::naturalsize(const EditableBezierPathSourceArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void EditableBezierPathSourceArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.EditableBezierPathSourceArchive)
}
EditableBezierPathSourceArchive::EditableBezierPathSourceArchive(const EditableBezierPathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditableBezierPathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subpaths_){from._impl_.subpaths_}
    , decltype(_impl_.naturalsize_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.EditableBezierPathSourceArchive)
}

inline void EditableBezierPathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subpaths_){arena}
    , decltype(_impl_.naturalsize_){nullptr}
  };
}

EditableBezierPathSourceArchive::~EditableBezierPathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.EditableBezierPathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditableBezierPathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subpaths_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
}

void EditableBezierPathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditableBezierPathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.EditableBezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subpaths_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
    _impl_.naturalsize_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditableBezierPathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subpaths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditableBezierPathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.EditableBezierPathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subpaths_size()); i < n; i++) {
    const auto& repfield = this->_internal_subpaths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Size naturalSize = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.EditableBezierPathSourceArchive)
  return target;
}

size_t EditableBezierPathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.EditableBezierPathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  total_size += 1UL * this->_internal_subpaths_size();
  for (const auto& msg : this->_impl_.subpaths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Size naturalSize = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.naturalsize_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditableBezierPathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditableBezierPathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditableBezierPathSourceArchive::GetClassData() const { return &_class_data_; }


void EditableBezierPathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditableBezierPathSourceArchive*>(&to_msg);
  auto& from = static_cast<const EditableBezierPathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.EditableBezierPathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subpaths_.MergeFrom(from._impl_.subpaths_);
  if (from._internal_has_naturalsize()) {
    _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
        from._internal_naturalsize());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditableBezierPathSourceArchive::CopyFrom(const EditableBezierPathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.EditableBezierPathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditableBezierPathSourceArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.subpaths_))
    return false;
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  return true;
}

void EditableBezierPathSourceArchive::InternalSwap(EditableBezierPathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subpaths_.InternalSwap(&other->_impl_.subpaths_);
  swap(_impl_.naturalsize_, other->_impl_.naturalsize_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EditableBezierPathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[9]);
}

// ===================================================================

class PathSourceArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PathSourceArchive>()._impl_._has_bits_);
  static void set_has_horizontalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_verticalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSD::PointPathSourceArchive& point_path_source(const PathSourceArchive* msg);
  static void set_has_point_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::ScalarPathSourceArchive& scalar_path_source(const PathSourceArchive* msg);
  static void set_has_scalar_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::BezierPathSourceArchive& bezier_path_source(const PathSourceArchive* msg);
  static void set_has_bezier_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::CalloutPathSourceArchive& callout_path_source(const PathSourceArchive* msg);
  static void set_has_callout_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ConnectionLinePathSourceArchive& connection_line_path_source(const PathSourceArchive* msg);
  static void set_has_connection_line_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::EditableBezierPathSourceArchive& editable_bezier_path_source(const PathSourceArchive* msg);
  static void set_has_editable_bezier_path_source(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSD::PointPathSourceArchive&
PathSourceArchive::_Internal::point_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.point_path_source_;
}
const ::TSD::ScalarPathSourceArchive&
PathSourceArchive::_Internal::scalar_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.scalar_path_source_;
}
const ::TSD::BezierPathSourceArchive&
PathSourceArchive::_Internal::bezier_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.bezier_path_source_;
}
const ::TSD::CalloutPathSourceArchive&
PathSourceArchive::_Internal::callout_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.callout_path_source_;
}
const ::TSD::ConnectionLinePathSourceArchive&
PathSourceArchive::_Internal::connection_line_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.connection_line_path_source_;
}
const ::TSD::EditableBezierPathSourceArchive&
PathSourceArchive::_Internal::editable_bezier_path_source(const PathSourceArchive* msg) {
  return *msg->_impl_.editable_bezier_path_source_;
}
PathSourceArchive::PathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PathSourceArchive)
}
PathSourceArchive::PathSourceArchive(const PathSourceArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathSourceArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_path_source_){nullptr}
    , decltype(_impl_.scalar_path_source_){nullptr}
    , decltype(_impl_.bezier_path_source_){nullptr}
    , decltype(_impl_.callout_path_source_){nullptr}
    , decltype(_impl_.connection_line_path_source_){nullptr}
    , decltype(_impl_.editable_bezier_path_source_){nullptr}
    , decltype(_impl_.horizontalflip_){}
    , decltype(_impl_.verticalflip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point_path_source()) {
    _this->_impl_.point_path_source_ = new ::TSD::PointPathSourceArchive(*from._impl_.point_path_source_);
  }
  if (from._internal_has_scalar_path_source()) {
    _this->_impl_.scalar_path_source_ = new ::TSD::ScalarPathSourceArchive(*from._impl_.scalar_path_source_);
  }
  if (from._internal_has_bezier_path_source()) {
    _this->_impl_.bezier_path_source_ = new ::TSD::BezierPathSourceArchive(*from._impl_.bezier_path_source_);
  }
  if (from._internal_has_callout_path_source()) {
    _this->_impl_.callout_path_source_ = new ::TSD::CalloutPathSourceArchive(*from._impl_.callout_path_source_);
  }
  if (from._internal_has_connection_line_path_source()) {
    _this->_impl_.connection_line_path_source_ = new ::TSD::ConnectionLinePathSourceArchive(*from._impl_.connection_line_path_source_);
  }
  if (from._internal_has_editable_bezier_path_source()) {
    _this->_impl_.editable_bezier_path_source_ = new ::TSD::EditableBezierPathSourceArchive(*from._impl_.editable_bezier_path_source_);
  }
  ::memcpy(&_impl_.horizontalflip_, &from._impl_.horizontalflip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.verticalflip_) -
    reinterpret_cast<char*>(&_impl_.horizontalflip_)) + sizeof(_impl_.verticalflip_));
  // @@protoc_insertion_point(copy_constructor:TSD.PathSourceArchive)
}

inline void PathSourceArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.point_path_source_){nullptr}
    , decltype(_impl_.scalar_path_source_){nullptr}
    , decltype(_impl_.bezier_path_source_){nullptr}
    , decltype(_impl_.callout_path_source_){nullptr}
    , decltype(_impl_.connection_line_path_source_){nullptr}
    , decltype(_impl_.editable_bezier_path_source_){nullptr}
    , decltype(_impl_.horizontalflip_){false}
    , decltype(_impl_.verticalflip_){false}
  };
}

PathSourceArchive::~PathSourceArchive() {
  // @@protoc_insertion_point(destructor:TSD.PathSourceArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathSourceArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.point_path_source_;
  if (this != internal_default_instance()) delete _impl_.scalar_path_source_;
  if (this != internal_default_instance()) delete _impl_.bezier_path_source_;
  if (this != internal_default_instance()) delete _impl_.callout_path_source_;
  if (this != internal_default_instance()) delete _impl_.connection_line_path_source_;
  if (this != internal_default_instance()) delete _impl_.editable_bezier_path_source_;
}

void PathSourceArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathSourceArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PathSourceArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.point_path_source_ != nullptr);
      _impl_.point_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.scalar_path_source_ != nullptr);
      _impl_.scalar_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.bezier_path_source_ != nullptr);
      _impl_.bezier_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.callout_path_source_ != nullptr);
      _impl_.callout_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.connection_line_path_source_ != nullptr);
      _impl_.connection_line_path_source_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.editable_bezier_path_source_ != nullptr);
      _impl_.editable_bezier_path_source_->Clear();
    }
  }
  ::memset(&_impl_.horizontalflip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.verticalflip_) -
      reinterpret_cast<char*>(&_impl_.horizontalflip_)) + sizeof(_impl_.verticalflip_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathSourceArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool horizontalFlip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_horizontalflip(&has_bits);
          _impl_.horizontalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool verticalFlip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_verticalflip(&has_bits);
          _impl_.verticalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PointPathSourceArchive point_path_source = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_scalar_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bezier_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_callout_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_line_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_editable_bezier_path_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathSourceArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PathSourceArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool horizontalFlip = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_horizontalflip(), target);
  }

  // optional bool verticalFlip = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_verticalflip(), target);
  }

  // optional .TSD.PointPathSourceArchive point_path_source = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point_path_source(this),
        _Internal::point_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::scalar_path_source(this),
        _Internal::scalar_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::bezier_path_source(this),
        _Internal::bezier_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::callout_path_source(this),
        _Internal::callout_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::connection_line_path_source(this),
        _Internal::connection_line_path_source(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::editable_bezier_path_source(this),
        _Internal::editable_bezier_path_source(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PathSourceArchive)
  return target;
}

size_t PathSourceArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PathSourceArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSD.PointPathSourceArchive point_path_source = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.point_path_source_);
    }

    // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scalar_path_source_);
    }

    // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bezier_path_source_);
    }

    // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.callout_path_source_);
    }

    // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connection_line_path_source_);
    }

    // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.editable_bezier_path_source_);
    }

    // optional bool horizontalFlip = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool verticalFlip = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathSourceArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathSourceArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathSourceArchive::GetClassData() const { return &_class_data_; }


void PathSourceArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathSourceArchive*>(&to_msg);
  auto& from = static_cast<const PathSourceArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PathSourceArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_point_path_source()->::TSD::PointPathSourceArchive::MergeFrom(
          from._internal_point_path_source());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_scalar_path_source()->::TSD::ScalarPathSourceArchive::MergeFrom(
          from._internal_scalar_path_source());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_bezier_path_source()->::TSD::BezierPathSourceArchive::MergeFrom(
          from._internal_bezier_path_source());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_callout_path_source()->::TSD::CalloutPathSourceArchive::MergeFrom(
          from._internal_callout_path_source());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_connection_line_path_source()->::TSD::ConnectionLinePathSourceArchive::MergeFrom(
          from._internal_connection_line_path_source());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_editable_bezier_path_source()->::TSD::EditableBezierPathSourceArchive::MergeFrom(
          from._internal_editable_bezier_path_source());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.horizontalflip_ = from._impl_.horizontalflip_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.verticalflip_ = from._impl_.verticalflip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathSourceArchive::CopyFrom(const PathSourceArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PathSourceArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathSourceArchive::IsInitialized() const {
  if (_internal_has_point_path_source()) {
    if (!_impl_.point_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_scalar_path_source()) {
    if (!_impl_.scalar_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_bezier_path_source()) {
    if (!_impl_.bezier_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_callout_path_source()) {
    if (!_impl_.callout_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_connection_line_path_source()) {
    if (!_impl_.connection_line_path_source_->IsInitialized()) return false;
  }
  if (_internal_has_editable_bezier_path_source()) {
    if (!_impl_.editable_bezier_path_source_->IsInitialized()) return false;
  }
  return true;
}

void PathSourceArchive::InternalSwap(PathSourceArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathSourceArchive, _impl_.verticalflip_)
      + sizeof(PathSourceArchive::_impl_.verticalflip_)
      - PROTOBUF_FIELD_OFFSET(PathSourceArchive, _impl_.point_path_source_)>(
          reinterpret_cast<char*>(&_impl_.point_path_source_),
          reinterpret_cast<char*>(&other->_impl_.point_path_source_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathSourceArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[10]);
}

// ===================================================================

class AngleGradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AngleGradientArchive>()._impl_._has_bits_);
  static void set_has_gradientangle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AngleGradientArchive::AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.AngleGradientArchive)
}
AngleGradientArchive::AngleGradientArchive(const AngleGradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AngleGradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gradientangle_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.gradientangle_ = from._impl_.gradientangle_;
  // @@protoc_insertion_point(copy_constructor:TSD.AngleGradientArchive)
}

inline void AngleGradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gradientangle_){0}
  };
}

AngleGradientArchive::~AngleGradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.AngleGradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AngleGradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AngleGradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AngleGradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.AngleGradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gradientangle_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AngleGradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float gradientangle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_gradientangle(&has_bits);
          _impl_.gradientangle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AngleGradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.AngleGradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float gradientangle = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_gradientangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.AngleGradientArchive)
  return target;
}

size_t AngleGradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.AngleGradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float gradientangle = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AngleGradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AngleGradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AngleGradientArchive::GetClassData() const { return &_class_data_; }


void AngleGradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AngleGradientArchive*>(&to_msg);
  auto& from = static_cast<const AngleGradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.AngleGradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gradientangle()) {
    _this->_internal_set_gradientangle(from._internal_gradientangle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AngleGradientArchive::CopyFrom(const AngleGradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.AngleGradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AngleGradientArchive::IsInitialized() const {
  return true;
}

void AngleGradientArchive::InternalSwap(AngleGradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.gradientangle_, other->_impl_.gradientangle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AngleGradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[11]);
}

// ===================================================================

class TransformGradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TransformGradientArchive>()._impl_._has_bits_);
  static const ::TSP::Point& start(const TransformGradientArchive* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Point& end(const TransformGradientArchive* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& basenaturalsize(const TransformGradientArchive* msg);
  static void set_has_basenaturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Point&
TransformGradientArchive::_Internal::start(const TransformGradientArchive* msg) {
  return *msg->_impl_.start_;
}
const ::TSP::Point&
TransformGradientArchive::_Internal::end(const TransformGradientArchive* msg) {
  return *msg->_impl_.end_;
}
const ::TSP::Size&
TransformGradientArchive::_Internal::basenaturalsize(const TransformGradientArchive* msg) {
  return *msg->_impl_.basenaturalsize_;
}
void TransformGradientArchive::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TransformGradientArchive::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TransformGradientArchive::clear_basenaturalsize() {
  if (_impl_.basenaturalsize_ != nullptr) _impl_.basenaturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TransformGradientArchive::TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.TransformGradientArchive)
}
TransformGradientArchive::TransformGradientArchive(const TransformGradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransformGradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.basenaturalsize_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::TSP::Point(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::TSP::Point(*from._impl_.end_);
  }
  if (from._internal_has_basenaturalsize()) {
    _this->_impl_.basenaturalsize_ = new ::TSP::Size(*from._impl_.basenaturalsize_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.TransformGradientArchive)
}

inline void TransformGradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.basenaturalsize_){nullptr}
  };
}

TransformGradientArchive::~TransformGradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.TransformGradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransformGradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
  if (this != internal_default_instance()) delete _impl_.basenaturalsize_;
}

void TransformGradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransformGradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.TransformGradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.basenaturalsize_ != nullptr);
      _impl_.basenaturalsize_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransformGradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Point start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size baseNaturalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_basenaturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransformGradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.TransformGradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Point start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Point end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size baseNaturalSize = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::basenaturalsize(this),
        _Internal::basenaturalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.TransformGradientArchive)
  return target;
}

size_t TransformGradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.TransformGradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Point start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .TSP.Point end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

    // optional .TSP.Size baseNaturalSize = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.basenaturalsize_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransformGradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransformGradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransformGradientArchive::GetClassData() const { return &_class_data_; }


void TransformGradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransformGradientArchive*>(&to_msg);
  auto& from = static_cast<const TransformGradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.TransformGradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::TSP::Point::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::TSP::Point::MergeFrom(
          from._internal_end());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_basenaturalsize()->::TSP::Size::MergeFrom(
          from._internal_basenaturalsize());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransformGradientArchive::CopyFrom(const TransformGradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.TransformGradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransformGradientArchive::IsInitialized() const {
  if (_internal_has_start()) {
    if (!_impl_.start_->IsInitialized()) return false;
  }
  if (_internal_has_end()) {
    if (!_impl_.end_->IsInitialized()) return false;
  }
  if (_internal_has_basenaturalsize()) {
    if (!_impl_.basenaturalsize_->IsInitialized()) return false;
  }
  return true;
}

void TransformGradientArchive::InternalSwap(TransformGradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransformGradientArchive, _impl_.basenaturalsize_)
      + sizeof(TransformGradientArchive::_impl_.basenaturalsize_)
      - PROTOBUF_FIELD_OFFSET(TransformGradientArchive, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransformGradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[12]);
}

// ===================================================================

class GradientArchive_GradientStop::_Internal {
 public:
  using HasBits = decltype(std::declval<GradientArchive_GradientStop>()._impl_._has_bits_);
  static const ::TSP::Color& color(const GradientArchive_GradientStop* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inflection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Color&
GradientArchive_GradientStop::_Internal::color(const GradientArchive_GradientStop* msg) {
  return *msg->_impl_.color_;
}
void GradientArchive_GradientStop::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
GradientArchive_GradientStop::GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GradientArchive.GradientStop)
}
GradientArchive_GradientStop::GradientArchive_GradientStop(const GradientArchive_GradientStop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GradientArchive_GradientStop* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.fraction_){}
    , decltype(_impl_.inflection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  ::memcpy(&_impl_.fraction_, &from._impl_.fraction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inflection_) -
    reinterpret_cast<char*>(&_impl_.fraction_)) + sizeof(_impl_.inflection_));
  // @@protoc_insertion_point(copy_constructor:TSD.GradientArchive.GradientStop)
}

inline void GradientArchive_GradientStop::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.fraction_){0}
    , decltype(_impl_.inflection_){0}
  };
}

GradientArchive_GradientStop::~GradientArchive_GradientStop() {
  // @@protoc_insertion_point(destructor:TSD.GradientArchive.GradientStop)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GradientArchive_GradientStop::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
}

void GradientArchive_GradientStop::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GradientArchive_GradientStop::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GradientArchive.GradientStop)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.color_ != nullptr);
    _impl_.color_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.fraction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inflection_) -
        reinterpret_cast<char*>(&_impl_.fraction_)) + sizeof(_impl_.inflection_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GradientArchive_GradientStop::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fraction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_fraction(&has_bits);
          _impl_.fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float inflection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_inflection(&has_bits);
          _impl_.inflection_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GradientArchive_GradientStop::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GradientArchive.GradientStop)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float fraction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_fraction(), target);
  }

  // optional float inflection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_inflection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GradientArchive.GradientStop)
  return target;
}

size_t GradientArchive_GradientStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GradientArchive.GradientStop)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional float fraction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float inflection = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GradientArchive_GradientStop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GradientArchive_GradientStop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GradientArchive_GradientStop::GetClassData() const { return &_class_data_; }


void GradientArchive_GradientStop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GradientArchive_GradientStop*>(&to_msg);
  auto& from = static_cast<const GradientArchive_GradientStop&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GradientArchive.GradientStop)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fraction_ = from._impl_.fraction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.inflection_ = from._impl_.inflection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GradientArchive_GradientStop::CopyFrom(const GradientArchive_GradientStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GradientArchive.GradientStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GradientArchive_GradientStop::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void GradientArchive_GradientStop::InternalSwap(GradientArchive_GradientStop* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GradientArchive_GradientStop, _impl_.inflection_)
      + sizeof(GradientArchive_GradientStop::_impl_.inflection_)
      - PROTOBUF_FIELD_OFFSET(GradientArchive_GradientStop, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GradientArchive_GradientStop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[13]);
}

// ===================================================================

class GradientArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GradientArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_advancedgradient(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::AngleGradientArchive& anglegradient(const GradientArchive* msg);
  static void set_has_anglegradient(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::TransformGradientArchive& transformgradient(const GradientArchive* msg);
  static void set_has_transformgradient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::AngleGradientArchive&
GradientArchive::_Internal::anglegradient(const GradientArchive* msg) {
  return *msg->_impl_.anglegradient_;
}
const ::TSD::TransformGradientArchive&
GradientArchive::_Internal::transformgradient(const GradientArchive* msg) {
  return *msg->_impl_.transformgradient_;
}
GradientArchive::GradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GradientArchive)
}
GradientArchive::GradientArchive(const GradientArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GradientArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stops_){from._impl_.stops_}
    , decltype(_impl_.anglegradient_){nullptr}
    , decltype(_impl_.transformgradient_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.opacity_){}
    , decltype(_impl_.advancedgradient_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_anglegradient()) {
    _this->_impl_.anglegradient_ = new ::TSD::AngleGradientArchive(*from._impl_.anglegradient_);
  }
  if (from._internal_has_transformgradient()) {
    _this->_impl_.transformgradient_ = new ::TSD::TransformGradientArchive(*from._impl_.transformgradient_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.advancedgradient_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.advancedgradient_));
  // @@protoc_insertion_point(copy_constructor:TSD.GradientArchive)
}

inline void GradientArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stops_){arena}
    , decltype(_impl_.anglegradient_){nullptr}
    , decltype(_impl_.transformgradient_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.opacity_){0}
    , decltype(_impl_.advancedgradient_){false}
  };
}

GradientArchive::~GradientArchive() {
  // @@protoc_insertion_point(destructor:TSD.GradientArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GradientArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stops_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.anglegradient_;
  if (this != internal_default_instance()) delete _impl_.transformgradient_;
}

void GradientArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GradientArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GradientArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stops_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.anglegradient_ != nullptr);
      _impl_.anglegradient_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.transformgradient_ != nullptr);
      _impl_.transformgradient_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.advancedgradient_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.advancedgradient_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GradientArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GradientArchive.GradientType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::GradientArchive_GradientType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::GradientArchive_GradientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.GradientArchive.GradientStop stops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool advancedGradient = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_advancedgradient(&has_bits);
          _impl_.advancedgradient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.AngleGradientArchive anglegradient = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_anglegradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.TransformGradientArchive transformgradient = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transformgradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GradientArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GradientArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GradientArchive.GradientType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stops_size()); i < n; i++) {
    const auto& repfield = this->_internal_stops(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float opacity = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_opacity(), target);
  }

  // optional bool advancedGradient = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_advancedgradient(), target);
  }

  // optional .TSD.AngleGradientArchive anglegradient = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::anglegradient(this),
        _Internal::anglegradient(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.TransformGradientArchive transformgradient = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::transformgradient(this),
        _Internal::transformgradient(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GradientArchive)
  return target;
}

size_t GradientArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GradientArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  total_size += 1UL * this->_internal_stops_size();
  for (const auto& msg : this->_impl_.stops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSD.AngleGradientArchive anglegradient = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.anglegradient_);
    }

    // optional .TSD.TransformGradientArchive transformgradient = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.transformgradient_);
    }

    // optional .TSD.GradientArchive.GradientType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float opacity = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool advancedGradient = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GradientArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GradientArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GradientArchive::GetClassData() const { return &_class_data_; }


void GradientArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GradientArchive*>(&to_msg);
  auto& from = static_cast<const GradientArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GradientArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stops_.MergeFrom(from._impl_.stops_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_anglegradient()->::TSD::AngleGradientArchive::MergeFrom(
          from._internal_anglegradient());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_transformgradient()->::TSD::TransformGradientArchive::MergeFrom(
          from._internal_transformgradient());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.advancedgradient_ = from._impl_.advancedgradient_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GradientArchive::CopyFrom(const GradientArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GradientArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GradientArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.stops_))
    return false;
  if (_internal_has_transformgradient()) {
    if (!_impl_.transformgradient_->IsInitialized()) return false;
  }
  return true;
}

void GradientArchive::InternalSwap(GradientArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stops_.InternalSwap(&other->_impl_.stops_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GradientArchive, _impl_.advancedgradient_)
      + sizeof(GradientArchive::_impl_.advancedgradient_)
      - PROTOBUF_FIELD_OFFSET(GradientArchive, _impl_.anglegradient_)>(
          reinterpret_cast<char*>(&_impl_.anglegradient_),
          reinterpret_cast<char*>(&other->_impl_.anglegradient_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GradientArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[14]);
}

// ===================================================================

class ImageFillArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageFillArchive>()._impl_._has_bits_);
  static const ::TSP::DataReference& imagedata(const ImageFillArchive* msg);
  static void set_has_imagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_technique(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Color& tint(const ImageFillArchive* msg);
  static void set_has_tint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& fillsize(const ImageFillArchive* msg);
  static void set_has_fillsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::DataReference& originalimagedata(const ImageFillArchive* msg);
  static void set_has_originalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_interpretsuntaggedimagedataasgeneric(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& database_imagedata(const ImageFillArchive* msg);
  static void set_has_database_imagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& database_originalimagedata(const ImageFillArchive* msg);
  static void set_has_database_originalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::DataReference&
ImageFillArchive::_Internal::imagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.imagedata_;
}
const ::TSP::Color&
ImageFillArchive::_Internal::tint(const ImageFillArchive* msg) {
  return *msg->_impl_.tint_;
}
const ::TSP::Size&
ImageFillArchive::_Internal::fillsize(const ImageFillArchive* msg) {
  return *msg->_impl_.fillsize_;
}
const ::TSP::DataReference&
ImageFillArchive::_Internal::originalimagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.originalimagedata_;
}
const ::TSP::Reference&
ImageFillArchive::_Internal::database_imagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.database_imagedata_;
}
const ::TSP::Reference&
ImageFillArchive::_Internal::database_originalimagedata(const ImageFillArchive* msg) {
  return *msg->_impl_.database_originalimagedata_;
}
void ImageFillArchive::clear_imagedata() {
  if (_impl_.imagedata_ != nullptr) _impl_.imagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageFillArchive::clear_tint() {
  if (_impl_.tint_ != nullptr) _impl_.tint_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageFillArchive::clear_fillsize() {
  if (_impl_.fillsize_ != nullptr) _impl_.fillsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageFillArchive::clear_originalimagedata() {
  if (_impl_.originalimagedata_ != nullptr) _impl_.originalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageFillArchive::clear_database_imagedata() {
  if (_impl_.database_imagedata_ != nullptr) _impl_.database_imagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ImageFillArchive::clear_database_originalimagedata() {
  if (_impl_.database_originalimagedata_ != nullptr) _impl_.database_originalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ImageFillArchive::ImageFillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageFillArchive)
}
ImageFillArchive::ImageFillArchive(const ImageFillArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageFillArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.database_imagedata_){nullptr}
    , decltype(_impl_.tint_){nullptr}
    , decltype(_impl_.fillsize_){nullptr}
    , decltype(_impl_.database_originalimagedata_){nullptr}
    , decltype(_impl_.imagedata_){nullptr}
    , decltype(_impl_.originalimagedata_){nullptr}
    , decltype(_impl_.technique_){}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_database_imagedata()) {
    _this->_impl_.database_imagedata_ = new ::TSP::Reference(*from._impl_.database_imagedata_);
  }
  if (from._internal_has_tint()) {
    _this->_impl_.tint_ = new ::TSP::Color(*from._impl_.tint_);
  }
  if (from._internal_has_fillsize()) {
    _this->_impl_.fillsize_ = new ::TSP::Size(*from._impl_.fillsize_);
  }
  if (from._internal_has_database_originalimagedata()) {
    _this->_impl_.database_originalimagedata_ = new ::TSP::Reference(*from._impl_.database_originalimagedata_);
  }
  if (from._internal_has_imagedata()) {
    _this->_impl_.imagedata_ = new ::TSP::DataReference(*from._impl_.imagedata_);
  }
  if (from._internal_has_originalimagedata()) {
    _this->_impl_.originalimagedata_ = new ::TSP::DataReference(*from._impl_.originalimagedata_);
  }
  ::memcpy(&_impl_.technique_, &from._impl_.technique_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.interpretsuntaggedimagedataasgeneric_) -
    reinterpret_cast<char*>(&_impl_.technique_)) + sizeof(_impl_.interpretsuntaggedimagedataasgeneric_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageFillArchive)
}

inline void ImageFillArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.database_imagedata_){nullptr}
    , decltype(_impl_.tint_){nullptr}
    , decltype(_impl_.fillsize_){nullptr}
    , decltype(_impl_.database_originalimagedata_){nullptr}
    , decltype(_impl_.imagedata_){nullptr}
    , decltype(_impl_.originalimagedata_){nullptr}
    , decltype(_impl_.technique_){0}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){false}
  };
}

ImageFillArchive::~ImageFillArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageFillArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageFillArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.database_imagedata_;
  if (this != internal_default_instance()) delete _impl_.tint_;
  if (this != internal_default_instance()) delete _impl_.fillsize_;
  if (this != internal_default_instance()) delete _impl_.database_originalimagedata_;
  if (this != internal_default_instance()) delete _impl_.imagedata_;
  if (this != internal_default_instance()) delete _impl_.originalimagedata_;
}

void ImageFillArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageFillArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageFillArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.database_imagedata_ != nullptr);
      _impl_.database_imagedata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tint_ != nullptr);
      _impl_.tint_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.fillsize_ != nullptr);
      _impl_.fillsize_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.database_originalimagedata_ != nullptr);
      _impl_.database_originalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.imagedata_ != nullptr);
      _impl_.imagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.originalimagedata_ != nullptr);
      _impl_.originalimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.technique_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.interpretsuntaggedimagedataasgeneric_) -
        reinterpret_cast<char*>(&_impl_.technique_)) + sizeof(_impl_.interpretsuntaggedimagedataasgeneric_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageFillArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference database_imagedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_imagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ImageFillArchive_ImageFillTechnique_IsValid(val))) {
            _internal_set_technique(static_cast<::TSD::ImageFillArchive_ImageFillTechnique>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color tint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size fillsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_fillsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_originalimagedata = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_originalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference imagedata = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_imagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference originalimagedata = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool interpretsUntaggedImageDataAsGeneric = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_interpretsuntaggedimagedataasgeneric(&has_bits);
          _impl_.interpretsuntaggedimagedataasgeneric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageFillArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageFillArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference database_imagedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::database_imagedata(this),
        _Internal::database_imagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_technique(), target);
  }

  // optional .TSP.Color tint = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tint(this),
        _Internal::tint(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size fillsize = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::fillsize(this),
        _Internal::fillsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_originalimagedata = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::database_originalimagedata(this),
        _Internal::database_originalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference imagedata = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::imagedata(this),
        _Internal::imagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference originalimagedata = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::originalimagedata(this),
        _Internal::originalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_interpretsuntaggedimagedataasgeneric(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageFillArchive)
  return target;
}

size_t ImageFillArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageFillArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Reference database_imagedata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_imagedata_);
    }

    // optional .TSP.Color tint = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tint_);
    }

    // optional .TSP.Size fillsize = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fillsize_);
    }

    // optional .TSP.Reference database_originalimagedata = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_originalimagedata_);
    }

    // optional .TSP.DataReference imagedata = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.imagedata_);
    }

    // optional .TSP.DataReference originalimagedata = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalimagedata_);
    }

    // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_technique());
    }

    // optional bool interpretsUntaggedImageDataAsGeneric = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageFillArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageFillArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageFillArchive::GetClassData() const { return &_class_data_; }


void ImageFillArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageFillArchive*>(&to_msg);
  auto& from = static_cast<const ImageFillArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageFillArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_database_imagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_imagedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tint()->::TSP::Color::MergeFrom(
          from._internal_tint());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fillsize()->::TSP::Size::MergeFrom(
          from._internal_fillsize());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_database_originalimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_originalimagedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_imagedata()->::TSP::DataReference::MergeFrom(
          from._internal_imagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_originalimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_originalimagedata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.technique_ = from._impl_.technique_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.interpretsuntaggedimagedataasgeneric_ = from._impl_.interpretsuntaggedimagedataasgeneric_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageFillArchive::CopyFrom(const ImageFillArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageFillArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFillArchive::IsInitialized() const {
  if (_internal_has_database_imagedata()) {
    if (!_impl_.database_imagedata_->IsInitialized()) return false;
  }
  if (_internal_has_tint()) {
    if (!_impl_.tint_->IsInitialized()) return false;
  }
  if (_internal_has_fillsize()) {
    if (!_impl_.fillsize_->IsInitialized()) return false;
  }
  if (_internal_has_database_originalimagedata()) {
    if (!_impl_.database_originalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_imagedata()) {
    if (!_impl_.imagedata_->IsInitialized()) return false;
  }
  if (_internal_has_originalimagedata()) {
    if (!_impl_.originalimagedata_->IsInitialized()) return false;
  }
  return true;
}

void ImageFillArchive::InternalSwap(ImageFillArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageFillArchive, _impl_.interpretsuntaggedimagedataasgeneric_)
      + sizeof(ImageFillArchive::_impl_.interpretsuntaggedimagedataasgeneric_)
      - PROTOBUF_FIELD_OFFSET(ImageFillArchive, _impl_.database_imagedata_)>(
          reinterpret_cast<char*>(&_impl_.database_imagedata_),
          reinterpret_cast<char*>(&other->_impl_.database_imagedata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageFillArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[15]);
}

// ===================================================================

class FillArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FillArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const FillArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::GradientArchive& gradient(const FillArchive* msg);
  static void set_has_gradient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ImageFillArchive& image(const FillArchive* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Color&
FillArchive::_Internal::color(const FillArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::GradientArchive&
FillArchive::_Internal::gradient(const FillArchive* msg) {
  return *msg->_impl_.gradient_;
}
const ::TSD::ImageFillArchive&
FillArchive::_Internal::image(const FillArchive* msg) {
  return *msg->_impl_.image_;
}
void FillArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FillArchive::FillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FillArchive)
}
FillArchive::FillArchive(const FillArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FillArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.gradient_){nullptr}
    , decltype(_impl_.image_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_gradient()) {
    _this->_impl_.gradient_ = new ::TSD::GradientArchive(*from._impl_.gradient_);
  }
  if (from._internal_has_image()) {
    _this->_impl_.image_ = new ::TSD::ImageFillArchive(*from._impl_.image_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.FillArchive)
}

inline void FillArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.gradient_){nullptr}
    , decltype(_impl_.image_){nullptr}
  };
}

FillArchive::~FillArchive() {
  // @@protoc_insertion_point(destructor:TSD.FillArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FillArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.gradient_;
  if (this != internal_default_instance()) delete _impl_.image_;
}

void FillArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FillArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FillArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.gradient_ != nullptr);
      _impl_.gradient_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FillArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GradientArchive gradient = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gradient(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageFillArchive image = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((800u <= tag)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FillArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FillArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GradientArchive gradient = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::gradient(this),
        _Internal::gradient(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageFillArchive image = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  // Extension range [100, 536870912)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 100, 536870912, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FillArchive)
  return target;
}

size_t FillArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FillArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.GradientArchive gradient = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.gradient_);
    }

    // optional .TSD.ImageFillArchive image = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FillArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FillArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FillArchive::GetClassData() const { return &_class_data_; }


void FillArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FillArchive*>(&to_msg);
  auto& from = static_cast<const FillArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FillArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_gradient()->::TSD::GradientArchive::MergeFrom(
          from._internal_gradient());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_image()->::TSD::ImageFillArchive::MergeFrom(
          from._internal_image());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FillArchive::CopyFrom(const FillArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FillArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FillArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  if (_internal_has_gradient()) {
    if (!_impl_.gradient_->IsInitialized()) return false;
  }
  if (_internal_has_image()) {
    if (!_impl_.image_->IsInitialized()) return false;
  }
  return true;
}

void FillArchive::InternalSwap(FillArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FillArchive, _impl_.image_)
      + sizeof(FillArchive::_impl_.image_)
      - PROTOBUF_FIELD_OFFSET(FillArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FillArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[16]);
}

// ===================================================================

class StrokePatternArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StrokePatternArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_phase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StrokePatternArchive::StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.StrokePatternArchive)
}
StrokePatternArchive::StrokePatternArchive(const StrokePatternArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StrokePatternArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_){from._impl_.pattern_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.phase_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSD.StrokePatternArchive)
}

inline void StrokePatternArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.phase_){0}
    , decltype(_impl_.count_){0u}
  };
}

StrokePatternArchive::~StrokePatternArchive() {
  // @@protoc_insertion_point(destructor:TSD.StrokePatternArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StrokePatternArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pattern_.~RepeatedField();
}

void StrokePatternArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StrokePatternArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.StrokePatternArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pattern_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrokePatternArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::StrokePatternArchive_StrokePatternType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::StrokePatternArchive_StrokePatternType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float phase = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_phase(&has_bits);
          _impl_.phase_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float pattern = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_pattern(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_pattern(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StrokePatternArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.StrokePatternArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float phase = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_phase(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // repeated float pattern = 4;
  for (int i = 0, n = this->_internal_pattern_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_pattern(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.StrokePatternArchive)
  return target;
}

size_t StrokePatternArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.StrokePatternArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float pattern = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_pattern_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_pattern_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float phase = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StrokePatternArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StrokePatternArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StrokePatternArchive::GetClassData() const { return &_class_data_; }


void StrokePatternArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StrokePatternArchive*>(&to_msg);
  auto& from = static_cast<const StrokePatternArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.StrokePatternArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pattern_.MergeFrom(from._impl_.pattern_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.phase_ = from._impl_.phase_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StrokePatternArchive::CopyFrom(const StrokePatternArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.StrokePatternArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrokePatternArchive::IsInitialized() const {
  return true;
}

void StrokePatternArchive::InternalSwap(StrokePatternArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pattern_.InternalSwap(&other->_impl_.pattern_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StrokePatternArchive, _impl_.count_)
      + sizeof(StrokePatternArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(StrokePatternArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StrokePatternArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[17]);
}

// ===================================================================

class StrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StrokeArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const StrokeArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cap(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_join(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_miterlimit(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSD::StrokePatternArchive& pattern(const StrokeArchive* msg);
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::SmartStrokeArchive& smartstroke(const StrokeArchive* msg);
  static void set_has_smartstroke(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FrameArchive& frame(const StrokeArchive* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::PatternedStrokeArchive& patterned_stroke(const StrokeArchive* msg);
  static void set_has_patterned_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Color&
StrokeArchive::_Internal::color(const StrokeArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::StrokePatternArchive&
StrokeArchive::_Internal::pattern(const StrokeArchive* msg) {
  return *msg->_impl_.pattern_;
}
const ::TSD::SmartStrokeArchive&
StrokeArchive::_Internal::smartstroke(const StrokeArchive* msg) {
  return *msg->_impl_.smartstroke_;
}
const ::TSD::FrameArchive&
StrokeArchive::_Internal::frame(const StrokeArchive* msg) {
  return *msg->_impl_.frame_;
}
const ::TSD::PatternedStrokeArchive&
StrokeArchive::_Internal::patterned_stroke(const StrokeArchive* msg) {
  return *msg->_impl_.patterned_stroke_;
}
void StrokeArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StrokeArchive::StrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.StrokeArchive)
}
StrokeArchive::StrokeArchive(const StrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.smartstroke_){nullptr}
    , decltype(_impl_.frame_){nullptr}
    , decltype(_impl_.patterned_stroke_){nullptr}
    , decltype(_impl_.width_){}
    , decltype(_impl_.cap_){}
    , decltype(_impl_.join_){}
    , decltype(_impl_.miterlimit_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_pattern()) {
    _this->_impl_.pattern_ = new ::TSD::StrokePatternArchive(*from._impl_.pattern_);
  }
  if (from._internal_has_smartstroke()) {
    _this->_impl_.smartstroke_ = new ::TSD::SmartStrokeArchive(*from._impl_.smartstroke_);
  }
  if (from._internal_has_frame()) {
    _this->_impl_.frame_ = new ::TSD::FrameArchive(*from._impl_.frame_);
  }
  if (from._internal_has_patterned_stroke()) {
    _this->_impl_.patterned_stroke_ = new ::TSD::PatternedStrokeArchive(*from._impl_.patterned_stroke_);
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.miterlimit_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.miterlimit_));
  // @@protoc_insertion_point(copy_constructor:TSD.StrokeArchive)
}

inline void StrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.pattern_){nullptr}
    , decltype(_impl_.smartstroke_){nullptr}
    , decltype(_impl_.frame_){nullptr}
    , decltype(_impl_.patterned_stroke_){nullptr}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.cap_){0}
    , decltype(_impl_.join_){0}
    , decltype(_impl_.miterlimit_){0}
  };
}

StrokeArchive::~StrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.StrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.pattern_;
  if (this != internal_default_instance()) delete _impl_.smartstroke_;
  if (this != internal_default_instance()) delete _impl_.frame_;
  if (this != internal_default_instance()) delete _impl_.patterned_stroke_;
}

void StrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.StrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pattern_ != nullptr);
      _impl_.pattern_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.smartstroke_ != nullptr);
      _impl_.smartstroke_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.frame_ != nullptr);
      _impl_.frame_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.patterned_stroke_ != nullptr);
      _impl_.patterned_stroke_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.join_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.join_));
  }
  _impl_.miterlimit_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokeArchive.LineCap cap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::StrokeArchive_LineCap_IsValid(val))) {
            _internal_set_cap(static_cast<::TSD::StrokeArchive_LineCap>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineJoin join = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::LineJoin_IsValid(val))) {
            _internal_set_join(static_cast<::TSD::LineJoin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float miterLimit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_miterlimit(&has_bits);
          _impl_.miterlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokePatternArchive pattern = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_pattern(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.SmartStrokeArchive smartStroke = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_smartstroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FrameArchive frame = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_patterned_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.StrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float width = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_width(), target);
  }

  // optional .TSD.StrokeArchive.LineCap cap = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_cap(), target);
  }

  // optional .TSD.LineJoin join = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_join(), target);
  }

  // optional float miterLimit = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_miterlimit(), target);
  }

  // optional .TSD.StrokePatternArchive pattern = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::pattern(this),
        _Internal::pattern(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.SmartStrokeArchive smartStroke = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::smartstroke(this),
        _Internal::smartstroke(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.FrameArchive frame = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::patterned_stroke(this),
        _Internal::patterned_stroke(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.StrokeArchive)
  return target;
}

size_t StrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.StrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.StrokePatternArchive pattern = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pattern_);
    }

    // optional .TSD.SmartStrokeArchive smartStroke = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.smartstroke_);
    }

    // optional .TSD.FrameArchive frame = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.frame_);
    }

    // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.patterned_stroke_);
    }

    // optional float width = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional .TSD.StrokeArchive.LineCap cap = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_cap());
    }

    // optional .TSD.LineJoin join = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_join());
    }

  }
  // optional float miterLimit = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StrokeArchive::GetClassData() const { return &_class_data_; }


void StrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StrokeArchive*>(&to_msg);
  auto& from = static_cast<const StrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.StrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pattern()->::TSD::StrokePatternArchive::MergeFrom(
          from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_smartstroke()->::TSD::SmartStrokeArchive::MergeFrom(
          from._internal_smartstroke());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_frame()->::TSD::FrameArchive::MergeFrom(
          from._internal_frame());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_patterned_stroke()->::TSD::PatternedStrokeArchive::MergeFrom(
          from._internal_patterned_stroke());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cap_ = from._impl_.cap_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.join_ = from._impl_.join_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_miterlimit(from._internal_miterlimit());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StrokeArchive::CopyFrom(const StrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.StrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrokeArchive::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  if (_internal_has_smartstroke()) {
    if (!_impl_.smartstroke_->IsInitialized()) return false;
  }
  return true;
}

void StrokeArchive::InternalSwap(StrokeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StrokeArchive, _impl_.miterlimit_)
      + sizeof(StrokeArchive::_impl_.miterlimit_)
      - PROTOBUF_FIELD_OFFSET(StrokeArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[18]);
}

// ===================================================================

class SmartStrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SmartStrokeArchive>()._impl_._has_bits_);
  static void set_has_strokename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_randomseed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::ReferenceDictionary& parametervalues(const SmartStrokeArchive* msg);
  static void set_has_parametervalues(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::ReferenceDictionary&
SmartStrokeArchive::_Internal::parametervalues(const SmartStrokeArchive* msg) {
  return *msg->_impl_.parametervalues_;
}
void SmartStrokeArchive::clear_parametervalues() {
  if (_impl_.parametervalues_ != nullptr) _impl_.parametervalues_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
SmartStrokeArchive::SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.SmartStrokeArchive)
}
SmartStrokeArchive::SmartStrokeArchive(const SmartStrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SmartStrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strokename_){}
    , decltype(_impl_.parametervalues_){nullptr}
    , decltype(_impl_.randomseed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.strokename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strokename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_strokename()) {
    _this->_impl_.strokename_.Set(from._internal_strokename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_parametervalues()) {
    _this->_impl_.parametervalues_ = new ::TSP::ReferenceDictionary(*from._impl_.parametervalues_);
  }
  _this->_impl_.randomseed_ = from._impl_.randomseed_;
  // @@protoc_insertion_point(copy_constructor:TSD.SmartStrokeArchive)
}

inline void SmartStrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.strokename_){}
    , decltype(_impl_.parametervalues_){nullptr}
    , decltype(_impl_.randomseed_){0}
  };
  _impl_.strokename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strokename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SmartStrokeArchive::~SmartStrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.SmartStrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SmartStrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.strokename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.parametervalues_;
}

void SmartStrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SmartStrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.SmartStrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.strokename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.parametervalues_ != nullptr);
      _impl_.parametervalues_->Clear();
    }
  }
  _impl_.randomseed_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SmartStrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string strokeName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_strokename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.SmartStrokeArchive.strokeName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 randomSeed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_randomseed(&has_bits);
          _impl_.randomseed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.ReferenceDictionary parameterValues = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_parametervalues(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SmartStrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.SmartStrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string strokeName = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_strokename().data(), static_cast<int>(this->_internal_strokename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.SmartStrokeArchive.strokeName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_strokename(), target);
  }

  // optional int32 randomSeed = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_randomseed(), target);
  }

  // optional .TSP.ReferenceDictionary parameterValues = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::parametervalues(this),
        _Internal::parametervalues(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.SmartStrokeArchive)
  return target;
}

size_t SmartStrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.SmartStrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string strokeName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_strokename());
    }

    // optional .TSP.ReferenceDictionary parameterValues = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parametervalues_);
    }

    // optional int32 randomSeed = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_randomseed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SmartStrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SmartStrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SmartStrokeArchive::GetClassData() const { return &_class_data_; }


void SmartStrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SmartStrokeArchive*>(&to_msg);
  auto& from = static_cast<const SmartStrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.SmartStrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_strokename(from._internal_strokename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_parametervalues()->::TSP::ReferenceDictionary::MergeFrom(
          from._internal_parametervalues());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.randomseed_ = from._impl_.randomseed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SmartStrokeArchive::CopyFrom(const SmartStrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.SmartStrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartStrokeArchive::IsInitialized() const {
  if (_internal_has_parametervalues()) {
    if (!_impl_.parametervalues_->IsInitialized()) return false;
  }
  return true;
}

void SmartStrokeArchive::InternalSwap(SmartStrokeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strokename_, lhs_arena,
      &other->_impl_.strokename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SmartStrokeArchive, _impl_.randomseed_)
      + sizeof(SmartStrokeArchive::_impl_.randomseed_)
      - PROTOBUF_FIELD_OFFSET(SmartStrokeArchive, _impl_.parametervalues_)>(
          reinterpret_cast<char*>(&_impl_.parametervalues_),
          reinterpret_cast<char*>(&other->_impl_.parametervalues_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SmartStrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[19]);
}

// ===================================================================

class FrameArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameArchive>()._impl_._has_bits_);
  static void set_has_framename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_assetscale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FrameArchive::FrameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.FrameArchive)
}
FrameArchive::FrameArchive(const FrameArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FrameArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.framename_){}
    , decltype(_impl_.assetscale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.framename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.framename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_framename()) {
    _this->_impl_.framename_.Set(from._internal_framename(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.assetscale_ = from._impl_.assetscale_;
  // @@protoc_insertion_point(copy_constructor:TSD.FrameArchive)
}

inline void FrameArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.framename_){}
    , decltype(_impl_.assetscale_){0}
  };
  _impl_.framename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.framename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FrameArchive::~FrameArchive() {
  // @@protoc_insertion_point(destructor:TSD.FrameArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FrameArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.framename_.Destroy();
}

void FrameArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FrameArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.FrameArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.framename_.ClearNonDefaultToEmpty();
  }
  _impl_.assetscale_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string frameName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_framename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.FrameArchive.frameName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional float assetScale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_assetscale(&has_bits);
          _impl_.assetscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FrameArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.FrameArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string frameName = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_framename().data(), static_cast<int>(this->_internal_framename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.FrameArchive.frameName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_framename(), target);
  }

  // optional float assetScale = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_assetscale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.FrameArchive)
  return target;
}

size_t FrameArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.FrameArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string frameName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_framename());
    }

    // optional float assetScale = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FrameArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameArchive::GetClassData() const { return &_class_data_; }


void FrameArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FrameArchive*>(&to_msg);
  auto& from = static_cast<const FrameArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.FrameArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_framename(from._internal_framename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.assetscale_ = from._impl_.assetscale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameArchive::CopyFrom(const FrameArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.FrameArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameArchive::IsInitialized() const {
  return true;
}

void FrameArchive::InternalSwap(FrameArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.framename_, lhs_arena,
      &other->_impl_.framename_, rhs_arena
  );
  swap(_impl_.assetscale_, other->_impl_.assetscale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[20]);
}

// ===================================================================

class PatternedStrokeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PatternedStrokeArchive>()._impl_._has_bits_);
  static void set_has_pattern_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PatternedStrokeArchive::PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PatternedStrokeArchive)
}
PatternedStrokeArchive::PatternedStrokeArchive(const PatternedStrokeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PatternedStrokeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_name_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pattern_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pattern_name()) {
    _this->_impl_.pattern_name_.Set(from._internal_pattern_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TSD.PatternedStrokeArchive)
}

inline void PatternedStrokeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pattern_name_){}
  };
  _impl_.pattern_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PatternedStrokeArchive::~PatternedStrokeArchive() {
  // @@protoc_insertion_point(destructor:TSD.PatternedStrokeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PatternedStrokeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pattern_name_.Destroy();
}

void PatternedStrokeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PatternedStrokeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PatternedStrokeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.pattern_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PatternedStrokeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pattern_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pattern_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.PatternedStrokeArchive.pattern_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PatternedStrokeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PatternedStrokeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string pattern_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_pattern_name().data(), static_cast<int>(this->_internal_pattern_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.PatternedStrokeArchive.pattern_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pattern_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PatternedStrokeArchive)
  return target;
}

size_t PatternedStrokeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PatternedStrokeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string pattern_name = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pattern_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PatternedStrokeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PatternedStrokeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PatternedStrokeArchive::GetClassData() const { return &_class_data_; }


void PatternedStrokeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PatternedStrokeArchive*>(&to_msg);
  auto& from = static_cast<const PatternedStrokeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PatternedStrokeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pattern_name()) {
    _this->_internal_set_pattern_name(from._internal_pattern_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PatternedStrokeArchive::CopyFrom(const PatternedStrokeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PatternedStrokeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PatternedStrokeArchive::IsInitialized() const {
  return true;
}

void PatternedStrokeArchive::InternalSwap(PatternedStrokeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pattern_name_, lhs_arena,
      &other->_impl_.pattern_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PatternedStrokeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[21]);
}

// ===================================================================

class LineEndArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<LineEndArchive>()._impl_._has_bits_);
  static const ::TSP::Path& path(const LineEndArchive* msg);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_line_join(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Point& end_point(const LineEndArchive* msg);
  static void set_has_end_point(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_filled(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Path&
LineEndArchive::_Internal::path(const LineEndArchive* msg) {
  return *msg->_impl_.path_;
}
const ::TSP::Point&
LineEndArchive::_Internal::end_point(const LineEndArchive* msg) {
  return *msg->_impl_.end_point_;
}
void LineEndArchive::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void LineEndArchive::clear_end_point() {
  if (_impl_.end_point_ != nullptr) _impl_.end_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
LineEndArchive::LineEndArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.LineEndArchive)
}
LineEndArchive::LineEndArchive(const LineEndArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LineEndArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.end_point_){nullptr}
    , decltype(_impl_.line_join_){}
    , decltype(_impl_.is_filled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    _this->_impl_.identifier_.Set(from._internal_identifier(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::TSP::Path(*from._impl_.path_);
  }
  if (from._internal_has_end_point()) {
    _this->_impl_.end_point_ = new ::TSP::Point(*from._impl_.end_point_);
  }
  ::memcpy(&_impl_.line_join_, &from._impl_.line_join_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_filled_) -
    reinterpret_cast<char*>(&_impl_.line_join_)) + sizeof(_impl_.is_filled_));
  // @@protoc_insertion_point(copy_constructor:TSD.LineEndArchive)
}

inline void LineEndArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.end_point_){nullptr}
    , decltype(_impl_.line_join_){0}
    , decltype(_impl_.is_filled_){false}
  };
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LineEndArchive::~LineEndArchive() {
  // @@protoc_insertion_point(destructor:TSD.LineEndArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LineEndArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.identifier_.Destroy();
  if (this != internal_default_instance()) delete _impl_.path_;
  if (this != internal_default_instance()) delete _impl_.end_point_;
}

void LineEndArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LineEndArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.LineEndArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.path_ != nullptr);
      _impl_.path_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.end_point_ != nullptr);
      _impl_.end_point_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.line_join_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_filled_) -
        reinterpret_cast<char*>(&_impl_.line_join_)) + sizeof(_impl_.is_filled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LineEndArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Path path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::LineJoin_IsValid(val))) {
            _internal_set_line_join(static_cast<::TSD::LineJoin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Point end_point = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_filled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_filled(&has_bits);
          _impl_.is_filled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.LineEndArchive.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LineEndArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.LineEndArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Path path = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_line_join(), target);
  }

  // optional .TSP.Point end_point = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end_point(this),
        _Internal::end_point(this).GetCachedSize(), target, stream);
  }

  // optional bool is_filled = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_filled(), target);
  }

  // optional string identifier = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.LineEndArchive.identifier");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.LineEndArchive)
  return target;
}

size_t LineEndArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.LineEndArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string identifier = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .TSP.Path path = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_);
    }

    // optional .TSP.Point end_point = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_point_);
    }

    // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_line_join());
    }

    // optional bool is_filled = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LineEndArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LineEndArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LineEndArchive::GetClassData() const { return &_class_data_; }


void LineEndArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LineEndArchive*>(&to_msg);
  auto& from = static_cast<const LineEndArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.LineEndArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_path()->::TSP::Path::MergeFrom(
          from._internal_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end_point()->::TSP::Point::MergeFrom(
          from._internal_end_point());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.line_join_ = from._impl_.line_join_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_filled_ = from._impl_.is_filled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LineEndArchive::CopyFrom(const LineEndArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.LineEndArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineEndArchive::IsInitialized() const {
  if (_internal_has_path()) {
    if (!_impl_.path_->IsInitialized()) return false;
  }
  if (_internal_has_end_point()) {
    if (!_impl_.end_point_->IsInitialized()) return false;
  }
  return true;
}

void LineEndArchive::InternalSwap(LineEndArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.identifier_, lhs_arena,
      &other->_impl_.identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LineEndArchive, _impl_.is_filled_)
      + sizeof(LineEndArchive::_impl_.is_filled_)
      - PROTOBUF_FIELD_OFFSET(LineEndArchive, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LineEndArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[22]);
}

// ===================================================================

class ShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShadowArchive>()._impl_._has_bits_);
  static const ::TSP::Color& color(const ShadowArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::DropShadowArchive& dropshadow(const ShadowArchive* msg);
  static void set_has_dropshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ContactShadowArchive& contactshadow(const ShadowArchive* msg);
  static void set_has_contactshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::CurvedShadowArchive& curvedshadow(const ShadowArchive* msg);
  static void set_has_curvedshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSP::Color&
ShadowArchive::_Internal::color(const ShadowArchive* msg) {
  return *msg->_impl_.color_;
}
const ::TSD::DropShadowArchive&
ShadowArchive::_Internal::dropshadow(const ShadowArchive* msg) {
  return *msg->_impl_.dropshadow_;
}
const ::TSD::ContactShadowArchive&
ShadowArchive::_Internal::contactshadow(const ShadowArchive* msg) {
  return *msg->_impl_.contactshadow_;
}
const ::TSD::CurvedShadowArchive&
ShadowArchive::_Internal::curvedshadow(const ShadowArchive* msg) {
  return *msg->_impl_.curvedshadow_;
}
void ShadowArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShadowArchive::ShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShadowArchive)
}
ShadowArchive::ShadowArchive(const ShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.dropshadow_){nullptr}
    , decltype(_impl_.contactshadow_){nullptr}
    , decltype(_impl_.curvedshadow_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.is_enabled_){}
    , decltype(_impl_.angle_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  if (from._internal_has_dropshadow()) {
    _this->_impl_.dropshadow_ = new ::TSD::DropShadowArchive(*from._impl_.dropshadow_);
  }
  if (from._internal_has_contactshadow()) {
    _this->_impl_.contactshadow_ = new ::TSD::ContactShadowArchive(*from._impl_.contactshadow_);
  }
  if (from._internal_has_curvedshadow()) {
    _this->_impl_.curvedshadow_ = new ::TSD::CurvedShadowArchive(*from._impl_.curvedshadow_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.opacity_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.opacity_));
  // @@protoc_insertion_point(copy_constructor:TSD.ShadowArchive)
}

inline void ShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.color_){nullptr}
    , decltype(_impl_.dropshadow_){nullptr}
    , decltype(_impl_.contactshadow_){nullptr}
    , decltype(_impl_.curvedshadow_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.is_enabled_){true}
    , decltype(_impl_.angle_){315}
    , decltype(_impl_.offset_){5}
    , decltype(_impl_.radius_){1}
    , decltype(_impl_.opacity_){1}
  };
}

ShadowArchive::~ShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.color_;
  if (this != internal_default_instance()) delete _impl_.dropshadow_;
  if (this != internal_default_instance()) delete _impl_.contactshadow_;
  if (this != internal_default_instance()) delete _impl_.curvedshadow_;
}

void ShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dropshadow_ != nullptr);
      _impl_.dropshadow_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.contactshadow_ != nullptr);
      _impl_.contactshadow_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.curvedshadow_ != nullptr);
      _impl_.curvedshadow_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    _impl_.type_ = 0;
    _impl_.is_enabled_ = true;
    _impl_.angle_ = 315;
    _impl_.offset_ = 5;
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.radius_ = 1;
    _impl_.opacity_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Color color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float angle = 2 [default = 315];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_angle(&has_bits);
          _impl_.angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 3 [default = 5];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 radius = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 5 [default = 1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_enabled(&has_bits);
          _impl_.is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::ShadowArchive_ShadowType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::ShadowArchive_ShadowType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.DropShadowArchive dropShadow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_dropshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ContactShadowArchive contactShadow = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_contactshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CurvedShadowArchive curvedShadow = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_curvedshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Color color = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  // optional float angle = 2 [default = 315];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_angle(), target);
  }

  // optional float offset = 3 [default = 5];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_offset(), target);
  }

  // optional int32 radius = 4 [default = 1];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_radius(), target);
  }

  // optional float opacity = 5 [default = 1];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_opacity(), target);
  }

  // optional bool is_enabled = 6 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_enabled(), target);
  }

  // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_type(), target);
  }

  // optional .TSD.DropShadowArchive dropShadow = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::dropshadow(this),
        _Internal::dropshadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ContactShadowArchive contactShadow = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::contactshadow(this),
        _Internal::contactshadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CurvedShadowArchive curvedShadow = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::curvedshadow(this),
        _Internal::curvedshadow(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShadowArchive)
  return target;
}

size_t ShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Color color = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

    // optional .TSD.DropShadowArchive dropShadow = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dropshadow_);
    }

    // optional .TSD.ContactShadowArchive contactShadow = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.contactshadow_);
    }

    // optional .TSD.CurvedShadowArchive curvedShadow = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.curvedshadow_);
    }

    // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool is_enabled = 6 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional float angle = 2 [default = 315];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float offset = 3 [default = 5];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 radius = 4 [default = 1];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_radius());
    }

    // optional float opacity = 5 [default = 1];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShadowArchive::GetClassData() const { return &_class_data_; }


void ShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShadowArchive*>(&to_msg);
  auto& from = static_cast<const ShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dropshadow()->::TSD::DropShadowArchive::MergeFrom(
          from._internal_dropshadow());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_contactshadow()->::TSD::ContactShadowArchive::MergeFrom(
          from._internal_contactshadow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_curvedshadow()->::TSD::CurvedShadowArchive::MergeFrom(
          from._internal_curvedshadow());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_enabled_ = from._impl_.is_enabled_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.angle_ = from._impl_.angle_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShadowArchive::CopyFrom(const ShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShadowArchive::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void ShadowArchive::InternalSwap(ShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShadowArchive, _impl_.type_)
      + sizeof(ShadowArchive::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(ShadowArchive, _impl_.color_)>(
          reinterpret_cast<char*>(&_impl_.color_),
          reinterpret_cast<char*>(&other->_impl_.color_));
  swap(_impl_.is_enabled_, other->_impl_.is_enabled_);
  swap(_impl_.angle_, other->_impl_.angle_);
  swap(_impl_.offset_, other->_impl_.offset_);
  swap(_impl_.radius_, other->_impl_.radius_);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[23]);
}

// ===================================================================

class DropShadowArchive::_Internal {
 public:
};

DropShadowArchive::DropShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TSD.DropShadowArchive)
}
DropShadowArchive::DropShadowArchive(const DropShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DropShadowArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.DropShadowArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DropShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DropShadowArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DropShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[24]);
}

// ===================================================================

class ContactShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactShadowArchive>()._impl_._has_bits_);
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ContactShadowArchive::ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContactShadowArchive)
}
ContactShadowArchive::ContactShadowArchive(const ContactShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContactShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.offset_, &from._impl_.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.offset_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:TSD.ContactShadowArchive)
}

inline void ContactShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.height_){0.2f}
  };
}

ContactShadowArchive::~ContactShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContactShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContactShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContactShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContactShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContactShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.offset_ = 0;
    _impl_.height_ = 0.2f;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContactShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float height = 2 [default = 0.2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContactShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float height = 2 [default = 0.2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_height(), target);
  }

  // optional float offset = 4 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_offset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContactShadowArchive)
  return target;
}

size_t ContactShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContactShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float offset = 4 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float height = 2 [default = 0.2];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContactShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContactShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContactShadowArchive::GetClassData() const { return &_class_data_; }


void ContactShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContactShadowArchive*>(&to_msg);
  auto& from = static_cast<const ContactShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContactShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContactShadowArchive::CopyFrom(const ContactShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContactShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactShadowArchive::IsInitialized() const {
  return true;
}

void ContactShadowArchive::InternalSwap(ContactShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.offset_, other->_impl_.offset_);
  swap(_impl_.height_, other->_impl_.height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContactShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[25]);
}

// ===================================================================

class CurvedShadowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CurvedShadowArchive>()._impl_._has_bits_);
  static void set_has_curve(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CurvedShadowArchive::CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CurvedShadowArchive)
}
CurvedShadowArchive::CurvedShadowArchive(const CurvedShadowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CurvedShadowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curve_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.curve_ = from._impl_.curve_;
  // @@protoc_insertion_point(copy_constructor:TSD.CurvedShadowArchive)
}

inline void CurvedShadowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.curve_){0.6f}
  };
}

CurvedShadowArchive::~CurvedShadowArchive() {
  // @@protoc_insertion_point(destructor:TSD.CurvedShadowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CurvedShadowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CurvedShadowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CurvedShadowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CurvedShadowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.curve_ = 0.6f;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CurvedShadowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float curve = 1 [default = 0.6];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_curve(&has_bits);
          _impl_.curve_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CurvedShadowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CurvedShadowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float curve = 1 [default = 0.6];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_curve(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CurvedShadowArchive)
  return target;
}

size_t CurvedShadowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CurvedShadowArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float curve = 1 [default = 0.6];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CurvedShadowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CurvedShadowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CurvedShadowArchive::GetClassData() const { return &_class_data_; }


void CurvedShadowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CurvedShadowArchive*>(&to_msg);
  auto& from = static_cast<const CurvedShadowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CurvedShadowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_curve()) {
    _this->_internal_set_curve(from._internal_curve());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CurvedShadowArchive::CopyFrom(const CurvedShadowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CurvedShadowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CurvedShadowArchive::IsInitialized() const {
  return true;
}

void CurvedShadowArchive::InternalSwap(CurvedShadowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.curve_, other->_impl_.curve_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CurvedShadowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[26]);
}

// ===================================================================

class ReflectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReflectionArchive>()._impl_._has_bits_);
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReflectionArchive::ReflectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ReflectionArchive)
}
ReflectionArchive::ReflectionArchive(const ReflectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReflectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.ReflectionArchive)
}

inline void ReflectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.opacity_){0.5f}
  };
}

ReflectionArchive::~ReflectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.ReflectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReflectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReflectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReflectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ReflectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.opacity_ = 0.5f;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReflectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float opacity = 1 [default = 0.5];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReflectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ReflectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float opacity = 1 [default = 0.5];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_opacity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ReflectionArchive)
  return target;
}

size_t ReflectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ReflectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float opacity = 1 [default = 0.5];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReflectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReflectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReflectionArchive::GetClassData() const { return &_class_data_; }


void ReflectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReflectionArchive*>(&to_msg);
  auto& from = static_cast<const ReflectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ReflectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_opacity()) {
    _this->_internal_set_opacity(from._internal_opacity());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReflectionArchive::CopyFrom(const ReflectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ReflectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReflectionArchive::IsInitialized() const {
  return true;
}

void ReflectionArchive::InternalSwap(ReflectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.opacity_, other->_impl_.opacity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReflectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[27]);
}

// ===================================================================

class ImageAdjustmentsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageAdjustmentsArchive>()._impl_._has_bits_);
  static void set_has_exposure(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_saturation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contrast(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highlights(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shadows(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sharpness(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_denoise(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_tint(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bottom_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_top_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_gamma(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enhance(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_represents_sage_adjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

ImageAdjustmentsArchive::ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageAdjustmentsArchive)
}
ImageAdjustmentsArchive::ImageAdjustmentsArchive(const ImageAdjustmentsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageAdjustmentsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exposure_){}
    , decltype(_impl_.saturation_){}
    , decltype(_impl_.contrast_){}
    , decltype(_impl_.highlights_){}
    , decltype(_impl_.shadows_){}
    , decltype(_impl_.sharpness_){}
    , decltype(_impl_.denoise_){}
    , decltype(_impl_.temperature_){}
    , decltype(_impl_.tint_){}
    , decltype(_impl_.bottom_level_){}
    , decltype(_impl_.gamma_){}
    , decltype(_impl_.enhance_){}
    , decltype(_impl_.represents_sage_adjustments_){}
    , decltype(_impl_.top_level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.exposure_, &from._impl_.exposure_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.top_level_) -
    reinterpret_cast<char*>(&_impl_.exposure_)) + sizeof(_impl_.top_level_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageAdjustmentsArchive)
}

inline void ImageAdjustmentsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.exposure_){0}
    , decltype(_impl_.saturation_){0}
    , decltype(_impl_.contrast_){0}
    , decltype(_impl_.highlights_){0}
    , decltype(_impl_.shadows_){0}
    , decltype(_impl_.sharpness_){0}
    , decltype(_impl_.denoise_){0}
    , decltype(_impl_.temperature_){0}
    , decltype(_impl_.tint_){0}
    , decltype(_impl_.bottom_level_){0}
    , decltype(_impl_.gamma_){0}
    , decltype(_impl_.enhance_){false}
    , decltype(_impl_.represents_sage_adjustments_){false}
    , decltype(_impl_.top_level_){1}
  };
}

ImageAdjustmentsArchive::~ImageAdjustmentsArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageAdjustmentsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageAdjustmentsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImageAdjustmentsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageAdjustmentsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageAdjustmentsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.exposure_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.temperature_) -
        reinterpret_cast<char*>(&_impl_.exposure_)) + sizeof(_impl_.temperature_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.tint_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.represents_sage_adjustments_) -
        reinterpret_cast<char*>(&_impl_.tint_)) + sizeof(_impl_.represents_sage_adjustments_));
    _impl_.top_level_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageAdjustmentsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float exposure = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_exposure(&has_bits);
          _impl_.exposure_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float saturation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_saturation(&has_bits);
          _impl_.saturation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float contrast = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_contrast(&has_bits);
          _impl_.contrast_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float highlights = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_highlights(&has_bits);
          _impl_.highlights_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float shadows = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_shadows(&has_bits);
          _impl_.shadows_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float sharpness = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_sharpness(&has_bits);
          _impl_.sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float denoise = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_denoise(&has_bits);
          _impl_.denoise_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float temperature = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_temperature(&has_bits);
          _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float tint = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_tint(&has_bits);
          _impl_.tint_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float bottom_level = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_bottom_level(&has_bits);
          _impl_.bottom_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float top_level = 11 [default = 1];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_top_level(&has_bits);
          _impl_.top_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float gamma = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_gamma(&has_bits);
          _impl_.gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool enhance = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_enhance(&has_bits);
          _impl_.enhance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool represents_sage_adjustments = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_represents_sage_adjustments(&has_bits);
          _impl_.represents_sage_adjustments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageAdjustmentsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageAdjustmentsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float exposure = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_exposure(), target);
  }

  // optional float saturation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_saturation(), target);
  }

  // optional float contrast = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_contrast(), target);
  }

  // optional float highlights = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_highlights(), target);
  }

  // optional float shadows = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_shadows(), target);
  }

  // optional float sharpness = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_sharpness(), target);
  }

  // optional float denoise = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_denoise(), target);
  }

  // optional float temperature = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_temperature(), target);
  }

  // optional float tint = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_tint(), target);
  }

  // optional float bottom_level = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_bottom_level(), target);
  }

  // optional float top_level = 11 [default = 1];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_top_level(), target);
  }

  // optional float gamma = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_gamma(), target);
  }

  // optional bool enhance = 13 [default = false];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_enhance(), target);
  }

  // optional bool represents_sage_adjustments = 14 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_represents_sage_adjustments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageAdjustmentsArchive)
  return target;
}

size_t ImageAdjustmentsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageAdjustmentsArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float exposure = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float saturation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float contrast = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float highlights = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float shadows = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float sharpness = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float denoise = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float temperature = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional float tint = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float bottom_level = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float gamma = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional bool enhance = 13 [default = false];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool represents_sage_adjustments = 14 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional float top_level = 11 [default = 1];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageAdjustmentsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageAdjustmentsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageAdjustmentsArchive::GetClassData() const { return &_class_data_; }


void ImageAdjustmentsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageAdjustmentsArchive*>(&to_msg);
  auto& from = static_cast<const ImageAdjustmentsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageAdjustmentsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.exposure_ = from._impl_.exposure_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.saturation_ = from._impl_.saturation_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.contrast_ = from._impl_.contrast_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.highlights_ = from._impl_.highlights_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.shadows_ = from._impl_.shadows_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sharpness_ = from._impl_.sharpness_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.denoise_ = from._impl_.denoise_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.temperature_ = from._impl_.temperature_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.tint_ = from._impl_.tint_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bottom_level_ = from._impl_.bottom_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.gamma_ = from._impl_.gamma_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.enhance_ = from._impl_.enhance_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.represents_sage_adjustments_ = from._impl_.represents_sage_adjustments_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.top_level_ = from._impl_.top_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageAdjustmentsArchive::CopyFrom(const ImageAdjustmentsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageAdjustmentsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageAdjustmentsArchive::IsInitialized() const {
  return true;
}

void ImageAdjustmentsArchive::InternalSwap(ImageAdjustmentsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageAdjustmentsArchive, _impl_.represents_sage_adjustments_)
      + sizeof(ImageAdjustmentsArchive::_impl_.represents_sage_adjustments_)
      - PROTOBUF_FIELD_OFFSET(ImageAdjustmentsArchive, _impl_.exposure_)>(
          reinterpret_cast<char*>(&_impl_.exposure_),
          reinterpret_cast<char*>(&other->_impl_.exposure_));
  swap(_impl_.top_level_, other->_impl_.top_level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageAdjustmentsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[28]);
}

// ===================================================================

class ShapeStylePropertiesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStylePropertiesArchive>()._impl_._has_bits_);
  static const ::TSD::FillArchive& fill(const ShapeStylePropertiesArchive* msg);
  static void set_has_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::StrokeArchive& stroke(const ShapeStylePropertiesArchive* msg);
  static void set_has_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::ShadowArchive& shadow(const ShapeStylePropertiesArchive* msg);
  static void set_has_shadow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ReflectionArchive& reflection(const ShapeStylePropertiesArchive* msg);
  static void set_has_reflection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSD::FillArchive&
ShapeStylePropertiesArchive::_Internal::fill(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.fill_;
}
const ::TSD::StrokeArchive&
ShapeStylePropertiesArchive::_Internal::stroke(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.stroke_;
}
const ::TSD::ShadowArchive&
ShapeStylePropertiesArchive::_Internal::shadow(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.shadow_;
}
const ::TSD::ReflectionArchive&
ShapeStylePropertiesArchive::_Internal::reflection(const ShapeStylePropertiesArchive* msg) {
  return *msg->_impl_.reflection_;
}
ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeStylePropertiesArchive)
}
ShapeStylePropertiesArchive::ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStylePropertiesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_fill()) {
    _this->_impl_.fill_ = new ::TSD::FillArchive(*from._impl_.fill_);
  }
  if (from._internal_has_stroke()) {
    _this->_impl_.stroke_ = new ::TSD::StrokeArchive(*from._impl_.stroke_);
  }
  if (from._internal_has_shadow()) {
    _this->_impl_.shadow_ = new ::TSD::ShadowArchive(*from._impl_.shadow_);
  }
  if (from._internal_has_reflection()) {
    _this->_impl_.reflection_ = new ::TSD::ReflectionArchive(*from._impl_.reflection_);
  }
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeStylePropertiesArchive)
}

inline void ShapeStylePropertiesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){0}
  };
}

ShapeStylePropertiesArchive::~ShapeStylePropertiesArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeStylePropertiesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStylePropertiesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.fill_;
  if (this != internal_default_instance()) delete _impl_.stroke_;
  if (this != internal_default_instance()) delete _impl_.shadow_;
  if (this != internal_default_instance()) delete _impl_.reflection_;
}

void ShapeStylePropertiesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStylePropertiesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.fill_ != nullptr);
      _impl_.fill_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stroke_ != nullptr);
      _impl_.stroke_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.shadow_ != nullptr);
      _impl_.shadow_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.reflection_ != nullptr);
      _impl_.reflection_->Clear();
    }
  }
  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStylePropertiesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.FillArchive fill = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.StrokeArchive stroke = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ReflectionArchive reflection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_reflection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStylePropertiesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.FillArchive fill = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::fill(this),
        _Internal::fill(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.StrokeArchive stroke = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stroke(this),
        _Internal::stroke(this).GetCachedSize(), target, stream);
  }

  // optional float opacity = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_opacity(), target);
  }

  // optional .TSD.ShadowArchive shadow = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::shadow(this),
        _Internal::shadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ReflectionArchive reflection = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::reflection(this),
        _Internal::reflection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeStylePropertiesArchive)
  return target;
}

size_t ShapeStylePropertiesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeStylePropertiesArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSD.FillArchive fill = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fill_);
    }

    // optional .TSD.StrokeArchive stroke = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_);
    }

    // optional .TSD.ShadowArchive shadow = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadow_);
    }

    // optional .TSD.ReflectionArchive reflection = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reflection_);
    }

    // optional float opacity = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStylePropertiesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStylePropertiesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStylePropertiesArchive::GetClassData() const { return &_class_data_; }


void ShapeStylePropertiesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStylePropertiesArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStylePropertiesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeStylePropertiesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_fill());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stroke()->::TSD::StrokeArchive::MergeFrom(
          from._internal_stroke());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_shadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_reflection()->::TSD::ReflectionArchive::MergeFrom(
          from._internal_reflection());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStylePropertiesArchive::CopyFrom(const ShapeStylePropertiesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeStylePropertiesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStylePropertiesArchive::IsInitialized() const {
  if (_internal_has_fill()) {
    if (!_impl_.fill_->IsInitialized()) return false;
  }
  if (_internal_has_stroke()) {
    if (!_impl_.stroke_->IsInitialized()) return false;
  }
  if (_internal_has_shadow()) {
    if (!_impl_.shadow_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStylePropertiesArchive::InternalSwap(ShapeStylePropertiesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStylePropertiesArchive, _impl_.opacity_)
      + sizeof(ShapeStylePropertiesArchive::_impl_.opacity_)
      - PROTOBUF_FIELD_OFFSET(ShapeStylePropertiesArchive, _impl_.fill_)>(
          reinterpret_cast<char*>(&_impl_.fill_),
          reinterpret_cast<char*>(&other->_impl_.fill_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStylePropertiesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[29]);
}

// ===================================================================

class ShapeStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const ShapeStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ShapeStylePropertiesArchive& shape_properties(const ShapeStyleArchive* msg);
  static void set_has_shape_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
ShapeStyleArchive::_Internal::super(const ShapeStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::ShapeStylePropertiesArchive&
ShapeStyleArchive::_Internal::shape_properties(const ShapeStyleArchive* msg) {
  return *msg->_impl_.shape_properties_;
}
void ShapeStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShapeStyleArchive::ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeStyleArchive)
}
ShapeStyleArchive::ShapeStyleArchive(const ShapeStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_shape_properties()) {
    _this->_impl_.shape_properties_ = new ::TSD::ShapeStylePropertiesArchive(*from._impl_.shape_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeStyleArchive)
}

inline void ShapeStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

ShapeStyleArchive::~ShapeStyleArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.shape_properties_;
}

void ShapeStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shape_properties_ != nullptr);
      _impl_.shape_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::shape_properties(this),
        _Internal::shape_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeStyleArchive)
  return target;
}

size_t ShapeStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStyleArchive::GetClassData() const { return &_class_data_; }


void ShapeStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStyleArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shape_properties()->::TSD::ShapeStylePropertiesArchive::MergeFrom(
          from._internal_shape_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStyleArchive::CopyFrom(const ShapeStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_shape_properties()) {
    if (!_impl_.shape_properties_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStyleArchive::InternalSwap(ShapeStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStyleArchive, _impl_.override_count_)
      + sizeof(ShapeStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(ShapeStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[30]);
}

// ===================================================================

class MediaStylePropertiesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaStylePropertiesArchive>()._impl_._has_bits_);
  static const ::TSD::StrokeArchive& stroke(const MediaStylePropertiesArchive* msg);
  static void set_has_stroke(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_opacity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ShadowArchive& shadow(const MediaStylePropertiesArchive* msg);
  static void set_has_shadow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ReflectionArchive& reflection(const MediaStylePropertiesArchive* msg);
  static void set_has_reflection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSD::StrokeArchive&
MediaStylePropertiesArchive::_Internal::stroke(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.stroke_;
}
const ::TSD::ShadowArchive&
MediaStylePropertiesArchive::_Internal::shadow(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.shadow_;
}
const ::TSD::ReflectionArchive&
MediaStylePropertiesArchive::_Internal::reflection(const MediaStylePropertiesArchive* msg) {
  return *msg->_impl_.reflection_;
}
MediaStylePropertiesArchive::MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaStylePropertiesArchive)
}
MediaStylePropertiesArchive::MediaStylePropertiesArchive(const MediaStylePropertiesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaStylePropertiesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_stroke()) {
    _this->_impl_.stroke_ = new ::TSD::StrokeArchive(*from._impl_.stroke_);
  }
  if (from._internal_has_shadow()) {
    _this->_impl_.shadow_ = new ::TSD::ShadowArchive(*from._impl_.shadow_);
  }
  if (from._internal_has_reflection()) {
    _this->_impl_.reflection_ = new ::TSD::ReflectionArchive(*from._impl_.reflection_);
  }
  _this->_impl_.opacity_ = from._impl_.opacity_;
  // @@protoc_insertion_point(copy_constructor:TSD.MediaStylePropertiesArchive)
}

inline void MediaStylePropertiesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stroke_){nullptr}
    , decltype(_impl_.shadow_){nullptr}
    , decltype(_impl_.reflection_){nullptr}
    , decltype(_impl_.opacity_){0}
  };
}

MediaStylePropertiesArchive::~MediaStylePropertiesArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaStylePropertiesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaStylePropertiesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.stroke_;
  if (this != internal_default_instance()) delete _impl_.shadow_;
  if (this != internal_default_instance()) delete _impl_.reflection_;
}

void MediaStylePropertiesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaStylePropertiesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.stroke_ != nullptr);
      _impl_.stroke_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shadow_ != nullptr);
      _impl_.shadow_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.reflection_ != nullptr);
      _impl_.reflection_->Clear();
    }
  }
  _impl_.opacity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaStylePropertiesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.StrokeArchive stroke = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float opacity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_opacity(&has_bits);
          _impl_.opacity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ReflectionArchive reflection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reflection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaStylePropertiesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaStylePropertiesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.StrokeArchive stroke = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::stroke(this),
        _Internal::stroke(this).GetCachedSize(), target, stream);
  }

  // optional float opacity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_opacity(), target);
  }

  // optional .TSD.ShadowArchive shadow = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::shadow(this),
        _Internal::shadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ReflectionArchive reflection = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reflection(this),
        _Internal::reflection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaStylePropertiesArchive)
  return target;
}

size_t MediaStylePropertiesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaStylePropertiesArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSD.StrokeArchive stroke = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stroke_);
    }

    // optional .TSD.ShadowArchive shadow = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadow_);
    }

    // optional .TSD.ReflectionArchive reflection = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reflection_);
    }

    // optional float opacity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaStylePropertiesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaStylePropertiesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaStylePropertiesArchive::GetClassData() const { return &_class_data_; }


void MediaStylePropertiesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaStylePropertiesArchive*>(&to_msg);
  auto& from = static_cast<const MediaStylePropertiesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaStylePropertiesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_stroke()->::TSD::StrokeArchive::MergeFrom(
          from._internal_stroke());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadow());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_reflection()->::TSD::ReflectionArchive::MergeFrom(
          from._internal_reflection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.opacity_ = from._impl_.opacity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaStylePropertiesArchive::CopyFrom(const MediaStylePropertiesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaStylePropertiesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaStylePropertiesArchive::IsInitialized() const {
  if (_internal_has_stroke()) {
    if (!_impl_.stroke_->IsInitialized()) return false;
  }
  if (_internal_has_shadow()) {
    if (!_impl_.shadow_->IsInitialized()) return false;
  }
  return true;
}

void MediaStylePropertiesArchive::InternalSwap(MediaStylePropertiesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaStylePropertiesArchive, _impl_.opacity_)
      + sizeof(MediaStylePropertiesArchive::_impl_.opacity_)
      - PROTOBUF_FIELD_OFFSET(MediaStylePropertiesArchive, _impl_.stroke_)>(
          reinterpret_cast<char*>(&_impl_.stroke_),
          reinterpret_cast<char*>(&other->_impl_.stroke_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaStylePropertiesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[31]);
}

// ===================================================================

class MediaStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const MediaStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::MediaStylePropertiesArchive& media_properties(const MediaStyleArchive* msg);
  static void set_has_media_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
MediaStyleArchive::_Internal::super(const MediaStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::MediaStylePropertiesArchive&
MediaStyleArchive::_Internal::media_properties(const MediaStyleArchive* msg) {
  return *msg->_impl_.media_properties_;
}
void MediaStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
MediaStyleArchive::MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaStyleArchive)
}
MediaStyleArchive::MediaStyleArchive(const MediaStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_media_properties()) {
    _this->_impl_.media_properties_ = new ::TSD::MediaStylePropertiesArchive(*from._impl_.media_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TSD.MediaStyleArchive)
}

inline void MediaStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

MediaStyleArchive::~MediaStyleArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.media_properties_;
}

void MediaStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.media_properties_ != nullptr);
      _impl_.media_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_media_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::media_properties(this),
        _Internal::media_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaStyleArchive)
  return target;
}

size_t MediaStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.media_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaStyleArchive::GetClassData() const { return &_class_data_; }


void MediaStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaStyleArchive*>(&to_msg);
  auto& from = static_cast<const MediaStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_media_properties()->::TSD::MediaStylePropertiesArchive::MergeFrom(
          from._internal_media_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaStyleArchive::CopyFrom(const MediaStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_media_properties()) {
    if (!_impl_.media_properties_->IsInitialized()) return false;
  }
  return true;
}

void MediaStyleArchive::InternalSwap(MediaStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaStyleArchive, _impl_.override_count_)
      + sizeof(MediaStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(MediaStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[32]);
}

// ===================================================================

class ThemePresetsArchive::_Internal {
 public:
};

void ThemePresetsArchive::clear_line_style_presets() {
  _impl_.line_style_presets_.Clear();
}
void ThemePresetsArchive::clear_shape_style_presets() {
  _impl_.shape_style_presets_.Clear();
}
void ThemePresetsArchive::clear_textbox_style_presets() {
  _impl_.textbox_style_presets_.Clear();
}
void ThemePresetsArchive::clear_image_style_presets() {
  _impl_.image_style_presets_.Clear();
}
void ThemePresetsArchive::clear_movie_style_presets() {
  _impl_.movie_style_presets_.Clear();
}
ThemePresetsArchive::ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ThemePresetsArchive)
}
ThemePresetsArchive::ThemePresetsArchive(const ThemePresetsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThemePresetsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gradient_fill_presets_){from._impl_.gradient_fill_presets_}
    , decltype(_impl_.image_fill_presets_){from._impl_.image_fill_presets_}
    , decltype(_impl_.shadow_presets_){from._impl_.shadow_presets_}
    , decltype(_impl_.line_style_presets_){from._impl_.line_style_presets_}
    , decltype(_impl_.shape_style_presets_){from._impl_.shape_style_presets_}
    , decltype(_impl_.textbox_style_presets_){from._impl_.textbox_style_presets_}
    , decltype(_impl_.image_style_presets_){from._impl_.image_style_presets_}
    , decltype(_impl_.movie_style_presets_){from._impl_.movie_style_presets_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.ThemePresetsArchive)
}

inline void ThemePresetsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gradient_fill_presets_){arena}
    , decltype(_impl_.image_fill_presets_){arena}
    , decltype(_impl_.shadow_presets_){arena}
    , decltype(_impl_.line_style_presets_){arena}
    , decltype(_impl_.shape_style_presets_){arena}
    , decltype(_impl_.textbox_style_presets_){arena}
    , decltype(_impl_.image_style_presets_){arena}
    , decltype(_impl_.movie_style_presets_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ThemePresetsArchive::~ThemePresetsArchive() {
  // @@protoc_insertion_point(destructor:TSD.ThemePresetsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThemePresetsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gradient_fill_presets_.~RepeatedPtrField();
  _impl_.image_fill_presets_.~RepeatedPtrField();
  _impl_.shadow_presets_.~RepeatedPtrField();
  _impl_.line_style_presets_.~RepeatedPtrField();
  _impl_.shape_style_presets_.~RepeatedPtrField();
  _impl_.textbox_style_presets_.~RepeatedPtrField();
  _impl_.image_style_presets_.~RepeatedPtrField();
  _impl_.movie_style_presets_.~RepeatedPtrField();
}

void ThemePresetsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThemePresetsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ThemePresetsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gradient_fill_presets_.Clear();
  _impl_.image_fill_presets_.Clear();
  _impl_.shadow_presets_.Clear();
  _impl_.line_style_presets_.Clear();
  _impl_.shape_style_presets_.Clear();
  _impl_.textbox_style_presets_.Clear();
  _impl_.image_style_presets_.Clear();
  _impl_.movie_style_presets_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThemePresetsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.FillArchive gradient_fill_presets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gradient_fill_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.FillArchive image_fill_presets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_image_fill_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.ShadowArchive shadow_presets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shadow_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference line_style_presets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_line_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference shape_style_presets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_shape_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference textbox_style_presets = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_textbox_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference image_style_presets = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_image_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference movie_style_presets = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_movie_style_presets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThemePresetsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ThemePresetsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gradient_fill_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_gradient_fill_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSD.FillArchive image_fill_presets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_image_fill_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_image_fill_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shadow_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_shadow_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference line_style_presets = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_line_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_line_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference shape_style_presets = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_shape_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_shape_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference textbox_style_presets = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_textbox_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_textbox_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference image_style_presets = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_image_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_image_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference movie_style_presets = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_movie_style_presets_size()); i < n; i++) {
    const auto& repfield = this->_internal_movie_style_presets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ThemePresetsArchive)
  return target;
}

size_t ThemePresetsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ThemePresetsArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  total_size += 1UL * this->_internal_gradient_fill_presets_size();
  for (const auto& msg : this->_impl_.gradient_fill_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSD.FillArchive image_fill_presets = 2;
  total_size += 1UL * this->_internal_image_fill_presets_size();
  for (const auto& msg : this->_impl_.image_fill_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  total_size += 1UL * this->_internal_shadow_presets_size();
  for (const auto& msg : this->_impl_.shadow_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference line_style_presets = 4;
  total_size += 1UL * this->_internal_line_style_presets_size();
  for (const auto& msg : this->_impl_.line_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference shape_style_presets = 5;
  total_size += 1UL * this->_internal_shape_style_presets_size();
  for (const auto& msg : this->_impl_.shape_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference textbox_style_presets = 6;
  total_size += 1UL * this->_internal_textbox_style_presets_size();
  for (const auto& msg : this->_impl_.textbox_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference image_style_presets = 7;
  total_size += 1UL * this->_internal_image_style_presets_size();
  for (const auto& msg : this->_impl_.image_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference movie_style_presets = 8;
  total_size += 1UL * this->_internal_movie_style_presets_size();
  for (const auto& msg : this->_impl_.movie_style_presets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThemePresetsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThemePresetsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThemePresetsArchive::GetClassData() const { return &_class_data_; }


void ThemePresetsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThemePresetsArchive*>(&to_msg);
  auto& from = static_cast<const ThemePresetsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ThemePresetsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gradient_fill_presets_.MergeFrom(from._impl_.gradient_fill_presets_);
  _this->_impl_.image_fill_presets_.MergeFrom(from._impl_.image_fill_presets_);
  _this->_impl_.shadow_presets_.MergeFrom(from._impl_.shadow_presets_);
  _this->_impl_.line_style_presets_.MergeFrom(from._impl_.line_style_presets_);
  _this->_impl_.shape_style_presets_.MergeFrom(from._impl_.shape_style_presets_);
  _this->_impl_.textbox_style_presets_.MergeFrom(from._impl_.textbox_style_presets_);
  _this->_impl_.image_style_presets_.MergeFrom(from._impl_.image_style_presets_);
  _this->_impl_.movie_style_presets_.MergeFrom(from._impl_.movie_style_presets_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThemePresetsArchive::CopyFrom(const ThemePresetsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ThemePresetsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThemePresetsArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.gradient_fill_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.image_fill_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.shadow_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.line_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.shape_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.textbox_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.image_style_presets_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.movie_style_presets_))
    return false;
  return true;
}

void ThemePresetsArchive::InternalSwap(ThemePresetsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gradient_fill_presets_.InternalSwap(&other->_impl_.gradient_fill_presets_);
  _impl_.image_fill_presets_.InternalSwap(&other->_impl_.image_fill_presets_);
  _impl_.shadow_presets_.InternalSwap(&other->_impl_.shadow_presets_);
  _impl_.line_style_presets_.InternalSwap(&other->_impl_.line_style_presets_);
  _impl_.shape_style_presets_.InternalSwap(&other->_impl_.shape_style_presets_);
  _impl_.textbox_style_presets_.InternalSwap(&other->_impl_.textbox_style_presets_);
  _impl_.image_style_presets_.InternalSwap(&other->_impl_.image_style_presets_);
  _impl_.movie_style_presets_.InternalSwap(&other->_impl_.movie_style_presets_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThemePresetsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[33]);
}

// ===================================================================

class ThemeReplaceFillPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ThemeReplaceFillPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::FillArchive& fill(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FillArchive& old_fill(const ThemeReplaceFillPresetCommandArchive* msg);
  static void set_has_old_fill(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TSK::CommandArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::super(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ThemeReplaceFillPresetCommandArchive::_Internal::theme(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
const ::TSD::FillArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::fill(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.fill_;
}
const ::TSD::FillArchive&
ThemeReplaceFillPresetCommandArchive::_Internal::old_fill(const ThemeReplaceFillPresetCommandArchive* msg) {
  return *msg->_impl_.old_fill_;
}
void ThemeReplaceFillPresetCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ThemeReplaceFillPresetCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ThemeReplaceFillPresetCommandArchive)
}
ThemeReplaceFillPresetCommandArchive::ThemeReplaceFillPresetCommandArchive(const ThemeReplaceFillPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThemeReplaceFillPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.old_fill_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  if (from._internal_has_fill()) {
    _this->_impl_.fill_ = new ::TSD::FillArchive(*from._impl_.fill_);
  }
  if (from._internal_has_old_fill()) {
    _this->_impl_.old_fill_ = new ::TSD::FillArchive(*from._impl_.old_fill_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSD.ThemeReplaceFillPresetCommandArchive)
}

inline void ThemeReplaceFillPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.fill_){nullptr}
    , decltype(_impl_.old_fill_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

ThemeReplaceFillPresetCommandArchive::~ThemeReplaceFillPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ThemeReplaceFillPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThemeReplaceFillPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
  if (this != internal_default_instance()) delete _impl_.fill_;
  if (this != internal_default_instance()) delete _impl_.old_fill_;
}

void ThemeReplaceFillPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThemeReplaceFillPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ThemeReplaceFillPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.fill_ != nullptr);
      _impl_.fill_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.old_fill_ != nullptr);
      _impl_.old_fill_->Clear();
    }
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThemeReplaceFillPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.FillArchive fill = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.FillArchive old_fill = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_fill(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThemeReplaceFillPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ThemeReplaceFillPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // required .TSD.FillArchive fill = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::fill(this),
        _Internal::fill(this).GetCachedSize(), target, stream);
  }

  // required .TSD.FillArchive old_fill = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::old_fill(this),
        _Internal::old_fill(this).GetCachedSize(), target, stream);
  }

  // required uint32 index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ThemeReplaceFillPresetCommandArchive)
  return target;
}

size_t ThemeReplaceFillPresetCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.ThemeReplaceFillPresetCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_theme()) {
    // required .TSP.Reference theme = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.theme_);
  }

  if (_internal_has_fill()) {
    // required .TSD.FillArchive fill = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fill_);
  }

  if (_internal_has_old_fill()) {
    // required .TSD.FillArchive old_fill = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_fill_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t ThemeReplaceFillPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ThemeReplaceFillPresetCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference theme = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.theme_);

    // required .TSD.FillArchive fill = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fill_);

    // required .TSD.FillArchive old_fill = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_fill_);

    // required uint32 index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThemeReplaceFillPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThemeReplaceFillPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThemeReplaceFillPresetCommandArchive::GetClassData() const { return &_class_data_; }


void ThemeReplaceFillPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThemeReplaceFillPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const ThemeReplaceFillPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ThemeReplaceFillPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_fill());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_old_fill()->::TSD::FillArchive::MergeFrom(
          from._internal_old_fill());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThemeReplaceFillPresetCommandArchive::CopyFrom(const ThemeReplaceFillPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ThemeReplaceFillPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThemeReplaceFillPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  if (_internal_has_fill()) {
    if (!_impl_.fill_->IsInitialized()) return false;
  }
  if (_internal_has_old_fill()) {
    if (!_impl_.old_fill_->IsInitialized()) return false;
  }
  return true;
}

void ThemeReplaceFillPresetCommandArchive::InternalSwap(ThemeReplaceFillPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThemeReplaceFillPresetCommandArchive, _impl_.index_)
      + sizeof(ThemeReplaceFillPresetCommandArchive::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(ThemeReplaceFillPresetCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThemeReplaceFillPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[34]);
}

// ===================================================================

class DrawableArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableArchive>()._impl_._has_bits_);
  static const ::TSD::GeometryArchive& geometry(const DrawableArchive* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& parent(const DrawableArchive* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap(const DrawableArchive* msg);
  static void set_has_exterior_text_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hyperlink_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& comment(const DrawableArchive* msg);
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_aspect_ratio_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_accessibility_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::GeometryArchive&
DrawableArchive::_Internal::geometry(const DrawableArchive* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::parent(const DrawableArchive* msg) {
  return *msg->_impl_.parent_;
}
const ::TSD::ExteriorTextWrapArchive&
DrawableArchive::_Internal::exterior_text_wrap(const DrawableArchive* msg) {
  return *msg->_impl_.exterior_text_wrap_;
}
const ::TSP::Reference&
DrawableArchive::_Internal::comment(const DrawableArchive* msg) {
  return *msg->_impl_.comment_;
}
void DrawableArchive::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DrawableArchive::clear_comment() {
  if (_impl_.comment_ != nullptr) _impl_.comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
DrawableArchive::DrawableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableArchive)
}
DrawableArchive::DrawableArchive(const DrawableArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hyperlink_url_){}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , decltype(_impl_.locked_){}
    , decltype(_impl_.aspect_ratio_locked_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hyperlink_url()) {
    _this->_impl_.hyperlink_url_.Set(from._internal_hyperlink_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accessibility_description()) {
    _this->_impl_.accessibility_description_.Set(from._internal_accessibility_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::TSP::Reference(*from._impl_.parent_);
  }
  if (from._internal_has_exterior_text_wrap()) {
    _this->_impl_.exterior_text_wrap_ = new ::TSD::ExteriorTextWrapArchive(*from._impl_.exterior_text_wrap_);
  }
  if (from._internal_has_comment()) {
    _this->_impl_.comment_ = new ::TSP::Reference(*from._impl_.comment_);
  }
  ::memcpy(&_impl_.locked_, &from._impl_.locked_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.aspect_ratio_locked_) -
    reinterpret_cast<char*>(&_impl_.locked_)) + sizeof(_impl_.aspect_ratio_locked_));
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableArchive)
}

inline void DrawableArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hyperlink_url_){}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}
    , decltype(_impl_.comment_){nullptr}
    , decltype(_impl_.locked_){false}
    , decltype(_impl_.aspect_ratio_locked_){false}
  };
  _impl_.hyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DrawableArchive::~DrawableArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hyperlink_url_.Destroy();
  _impl_.accessibility_description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.parent_;
  if (this != internal_default_instance()) delete _impl_.exterior_text_wrap_;
  if (this != internal_default_instance()) delete _impl_.comment_;
}

void DrawableArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hyperlink_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.accessibility_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.exterior_text_wrap_ != nullptr);
      _impl_.exterior_text_wrap_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.comment_ != nullptr);
      _impl_.comment_->Clear();
    }
  }
  ::memset(&_impl_.locked_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.aspect_ratio_locked_) -
      reinterpret_cast<char*>(&_impl_.locked_)) + sizeof(_impl_.aspect_ratio_locked_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GeometryArchive geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_exterior_text_wrap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hyperlink_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hyperlink_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableArchive.hyperlink_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool locked = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_locked(&has_bits);
          _impl_.locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference comment = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool aspect_ratio_locked = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_aspect_ratio_locked(&has_bits);
          _impl_.aspect_ratio_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string accessibility_description = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_accessibility_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableArchive.accessibility_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GeometryArchive geometry = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference parent = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::exterior_text_wrap(this),
        _Internal::exterior_text_wrap(this).GetCachedSize(), target, stream);
  }

  // optional string hyperlink_url = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hyperlink_url().data(), static_cast<int>(this->_internal_hyperlink_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableArchive.hyperlink_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hyperlink_url(), target);
  }

  // optional bool locked = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_locked(), target);
  }

  // optional .TSP.Reference comment = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::comment(this),
        _Internal::comment(this).GetCachedSize(), target, stream);
  }

  // optional bool aspect_ratio_locked = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_aspect_ratio_locked(), target);
  }

  // optional string accessibility_description = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_accessibility_description().data(), static_cast<int>(this->_internal_accessibility_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableArchive.accessibility_description");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_accessibility_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableArchive)
  return target;
}

size_t DrawableArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string hyperlink_url = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hyperlink_url());
    }

    // optional string accessibility_description = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_accessibility_description());
    }

    // optional .TSD.GeometryArchive geometry = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference parent = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

    // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.exterior_text_wrap_);
    }

    // optional .TSP.Reference comment = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.comment_);
    }

    // optional bool locked = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool aspect_ratio_locked = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableArchive::GetClassData() const { return &_class_data_; }


void DrawableArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableArchive*>(&to_msg);
  auto& from = static_cast<const DrawableArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hyperlink_url(from._internal_hyperlink_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_accessibility_description(from._internal_accessibility_description());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_parent()->::TSP::Reference::MergeFrom(
          from._internal_parent());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_exterior_text_wrap()->::TSD::ExteriorTextWrapArchive::MergeFrom(
          from._internal_exterior_text_wrap());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_comment()->::TSP::Reference::MergeFrom(
          from._internal_comment());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.locked_ = from._impl_.locked_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.aspect_ratio_locked_ = from._impl_.aspect_ratio_locked_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableArchive::CopyFrom(const DrawableArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableArchive::IsInitialized() const {
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  if (_internal_has_comment()) {
    if (!_impl_.comment_->IsInitialized()) return false;
  }
  return true;
}

void DrawableArchive::InternalSwap(DrawableArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hyperlink_url_, lhs_arena,
      &other->_impl_.hyperlink_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accessibility_description_, lhs_arena,
      &other->_impl_.accessibility_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableArchive, _impl_.aspect_ratio_locked_)
      + sizeof(DrawableArchive::_impl_.aspect_ratio_locked_)
      - PROTOBUF_FIELD_OFFSET(DrawableArchive, _impl_.geometry_)>(
          reinterpret_cast<char*>(&_impl_.geometry_),
          reinterpret_cast<char*>(&other->_impl_.geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[35]);
}

// ===================================================================

class ContainerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerArchive>()._impl_._has_bits_);
  static const ::TSD::GeometryArchive& geometry(const ContainerArchive* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& parent(const ContainerArchive* msg);
  static void set_has_parent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSD::GeometryArchive&
ContainerArchive::_Internal::geometry(const ContainerArchive* msg) {
  return *msg->_impl_.geometry_;
}
const ::TSP::Reference&
ContainerArchive::_Internal::parent(const ContainerArchive* msg) {
  return *msg->_impl_.parent_;
}
void ContainerArchive::clear_parent() {
  if (_impl_.parent_ != nullptr) _impl_.parent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainerArchive::clear_children() {
  _impl_.children_.Clear();
}
ContainerArchive::ContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContainerArchive)
}
ContainerArchive::ContainerArchive(const ContainerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_geometry()) {
    _this->_impl_.geometry_ = new ::TSD::GeometryArchive(*from._impl_.geometry_);
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::TSP::Reference(*from._impl_.parent_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ContainerArchive)
}

inline void ContainerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.geometry_){nullptr}
    , decltype(_impl_.parent_){nullptr}
  };
}

ContainerArchive::~ContainerArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContainerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.geometry_;
  if (this != internal_default_instance()) delete _impl_.parent_;
}

void ContainerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContainerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.geometry_ != nullptr);
      _impl_.geometry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.parent_ != nullptr);
      _impl_.parent_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GeometryArchive geometry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference parent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContainerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GeometryArchive geometry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::geometry(this),
        _Internal::geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference parent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContainerArchive)
  return target;
}

size_t ContainerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContainerArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 3;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSD.GeometryArchive geometry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.geometry_);
    }

    // optional .TSP.Reference parent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.parent_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerArchive::GetClassData() const { return &_class_data_; }


void ContainerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerArchive*>(&to_msg);
  auto& from = static_cast<const ContainerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContainerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_geometry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_parent()->::TSP::Reference::MergeFrom(
          from._internal_parent());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerArchive::CopyFrom(const ContainerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContainerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_geometry()) {
    if (!_impl_.geometry_->IsInitialized()) return false;
  }
  if (_internal_has_parent()) {
    if (!_impl_.parent_->IsInitialized()) return false;
  }
  return true;
}

void ContainerArchive::InternalSwap(ContainerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerArchive, _impl_.parent_)
      + sizeof(ContainerArchive::_impl_.parent_)
      - PROTOBUF_FIELD_OFFSET(ContainerArchive, _impl_.geometry_)>(
          reinterpret_cast<char*>(&_impl_.geometry_),
          reinterpret_cast<char*>(&other->_impl_.geometry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[36]);
}

// ===================================================================

class GroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const GroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
GroupArchive::_Internal::super(const GroupArchive* msg) {
  return *msg->_impl_.super_;
}
void GroupArchive::clear_children() {
  _impl_.children_.Clear();
}
GroupArchive::GroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GroupArchive)
}
GroupArchive::GroupArchive(const GroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.GroupArchive)
}

inline void GroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

GroupArchive::~GroupArchive() {
  // @@protoc_insertion_point(destructor:TSD.GroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void GroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GroupArchive)
  return target;
}

size_t GroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GroupArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 2;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupArchive::GetClassData() const { return &_class_data_; }


void GroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupArchive*>(&to_msg);
  auto& from = static_cast<const GroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupArchive::CopyFrom(const GroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void GroupArchive::InternalSwap(GroupArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[37]);
}

// ===================================================================

class ShapeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const ShapeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& style(const ShapeArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::PathSourceArchive& pathsource(const ShapeArchive* msg);
  static void set_has_pathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::LineEndArchive& head_line_end(const ShapeArchive* msg);
  static void set_has_head_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::LineEndArchive& tail_line_end(const ShapeArchive* msg);
  static void set_has_tail_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
ShapeArchive::_Internal::super(const ShapeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapeArchive::_Internal::style(const ShapeArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSD::PathSourceArchive&
ShapeArchive::_Internal::pathsource(const ShapeArchive* msg) {
  return *msg->_impl_.pathsource_;
}
const ::TSD::LineEndArchive&
ShapeArchive::_Internal::head_line_end(const ShapeArchive* msg) {
  return *msg->_impl_.head_line_end_;
}
const ::TSD::LineEndArchive&
ShapeArchive::_Internal::tail_line_end(const ShapeArchive* msg) {
  return *msg->_impl_.tail_line_end_;
}
void ShapeArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeArchive::ShapeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeArchive)
}
ShapeArchive::ShapeArchive(const ShapeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_pathsource()) {
    _this->_impl_.pathsource_ = new ::TSD::PathSourceArchive(*from._impl_.pathsource_);
  }
  if (from._internal_has_head_line_end()) {
    _this->_impl_.head_line_end_ = new ::TSD::LineEndArchive(*from._impl_.head_line_end_);
  }
  if (from._internal_has_tail_line_end()) {
    _this->_impl_.tail_line_end_ = new ::TSD::LineEndArchive(*from._impl_.tail_line_end_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeArchive)
}

inline void ShapeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
    , decltype(_impl_.head_line_end_){nullptr}
    , decltype(_impl_.tail_line_end_){nullptr}
  };
}

ShapeArchive::~ShapeArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.pathsource_;
  if (this != internal_default_instance()) delete _impl_.head_line_end_;
  if (this != internal_default_instance()) delete _impl_.tail_line_end_;
}

void ShapeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.pathsource_ != nullptr);
      _impl_.pathsource_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.head_line_end_ != nullptr);
      _impl_.head_line_end_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.tail_line_end_ != nullptr);
      _impl_.tail_line_end_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive pathsource = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive head_line_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_head_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive tail_line_end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive pathsource = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pathsource(this),
        _Internal::pathsource(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive head_line_end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::head_line_end(this),
        _Internal::head_line_end(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive tail_line_end = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::tail_line_end(this),
        _Internal::tail_line_end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeArchive)
  return target;
}

size_t ShapeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSP.Reference style = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSD.PathSourceArchive pathsource = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pathsource_);
    }

    // optional .TSD.LineEndArchive head_line_end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.head_line_end_);
    }

    // optional .TSD.LineEndArchive tail_line_end = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tail_line_end_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeArchive::GetClassData() const { return &_class_data_; }


void ShapeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeArchive*>(&to_msg);
  auto& from = static_cast<const ShapeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_pathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_pathsource());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_head_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_head_line_end());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_tail_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_tail_line_end());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeArchive::CopyFrom(const ShapeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_pathsource()) {
    if (!_impl_.pathsource_->IsInitialized()) return false;
  }
  if (_internal_has_head_line_end()) {
    if (!_impl_.head_line_end_->IsInitialized()) return false;
  }
  if (_internal_has_tail_line_end()) {
    if (!_impl_.tail_line_end_->IsInitialized()) return false;
  }
  return true;
}

void ShapeArchive::InternalSwap(ShapeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeArchive, _impl_.tail_line_end_)
      + sizeof(ShapeArchive::_impl_.tail_line_end_)
      - PROTOBUF_FIELD_OFFSET(ShapeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[38]);
}

// ===================================================================

class ConnectionLineArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionLineArchive>()._impl_._has_bits_);
  static const ::TSD::ShapeArchive& super(const ConnectionLineArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& connected_from(const ConnectionLineArchive* msg);
  static void set_has_connected_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& connected_to(const ConnectionLineArchive* msg);
  static void set_has_connected_to(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::ShapeArchive&
ConnectionLineArchive::_Internal::super(const ConnectionLineArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ConnectionLineArchive::_Internal::connected_from(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_from_;
}
const ::TSP::Reference&
ConnectionLineArchive::_Internal::connected_to(const ConnectionLineArchive* msg) {
  return *msg->_impl_.connected_to_;
}
void ConnectionLineArchive::clear_connected_from() {
  if (_impl_.connected_from_ != nullptr) _impl_.connected_from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ConnectionLineArchive::clear_connected_to() {
  if (_impl_.connected_to_ != nullptr) _impl_.connected_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ConnectionLineArchive::ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ConnectionLineArchive)
}
ConnectionLineArchive::ConnectionLineArchive(const ConnectionLineArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectionLineArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connected_from_){nullptr}
    , decltype(_impl_.connected_to_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::ShapeArchive(*from._impl_.super_);
  }
  if (from._internal_has_connected_from()) {
    _this->_impl_.connected_from_ = new ::TSP::Reference(*from._impl_.connected_from_);
  }
  if (from._internal_has_connected_to()) {
    _this->_impl_.connected_to_ = new ::TSP::Reference(*from._impl_.connected_to_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ConnectionLineArchive)
}

inline void ConnectionLineArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connected_from_){nullptr}
    , decltype(_impl_.connected_to_){nullptr}
  };
}

ConnectionLineArchive::~ConnectionLineArchive() {
  // @@protoc_insertion_point(destructor:TSD.ConnectionLineArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionLineArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.connected_from_;
  if (this != internal_default_instance()) delete _impl_.connected_to_;
}

void ConnectionLineArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionLineArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ConnectionLineArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.connected_from_ != nullptr);
      _impl_.connected_from_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.connected_to_ != nullptr);
      _impl_.connected_to_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectionLineArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.ShapeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connected_from = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connected_to = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connected_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionLineArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ConnectionLineArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.ShapeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connected_from = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connected_from(this),
        _Internal::connected_from(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connected_to = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::connected_to(this),
        _Internal::connected_to(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ConnectionLineArchive)
  return target;
}

size_t ConnectionLineArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ConnectionLineArchive)
  size_t total_size = 0;

  // required .TSD.ShapeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference connected_from = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_from_);
    }

    // optional .TSP.Reference connected_to = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connected_to_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectionLineArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectionLineArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectionLineArchive::GetClassData() const { return &_class_data_; }


void ConnectionLineArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectionLineArchive*>(&to_msg);
  auto& from = static_cast<const ConnectionLineArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ConnectionLineArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::ShapeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connected_from()->::TSP::Reference::MergeFrom(
          from._internal_connected_from());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_connected_to()->::TSP::Reference::MergeFrom(
          from._internal_connected_to());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectionLineArchive::CopyFrom(const ConnectionLineArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ConnectionLineArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionLineArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_connected_from()) {
    if (!_impl_.connected_from_->IsInitialized()) return false;
  }
  if (_internal_has_connected_to()) {
    if (!_impl_.connected_to_->IsInitialized()) return false;
  }
  return true;
}

void ConnectionLineArchive::InternalSwap(ConnectionLineArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionLineArchive, _impl_.connected_to_)
      + sizeof(ConnectionLineArchive::_impl_.connected_to_)
      - PROTOBUF_FIELD_OFFSET(ConnectionLineArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectionLineArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[39]);
}

// ===================================================================

class ImageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const ImageArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::DataReference& data(const ImageArchive* msg);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Reference& style(const ImageArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Size& originalsize(const ImageArchive* msg);
  static void set_has_originalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& mask(const ImageArchive* msg);
  static void set_has_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::DataReference& thumbnaildata(const ImageArchive* msg);
  static void set_has_thumbnaildata(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::TSP::DataReference& originaldata(const ImageArchive* msg);
  static void set_has_originaldata(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Size& naturalsize(const ImageArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Path& instantalphapath(const ImageArchive* msg);
  static void set_has_instantalphapath(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSD::ImageAdjustmentsArchive& imageadjustments(const ImageArchive* msg);
  static void set_has_imageadjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::DataReference& enhancedimagedata(const ImageArchive* msg);
  static void set_has_enhancedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::TSP::DataReference& adjustedimagedata(const ImageArchive* msg);
  static void set_has_adjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSP::DataReference& thumbnailadjustedimagedata(const ImageArchive* msg);
  static void set_has_thumbnailadjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_interpretsuntaggedimagedataasgeneric(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::TSP::Reference& database_data(const ImageArchive* msg);
  static void set_has_database_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& database_thumbnaildata(const ImageArchive* msg);
  static void set_has_database_thumbnaildata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& database_originaldata(const ImageArchive* msg);
  static void set_has_database_originaldata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
ImageArchive::_Internal::super(const ImageArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::data(const ImageArchive* msg) {
  return *msg->_impl_.data_;
}
const ::TSP::Reference&
ImageArchive::_Internal::style(const ImageArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSP::Size&
ImageArchive::_Internal::originalsize(const ImageArchive* msg) {
  return *msg->_impl_.originalsize_;
}
const ::TSP::Reference&
ImageArchive::_Internal::mask(const ImageArchive* msg) {
  return *msg->_impl_.mask_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::thumbnaildata(const ImageArchive* msg) {
  return *msg->_impl_.thumbnaildata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::originaldata(const ImageArchive* msg) {
  return *msg->_impl_.originaldata_;
}
const ::TSP::Size&
ImageArchive::_Internal::naturalsize(const ImageArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
const ::TSP::Path&
ImageArchive::_Internal::instantalphapath(const ImageArchive* msg) {
  return *msg->_impl_.instantalphapath_;
}
const ::TSD::ImageAdjustmentsArchive&
ImageArchive::_Internal::imageadjustments(const ImageArchive* msg) {
  return *msg->_impl_.imageadjustments_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::enhancedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.enhancedimagedata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::adjustedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.adjustedimagedata_;
}
const ::TSP::DataReference&
ImageArchive::_Internal::thumbnailadjustedimagedata(const ImageArchive* msg) {
  return *msg->_impl_.thumbnailadjustedimagedata_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_data(const ImageArchive* msg) {
  return *msg->_impl_.database_data_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_thumbnaildata(const ImageArchive* msg) {
  return *msg->_impl_.database_thumbnaildata_;
}
const ::TSP::Reference&
ImageArchive::_Internal::database_originaldata(const ImageArchive* msg) {
  return *msg->_impl_.database_originaldata_;
}
void ImageArchive::clear_data() {
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void ImageArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageArchive::clear_originalsize() {
  if (_impl_.originalsize_ != nullptr) _impl_.originalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ImageArchive::clear_mask() {
  if (_impl_.mask_ != nullptr) _impl_.mask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageArchive::clear_thumbnaildata() {
  if (_impl_.thumbnaildata_ != nullptr) _impl_.thumbnaildata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void ImageArchive::clear_originaldata() {
  if (_impl_.originaldata_ != nullptr) _impl_.originaldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void ImageArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void ImageArchive::clear_instantalphapath() {
  if (_impl_.instantalphapath_ != nullptr) _impl_.instantalphapath_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void ImageArchive::clear_enhancedimagedata() {
  if (_impl_.enhancedimagedata_ != nullptr) _impl_.enhancedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
void ImageArchive::clear_adjustedimagedata() {
  if (_impl_.adjustedimagedata_ != nullptr) _impl_.adjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void ImageArchive::clear_thumbnailadjustedimagedata() {
  if (_impl_.thumbnailadjustedimagedata_ != nullptr) _impl_.thumbnailadjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
void ImageArchive::clear_database_data() {
  if (_impl_.database_data_ != nullptr) _impl_.database_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageArchive::clear_database_thumbnaildata() {
  if (_impl_.database_thumbnaildata_ != nullptr) _impl_.database_thumbnaildata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageArchive::clear_database_originaldata() {
  if (_impl_.database_originaldata_ != nullptr) _impl_.database_originaldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
ImageArchive::ImageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageArchive)
}
ImageArchive::ImageArchive(const ImageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_data_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.mask_){nullptr}
    , decltype(_impl_.database_thumbnaildata_){nullptr}
    , decltype(_impl_.database_originaldata_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.instantalphapath_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.thumbnaildata_){nullptr}
    , decltype(_impl_.originaldata_){nullptr}
    , decltype(_impl_.imageadjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.thumbnailadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_database_data()) {
    _this->_impl_.database_data_ = new ::TSP::Reference(*from._impl_.database_data_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_originalsize()) {
    _this->_impl_.originalsize_ = new ::TSP::Size(*from._impl_.originalsize_);
  }
  if (from._internal_has_mask()) {
    _this->_impl_.mask_ = new ::TSP::Reference(*from._impl_.mask_);
  }
  if (from._internal_has_database_thumbnaildata()) {
    _this->_impl_.database_thumbnaildata_ = new ::TSP::Reference(*from._impl_.database_thumbnaildata_);
  }
  if (from._internal_has_database_originaldata()) {
    _this->_impl_.database_originaldata_ = new ::TSP::Reference(*from._impl_.database_originaldata_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_instantalphapath()) {
    _this->_impl_.instantalphapath_ = new ::TSP::Path(*from._impl_.instantalphapath_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::TSP::DataReference(*from._impl_.data_);
  }
  if (from._internal_has_thumbnaildata()) {
    _this->_impl_.thumbnaildata_ = new ::TSP::DataReference(*from._impl_.thumbnaildata_);
  }
  if (from._internal_has_originaldata()) {
    _this->_impl_.originaldata_ = new ::TSP::DataReference(*from._impl_.originaldata_);
  }
  if (from._internal_has_imageadjustments()) {
    _this->_impl_.imageadjustments_ = new ::TSD::ImageAdjustmentsArchive(*from._impl_.imageadjustments_);
  }
  if (from._internal_has_adjustedimagedata()) {
    _this->_impl_.adjustedimagedata_ = new ::TSP::DataReference(*from._impl_.adjustedimagedata_);
  }
  if (from._internal_has_thumbnailadjustedimagedata()) {
    _this->_impl_.thumbnailadjustedimagedata_ = new ::TSP::DataReference(*from._impl_.thumbnailadjustedimagedata_);
  }
  if (from._internal_has_enhancedimagedata()) {
    _this->_impl_.enhancedimagedata_ = new ::TSP::DataReference(*from._impl_.enhancedimagedata_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.interpretsuntaggedimagedataasgeneric_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.interpretsuntaggedimagedataasgeneric_));
  // @@protoc_insertion_point(copy_constructor:TSD.ImageArchive)
}

inline void ImageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_data_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.mask_){nullptr}
    , decltype(_impl_.database_thumbnaildata_){nullptr}
    , decltype(_impl_.database_originaldata_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.instantalphapath_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , decltype(_impl_.thumbnaildata_){nullptr}
    , decltype(_impl_.originaldata_){nullptr}
    , decltype(_impl_.imageadjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.thumbnailadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.interpretsuntaggedimagedataasgeneric_){false}
  };
}

ImageArchive::~ImageArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.database_data_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.originalsize_;
  if (this != internal_default_instance()) delete _impl_.mask_;
  if (this != internal_default_instance()) delete _impl_.database_thumbnaildata_;
  if (this != internal_default_instance()) delete _impl_.database_originaldata_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.instantalphapath_;
  if (this != internal_default_instance()) delete _impl_.data_;
  if (this != internal_default_instance()) delete _impl_.thumbnaildata_;
  if (this != internal_default_instance()) delete _impl_.originaldata_;
  if (this != internal_default_instance()) delete _impl_.imageadjustments_;
  if (this != internal_default_instance()) delete _impl_.adjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.thumbnailadjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.enhancedimagedata_;
}

void ImageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.database_data_ != nullptr);
      _impl_.database_data_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.originalsize_ != nullptr);
      _impl_.originalsize_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.mask_ != nullptr);
      _impl_.mask_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.database_thumbnaildata_ != nullptr);
      _impl_.database_thumbnaildata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.database_originaldata_ != nullptr);
      _impl_.database_originaldata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.instantalphapath_ != nullptr);
      _impl_.instantalphapath_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.data_ != nullptr);
      _impl_.data_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.thumbnaildata_ != nullptr);
      _impl_.thumbnaildata_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.originaldata_ != nullptr);
      _impl_.originaldata_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.imageadjustments_ != nullptr);
      _impl_.imageadjustments_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.adjustedimagedata_ != nullptr);
      _impl_.adjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.thumbnailadjustedimagedata_ != nullptr);
      _impl_.thumbnailadjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.enhancedimagedata_ != nullptr);
      _impl_.enhancedimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.interpretsuntaggedimagedataasgeneric_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.interpretsuntaggedimagedataasgeneric_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size originalSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_thumbnailData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_thumbnaildata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_originalData = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_originaldata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path instantAlphaPath = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_instantalphapath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference thumbnailData = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_thumbnaildata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference originalData = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_originaldata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_imageadjustments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference adjustedImageData = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_adjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_thumbnailadjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference enhancedImageData = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_enhancedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool interpretsUntaggedImageDataAsGeneric = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_interpretsuntaggedimagedataasgeneric(&has_bits);
          _impl_.interpretsuntaggedimagedataasgeneric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_data = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::database_data(this),
        _Internal::database_data(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size originalSize = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::originalsize(this),
        _Internal::originalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference mask = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::mask(this),
        _Internal::mask(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_thumbnailData = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::database_thumbnaildata(this),
        _Internal::database_thumbnaildata(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 7;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_flags(), target);
  }

  // optional .TSP.Reference database_originalData = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::database_originaldata(this),
        _Internal::database_originaldata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path instantAlphaPath = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::instantalphapath(this),
        _Internal::instantalphapath(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference data = 11;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference thumbnailData = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::thumbnaildata(this),
        _Internal::thumbnaildata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference originalData = 13;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::originaldata(this),
        _Internal::originaldata(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::imageadjustments(this),
        _Internal::imageadjustments(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference adjustedImageData = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::adjustedimagedata(this),
        _Internal::adjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::thumbnailadjustedimagedata(this),
        _Internal::thumbnailadjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference enhancedImageData = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::enhancedimagedata(this),
        _Internal::enhancedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional bool interpretsUntaggedImageDataAsGeneric = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_interpretsuntaggedimagedataasgeneric(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageArchive)
  return target;
}

size_t ImageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .TSP.Reference database_data = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_data_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSP.Size originalSize = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsize_);
    }

    // optional .TSP.Reference mask = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mask_);
    }

    // optional .TSP.Reference database_thumbnailData = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_thumbnaildata_);
    }

    // optional .TSP.Reference database_originalData = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_originaldata_);
    }

    // optional .TSP.Size naturalSize = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSP.Path instantAlphaPath = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instantalphapath_);
    }

    // optional .TSP.DataReference data = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.data_);
    }

    // optional .TSP.DataReference thumbnailData = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.thumbnaildata_);
    }

    // optional .TSP.DataReference originalData = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originaldata_);
    }

    // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.imageadjustments_);
    }

    // optional .TSP.DataReference adjustedImageData = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.adjustedimagedata_);
    }

    // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.thumbnailadjustedimagedata_);
    }

    // optional .TSP.DataReference enhancedImageData = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.enhancedimagedata_);
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional uint32 flags = 7;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional bool interpretsUntaggedImageDataAsGeneric = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageArchive::GetClassData() const { return &_class_data_; }


void ImageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageArchive*>(&to_msg);
  auto& from = static_cast<const ImageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_database_data()->::TSP::Reference::MergeFrom(
          from._internal_database_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_originalsize()->::TSP::Size::MergeFrom(
          from._internal_originalsize());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_mask()->::TSP::Reference::MergeFrom(
          from._internal_mask());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_database_thumbnaildata()->::TSP::Reference::MergeFrom(
          from._internal_database_thumbnaildata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_database_originaldata()->::TSP::Reference::MergeFrom(
          from._internal_database_originaldata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_instantalphapath()->::TSP::Path::MergeFrom(
          from._internal_instantalphapath());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_data()->::TSP::DataReference::MergeFrom(
          from._internal_data());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_thumbnaildata()->::TSP::DataReference::MergeFrom(
          from._internal_thumbnaildata());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_originaldata()->::TSP::DataReference::MergeFrom(
          from._internal_originaldata());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_imageadjustments()->::TSD::ImageAdjustmentsArchive::MergeFrom(
          from._internal_imageadjustments());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_adjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_adjustedimagedata());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_thumbnailadjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_thumbnailadjustedimagedata());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_enhancedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_enhancedimagedata());
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.interpretsuntaggedimagedataasgeneric_ = from._impl_.interpretsuntaggedimagedataasgeneric_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageArchive::CopyFrom(const ImageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_database_data()) {
    if (!_impl_.database_data_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_originalsize()) {
    if (!_impl_.originalsize_->IsInitialized()) return false;
  }
  if (_internal_has_mask()) {
    if (!_impl_.mask_->IsInitialized()) return false;
  }
  if (_internal_has_database_thumbnaildata()) {
    if (!_impl_.database_thumbnaildata_->IsInitialized()) return false;
  }
  if (_internal_has_database_originaldata()) {
    if (!_impl_.database_originaldata_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_instantalphapath()) {
    if (!_impl_.instantalphapath_->IsInitialized()) return false;
  }
  if (_internal_has_data()) {
    if (!_impl_.data_->IsInitialized()) return false;
  }
  if (_internal_has_thumbnaildata()) {
    if (!_impl_.thumbnaildata_->IsInitialized()) return false;
  }
  if (_internal_has_originaldata()) {
    if (!_impl_.originaldata_->IsInitialized()) return false;
  }
  if (_internal_has_adjustedimagedata()) {
    if (!_impl_.adjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_thumbnailadjustedimagedata()) {
    if (!_impl_.thumbnailadjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_enhancedimagedata()) {
    if (!_impl_.enhancedimagedata_->IsInitialized()) return false;
  }
  return true;
}

void ImageArchive::InternalSwap(ImageArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageArchive, _impl_.interpretsuntaggedimagedataasgeneric_)
      + sizeof(ImageArchive::_impl_.interpretsuntaggedimagedataasgeneric_)
      - PROTOBUF_FIELD_OFFSET(ImageArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[40]);
}

// ===================================================================

class MaskArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MaskArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const MaskArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::PathSourceArchive& pathsource(const MaskArchive* msg);
  static void set_has_pathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::DrawableArchive&
MaskArchive::_Internal::super(const MaskArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::PathSourceArchive&
MaskArchive::_Internal::pathsource(const MaskArchive* msg) {
  return *msg->_impl_.pathsource_;
}
MaskArchive::MaskArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MaskArchive)
}
MaskArchive::MaskArchive(const MaskArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MaskArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_pathsource()) {
    _this->_impl_.pathsource_ = new ::TSD::PathSourceArchive(*from._impl_.pathsource_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.MaskArchive)
}

inline void MaskArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.pathsource_){nullptr}
  };
}

MaskArchive::~MaskArchive() {
  // @@protoc_insertion_point(destructor:TSD.MaskArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MaskArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.pathsource_;
}

void MaskArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MaskArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MaskArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.pathsource_ != nullptr);
      _impl_.pathsource_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MaskArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive pathsource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MaskArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MaskArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive pathsource = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pathsource(this),
        _Internal::pathsource(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MaskArchive)
  return target;
}

size_t MaskArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MaskArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSD.PathSourceArchive pathsource = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pathsource_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MaskArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MaskArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MaskArchive::GetClassData() const { return &_class_data_; }


void MaskArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MaskArchive*>(&to_msg);
  auto& from = static_cast<const MaskArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MaskArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_pathsource());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MaskArchive::CopyFrom(const MaskArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MaskArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaskArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_pathsource()) {
    if (!_impl_.pathsource_->IsInitialized()) return false;
  }
  return true;
}

void MaskArchive::InternalSwap(MaskArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MaskArchive, _impl_.pathsource_)
      + sizeof(MaskArchive::_impl_.pathsource_)
      - PROTOBUF_FIELD_OFFSET(MaskArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MaskArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[41]);
}

// ===================================================================

class MovieArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MovieArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const MovieArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::DataReference& moviedata(const MovieArchive* msg);
  static void set_has_moviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::DataReference& importedauxiliarymoviedata(const MovieArchive* msg);
  static void set_has_importedauxiliarymoviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_movieremoteurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_endtime(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_postertime(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_loopoption(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_autoplay(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_audioonly(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::TSP::DataReference& posterimagedata(const MovieArchive* msg);
  static void set_has_posterimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::DataReference& audioonlyimagedata(const MovieArchive* msg);
  static void set_has_audioonlyimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_playablestate(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::TSP::Reference& database_moviedata(const MovieArchive* msg);
  static void set_has_database_moviedata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& database_posterimagedata(const MovieArchive* msg);
  static void set_has_database_posterimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& database_audioonlyimagedata(const MovieArchive* msg);
  static void set_has_database_audioonlyimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& style(const MovieArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Size& originalsize(const MovieArchive* msg);
  static void set_has_originalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Size& naturalsize(const MovieArchive* msg);
  static void set_has_naturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSD::DrawableArchive&
MovieArchive::_Internal::super(const MovieArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::moviedata(const MovieArchive* msg) {
  return *msg->_impl_.moviedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::importedauxiliarymoviedata(const MovieArchive* msg) {
  return *msg->_impl_.importedauxiliarymoviedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::posterimagedata(const MovieArchive* msg) {
  return *msg->_impl_.posterimagedata_;
}
const ::TSP::DataReference&
MovieArchive::_Internal::audioonlyimagedata(const MovieArchive* msg) {
  return *msg->_impl_.audioonlyimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_moviedata(const MovieArchive* msg) {
  return *msg->_impl_.database_moviedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_posterimagedata(const MovieArchive* msg) {
  return *msg->_impl_.database_posterimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::database_audioonlyimagedata(const MovieArchive* msg) {
  return *msg->_impl_.database_audioonlyimagedata_;
}
const ::TSP::Reference&
MovieArchive::_Internal::style(const MovieArchive* msg) {
  return *msg->_impl_.style_;
}
const ::TSP::Size&
MovieArchive::_Internal::originalsize(const MovieArchive* msg) {
  return *msg->_impl_.originalsize_;
}
const ::TSP::Size&
MovieArchive::_Internal::naturalsize(const MovieArchive* msg) {
  return *msg->_impl_.naturalsize_;
}
void MovieArchive::clear_moviedata() {
  if (_impl_.moviedata_ != nullptr) _impl_.moviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void MovieArchive::clear_importedauxiliarymoviedata() {
  if (_impl_.importedauxiliarymoviedata_ != nullptr) _impl_.importedauxiliarymoviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void MovieArchive::clear_posterimagedata() {
  if (_impl_.posterimagedata_ != nullptr) _impl_.posterimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void MovieArchive::clear_audioonlyimagedata() {
  if (_impl_.audioonlyimagedata_ != nullptr) _impl_.audioonlyimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void MovieArchive::clear_database_moviedata() {
  if (_impl_.database_moviedata_ != nullptr) _impl_.database_moviedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void MovieArchive::clear_database_posterimagedata() {
  if (_impl_.database_posterimagedata_ != nullptr) _impl_.database_posterimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void MovieArchive::clear_database_audioonlyimagedata() {
  if (_impl_.database_audioonlyimagedata_ != nullptr) _impl_.database_audioonlyimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void MovieArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void MovieArchive::clear_originalsize() {
  if (_impl_.originalsize_ != nullptr) _impl_.originalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void MovieArchive::clear_naturalsize() {
  if (_impl_.naturalsize_ != nullptr) _impl_.naturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
MovieArchive::MovieArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieArchive)
}
MovieArchive::MovieArchive(const MovieArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movieremoteurl_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_moviedata_){nullptr}
    , decltype(_impl_.database_posterimagedata_){nullptr}
    , decltype(_impl_.database_audioonlyimagedata_){nullptr}
    , decltype(_impl_.moviedata_){nullptr}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.audioonlyimagedata_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.importedauxiliarymoviedata_){nullptr}
    , decltype(_impl_.starttime_){}
    , decltype(_impl_.endtime_){}
    , decltype(_impl_.postertime_){}
    , decltype(_impl_.loopoption_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.autoplay_){}
    , decltype(_impl_.audioonly_){}
    , decltype(_impl_.streaming_){}
    , decltype(_impl_.playablestate_){}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.movieremoteurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_movieremoteurl()) {
    _this->_impl_.movieremoteurl_.Set(from._internal_movieremoteurl(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_database_moviedata()) {
    _this->_impl_.database_moviedata_ = new ::TSP::Reference(*from._impl_.database_moviedata_);
  }
  if (from._internal_has_database_posterimagedata()) {
    _this->_impl_.database_posterimagedata_ = new ::TSP::Reference(*from._impl_.database_posterimagedata_);
  }
  if (from._internal_has_database_audioonlyimagedata()) {
    _this->_impl_.database_audioonlyimagedata_ = new ::TSP::Reference(*from._impl_.database_audioonlyimagedata_);
  }
  if (from._internal_has_moviedata()) {
    _this->_impl_.moviedata_ = new ::TSP::DataReference(*from._impl_.moviedata_);
  }
  if (from._internal_has_posterimagedata()) {
    _this->_impl_.posterimagedata_ = new ::TSP::DataReference(*from._impl_.posterimagedata_);
  }
  if (from._internal_has_audioonlyimagedata()) {
    _this->_impl_.audioonlyimagedata_ = new ::TSP::DataReference(*from._impl_.audioonlyimagedata_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  if (from._internal_has_originalsize()) {
    _this->_impl_.originalsize_ = new ::TSP::Size(*from._impl_.originalsize_);
  }
  if (from._internal_has_naturalsize()) {
    _this->_impl_.naturalsize_ = new ::TSP::Size(*from._impl_.naturalsize_);
  }
  if (from._internal_has_importedauxiliarymoviedata()) {
    _this->_impl_.importedauxiliarymoviedata_ = new ::TSP::DataReference(*from._impl_.importedauxiliarymoviedata_);
  }
  ::memcpy(&_impl_.starttime_, &from._impl_.starttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:TSD.MovieArchive)
}

inline void MovieArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movieremoteurl_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.database_moviedata_){nullptr}
    , decltype(_impl_.database_posterimagedata_){nullptr}
    , decltype(_impl_.database_audioonlyimagedata_){nullptr}
    , decltype(_impl_.moviedata_){nullptr}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.audioonlyimagedata_){nullptr}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.originalsize_){nullptr}
    , decltype(_impl_.naturalsize_){nullptr}
    , decltype(_impl_.importedauxiliarymoviedata_){nullptr}
    , decltype(_impl_.starttime_){0}
    , decltype(_impl_.endtime_){0}
    , decltype(_impl_.postertime_){0}
    , decltype(_impl_.loopoption_){0u}
    , decltype(_impl_.volume_){0}
    , decltype(_impl_.autoplay_){false}
    , decltype(_impl_.audioonly_){false}
    , decltype(_impl_.streaming_){false}
    , decltype(_impl_.playablestate_){0u}
    , decltype(_impl_.flags_){0u}
  };
  _impl_.movieremoteurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MovieArchive::~MovieArchive() {
  // @@protoc_insertion_point(destructor:TSD.MovieArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.movieremoteurl_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.database_moviedata_;
  if (this != internal_default_instance()) delete _impl_.database_posterimagedata_;
  if (this != internal_default_instance()) delete _impl_.database_audioonlyimagedata_;
  if (this != internal_default_instance()) delete _impl_.moviedata_;
  if (this != internal_default_instance()) delete _impl_.posterimagedata_;
  if (this != internal_default_instance()) delete _impl_.audioonlyimagedata_;
  if (this != internal_default_instance()) delete _impl_.style_;
  if (this != internal_default_instance()) delete _impl_.originalsize_;
  if (this != internal_default_instance()) delete _impl_.naturalsize_;
  if (this != internal_default_instance()) delete _impl_.importedauxiliarymoviedata_;
}

void MovieArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.movieremoteurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.database_moviedata_ != nullptr);
      _impl_.database_moviedata_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.database_posterimagedata_ != nullptr);
      _impl_.database_posterimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.database_audioonlyimagedata_ != nullptr);
      _impl_.database_audioonlyimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.moviedata_ != nullptr);
      _impl_.moviedata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.posterimagedata_ != nullptr);
      _impl_.posterimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.audioonlyimagedata_ != nullptr);
      _impl_.audioonlyimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.originalsize_ != nullptr);
      _impl_.originalsize_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.naturalsize_ != nullptr);
      _impl_.naturalsize_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.importedauxiliarymoviedata_ != nullptr);
      _impl_.importedauxiliarymoviedata_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&_impl_.starttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.loopoption_) -
        reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.loopoption_));
  }
  if (cached_has_bits & 0x003f0000u) {
    ::memset(&_impl_.volume_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.volume_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_movieData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_moviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float startTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_starttime(&has_bits);
          _impl_.starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float endTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_endtime(&has_bits);
          _impl_.endtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float posterTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_postertime(&has_bits);
          _impl_.postertime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 loopOption = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_loopoption(&has_bits);
          _impl_.loopoption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float volume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoPlay = 8 [deprecated = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_autoplay(&has_bits);
          _impl_.autoplay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool audioOnly = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_audioonly(&has_bits);
          _impl_.audioonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_posterImageData = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_posterimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_audioOnlyImageData = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_audioonlyimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 playableState = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_playablestate(&has_bits);
          _impl_.playablestate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference movieData = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_moviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference posterImageData = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_posterimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference audioOnlyImageData = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_audioonlyimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string movieRemoteURL = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_movieremoteurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieArchive.movieRemoteURL");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool streaming = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_streaming(&has_bits);
          _impl_.streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size originalSize = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_originalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size naturalSize = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_naturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_importedauxiliarymoviedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_movieData = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::database_moviedata(this),
        _Internal::database_moviedata(this).GetCachedSize(), target, stream);
  }

  // optional float startTime = 3;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_starttime(), target);
  }

  // optional float endTime = 4;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_endtime(), target);
  }

  // optional float posterTime = 5;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_postertime(), target);
  }

  // optional uint32 loopOption = 6;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_loopoption(), target);
  }

  // optional float volume = 7;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_volume(), target);
  }

  // optional bool autoPlay = 8 [deprecated = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_autoplay(), target);
  }

  // optional bool audioOnly = 9;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_audioonly(), target);
  }

  // optional .TSP.Reference database_posterImageData = 10;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::database_posterimagedata(this),
        _Internal::database_posterimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_audioOnlyImageData = 11;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::database_audioonlyimagedata(this),
        _Internal::database_audioonlyimagedata(this).GetCachedSize(), target, stream);
  }

  // optional uint32 playableState = 12;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_playablestate(), target);
  }

  // optional uint32 flags = 13;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_flags(), target);
  }

  // optional .TSP.DataReference movieData = 14;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::moviedata(this),
        _Internal::moviedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference posterImageData = 15;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::posterimagedata(this),
        _Internal::posterimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference audioOnlyImageData = 16;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::audioonlyimagedata(this),
        _Internal::audioonlyimagedata(this).GetCachedSize(), target, stream);
  }

  // optional string movieRemoteURL = 17;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_movieremoteurl().data(), static_cast<int>(this->_internal_movieremoteurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieArchive.movieRemoteURL");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_movieremoteurl(), target);
  }

  // optional bool streaming = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_streaming(), target);
  }

  // optional .TSP.Reference style = 19;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size originalSize = 20;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::originalsize(this),
        _Internal::originalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size naturalSize = 21;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::naturalsize(this),
        _Internal::naturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::importedauxiliarymoviedata(this),
        _Internal::importedauxiliarymoviedata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieArchive)
  return target;
}

size_t MovieArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieArchive)
  size_t total_size = 0;

  // required .TSD.DrawableArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string movieRemoteURL = 17;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_movieremoteurl());
  }

  if (cached_has_bits & 0x000000fcu) {
    // optional .TSP.Reference database_movieData = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_moviedata_);
    }

    // optional .TSP.Reference database_posterImageData = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_posterimagedata_);
    }

    // optional .TSP.Reference database_audioOnlyImageData = 11;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_audioonlyimagedata_);
    }

    // optional .TSP.DataReference movieData = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.moviedata_);
    }

    // optional .TSP.DataReference posterImageData = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.posterimagedata_);
    }

    // optional .TSP.DataReference audioOnlyImageData = 16;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audioonlyimagedata_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSP.Reference style = 19;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

    // optional .TSP.Size originalSize = 20;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.originalsize_);
    }

    // optional .TSP.Size naturalSize = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.naturalsize_);
    }

    // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.importedauxiliarymoviedata_);
    }

    // optional float startTime = 3;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float endTime = 4;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float posterTime = 5;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional uint32 loopOption = 6;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_loopoption());
    }

  }
  if (cached_has_bits & 0x003f0000u) {
    // optional float volume = 7;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 4;
    }

    // optional bool autoPlay = 8 [deprecated = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool audioOnly = 9;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool streaming = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional uint32 playableState = 12;
    if (cached_has_bits & 0x00100000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_playablestate());
    }

    // optional uint32 flags = 13;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieArchive::GetClassData() const { return &_class_data_; }


void MovieArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieArchive*>(&to_msg);
  auto& from = static_cast<const MovieArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_movieremoteurl(from._internal_movieremoteurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_database_moviedata()->::TSP::Reference::MergeFrom(
          from._internal_database_moviedata());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_database_posterimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_posterimagedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_database_audioonlyimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_audioonlyimagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_moviedata()->::TSP::DataReference::MergeFrom(
          from._internal_moviedata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_posterimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_posterimagedata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_audioonlyimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_audioonlyimagedata());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_originalsize()->::TSP::Size::MergeFrom(
          from._internal_originalsize());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_naturalsize()->::TSP::Size::MergeFrom(
          from._internal_naturalsize());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_importedauxiliarymoviedata()->::TSP::DataReference::MergeFrom(
          from._internal_importedauxiliarymoviedata());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.starttime_ = from._impl_.starttime_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.endtime_ = from._impl_.endtime_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.postertime_ = from._impl_.postertime_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.loopoption_ = from._impl_.loopoption_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x003f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.autoplay_ = from._impl_.autoplay_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.audioonly_ = from._impl_.audioonly_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.streaming_ = from._impl_.streaming_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.playablestate_ = from._impl_.playablestate_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieArchive::CopyFrom(const MovieArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_database_moviedata()) {
    if (!_impl_.database_moviedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_posterimagedata()) {
    if (!_impl_.database_posterimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_audioonlyimagedata()) {
    if (!_impl_.database_audioonlyimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_moviedata()) {
    if (!_impl_.moviedata_->IsInitialized()) return false;
  }
  if (_internal_has_posterimagedata()) {
    if (!_impl_.posterimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_audioonlyimagedata()) {
    if (!_impl_.audioonlyimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  if (_internal_has_originalsize()) {
    if (!_impl_.originalsize_->IsInitialized()) return false;
  }
  if (_internal_has_naturalsize()) {
    if (!_impl_.naturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_importedauxiliarymoviedata()) {
    if (!_impl_.importedauxiliarymoviedata_->IsInitialized()) return false;
  }
  return true;
}

void MovieArchive::InternalSwap(MovieArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.movieremoteurl_, lhs_arena,
      &other->_impl_.movieremoteurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovieArchive, _impl_.flags_)
      + sizeof(MovieArchive::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(MovieArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[42]);
}

// ===================================================================

class ExteriorTextWrapArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ExteriorTextWrapArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_alpha_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ExteriorTextWrapArchive::ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ExteriorTextWrapArchive)
}
ExteriorTextWrapArchive::ExteriorTextWrapArchive(const ExteriorTextWrapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExteriorTextWrapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.fit_type_){}
    , decltype(_impl_.margin_){}
    , decltype(_impl_.alpha_threshold_){}
    , decltype(_impl_.is_html_wrap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_html_wrap_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_html_wrap_));
  // @@protoc_insertion_point(copy_constructor:TSD.ExteriorTextWrapArchive)
}

inline void ExteriorTextWrapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.direction_){0u}
    , decltype(_impl_.fit_type_){0u}
    , decltype(_impl_.margin_){0}
    , decltype(_impl_.alpha_threshold_){0}
    , decltype(_impl_.is_html_wrap_){false}
  };
}

ExteriorTextWrapArchive::~ExteriorTextWrapArchive() {
  // @@protoc_insertion_point(destructor:TSD.ExteriorTextWrapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExteriorTextWrapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExteriorTextWrapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExteriorTextWrapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ExteriorTextWrapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_html_wrap_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_html_wrap_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExteriorTextWrapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_direction(&has_bits);
          _impl_.direction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fit_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fit_type(&has_bits);
          _impl_.fit_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float margin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_margin(&has_bits);
          _impl_.margin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float alpha_threshold = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_alpha_threshold(&has_bits);
          _impl_.alpha_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExteriorTextWrapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ExteriorTextWrapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint32 direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_direction(), target);
  }

  // optional uint32 fit_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_fit_type(), target);
  }

  // optional float margin = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_margin(), target);
  }

  // optional float alpha_threshold = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_alpha_threshold(), target);
  }

  // optional bool is_html_wrap = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_html_wrap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ExteriorTextWrapArchive)
  return target;
}

size_t ExteriorTextWrapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ExteriorTextWrapArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_direction());
    }

    // optional uint32 fit_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fit_type());
    }

    // optional float margin = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float alpha_threshold = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional bool is_html_wrap = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExteriorTextWrapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExteriorTextWrapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExteriorTextWrapArchive::GetClassData() const { return &_class_data_; }


void ExteriorTextWrapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExteriorTextWrapArchive*>(&to_msg);
  auto& from = static_cast<const ExteriorTextWrapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ExteriorTextWrapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fit_type_ = from._impl_.fit_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.margin_ = from._impl_.margin_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.alpha_threshold_ = from._impl_.alpha_threshold_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_html_wrap_ = from._impl_.is_html_wrap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExteriorTextWrapArchive::CopyFrom(const ExteriorTextWrapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ExteriorTextWrapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExteriorTextWrapArchive::IsInitialized() const {
  return true;
}

void ExteriorTextWrapArchive::InternalSwap(ExteriorTextWrapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExteriorTextWrapArchive, _impl_.is_html_wrap_)
      + sizeof(ExteriorTextWrapArchive::_impl_.is_html_wrap_)
      - PROTOBUF_FIELD_OFFSET(ExteriorTextWrapArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExteriorTextWrapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[43]);
}

// ===================================================================

class GuideArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GuideArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dynamic(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_infinite(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

GuideArchive::GuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GuideArchive)
}
GuideArchive::GuideArchive(const GuideArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuideArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.start_){}
    , decltype(_impl_.end_){}
    , decltype(_impl_.dynamic_){}
    , decltype(_impl_.infinite_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.infinite_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.infinite_));
  // @@protoc_insertion_point(copy_constructor:TSD.GuideArchive)
}

inline void GuideArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.offset_){0}
    , decltype(_impl_.start_){0}
    , decltype(_impl_.end_){0}
    , decltype(_impl_.dynamic_){false}
    , decltype(_impl_.infinite_){false}
  };
}

GuideArchive::~GuideArchive() {
  // @@protoc_insertion_point(destructor:TSD.GuideArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuideArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GuideArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuideArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GuideArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.infinite_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.infinite_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuideArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.GuideArchive.GuideType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::GuideArchive_GuideType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::GuideArchive_GuideType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_offset(&has_bits);
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool dynamic = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dynamic(&has_bits);
          _impl_.dynamic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool infinite = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_infinite(&has_bits);
          _impl_.infinite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuideArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GuideArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.GuideArchive.GuideType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float offset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_offset(), target);
  }

  // optional float start = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_start(), target);
  }

  // optional float end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_end(), target);
  }

  // optional bool dynamic = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_dynamic(), target);
  }

  // optional bool infinite = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_infinite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GuideArchive)
  return target;
}

size_t GuideArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GuideArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSD.GuideArchive.GuideType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float offset = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool dynamic = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool infinite = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuideArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuideArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuideArchive::GetClassData() const { return &_class_data_; }


void GuideArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuideArchive*>(&to_msg);
  auto& from = static_cast<const GuideArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GuideArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.offset_ = from._impl_.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dynamic_ = from._impl_.dynamic_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.infinite_ = from._impl_.infinite_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuideArchive::CopyFrom(const GuideArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GuideArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideArchive::IsInitialized() const {
  return true;
}

void GuideArchive::InternalSwap(GuideArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GuideArchive, _impl_.infinite_)
      + sizeof(GuideArchive::_impl_.infinite_)
      - PROTOBUF_FIELD_OFFSET(GuideArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GuideArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[44]);
}

// ===================================================================

class UserDefinedGuideArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UserDefinedGuideArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserDefinedGuideArchive::UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.UserDefinedGuideArchive)
}
UserDefinedGuideArchive::UserDefinedGuideArchive(const UserDefinedGuideArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserDefinedGuideArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.position_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.position_));
  // @@protoc_insertion_point(copy_constructor:TSD.UserDefinedGuideArchive)
}

inline void UserDefinedGuideArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.position_){0}
  };
}

UserDefinedGuideArchive::~UserDefinedGuideArchive() {
  // @@protoc_insertion_point(destructor:TSD.UserDefinedGuideArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserDefinedGuideArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserDefinedGuideArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserDefinedGuideArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.UserDefinedGuideArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.position_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.position_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserDefinedGuideArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::UserDefinedGuideArchive_GuideType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::UserDefinedGuideArchive_GuideType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserDefinedGuideArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.UserDefinedGuideArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional float position = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.UserDefinedGuideArchive)
  return target;
}

size_t UserDefinedGuideArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.UserDefinedGuideArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional float position = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserDefinedGuideArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserDefinedGuideArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserDefinedGuideArchive::GetClassData() const { return &_class_data_; }


void UserDefinedGuideArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserDefinedGuideArchive*>(&to_msg);
  auto& from = static_cast<const UserDefinedGuideArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.UserDefinedGuideArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserDefinedGuideArchive::CopyFrom(const UserDefinedGuideArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.UserDefinedGuideArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserDefinedGuideArchive::IsInitialized() const {
  return true;
}

void UserDefinedGuideArchive::InternalSwap(UserDefinedGuideArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserDefinedGuideArchive, _impl_.position_)
      + sizeof(UserDefinedGuideArchive::_impl_.position_)
      - PROTOBUF_FIELD_OFFSET(UserDefinedGuideArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserDefinedGuideArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[45]);
}

// ===================================================================

class GuideStorageArchive::_Internal {
 public:
};

GuideStorageArchive::GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GuideStorageArchive)
}
GuideStorageArchive::GuideStorageArchive(const GuideStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuideStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.userdefinedguides_){from._impl_.userdefinedguides_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSD.GuideStorageArchive)
}

inline void GuideStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.userdefinedguides_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GuideStorageArchive::~GuideStorageArchive() {
  // @@protoc_insertion_point(destructor:TSD.GuideStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuideStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.userdefinedguides_.~RepeatedPtrField();
}

void GuideStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuideStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GuideStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.userdefinedguides_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuideStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userdefinedguides(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuideStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GuideStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_userdefinedguides_size()); i < n; i++) {
    const auto& repfield = this->_internal_userdefinedguides(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GuideStorageArchive)
  return target;
}

size_t GuideStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GuideStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  total_size += 1UL * this->_internal_userdefinedguides_size();
  for (const auto& msg : this->_impl_.userdefinedguides_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuideStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuideStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuideStorageArchive::GetClassData() const { return &_class_data_; }


void GuideStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuideStorageArchive*>(&to_msg);
  auto& from = static_cast<const GuideStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GuideStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.userdefinedguides_.MergeFrom(from._impl_.userdefinedguides_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuideStorageArchive::CopyFrom(const GuideStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GuideStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideStorageArchive::IsInitialized() const {
  return true;
}

void GuideStorageArchive::InternalSwap(GuideStorageArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.userdefinedguides_.InternalSwap(&other->_impl_.userdefinedguides_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GuideStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[46]);
}

// ===================================================================

class CanvasSelectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CanvasSelectionArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& container(const CanvasSelectionArchive* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
CanvasSelectionArchive::_Internal::container(const CanvasSelectionArchive* msg) {
  return *msg->_impl_.container_;
}
void CanvasSelectionArchive::clear_infos() {
  _impl_.infos_.Clear();
}
void CanvasSelectionArchive::clear_container() {
  if (_impl_.container_ != nullptr) _impl_.container_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CanvasSelectionArchive::CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CanvasSelectionArchive)
}
CanvasSelectionArchive::CanvasSelectionArchive(const CanvasSelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CanvasSelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.infos_){from._impl_.infos_}
    , decltype(_impl_.container_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_container()) {
    _this->_impl_.container_ = new ::TSP::Reference(*from._impl_.container_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.CanvasSelectionArchive)
}

inline void CanvasSelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.infos_){arena}
    , decltype(_impl_.container_){nullptr}
  };
}

CanvasSelectionArchive::~CanvasSelectionArchive() {
  // @@protoc_insertion_point(destructor:TSD.CanvasSelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CanvasSelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.infos_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.container_;
}

void CanvasSelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CanvasSelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CanvasSelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.infos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.container_ != nullptr);
    _impl_.container_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CanvasSelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference container = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CanvasSelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CanvasSelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_infos_size()); i < n; i++) {
    const auto& repfield = this->_internal_infos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference container = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CanvasSelectionArchive)
  return target;
}

size_t CanvasSelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CanvasSelectionArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference infos = 1;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->_impl_.infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference container = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.container_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CanvasSelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CanvasSelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CanvasSelectionArchive::GetClassData() const { return &_class_data_; }


void CanvasSelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CanvasSelectionArchive*>(&to_msg);
  auto& from = static_cast<const CanvasSelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CanvasSelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.infos_.MergeFrom(from._impl_.infos_);
  if (from._internal_has_container()) {
    _this->_internal_mutable_container()->::TSP::Reference::MergeFrom(
        from._internal_container());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CanvasSelectionArchive::CopyFrom(const CanvasSelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CanvasSelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CanvasSelectionArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.infos_))
    return false;
  if (_internal_has_container()) {
    if (!_impl_.container_->IsInitialized()) return false;
  }
  return true;
}

void CanvasSelectionArchive::InternalSwap(CanvasSelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.infos_.InternalSwap(&other->_impl_.infos_);
  swap(_impl_.container_, other->_impl_.container_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CanvasSelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[47]);
}

// ===================================================================

class CommentStorageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommentStorageArchive>()._impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Date& creation_date(const CommentStorageArchive* msg);
  static void set_has_creation_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& author(const CommentStorageArchive* msg);
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Date&
CommentStorageArchive::_Internal::creation_date(const CommentStorageArchive* msg) {
  return *msg->_impl_.creation_date_;
}
const ::TSP::Reference&
CommentStorageArchive::_Internal::author(const CommentStorageArchive* msg) {
  return *msg->_impl_.author_;
}
void CommentStorageArchive::clear_creation_date() {
  if (_impl_.creation_date_ != nullptr) _impl_.creation_date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommentStorageArchive::clear_author() {
  if (_impl_.author_ != nullptr) _impl_.author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommentStorageArchive::CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CommentStorageArchive)
}
CommentStorageArchive::CommentStorageArchive(const CommentStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommentStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.author_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_creation_date()) {
    _this->_impl_.creation_date_ = new ::TSP::Date(*from._impl_.creation_date_);
  }
  if (from._internal_has_author()) {
    _this->_impl_.author_ = new ::TSP::Reference(*from._impl_.author_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.CommentStorageArchive)
}

inline void CommentStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
    , decltype(_impl_.creation_date_){nullptr}
    , decltype(_impl_.author_){nullptr}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommentStorageArchive::~CommentStorageArchive() {
  // @@protoc_insertion_point(destructor:TSD.CommentStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommentStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.creation_date_;
  if (this != internal_default_instance()) delete _impl_.author_;
}

void CommentStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommentStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CommentStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.creation_date_ != nullptr);
      _impl_.creation_date_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.author_ != nullptr);
      _impl_.author_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommentStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.CommentStorageArchive.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Date creation_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_creation_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference author = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommentStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CommentStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.CommentStorageArchive.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // optional .TSP.Date creation_date = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::creation_date(this),
        _Internal::creation_date(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference author = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::author(this),
        _Internal::author(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CommentStorageArchive)
  return target;
}

size_t CommentStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CommentStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional .TSP.Date creation_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.creation_date_);
    }

    // optional .TSP.Reference author = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.author_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommentStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommentStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommentStorageArchive::GetClassData() const { return &_class_data_; }


void CommentStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommentStorageArchive*>(&to_msg);
  auto& from = static_cast<const CommentStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CommentStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_creation_date()->::TSP::Date::MergeFrom(
          from._internal_creation_date());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_author()->::TSP::Reference::MergeFrom(
          from._internal_author());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommentStorageArchive::CopyFrom(const CommentStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CommentStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommentStorageArchive::IsInitialized() const {
  if (_internal_has_creation_date()) {
    if (!_impl_.creation_date_->IsInitialized()) return false;
  }
  if (_internal_has_author()) {
    if (!_impl_.author_->IsInitialized()) return false;
  }
  return true;
}

void CommentStorageArchive::InternalSwap(CommentStorageArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommentStorageArchive, _impl_.author_)
      + sizeof(CommentStorageArchive::_impl_.author_)
      - PROTOBUF_FIELD_OFFSET(CommentStorageArchive, _impl_.creation_date_)>(
          reinterpret_cast<char*>(&_impl_.creation_date_),
          reinterpret_cast<char*>(&other->_impl_.creation_date_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommentStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDArchives_2eproto_getter, &descriptor_table_TSDArchives_2eproto_once,
      file_level_metadata_TSDArchives_2eproto[48]);
}
#if !defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912)
const int ThemePresetsArchive::kExtensionFieldNumber;
#endif
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ThemePresetsArchive >, 11, false>
  ThemePresetsArchive::extension(kExtensionFieldNumber, ::TSD::ThemePresetsArchive::default_instance(), nullptr);

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSD
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSD::EdgeInsetsArchive*
Arena::CreateMaybeMessage< ::TSD::EdgeInsetsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EdgeInsetsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GeometryArchive*
Arena::CreateMaybeMessage< ::TSD::GeometryArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GeometryArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PointPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::PointPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PointPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ScalarPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::ScalarPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ScalarPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::BezierPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::BezierPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::BezierPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CalloutPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::CalloutPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CalloutPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ConnectionLinePathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::ConnectionLinePathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ConnectionLinePathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive_Node*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive_Subpath*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive_Subpath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive_Subpath >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::EditableBezierPathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::EditableBezierPathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::EditableBezierPathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PathSourceArchive*
Arena::CreateMaybeMessage< ::TSD::PathSourceArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PathSourceArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::AngleGradientArchive*
Arena::CreateMaybeMessage< ::TSD::AngleGradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::AngleGradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::TransformGradientArchive*
Arena::CreateMaybeMessage< ::TSD::TransformGradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::TransformGradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GradientArchive_GradientStop*
Arena::CreateMaybeMessage< ::TSD::GradientArchive_GradientStop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GradientArchive_GradientStop >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GradientArchive*
Arena::CreateMaybeMessage< ::TSD::GradientArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GradientArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageFillArchive*
Arena::CreateMaybeMessage< ::TSD::ImageFillArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageFillArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FillArchive*
Arena::CreateMaybeMessage< ::TSD::FillArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FillArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StrokePatternArchive*
Arena::CreateMaybeMessage< ::TSD::StrokePatternArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StrokePatternArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StrokeArchive*
Arena::CreateMaybeMessage< ::TSD::StrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::SmartStrokeArchive*
Arena::CreateMaybeMessage< ::TSD::SmartStrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::SmartStrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::FrameArchive*
Arena::CreateMaybeMessage< ::TSD::FrameArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::FrameArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PatternedStrokeArchive*
Arena::CreateMaybeMessage< ::TSD::PatternedStrokeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PatternedStrokeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::LineEndArchive*
Arena::CreateMaybeMessage< ::TSD::LineEndArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::LineEndArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShadowArchive*
Arena::CreateMaybeMessage< ::TSD::ShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DropShadowArchive*
Arena::CreateMaybeMessage< ::TSD::DropShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DropShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContactShadowArchive*
Arena::CreateMaybeMessage< ::TSD::ContactShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContactShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CurvedShadowArchive*
Arena::CreateMaybeMessage< ::TSD::CurvedShadowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CurvedShadowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ReflectionArchive*
Arena::CreateMaybeMessage< ::TSD::ReflectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ReflectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageAdjustmentsArchive*
Arena::CreateMaybeMessage< ::TSD::ImageAdjustmentsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageAdjustmentsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeStylePropertiesArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeStylePropertiesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeStylePropertiesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeStyleArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaStylePropertiesArchive*
Arena::CreateMaybeMessage< ::TSD::MediaStylePropertiesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaStylePropertiesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaStyleArchive*
Arena::CreateMaybeMessage< ::TSD::MediaStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ThemePresetsArchive*
Arena::CreateMaybeMessage< ::TSD::ThemePresetsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ThemePresetsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ThemeReplaceFillPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ThemeReplaceFillPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ThemeReplaceFillPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContainerArchive*
Arena::CreateMaybeMessage< ::TSD::ContainerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContainerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GroupArchive*
Arena::CreateMaybeMessage< ::TSD::GroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ConnectionLineArchive*
Arena::CreateMaybeMessage< ::TSD::ConnectionLineArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ConnectionLineArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageArchive*
Arena::CreateMaybeMessage< ::TSD::ImageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MaskArchive*
Arena::CreateMaybeMessage< ::TSD::MaskArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MaskArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieArchive*
Arena::CreateMaybeMessage< ::TSD::MovieArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ExteriorTextWrapArchive*
Arena::CreateMaybeMessage< ::TSD::ExteriorTextWrapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ExteriorTextWrapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GuideArchive*
Arena::CreateMaybeMessage< ::TSD::GuideArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GuideArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::UserDefinedGuideArchive*
Arena::CreateMaybeMessage< ::TSD::UserDefinedGuideArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::UserDefinedGuideArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GuideStorageArchive*
Arena::CreateMaybeMessage< ::TSD::GuideStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GuideStorageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CanvasSelectionArchive*
Arena::CreateMaybeMessage< ::TSD::CanvasSelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CanvasSelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CommentStorageArchive*
Arena::CreateMaybeMessage< ::TSD::CommentStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CommentStorageArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
