// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSDArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSDArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSDArchives_2eproto;
namespace TSD {
class AngleGradientArchive;
struct AngleGradientArchiveDefaultTypeInternal;
extern AngleGradientArchiveDefaultTypeInternal _AngleGradientArchive_default_instance_;
class BezierPathSourceArchive;
struct BezierPathSourceArchiveDefaultTypeInternal;
extern BezierPathSourceArchiveDefaultTypeInternal _BezierPathSourceArchive_default_instance_;
class CalloutPathSourceArchive;
struct CalloutPathSourceArchiveDefaultTypeInternal;
extern CalloutPathSourceArchiveDefaultTypeInternal _CalloutPathSourceArchive_default_instance_;
class CanvasSelectionArchive;
struct CanvasSelectionArchiveDefaultTypeInternal;
extern CanvasSelectionArchiveDefaultTypeInternal _CanvasSelectionArchive_default_instance_;
class CommentStorageArchive;
struct CommentStorageArchiveDefaultTypeInternal;
extern CommentStorageArchiveDefaultTypeInternal _CommentStorageArchive_default_instance_;
class ConnectionLineArchive;
struct ConnectionLineArchiveDefaultTypeInternal;
extern ConnectionLineArchiveDefaultTypeInternal _ConnectionLineArchive_default_instance_;
class ConnectionLinePathSourceArchive;
struct ConnectionLinePathSourceArchiveDefaultTypeInternal;
extern ConnectionLinePathSourceArchiveDefaultTypeInternal _ConnectionLinePathSourceArchive_default_instance_;
class ContactShadowArchive;
struct ContactShadowArchiveDefaultTypeInternal;
extern ContactShadowArchiveDefaultTypeInternal _ContactShadowArchive_default_instance_;
class ContainerArchive;
struct ContainerArchiveDefaultTypeInternal;
extern ContainerArchiveDefaultTypeInternal _ContainerArchive_default_instance_;
class CurvedShadowArchive;
struct CurvedShadowArchiveDefaultTypeInternal;
extern CurvedShadowArchiveDefaultTypeInternal _CurvedShadowArchive_default_instance_;
class DrawableArchive;
struct DrawableArchiveDefaultTypeInternal;
extern DrawableArchiveDefaultTypeInternal _DrawableArchive_default_instance_;
class DropShadowArchive;
struct DropShadowArchiveDefaultTypeInternal;
extern DropShadowArchiveDefaultTypeInternal _DropShadowArchive_default_instance_;
class EdgeInsetsArchive;
struct EdgeInsetsArchiveDefaultTypeInternal;
extern EdgeInsetsArchiveDefaultTypeInternal _EdgeInsetsArchive_default_instance_;
class EditableBezierPathSourceArchive;
struct EditableBezierPathSourceArchiveDefaultTypeInternal;
extern EditableBezierPathSourceArchiveDefaultTypeInternal _EditableBezierPathSourceArchive_default_instance_;
class EditableBezierPathSourceArchive_Node;
struct EditableBezierPathSourceArchive_NodeDefaultTypeInternal;
extern EditableBezierPathSourceArchive_NodeDefaultTypeInternal _EditableBezierPathSourceArchive_Node_default_instance_;
class EditableBezierPathSourceArchive_Subpath;
struct EditableBezierPathSourceArchive_SubpathDefaultTypeInternal;
extern EditableBezierPathSourceArchive_SubpathDefaultTypeInternal _EditableBezierPathSourceArchive_Subpath_default_instance_;
class ExteriorTextWrapArchive;
struct ExteriorTextWrapArchiveDefaultTypeInternal;
extern ExteriorTextWrapArchiveDefaultTypeInternal _ExteriorTextWrapArchive_default_instance_;
class FillArchive;
struct FillArchiveDefaultTypeInternal;
extern FillArchiveDefaultTypeInternal _FillArchive_default_instance_;
class FrameArchive;
struct FrameArchiveDefaultTypeInternal;
extern FrameArchiveDefaultTypeInternal _FrameArchive_default_instance_;
class GeometryArchive;
struct GeometryArchiveDefaultTypeInternal;
extern GeometryArchiveDefaultTypeInternal _GeometryArchive_default_instance_;
class GradientArchive;
struct GradientArchiveDefaultTypeInternal;
extern GradientArchiveDefaultTypeInternal _GradientArchive_default_instance_;
class GradientArchive_GradientStop;
struct GradientArchive_GradientStopDefaultTypeInternal;
extern GradientArchive_GradientStopDefaultTypeInternal _GradientArchive_GradientStop_default_instance_;
class GroupArchive;
struct GroupArchiveDefaultTypeInternal;
extern GroupArchiveDefaultTypeInternal _GroupArchive_default_instance_;
class GuideArchive;
struct GuideArchiveDefaultTypeInternal;
extern GuideArchiveDefaultTypeInternal _GuideArchive_default_instance_;
class GuideStorageArchive;
struct GuideStorageArchiveDefaultTypeInternal;
extern GuideStorageArchiveDefaultTypeInternal _GuideStorageArchive_default_instance_;
class ImageAdjustmentsArchive;
struct ImageAdjustmentsArchiveDefaultTypeInternal;
extern ImageAdjustmentsArchiveDefaultTypeInternal _ImageAdjustmentsArchive_default_instance_;
class ImageArchive;
struct ImageArchiveDefaultTypeInternal;
extern ImageArchiveDefaultTypeInternal _ImageArchive_default_instance_;
class ImageFillArchive;
struct ImageFillArchiveDefaultTypeInternal;
extern ImageFillArchiveDefaultTypeInternal _ImageFillArchive_default_instance_;
class LineEndArchive;
struct LineEndArchiveDefaultTypeInternal;
extern LineEndArchiveDefaultTypeInternal _LineEndArchive_default_instance_;
class MaskArchive;
struct MaskArchiveDefaultTypeInternal;
extern MaskArchiveDefaultTypeInternal _MaskArchive_default_instance_;
class MediaStyleArchive;
struct MediaStyleArchiveDefaultTypeInternal;
extern MediaStyleArchiveDefaultTypeInternal _MediaStyleArchive_default_instance_;
class MediaStylePropertiesArchive;
struct MediaStylePropertiesArchiveDefaultTypeInternal;
extern MediaStylePropertiesArchiveDefaultTypeInternal _MediaStylePropertiesArchive_default_instance_;
class MovieArchive;
struct MovieArchiveDefaultTypeInternal;
extern MovieArchiveDefaultTypeInternal _MovieArchive_default_instance_;
class PathSourceArchive;
struct PathSourceArchiveDefaultTypeInternal;
extern PathSourceArchiveDefaultTypeInternal _PathSourceArchive_default_instance_;
class PatternedStrokeArchive;
struct PatternedStrokeArchiveDefaultTypeInternal;
extern PatternedStrokeArchiveDefaultTypeInternal _PatternedStrokeArchive_default_instance_;
class PointPathSourceArchive;
struct PointPathSourceArchiveDefaultTypeInternal;
extern PointPathSourceArchiveDefaultTypeInternal _PointPathSourceArchive_default_instance_;
class ReflectionArchive;
struct ReflectionArchiveDefaultTypeInternal;
extern ReflectionArchiveDefaultTypeInternal _ReflectionArchive_default_instance_;
class ScalarPathSourceArchive;
struct ScalarPathSourceArchiveDefaultTypeInternal;
extern ScalarPathSourceArchiveDefaultTypeInternal _ScalarPathSourceArchive_default_instance_;
class ShadowArchive;
struct ShadowArchiveDefaultTypeInternal;
extern ShadowArchiveDefaultTypeInternal _ShadowArchive_default_instance_;
class ShapeArchive;
struct ShapeArchiveDefaultTypeInternal;
extern ShapeArchiveDefaultTypeInternal _ShapeArchive_default_instance_;
class ShapeStyleArchive;
struct ShapeStyleArchiveDefaultTypeInternal;
extern ShapeStyleArchiveDefaultTypeInternal _ShapeStyleArchive_default_instance_;
class ShapeStylePropertiesArchive;
struct ShapeStylePropertiesArchiveDefaultTypeInternal;
extern ShapeStylePropertiesArchiveDefaultTypeInternal _ShapeStylePropertiesArchive_default_instance_;
class SmartStrokeArchive;
struct SmartStrokeArchiveDefaultTypeInternal;
extern SmartStrokeArchiveDefaultTypeInternal _SmartStrokeArchive_default_instance_;
class StrokeArchive;
struct StrokeArchiveDefaultTypeInternal;
extern StrokeArchiveDefaultTypeInternal _StrokeArchive_default_instance_;
class StrokePatternArchive;
struct StrokePatternArchiveDefaultTypeInternal;
extern StrokePatternArchiveDefaultTypeInternal _StrokePatternArchive_default_instance_;
class ThemePresetsArchive;
struct ThemePresetsArchiveDefaultTypeInternal;
extern ThemePresetsArchiveDefaultTypeInternal _ThemePresetsArchive_default_instance_;
class ThemeReplaceFillPresetCommandArchive;
struct ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal;
extern ThemeReplaceFillPresetCommandArchiveDefaultTypeInternal _ThemeReplaceFillPresetCommandArchive_default_instance_;
class TransformGradientArchive;
struct TransformGradientArchiveDefaultTypeInternal;
extern TransformGradientArchiveDefaultTypeInternal _TransformGradientArchive_default_instance_;
class UserDefinedGuideArchive;
struct UserDefinedGuideArchiveDefaultTypeInternal;
extern UserDefinedGuideArchiveDefaultTypeInternal _UserDefinedGuideArchive_default_instance_;
}  // namespace TSD
PROTOBUF_NAMESPACE_OPEN
template<> ::TSD::AngleGradientArchive* Arena::CreateMaybeMessage<::TSD::AngleGradientArchive>(Arena*);
template<> ::TSD::BezierPathSourceArchive* Arena::CreateMaybeMessage<::TSD::BezierPathSourceArchive>(Arena*);
template<> ::TSD::CalloutPathSourceArchive* Arena::CreateMaybeMessage<::TSD::CalloutPathSourceArchive>(Arena*);
template<> ::TSD::CanvasSelectionArchive* Arena::CreateMaybeMessage<::TSD::CanvasSelectionArchive>(Arena*);
template<> ::TSD::CommentStorageArchive* Arena::CreateMaybeMessage<::TSD::CommentStorageArchive>(Arena*);
template<> ::TSD::ConnectionLineArchive* Arena::CreateMaybeMessage<::TSD::ConnectionLineArchive>(Arena*);
template<> ::TSD::ConnectionLinePathSourceArchive* Arena::CreateMaybeMessage<::TSD::ConnectionLinePathSourceArchive>(Arena*);
template<> ::TSD::ContactShadowArchive* Arena::CreateMaybeMessage<::TSD::ContactShadowArchive>(Arena*);
template<> ::TSD::ContainerArchive* Arena::CreateMaybeMessage<::TSD::ContainerArchive>(Arena*);
template<> ::TSD::CurvedShadowArchive* Arena::CreateMaybeMessage<::TSD::CurvedShadowArchive>(Arena*);
template<> ::TSD::DrawableArchive* Arena::CreateMaybeMessage<::TSD::DrawableArchive>(Arena*);
template<> ::TSD::DropShadowArchive* Arena::CreateMaybeMessage<::TSD::DropShadowArchive>(Arena*);
template<> ::TSD::EdgeInsetsArchive* Arena::CreateMaybeMessage<::TSD::EdgeInsetsArchive>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive_Node* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive_Node>(Arena*);
template<> ::TSD::EditableBezierPathSourceArchive_Subpath* Arena::CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive_Subpath>(Arena*);
template<> ::TSD::ExteriorTextWrapArchive* Arena::CreateMaybeMessage<::TSD::ExteriorTextWrapArchive>(Arena*);
template<> ::TSD::FillArchive* Arena::CreateMaybeMessage<::TSD::FillArchive>(Arena*);
template<> ::TSD::FrameArchive* Arena::CreateMaybeMessage<::TSD::FrameArchive>(Arena*);
template<> ::TSD::GeometryArchive* Arena::CreateMaybeMessage<::TSD::GeometryArchive>(Arena*);
template<> ::TSD::GradientArchive* Arena::CreateMaybeMessage<::TSD::GradientArchive>(Arena*);
template<> ::TSD::GradientArchive_GradientStop* Arena::CreateMaybeMessage<::TSD::GradientArchive_GradientStop>(Arena*);
template<> ::TSD::GroupArchive* Arena::CreateMaybeMessage<::TSD::GroupArchive>(Arena*);
template<> ::TSD::GuideArchive* Arena::CreateMaybeMessage<::TSD::GuideArchive>(Arena*);
template<> ::TSD::GuideStorageArchive* Arena::CreateMaybeMessage<::TSD::GuideStorageArchive>(Arena*);
template<> ::TSD::ImageAdjustmentsArchive* Arena::CreateMaybeMessage<::TSD::ImageAdjustmentsArchive>(Arena*);
template<> ::TSD::ImageArchive* Arena::CreateMaybeMessage<::TSD::ImageArchive>(Arena*);
template<> ::TSD::ImageFillArchive* Arena::CreateMaybeMessage<::TSD::ImageFillArchive>(Arena*);
template<> ::TSD::LineEndArchive* Arena::CreateMaybeMessage<::TSD::LineEndArchive>(Arena*);
template<> ::TSD::MaskArchive* Arena::CreateMaybeMessage<::TSD::MaskArchive>(Arena*);
template<> ::TSD::MediaStyleArchive* Arena::CreateMaybeMessage<::TSD::MediaStyleArchive>(Arena*);
template<> ::TSD::MediaStylePropertiesArchive* Arena::CreateMaybeMessage<::TSD::MediaStylePropertiesArchive>(Arena*);
template<> ::TSD::MovieArchive* Arena::CreateMaybeMessage<::TSD::MovieArchive>(Arena*);
template<> ::TSD::PathSourceArchive* Arena::CreateMaybeMessage<::TSD::PathSourceArchive>(Arena*);
template<> ::TSD::PatternedStrokeArchive* Arena::CreateMaybeMessage<::TSD::PatternedStrokeArchive>(Arena*);
template<> ::TSD::PointPathSourceArchive* Arena::CreateMaybeMessage<::TSD::PointPathSourceArchive>(Arena*);
template<> ::TSD::ReflectionArchive* Arena::CreateMaybeMessage<::TSD::ReflectionArchive>(Arena*);
template<> ::TSD::ScalarPathSourceArchive* Arena::CreateMaybeMessage<::TSD::ScalarPathSourceArchive>(Arena*);
template<> ::TSD::ShadowArchive* Arena::CreateMaybeMessage<::TSD::ShadowArchive>(Arena*);
template<> ::TSD::ShapeArchive* Arena::CreateMaybeMessage<::TSD::ShapeArchive>(Arena*);
template<> ::TSD::ShapeStyleArchive* Arena::CreateMaybeMessage<::TSD::ShapeStyleArchive>(Arena*);
template<> ::TSD::ShapeStylePropertiesArchive* Arena::CreateMaybeMessage<::TSD::ShapeStylePropertiesArchive>(Arena*);
template<> ::TSD::SmartStrokeArchive* Arena::CreateMaybeMessage<::TSD::SmartStrokeArchive>(Arena*);
template<> ::TSD::StrokeArchive* Arena::CreateMaybeMessage<::TSD::StrokeArchive>(Arena*);
template<> ::TSD::StrokePatternArchive* Arena::CreateMaybeMessage<::TSD::StrokePatternArchive>(Arena*);
template<> ::TSD::ThemePresetsArchive* Arena::CreateMaybeMessage<::TSD::ThemePresetsArchive>(Arena*);
template<> ::TSD::ThemeReplaceFillPresetCommandArchive* Arena::CreateMaybeMessage<::TSD::ThemeReplaceFillPresetCommandArchive>(Arena*);
template<> ::TSD::TransformGradientArchive* Arena::CreateMaybeMessage<::TSD::TransformGradientArchive>(Arena*);
template<> ::TSD::UserDefinedGuideArchive* Arena::CreateMaybeMessage<::TSD::UserDefinedGuideArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSD {

enum PointPathSourceArchive_PointPathSourceType : int {
  PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow = 0,
  PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow = 1,
  PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow = 10,
  PointPathSourceArchive_PointPathSourceType_kTSDStar = 100,
  PointPathSourceArchive_PointPathSourceType_kTSDPlus = 200
};
bool PointPathSourceArchive_PointPathSourceType_IsValid(int value);
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN = PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
constexpr PointPathSourceArchive_PointPathSourceType PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX = PointPathSourceArchive_PointPathSourceType_kTSDPlus;
constexpr int PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE = PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PointPathSourceArchive_PointPathSourceType_descriptor();
template<typename T>
inline const std::string& PointPathSourceArchive_PointPathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PointPathSourceArchive_PointPathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PointPathSourceArchive_PointPathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PointPathSourceArchive_PointPathSourceType_descriptor(), enum_t_value);
}
inline bool PointPathSourceArchive_PointPathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PointPathSourceArchive_PointPathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PointPathSourceArchive_PointPathSourceType>(
    PointPathSourceArchive_PointPathSourceType_descriptor(), name, value);
}
enum ScalarPathSourceArchive_ScalarPathSourceType : int {
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle = 0,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon = 1,
  ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron = 2
};
bool ScalarPathSourceArchive_ScalarPathSourceType_IsValid(int value);
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN = ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
constexpr ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX = ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
constexpr int ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE = ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
template<typename T>
inline const std::string& ScalarPathSourceArchive_ScalarPathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScalarPathSourceArchive_ScalarPathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScalarPathSourceArchive_ScalarPathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), enum_t_value);
}
inline bool ScalarPathSourceArchive_ScalarPathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScalarPathSourceArchive_ScalarPathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScalarPathSourceArchive_ScalarPathSourceType>(
    ScalarPathSourceArchive_ScalarPathSourceType_descriptor(), name, value);
}
enum ConnectionLinePathSourceArchive_ConnectionLinePathSourceType : int {
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic = 0,
  ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal = 1
};
bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(int value);
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
constexpr ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
constexpr int ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE = ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
template<typename T>
inline const std::string& ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), enum_t_value);
}
inline bool ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConnectionLinePathSourceArchive_ConnectionLinePathSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>(
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor(), name, value);
}
enum EditableBezierPathSourceArchive_NodeType : int {
  EditableBezierPathSourceArchive_NodeType_sharp = 1,
  EditableBezierPathSourceArchive_NodeType_bezier = 2,
  EditableBezierPathSourceArchive_NodeType_smooth = 3
};
bool EditableBezierPathSourceArchive_NodeType_IsValid(int value);
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MIN = EditableBezierPathSourceArchive_NodeType_sharp;
constexpr EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_NodeType_NodeType_MAX = EditableBezierPathSourceArchive_NodeType_smooth;
constexpr int EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE = EditableBezierPathSourceArchive_NodeType_NodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EditableBezierPathSourceArchive_NodeType_descriptor();
template<typename T>
inline const std::string& EditableBezierPathSourceArchive_NodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EditableBezierPathSourceArchive_NodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EditableBezierPathSourceArchive_NodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EditableBezierPathSourceArchive_NodeType_descriptor(), enum_t_value);
}
inline bool EditableBezierPathSourceArchive_NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EditableBezierPathSourceArchive_NodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EditableBezierPathSourceArchive_NodeType>(
    EditableBezierPathSourceArchive_NodeType_descriptor(), name, value);
}
enum GradientArchive_GradientType : int {
  GradientArchive_GradientType_Linear = 0,
  GradientArchive_GradientType_Radial = 1
};
bool GradientArchive_GradientType_IsValid(int value);
constexpr GradientArchive_GradientType GradientArchive_GradientType_GradientType_MIN = GradientArchive_GradientType_Linear;
constexpr GradientArchive_GradientType GradientArchive_GradientType_GradientType_MAX = GradientArchive_GradientType_Radial;
constexpr int GradientArchive_GradientType_GradientType_ARRAYSIZE = GradientArchive_GradientType_GradientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GradientArchive_GradientType_descriptor();
template<typename T>
inline const std::string& GradientArchive_GradientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GradientArchive_GradientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GradientArchive_GradientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GradientArchive_GradientType_descriptor(), enum_t_value);
}
inline bool GradientArchive_GradientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GradientArchive_GradientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GradientArchive_GradientType>(
    GradientArchive_GradientType_descriptor(), name, value);
}
enum ImageFillArchive_ImageFillTechnique : int {
  ImageFillArchive_ImageFillTechnique_NaturalSize = 0,
  ImageFillArchive_ImageFillTechnique_Stretch = 1,
  ImageFillArchive_ImageFillTechnique_Tile = 2,
  ImageFillArchive_ImageFillTechnique_ScaleToFill = 3,
  ImageFillArchive_ImageFillTechnique_ScaleToFit = 4
};
bool ImageFillArchive_ImageFillTechnique_IsValid(int value);
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN = ImageFillArchive_ImageFillTechnique_NaturalSize;
constexpr ImageFillArchive_ImageFillTechnique ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX = ImageFillArchive_ImageFillTechnique_ScaleToFit;
constexpr int ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE = ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageFillArchive_ImageFillTechnique_descriptor();
template<typename T>
inline const std::string& ImageFillArchive_ImageFillTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageFillArchive_ImageFillTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageFillArchive_ImageFillTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageFillArchive_ImageFillTechnique_descriptor(), enum_t_value);
}
inline bool ImageFillArchive_ImageFillTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageFillArchive_ImageFillTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageFillArchive_ImageFillTechnique>(
    ImageFillArchive_ImageFillTechnique_descriptor(), name, value);
}
enum StrokePatternArchive_StrokePatternType : int {
  StrokePatternArchive_StrokePatternType_TSDPattern = 0,
  StrokePatternArchive_StrokePatternType_TSDSolidPattern = 1,
  StrokePatternArchive_StrokePatternType_TSDEmptyPattern = 2
};
bool StrokePatternArchive_StrokePatternType_IsValid(int value);
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MIN = StrokePatternArchive_StrokePatternType_TSDPattern;
constexpr StrokePatternArchive_StrokePatternType StrokePatternArchive_StrokePatternType_StrokePatternType_MAX = StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
constexpr int StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE = StrokePatternArchive_StrokePatternType_StrokePatternType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokePatternArchive_StrokePatternType_descriptor();
template<typename T>
inline const std::string& StrokePatternArchive_StrokePatternType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StrokePatternArchive_StrokePatternType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StrokePatternArchive_StrokePatternType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StrokePatternArchive_StrokePatternType_descriptor(), enum_t_value);
}
inline bool StrokePatternArchive_StrokePatternType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StrokePatternArchive_StrokePatternType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrokePatternArchive_StrokePatternType>(
    StrokePatternArchive_StrokePatternType_descriptor(), name, value);
}
enum StrokeArchive_LineCap : int {
  StrokeArchive_LineCap_ButtCap = 0,
  StrokeArchive_LineCap_RoundCap = 1,
  StrokeArchive_LineCap_SquareCap = 2
};
bool StrokeArchive_LineCap_IsValid(int value);
constexpr StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MIN = StrokeArchive_LineCap_ButtCap;
constexpr StrokeArchive_LineCap StrokeArchive_LineCap_LineCap_MAX = StrokeArchive_LineCap_SquareCap;
constexpr int StrokeArchive_LineCap_LineCap_ARRAYSIZE = StrokeArchive_LineCap_LineCap_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StrokeArchive_LineCap_descriptor();
template<typename T>
inline const std::string& StrokeArchive_LineCap_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StrokeArchive_LineCap>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StrokeArchive_LineCap_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StrokeArchive_LineCap_descriptor(), enum_t_value);
}
inline bool StrokeArchive_LineCap_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StrokeArchive_LineCap* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StrokeArchive_LineCap>(
    StrokeArchive_LineCap_descriptor(), name, value);
}
enum ShadowArchive_ShadowType : int {
  ShadowArchive_ShadowType_TSDDropShadow = 0,
  ShadowArchive_ShadowType_TSDContactShadow = 1,
  ShadowArchive_ShadowType_TSDCurvedShadow = 2
};
bool ShadowArchive_ShadowType_IsValid(int value);
constexpr ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MIN = ShadowArchive_ShadowType_TSDDropShadow;
constexpr ShadowArchive_ShadowType ShadowArchive_ShadowType_ShadowType_MAX = ShadowArchive_ShadowType_TSDCurvedShadow;
constexpr int ShadowArchive_ShadowType_ShadowType_ARRAYSIZE = ShadowArchive_ShadowType_ShadowType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShadowArchive_ShadowType_descriptor();
template<typename T>
inline const std::string& ShadowArchive_ShadowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShadowArchive_ShadowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShadowArchive_ShadowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShadowArchive_ShadowType_descriptor(), enum_t_value);
}
inline bool ShadowArchive_ShadowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShadowArchive_ShadowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShadowArchive_ShadowType>(
    ShadowArchive_ShadowType_descriptor(), name, value);
}
enum GuideArchive_GuideType : int {
  GuideArchive_GuideType_Horizontal = 0,
  GuideArchive_GuideType_Vertical = 1
};
bool GuideArchive_GuideType_IsValid(int value);
constexpr GuideArchive_GuideType GuideArchive_GuideType_GuideType_MIN = GuideArchive_GuideType_Horizontal;
constexpr GuideArchive_GuideType GuideArchive_GuideType_GuideType_MAX = GuideArchive_GuideType_Vertical;
constexpr int GuideArchive_GuideType_GuideType_ARRAYSIZE = GuideArchive_GuideType_GuideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideArchive_GuideType_descriptor();
template<typename T>
inline const std::string& GuideArchive_GuideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GuideArchive_GuideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GuideArchive_GuideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GuideArchive_GuideType_descriptor(), enum_t_value);
}
inline bool GuideArchive_GuideType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GuideArchive_GuideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GuideArchive_GuideType>(
    GuideArchive_GuideType_descriptor(), name, value);
}
enum UserDefinedGuideArchive_GuideType : int {
  UserDefinedGuideArchive_GuideType_Horizontal = 0,
  UserDefinedGuideArchive_GuideType_Vertical = 1
};
bool UserDefinedGuideArchive_GuideType_IsValid(int value);
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MIN = UserDefinedGuideArchive_GuideType_Horizontal;
constexpr UserDefinedGuideArchive_GuideType UserDefinedGuideArchive_GuideType_GuideType_MAX = UserDefinedGuideArchive_GuideType_Vertical;
constexpr int UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE = UserDefinedGuideArchive_GuideType_GuideType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserDefinedGuideArchive_GuideType_descriptor();
template<typename T>
inline const std::string& UserDefinedGuideArchive_GuideType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserDefinedGuideArchive_GuideType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserDefinedGuideArchive_GuideType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserDefinedGuideArchive_GuideType_descriptor(), enum_t_value);
}
inline bool UserDefinedGuideArchive_GuideType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserDefinedGuideArchive_GuideType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserDefinedGuideArchive_GuideType>(
    UserDefinedGuideArchive_GuideType_descriptor(), name, value);
}
enum LineJoin : int {
  MiterJoin = 0,
  RoundJoin = 1,
  BevelJoin = 2
};
bool LineJoin_IsValid(int value);
constexpr LineJoin LineJoin_MIN = MiterJoin;
constexpr LineJoin LineJoin_MAX = BevelJoin;
constexpr int LineJoin_ARRAYSIZE = LineJoin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LineJoin_descriptor();
template<typename T>
inline const std::string& LineJoin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LineJoin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LineJoin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LineJoin_descriptor(), enum_t_value);
}
inline bool LineJoin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LineJoin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LineJoin>(
    LineJoin_descriptor(), name, value);
}
// ===================================================================

class EdgeInsetsArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EdgeInsetsArchive) */ {
 public:
  inline EdgeInsetsArchive() : EdgeInsetsArchive(nullptr) {}
  ~EdgeInsetsArchive() override;
  explicit PROTOBUF_CONSTEXPR EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeInsetsArchive(const EdgeInsetsArchive& from);
  EdgeInsetsArchive(EdgeInsetsArchive&& from) noexcept
    : EdgeInsetsArchive() {
    *this = ::std::move(from);
  }

  inline EdgeInsetsArchive& operator=(const EdgeInsetsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeInsetsArchive& operator=(EdgeInsetsArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgeInsetsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeInsetsArchive* internal_default_instance() {
    return reinterpret_cast<const EdgeInsetsArchive*>(
               &_EdgeInsetsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EdgeInsetsArchive& a, EdgeInsetsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeInsetsArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeInsetsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeInsetsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeInsetsArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgeInsetsArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdgeInsetsArchive& from) {
    EdgeInsetsArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeInsetsArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EdgeInsetsArchive";
  }
  protected:
  explicit EdgeInsetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopFieldNumber = 1,
    kLeftFieldNumber = 2,
    kBottomFieldNumber = 3,
    kRightFieldNumber = 4,
  };
  // required float top = 1;
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  float top() const;
  void set_top(float value);
  private:
  float _internal_top() const;
  void _internal_set_top(float value);
  public:

  // required float left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  float left() const;
  void set_left(float value);
  private:
  float _internal_left() const;
  void _internal_set_left(float value);
  public:

  // required float bottom = 3;
  bool has_bottom() const;
  private:
  bool _internal_has_bottom() const;
  public:
  void clear_bottom();
  float bottom() const;
  void set_bottom(float value);
  private:
  float _internal_bottom() const;
  void _internal_set_bottom(float value);
  public:

  // required float right = 4;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  float right() const;
  void set_right(float value);
  private:
  float _internal_right() const;
  void _internal_set_right(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EdgeInsetsArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float top_;
    float left_;
    float bottom_;
    float right_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GeometryArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GeometryArchive) */ {
 public:
  inline GeometryArchive() : GeometryArchive(nullptr) {}
  ~GeometryArchive() override;
  explicit PROTOBUF_CONSTEXPR GeometryArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeometryArchive(const GeometryArchive& from);
  GeometryArchive(GeometryArchive&& from) noexcept
    : GeometryArchive() {
    *this = ::std::move(from);
  }

  inline GeometryArchive& operator=(const GeometryArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeometryArchive& operator=(GeometryArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GeometryArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeometryArchive* internal_default_instance() {
    return reinterpret_cast<const GeometryArchive*>(
               &_GeometryArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GeometryArchive& a, GeometryArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GeometryArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeometryArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeometryArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeometryArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GeometryArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GeometryArchive& from) {
    GeometryArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeometryArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GeometryArchive";
  }
  protected:
  explicit GeometryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kSizeFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kAngleFieldNumber = 4,
  };
  // optional .TSP.Point position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::TSP::Point& position() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_position();
  ::TSP::Point* mutable_position();
  void set_allocated_position(::TSP::Point* position);
  private:
  const ::TSP::Point& _internal_position() const;
  ::TSP::Point* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::TSP::Point* position);
  ::TSP::Point* unsafe_arena_release_position();

  // optional .TSP.Size size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::TSP::Size& size() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_size();
  ::TSP::Size* mutable_size();
  void set_allocated_size(::TSP::Size* size);
  private:
  const ::TSP::Size& _internal_size() const;
  ::TSP::Size* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::TSP::Size* size);
  ::TSP::Size* unsafe_arena_release_size();

  // optional uint32 flags = 3;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional float angle = 4;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GeometryArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Point* position_;
    ::TSP::Size* size_;
    uint32_t flags_;
    float angle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PointPathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PointPathSourceArchive) */ {
 public:
  inline PointPathSourceArchive() : PointPathSourceArchive(nullptr) {}
  ~PointPathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointPathSourceArchive(const PointPathSourceArchive& from);
  PointPathSourceArchive(PointPathSourceArchive&& from) noexcept
    : PointPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline PointPathSourceArchive& operator=(const PointPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointPathSourceArchive& operator=(PointPathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const PointPathSourceArchive*>(
               &_PointPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PointPathSourceArchive& a, PointPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PointPathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointPathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointPathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointPathSourceArchive& from) {
    PointPathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointPathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PointPathSourceArchive";
  }
  protected:
  explicit PointPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PointPathSourceArchive_PointPathSourceType PointPathSourceType;
  static constexpr PointPathSourceType kTSDLeftSingleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDLeftSingleArrow;
  static constexpr PointPathSourceType kTSDRightSingleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDRightSingleArrow;
  static constexpr PointPathSourceType kTSDDoubleArrow =
    PointPathSourceArchive_PointPathSourceType_kTSDDoubleArrow;
  static constexpr PointPathSourceType kTSDStar =
    PointPathSourceArchive_PointPathSourceType_kTSDStar;
  static constexpr PointPathSourceType kTSDPlus =
    PointPathSourceArchive_PointPathSourceType_kTSDPlus;
  static inline bool PointPathSourceType_IsValid(int value) {
    return PointPathSourceArchive_PointPathSourceType_IsValid(value);
  }
  static constexpr PointPathSourceType PointPathSourceType_MIN =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MIN;
  static constexpr PointPathSourceType PointPathSourceType_MAX =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_MAX;
  static constexpr int PointPathSourceType_ARRAYSIZE =
    PointPathSourceArchive_PointPathSourceType_PointPathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PointPathSourceType_descriptor() {
    return PointPathSourceArchive_PointPathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& PointPathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PointPathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PointPathSourceType_Name.");
    return PointPathSourceArchive_PointPathSourceType_Name(enum_t_value);
  }
  static inline bool PointPathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PointPathSourceType* value) {
    return PointPathSourceArchive_PointPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 2,
    kNaturalSizeFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .TSP.Point point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::TSP::Point& point() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_point();
  ::TSP::Point* mutable_point();
  void set_allocated_point(::TSP::Point* point);
  private:
  const ::TSP::Point& _internal_point() const;
  ::TSP::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::TSP::Point* point);
  ::TSP::Point* unsafe_arena_release_point();

  // optional .TSP.Size naturalSize = 3;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::PointPathSourceArchive_PointPathSourceType type() const;
  void set_type(::TSD::PointPathSourceArchive_PointPathSourceType value);
  private:
  ::TSD::PointPathSourceArchive_PointPathSourceType _internal_type() const;
  void _internal_set_type(::TSD::PointPathSourceArchive_PointPathSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.PointPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Point* point_;
    ::TSP::Size* naturalsize_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ScalarPathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ScalarPathSourceArchive) */ {
 public:
  inline ScalarPathSourceArchive() : ScalarPathSourceArchive(nullptr) {}
  ~ScalarPathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScalarPathSourceArchive(const ScalarPathSourceArchive& from);
  ScalarPathSourceArchive(ScalarPathSourceArchive&& from) noexcept
    : ScalarPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline ScalarPathSourceArchive& operator=(const ScalarPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScalarPathSourceArchive& operator=(ScalarPathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScalarPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScalarPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const ScalarPathSourceArchive*>(
               &_ScalarPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScalarPathSourceArchive& a, ScalarPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ScalarPathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScalarPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScalarPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScalarPathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScalarPathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScalarPathSourceArchive& from) {
    ScalarPathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScalarPathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ScalarPathSourceArchive";
  }
  protected:
  explicit ScalarPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceType;
  static constexpr ScalarPathSourceType kTSDRoundedRectangle =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDRoundedRectangle;
  static constexpr ScalarPathSourceType kTSDRegularPolygon =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDRegularPolygon;
  static constexpr ScalarPathSourceType kTSDChevron =
    ScalarPathSourceArchive_ScalarPathSourceType_kTSDChevron;
  static inline bool ScalarPathSourceType_IsValid(int value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value);
  }
  static constexpr ScalarPathSourceType ScalarPathSourceType_MIN =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MIN;
  static constexpr ScalarPathSourceType ScalarPathSourceType_MAX =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_MAX;
  static constexpr int ScalarPathSourceType_ARRAYSIZE =
    ScalarPathSourceArchive_ScalarPathSourceType_ScalarPathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScalarPathSourceType_descriptor() {
    return ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ScalarPathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScalarPathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScalarPathSourceType_Name.");
    return ScalarPathSourceArchive_ScalarPathSourceType_Name(enum_t_value);
  }
  static inline bool ScalarPathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScalarPathSourceType* value) {
    return ScalarPathSourceArchive_ScalarPathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNaturalSizeFieldNumber = 3,
    kTypeFieldNumber = 1,
    kScalarFieldNumber = 2,
  };
  // optional .TSP.Size naturalSize = 3;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ScalarPathSourceArchive_ScalarPathSourceType type() const;
  void set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value);
  private:
  ::TSD::ScalarPathSourceArchive_ScalarPathSourceType _internal_type() const;
  void _internal_set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value);
  public:

  // optional float scalar = 2;
  bool has_scalar() const;
  private:
  bool _internal_has_scalar() const;
  public:
  void clear_scalar();
  float scalar() const;
  void set_scalar(float value);
  private:
  float _internal_scalar() const;
  void _internal_set_scalar(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ScalarPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Size* naturalsize_;
    int type_;
    float scalar_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class BezierPathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.BezierPathSourceArchive) */ {
 public:
  inline BezierPathSourceArchive() : BezierPathSourceArchive(nullptr) {}
  ~BezierPathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BezierPathSourceArchive(const BezierPathSourceArchive& from);
  BezierPathSourceArchive(BezierPathSourceArchive&& from) noexcept
    : BezierPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline BezierPathSourceArchive& operator=(const BezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline BezierPathSourceArchive& operator=(BezierPathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BezierPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const BezierPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const BezierPathSourceArchive*>(
               &_BezierPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BezierPathSourceArchive& a, BezierPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(BezierPathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BezierPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BezierPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BezierPathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BezierPathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BezierPathSourceArchive& from) {
    BezierPathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BezierPathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.BezierPathSourceArchive";
  }
  protected:
  explicit BezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathStringFieldNumber = 1,
    kNaturalSizeFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // optional string path_string = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_path_string() const;
  private:
  bool _internal_has_path_string() const;
  public:
  PROTOBUF_DEPRECATED void clear_path_string();
  PROTOBUF_DEPRECATED const std::string& path_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_path_string(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_path_string();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_path_string();
  PROTOBUF_DEPRECATED void set_allocated_path_string(std::string* path_string);
  private:
  const std::string& _internal_path_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_string(const std::string& value);
  std::string* _internal_mutable_path_string();
  public:

  // optional .TSP.Size naturalSize = 2;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.Path path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::TSP::Path& path() const;
  PROTOBUF_NODISCARD ::TSP::Path* release_path();
  ::TSP::Path* mutable_path();
  void set_allocated_path(::TSP::Path* path);
  private:
  const ::TSP::Path& _internal_path() const;
  ::TSP::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::TSP::Path* path);
  ::TSP::Path* unsafe_arena_release_path();

  // @@protoc_insertion_point(class_scope:TSD.BezierPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_string_;
    ::TSP::Size* naturalsize_;
    ::TSP::Path* path_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CalloutPathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CalloutPathSourceArchive) */ {
 public:
  inline CalloutPathSourceArchive() : CalloutPathSourceArchive(nullptr) {}
  ~CalloutPathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CalloutPathSourceArchive(const CalloutPathSourceArchive& from);
  CalloutPathSourceArchive(CalloutPathSourceArchive&& from) noexcept
    : CalloutPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline CalloutPathSourceArchive& operator=(const CalloutPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalloutPathSourceArchive& operator=(CalloutPathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CalloutPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CalloutPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const CalloutPathSourceArchive*>(
               &_CalloutPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CalloutPathSourceArchive& a, CalloutPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CalloutPathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CalloutPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CalloutPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CalloutPathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CalloutPathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CalloutPathSourceArchive& from) {
    CalloutPathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalloutPathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CalloutPathSourceArchive";
  }
  protected:
  explicit CalloutPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNaturalSizeFieldNumber = 1,
    kTailPositionFieldNumber = 2,
    kTailSizeFieldNumber = 3,
    kCornerRadiusFieldNumber = 4,
    kCenterTailFieldNumber = 5,
  };
  // optional .TSP.Size natural_size = 1;
  bool has_natural_size() const;
  private:
  bool _internal_has_natural_size() const;
  public:
  void clear_natural_size();
  const ::TSP::Size& natural_size() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_natural_size();
  ::TSP::Size* mutable_natural_size();
  void set_allocated_natural_size(::TSP::Size* natural_size);
  private:
  const ::TSP::Size& _internal_natural_size() const;
  ::TSP::Size* _internal_mutable_natural_size();
  public:
  void unsafe_arena_set_allocated_natural_size(
      ::TSP::Size* natural_size);
  ::TSP::Size* unsafe_arena_release_natural_size();

  // optional .TSP.Point tail_position = 2;
  bool has_tail_position() const;
  private:
  bool _internal_has_tail_position() const;
  public:
  void clear_tail_position();
  const ::TSP::Point& tail_position() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_tail_position();
  ::TSP::Point* mutable_tail_position();
  void set_allocated_tail_position(::TSP::Point* tail_position);
  private:
  const ::TSP::Point& _internal_tail_position() const;
  ::TSP::Point* _internal_mutable_tail_position();
  public:
  void unsafe_arena_set_allocated_tail_position(
      ::TSP::Point* tail_position);
  ::TSP::Point* unsafe_arena_release_tail_position();

  // optional float tail_size = 3;
  bool has_tail_size() const;
  private:
  bool _internal_has_tail_size() const;
  public:
  void clear_tail_size();
  float tail_size() const;
  void set_tail_size(float value);
  private:
  float _internal_tail_size() const;
  void _internal_set_tail_size(float value);
  public:

  // optional float corner_radius = 4;
  bool has_corner_radius() const;
  private:
  bool _internal_has_corner_radius() const;
  public:
  void clear_corner_radius();
  float corner_radius() const;
  void set_corner_radius(float value);
  private:
  float _internal_corner_radius() const;
  void _internal_set_corner_radius(float value);
  public:

  // optional bool center_tail = 5;
  bool has_center_tail() const;
  private:
  bool _internal_has_center_tail() const;
  public:
  void clear_center_tail();
  bool center_tail() const;
  void set_center_tail(bool value);
  private:
  bool _internal_center_tail() const;
  void _internal_set_center_tail(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.CalloutPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Size* natural_size_;
    ::TSP::Point* tail_position_;
    float tail_size_;
    float corner_radius_;
    bool center_tail_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ConnectionLinePathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ConnectionLinePathSourceArchive) */ {
 public:
  inline ConnectionLinePathSourceArchive() : ConnectionLinePathSourceArchive(nullptr) {}
  ~ConnectionLinePathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionLinePathSourceArchive(const ConnectionLinePathSourceArchive& from);
  ConnectionLinePathSourceArchive(ConnectionLinePathSourceArchive&& from) noexcept
    : ConnectionLinePathSourceArchive() {
    *this = ::std::move(from);
  }

  inline ConnectionLinePathSourceArchive& operator=(const ConnectionLinePathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionLinePathSourceArchive& operator=(ConnectionLinePathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionLinePathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionLinePathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const ConnectionLinePathSourceArchive*>(
               &_ConnectionLinePathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConnectionLinePathSourceArchive& a, ConnectionLinePathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionLinePathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionLinePathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionLinePathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionLinePathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionLinePathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionLinePathSourceArchive& from) {
    ConnectionLinePathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionLinePathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ConnectionLinePathSourceArchive";
  }
  protected:
  explicit ConnectionLinePathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceType;
  static constexpr ConnectionLinePathSourceType kTSDConnectionLineTypeQuadratic =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeQuadratic;
  static constexpr ConnectionLinePathSourceType kTSDConnectionLineTypeOrthogonal =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_kTSDConnectionLineTypeOrthogonal;
  static inline bool ConnectionLinePathSourceType_IsValid(int value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value);
  }
  static constexpr ConnectionLinePathSourceType ConnectionLinePathSourceType_MIN =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MIN;
  static constexpr ConnectionLinePathSourceType ConnectionLinePathSourceType_MAX =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_MAX;
  static constexpr int ConnectionLinePathSourceType_ARRAYSIZE =
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_ConnectionLinePathSourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConnectionLinePathSourceType_descriptor() {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConnectionLinePathSourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionLinePathSourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionLinePathSourceType_Name.");
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Name(enum_t_value);
  }
  static inline bool ConnectionLinePathSourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionLinePathSourceType* value) {
    return ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOutsetFromFieldNumber = 3,
    kOutsetToFieldNumber = 4,
  };
  // required .TSD.BezierPathSourceArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::BezierPathSourceArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::BezierPathSourceArchive* release_super();
  ::TSD::BezierPathSourceArchive* mutable_super();
  void set_allocated_super(::TSD::BezierPathSourceArchive* super);
  private:
  const ::TSD::BezierPathSourceArchive& _internal_super() const;
  ::TSD::BezierPathSourceArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::BezierPathSourceArchive* super);
  ::TSD::BezierPathSourceArchive* unsafe_arena_release_super();

  // optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType type() const;
  void set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value);
  private:
  ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType _internal_type() const;
  void _internal_set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value);
  public:

  // optional float outset_from = 3;
  bool has_outset_from() const;
  private:
  bool _internal_has_outset_from() const;
  public:
  void clear_outset_from();
  float outset_from() const;
  void set_outset_from(float value);
  private:
  float _internal_outset_from() const;
  void _internal_set_outset_from(float value);
  public:

  // optional float outset_to = 4;
  bool has_outset_to() const;
  private:
  bool _internal_has_outset_to() const;
  public:
  void clear_outset_to();
  float outset_to() const;
  void set_outset_to(float value);
  private:
  float _internal_outset_to() const;
  void _internal_set_outset_to(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLinePathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::BezierPathSourceArchive* super_;
    int type_;
    float outset_from_;
    float outset_to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive.Node) */ {
 public:
  inline EditableBezierPathSourceArchive_Node() : EditableBezierPathSourceArchive_Node(nullptr) {}
  ~EditableBezierPathSourceArchive_Node() override;
  explicit PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive_Node(const EditableBezierPathSourceArchive_Node& from);
  EditableBezierPathSourceArchive_Node(EditableBezierPathSourceArchive_Node&& from) noexcept
    : EditableBezierPathSourceArchive_Node() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive_Node& operator=(const EditableBezierPathSourceArchive_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive_Node& operator=(EditableBezierPathSourceArchive_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive_Node* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive_Node*>(
               &_EditableBezierPathSourceArchive_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EditableBezierPathSourceArchive_Node& a, EditableBezierPathSourceArchive_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditableBezierPathSourceArchive_Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditableBezierPathSourceArchive_Node& from) {
    EditableBezierPathSourceArchive_Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive.Node";
  }
  protected:
  explicit EditableBezierPathSourceArchive_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInControlPointFieldNumber = 1,
    kNodePointFieldNumber = 2,
    kOutControlPointFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // required .TSP.Point inControlPoint = 1;
  bool has_incontrolpoint() const;
  private:
  bool _internal_has_incontrolpoint() const;
  public:
  void clear_incontrolpoint();
  const ::TSP::Point& incontrolpoint() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_incontrolpoint();
  ::TSP::Point* mutable_incontrolpoint();
  void set_allocated_incontrolpoint(::TSP::Point* incontrolpoint);
  private:
  const ::TSP::Point& _internal_incontrolpoint() const;
  ::TSP::Point* _internal_mutable_incontrolpoint();
  public:
  void unsafe_arena_set_allocated_incontrolpoint(
      ::TSP::Point* incontrolpoint);
  ::TSP::Point* unsafe_arena_release_incontrolpoint();

  // required .TSP.Point nodePoint = 2;
  bool has_nodepoint() const;
  private:
  bool _internal_has_nodepoint() const;
  public:
  void clear_nodepoint();
  const ::TSP::Point& nodepoint() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_nodepoint();
  ::TSP::Point* mutable_nodepoint();
  void set_allocated_nodepoint(::TSP::Point* nodepoint);
  private:
  const ::TSP::Point& _internal_nodepoint() const;
  ::TSP::Point* _internal_mutable_nodepoint();
  public:
  void unsafe_arena_set_allocated_nodepoint(
      ::TSP::Point* nodepoint);
  ::TSP::Point* unsafe_arena_release_nodepoint();

  // required .TSP.Point outControlPoint = 3;
  bool has_outcontrolpoint() const;
  private:
  bool _internal_has_outcontrolpoint() const;
  public:
  void clear_outcontrolpoint();
  const ::TSP::Point& outcontrolpoint() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_outcontrolpoint();
  ::TSP::Point* mutable_outcontrolpoint();
  void set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint);
  private:
  const ::TSP::Point& _internal_outcontrolpoint() const;
  ::TSP::Point* _internal_mutable_outcontrolpoint();
  public:
  void unsafe_arena_set_allocated_outcontrolpoint(
      ::TSP::Point* outcontrolpoint);
  ::TSP::Point* unsafe_arena_release_outcontrolpoint();

  // required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::EditableBezierPathSourceArchive_NodeType type() const;
  void set_type(::TSD::EditableBezierPathSourceArchive_NodeType value);
  private:
  ::TSD::EditableBezierPathSourceArchive_NodeType _internal_type() const;
  void _internal_set_type(::TSD::EditableBezierPathSourceArchive_NodeType value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Node)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Point* incontrolpoint_;
    ::TSP::Point* nodepoint_;
    ::TSP::Point* outcontrolpoint_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive_Subpath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive.Subpath) */ {
 public:
  inline EditableBezierPathSourceArchive_Subpath() : EditableBezierPathSourceArchive_Subpath(nullptr) {}
  ~EditableBezierPathSourceArchive_Subpath() override;
  explicit PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive_Subpath(const EditableBezierPathSourceArchive_Subpath& from);
  EditableBezierPathSourceArchive_Subpath(EditableBezierPathSourceArchive_Subpath&& from) noexcept
    : EditableBezierPathSourceArchive_Subpath() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive_Subpath& operator=(const EditableBezierPathSourceArchive_Subpath& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive_Subpath& operator=(EditableBezierPathSourceArchive_Subpath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive_Subpath& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive_Subpath* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive_Subpath*>(
               &_EditableBezierPathSourceArchive_Subpath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EditableBezierPathSourceArchive_Subpath& a, EditableBezierPathSourceArchive_Subpath& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive_Subpath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive_Subpath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive_Subpath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive_Subpath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditableBezierPathSourceArchive_Subpath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditableBezierPathSourceArchive_Subpath& from) {
    EditableBezierPathSourceArchive_Subpath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive_Subpath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive.Subpath";
  }
  protected:
  explicit EditableBezierPathSourceArchive_Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kClosedFieldNumber = 2,
  };
  // repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::TSD::EditableBezierPathSourceArchive_Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
      mutable_nodes();
  private:
  const ::TSD::EditableBezierPathSourceArchive_Node& _internal_nodes(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Node* _internal_add_nodes();
  public:
  const ::TSD::EditableBezierPathSourceArchive_Node& nodes(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
      nodes() const;

  // required bool closed = 2;
  bool has_closed() const;
  private:
  bool _internal_has_closed() const;
  public:
  void clear_closed();
  bool closed() const;
  void set_closed(bool value);
  private:
  bool _internal_closed() const;
  void _internal_set_closed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive.Subpath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node > nodes_;
    bool closed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class EditableBezierPathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.EditableBezierPathSourceArchive) */ {
 public:
  inline EditableBezierPathSourceArchive() : EditableBezierPathSourceArchive(nullptr) {}
  ~EditableBezierPathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditableBezierPathSourceArchive(const EditableBezierPathSourceArchive& from);
  EditableBezierPathSourceArchive(EditableBezierPathSourceArchive&& from) noexcept
    : EditableBezierPathSourceArchive() {
    *this = ::std::move(from);
  }

  inline EditableBezierPathSourceArchive& operator=(const EditableBezierPathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditableBezierPathSourceArchive& operator=(EditableBezierPathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditableBezierPathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditableBezierPathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const EditableBezierPathSourceArchive*>(
               &_EditableBezierPathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EditableBezierPathSourceArchive& a, EditableBezierPathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EditableBezierPathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditableBezierPathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditableBezierPathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditableBezierPathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditableBezierPathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditableBezierPathSourceArchive& from) {
    EditableBezierPathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditableBezierPathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.EditableBezierPathSourceArchive";
  }
  protected:
  explicit EditableBezierPathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EditableBezierPathSourceArchive_Node Node;
  typedef EditableBezierPathSourceArchive_Subpath Subpath;

  typedef EditableBezierPathSourceArchive_NodeType NodeType;
  static constexpr NodeType sharp =
    EditableBezierPathSourceArchive_NodeType_sharp;
  static constexpr NodeType bezier =
    EditableBezierPathSourceArchive_NodeType_bezier;
  static constexpr NodeType smooth =
    EditableBezierPathSourceArchive_NodeType_smooth;
  static inline bool NodeType_IsValid(int value) {
    return EditableBezierPathSourceArchive_NodeType_IsValid(value);
  }
  static constexpr NodeType NodeType_MIN =
    EditableBezierPathSourceArchive_NodeType_NodeType_MIN;
  static constexpr NodeType NodeType_MAX =
    EditableBezierPathSourceArchive_NodeType_NodeType_MAX;
  static constexpr int NodeType_ARRAYSIZE =
    EditableBezierPathSourceArchive_NodeType_NodeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NodeType_descriptor() {
    return EditableBezierPathSourceArchive_NodeType_descriptor();
  }
  template<typename T>
  static inline const std::string& NodeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NodeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NodeType_Name.");
    return EditableBezierPathSourceArchive_NodeType_Name(enum_t_value);
  }
  static inline bool NodeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NodeType* value) {
    return EditableBezierPathSourceArchive_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubpathsFieldNumber = 1,
    kNaturalSizeFieldNumber = 2,
  };
  // repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
  int subpaths_size() const;
  private:
  int _internal_subpaths_size() const;
  public:
  void clear_subpaths();
  ::TSD::EditableBezierPathSourceArchive_Subpath* mutable_subpaths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
      mutable_subpaths();
  private:
  const ::TSD::EditableBezierPathSourceArchive_Subpath& _internal_subpaths(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Subpath* _internal_add_subpaths();
  public:
  const ::TSD::EditableBezierPathSourceArchive_Subpath& subpaths(int index) const;
  ::TSD::EditableBezierPathSourceArchive_Subpath* add_subpaths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
      subpaths() const;

  // optional .TSP.Size naturalSize = 2;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // @@protoc_insertion_point(class_scope:TSD.EditableBezierPathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath > subpaths_;
    ::TSP::Size* naturalsize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PathSourceArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PathSourceArchive) */ {
 public:
  inline PathSourceArchive() : PathSourceArchive(nullptr) {}
  ~PathSourceArchive() override;
  explicit PROTOBUF_CONSTEXPR PathSourceArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathSourceArchive(const PathSourceArchive& from);
  PathSourceArchive(PathSourceArchive&& from) noexcept
    : PathSourceArchive() {
    *this = ::std::move(from);
  }

  inline PathSourceArchive& operator=(const PathSourceArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathSourceArchive& operator=(PathSourceArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathSourceArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathSourceArchive* internal_default_instance() {
    return reinterpret_cast<const PathSourceArchive*>(
               &_PathSourceArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PathSourceArchive& a, PathSourceArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PathSourceArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathSourceArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathSourceArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathSourceArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathSourceArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathSourceArchive& from) {
    PathSourceArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathSourceArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PathSourceArchive";
  }
  protected:
  explicit PathSourceArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointPathSourceFieldNumber = 3,
    kScalarPathSourceFieldNumber = 4,
    kBezierPathSourceFieldNumber = 5,
    kCalloutPathSourceFieldNumber = 6,
    kConnectionLinePathSourceFieldNumber = 7,
    kEditableBezierPathSourceFieldNumber = 8,
    kHorizontalFlipFieldNumber = 1,
    kVerticalFlipFieldNumber = 2,
  };
  // optional .TSD.PointPathSourceArchive point_path_source = 3;
  bool has_point_path_source() const;
  private:
  bool _internal_has_point_path_source() const;
  public:
  void clear_point_path_source();
  const ::TSD::PointPathSourceArchive& point_path_source() const;
  PROTOBUF_NODISCARD ::TSD::PointPathSourceArchive* release_point_path_source();
  ::TSD::PointPathSourceArchive* mutable_point_path_source();
  void set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source);
  private:
  const ::TSD::PointPathSourceArchive& _internal_point_path_source() const;
  ::TSD::PointPathSourceArchive* _internal_mutable_point_path_source();
  public:
  void unsafe_arena_set_allocated_point_path_source(
      ::TSD::PointPathSourceArchive* point_path_source);
  ::TSD::PointPathSourceArchive* unsafe_arena_release_point_path_source();

  // optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
  bool has_scalar_path_source() const;
  private:
  bool _internal_has_scalar_path_source() const;
  public:
  void clear_scalar_path_source();
  const ::TSD::ScalarPathSourceArchive& scalar_path_source() const;
  PROTOBUF_NODISCARD ::TSD::ScalarPathSourceArchive* release_scalar_path_source();
  ::TSD::ScalarPathSourceArchive* mutable_scalar_path_source();
  void set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source);
  private:
  const ::TSD::ScalarPathSourceArchive& _internal_scalar_path_source() const;
  ::TSD::ScalarPathSourceArchive* _internal_mutable_scalar_path_source();
  public:
  void unsafe_arena_set_allocated_scalar_path_source(
      ::TSD::ScalarPathSourceArchive* scalar_path_source);
  ::TSD::ScalarPathSourceArchive* unsafe_arena_release_scalar_path_source();

  // optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
  bool has_bezier_path_source() const;
  private:
  bool _internal_has_bezier_path_source() const;
  public:
  void clear_bezier_path_source();
  const ::TSD::BezierPathSourceArchive& bezier_path_source() const;
  PROTOBUF_NODISCARD ::TSD::BezierPathSourceArchive* release_bezier_path_source();
  ::TSD::BezierPathSourceArchive* mutable_bezier_path_source();
  void set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source);
  private:
  const ::TSD::BezierPathSourceArchive& _internal_bezier_path_source() const;
  ::TSD::BezierPathSourceArchive* _internal_mutable_bezier_path_source();
  public:
  void unsafe_arena_set_allocated_bezier_path_source(
      ::TSD::BezierPathSourceArchive* bezier_path_source);
  ::TSD::BezierPathSourceArchive* unsafe_arena_release_bezier_path_source();

  // optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
  bool has_callout_path_source() const;
  private:
  bool _internal_has_callout_path_source() const;
  public:
  void clear_callout_path_source();
  const ::TSD::CalloutPathSourceArchive& callout_path_source() const;
  PROTOBUF_NODISCARD ::TSD::CalloutPathSourceArchive* release_callout_path_source();
  ::TSD::CalloutPathSourceArchive* mutable_callout_path_source();
  void set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source);
  private:
  const ::TSD::CalloutPathSourceArchive& _internal_callout_path_source() const;
  ::TSD::CalloutPathSourceArchive* _internal_mutable_callout_path_source();
  public:
  void unsafe_arena_set_allocated_callout_path_source(
      ::TSD::CalloutPathSourceArchive* callout_path_source);
  ::TSD::CalloutPathSourceArchive* unsafe_arena_release_callout_path_source();

  // optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
  bool has_connection_line_path_source() const;
  private:
  bool _internal_has_connection_line_path_source() const;
  public:
  void clear_connection_line_path_source();
  const ::TSD::ConnectionLinePathSourceArchive& connection_line_path_source() const;
  PROTOBUF_NODISCARD ::TSD::ConnectionLinePathSourceArchive* release_connection_line_path_source();
  ::TSD::ConnectionLinePathSourceArchive* mutable_connection_line_path_source();
  void set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source);
  private:
  const ::TSD::ConnectionLinePathSourceArchive& _internal_connection_line_path_source() const;
  ::TSD::ConnectionLinePathSourceArchive* _internal_mutable_connection_line_path_source();
  public:
  void unsafe_arena_set_allocated_connection_line_path_source(
      ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source);
  ::TSD::ConnectionLinePathSourceArchive* unsafe_arena_release_connection_line_path_source();

  // optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
  bool has_editable_bezier_path_source() const;
  private:
  bool _internal_has_editable_bezier_path_source() const;
  public:
  void clear_editable_bezier_path_source();
  const ::TSD::EditableBezierPathSourceArchive& editable_bezier_path_source() const;
  PROTOBUF_NODISCARD ::TSD::EditableBezierPathSourceArchive* release_editable_bezier_path_source();
  ::TSD::EditableBezierPathSourceArchive* mutable_editable_bezier_path_source();
  void set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source);
  private:
  const ::TSD::EditableBezierPathSourceArchive& _internal_editable_bezier_path_source() const;
  ::TSD::EditableBezierPathSourceArchive* _internal_mutable_editable_bezier_path_source();
  public:
  void unsafe_arena_set_allocated_editable_bezier_path_source(
      ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source);
  ::TSD::EditableBezierPathSourceArchive* unsafe_arena_release_editable_bezier_path_source();

  // optional bool horizontalFlip = 1;
  bool has_horizontalflip() const;
  private:
  bool _internal_has_horizontalflip() const;
  public:
  void clear_horizontalflip();
  bool horizontalflip() const;
  void set_horizontalflip(bool value);
  private:
  bool _internal_horizontalflip() const;
  void _internal_set_horizontalflip(bool value);
  public:

  // optional bool verticalFlip = 2;
  bool has_verticalflip() const;
  private:
  bool _internal_has_verticalflip() const;
  public:
  void clear_verticalflip();
  bool verticalflip() const;
  void set_verticalflip(bool value);
  private:
  bool _internal_verticalflip() const;
  void _internal_set_verticalflip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.PathSourceArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::PointPathSourceArchive* point_path_source_;
    ::TSD::ScalarPathSourceArchive* scalar_path_source_;
    ::TSD::BezierPathSourceArchive* bezier_path_source_;
    ::TSD::CalloutPathSourceArchive* callout_path_source_;
    ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source_;
    ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source_;
    bool horizontalflip_;
    bool verticalflip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class AngleGradientArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.AngleGradientArchive) */ {
 public:
  inline AngleGradientArchive() : AngleGradientArchive(nullptr) {}
  ~AngleGradientArchive() override;
  explicit PROTOBUF_CONSTEXPR AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AngleGradientArchive(const AngleGradientArchive& from);
  AngleGradientArchive(AngleGradientArchive&& from) noexcept
    : AngleGradientArchive() {
    *this = ::std::move(from);
  }

  inline AngleGradientArchive& operator=(const AngleGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AngleGradientArchive& operator=(AngleGradientArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AngleGradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AngleGradientArchive* internal_default_instance() {
    return reinterpret_cast<const AngleGradientArchive*>(
               &_AngleGradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AngleGradientArchive& a, AngleGradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AngleGradientArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AngleGradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AngleGradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AngleGradientArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AngleGradientArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AngleGradientArchive& from) {
    AngleGradientArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AngleGradientArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.AngleGradientArchive";
  }
  protected:
  explicit AngleGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradientangleFieldNumber = 2,
  };
  // optional float gradientangle = 2;
  bool has_gradientangle() const;
  private:
  bool _internal_has_gradientangle() const;
  public:
  void clear_gradientangle();
  float gradientangle() const;
  void set_gradientangle(float value);
  private:
  float _internal_gradientangle() const;
  void _internal_set_gradientangle(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.AngleGradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float gradientangle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class TransformGradientArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.TransformGradientArchive) */ {
 public:
  inline TransformGradientArchive() : TransformGradientArchive(nullptr) {}
  ~TransformGradientArchive() override;
  explicit PROTOBUF_CONSTEXPR TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransformGradientArchive(const TransformGradientArchive& from);
  TransformGradientArchive(TransformGradientArchive&& from) noexcept
    : TransformGradientArchive() {
    *this = ::std::move(from);
  }

  inline TransformGradientArchive& operator=(const TransformGradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformGradientArchive& operator=(TransformGradientArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransformGradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransformGradientArchive* internal_default_instance() {
    return reinterpret_cast<const TransformGradientArchive*>(
               &_TransformGradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransformGradientArchive& a, TransformGradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformGradientArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransformGradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransformGradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransformGradientArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransformGradientArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransformGradientArchive& from) {
    TransformGradientArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformGradientArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.TransformGradientArchive";
  }
  protected:
  explicit TransformGradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
    kBaseNaturalSizeFieldNumber = 3,
  };
  // optional .TSP.Point start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::TSP::Point& start() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_start();
  ::TSP::Point* mutable_start();
  void set_allocated_start(::TSP::Point* start);
  private:
  const ::TSP::Point& _internal_start() const;
  ::TSP::Point* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::TSP::Point* start);
  ::TSP::Point* unsafe_arena_release_start();

  // optional .TSP.Point end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::TSP::Point& end() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_end();
  ::TSP::Point* mutable_end();
  void set_allocated_end(::TSP::Point* end);
  private:
  const ::TSP::Point& _internal_end() const;
  ::TSP::Point* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::TSP::Point* end);
  ::TSP::Point* unsafe_arena_release_end();

  // optional .TSP.Size baseNaturalSize = 3;
  bool has_basenaturalsize() const;
  private:
  bool _internal_has_basenaturalsize() const;
  public:
  void clear_basenaturalsize();
  const ::TSP::Size& basenaturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_basenaturalsize();
  ::TSP::Size* mutable_basenaturalsize();
  void set_allocated_basenaturalsize(::TSP::Size* basenaturalsize);
  private:
  const ::TSP::Size& _internal_basenaturalsize() const;
  ::TSP::Size* _internal_mutable_basenaturalsize();
  public:
  void unsafe_arena_set_allocated_basenaturalsize(
      ::TSP::Size* basenaturalsize);
  ::TSP::Size* unsafe_arena_release_basenaturalsize();

  // @@protoc_insertion_point(class_scope:TSD.TransformGradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Point* start_;
    ::TSP::Point* end_;
    ::TSP::Size* basenaturalsize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GradientArchive_GradientStop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GradientArchive.GradientStop) */ {
 public:
  inline GradientArchive_GradientStop() : GradientArchive_GradientStop(nullptr) {}
  ~GradientArchive_GradientStop() override;
  explicit PROTOBUF_CONSTEXPR GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GradientArchive_GradientStop(const GradientArchive_GradientStop& from);
  GradientArchive_GradientStop(GradientArchive_GradientStop&& from) noexcept
    : GradientArchive_GradientStop() {
    *this = ::std::move(from);
  }

  inline GradientArchive_GradientStop& operator=(const GradientArchive_GradientStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradientArchive_GradientStop& operator=(GradientArchive_GradientStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GradientArchive_GradientStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const GradientArchive_GradientStop* internal_default_instance() {
    return reinterpret_cast<const GradientArchive_GradientStop*>(
               &_GradientArchive_GradientStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GradientArchive_GradientStop& a, GradientArchive_GradientStop& b) {
    a.Swap(&b);
  }
  inline void Swap(GradientArchive_GradientStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradientArchive_GradientStop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GradientArchive_GradientStop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GradientArchive_GradientStop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GradientArchive_GradientStop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GradientArchive_GradientStop& from) {
    GradientArchive_GradientStop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradientArchive_GradientStop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GradientArchive.GradientStop";
  }
  protected:
  explicit GradientArchive_GradientStop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kFractionFieldNumber = 2,
    kInflectionFieldNumber = 3,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional float fraction = 2;
  bool has_fraction() const;
  private:
  bool _internal_has_fraction() const;
  public:
  void clear_fraction();
  float fraction() const;
  void set_fraction(float value);
  private:
  float _internal_fraction() const;
  void _internal_set_fraction(float value);
  public:

  // optional float inflection = 3;
  bool has_inflection() const;
  private:
  bool _internal_has_inflection() const;
  public:
  void clear_inflection();
  float inflection() const;
  void set_inflection(float value);
  private:
  float _internal_inflection() const;
  void _internal_set_inflection(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive.GradientStop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Color* color_;
    float fraction_;
    float inflection_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GradientArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GradientArchive) */ {
 public:
  inline GradientArchive() : GradientArchive(nullptr) {}
  ~GradientArchive() override;
  explicit PROTOBUF_CONSTEXPR GradientArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GradientArchive(const GradientArchive& from);
  GradientArchive(GradientArchive&& from) noexcept
    : GradientArchive() {
    *this = ::std::move(from);
  }

  inline GradientArchive& operator=(const GradientArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradientArchive& operator=(GradientArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GradientArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GradientArchive* internal_default_instance() {
    return reinterpret_cast<const GradientArchive*>(
               &_GradientArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GradientArchive& a, GradientArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GradientArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradientArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GradientArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GradientArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GradientArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GradientArchive& from) {
    GradientArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradientArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GradientArchive";
  }
  protected:
  explicit GradientArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GradientArchive_GradientStop GradientStop;

  typedef GradientArchive_GradientType GradientType;
  static constexpr GradientType Linear =
    GradientArchive_GradientType_Linear;
  static constexpr GradientType Radial =
    GradientArchive_GradientType_Radial;
  static inline bool GradientType_IsValid(int value) {
    return GradientArchive_GradientType_IsValid(value);
  }
  static constexpr GradientType GradientType_MIN =
    GradientArchive_GradientType_GradientType_MIN;
  static constexpr GradientType GradientType_MAX =
    GradientArchive_GradientType_GradientType_MAX;
  static constexpr int GradientType_ARRAYSIZE =
    GradientArchive_GradientType_GradientType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GradientType_descriptor() {
    return GradientArchive_GradientType_descriptor();
  }
  template<typename T>
  static inline const std::string& GradientType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GradientType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GradientType_Name.");
    return GradientArchive_GradientType_Name(enum_t_value);
  }
  static inline bool GradientType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GradientType* value) {
    return GradientArchive_GradientType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStopsFieldNumber = 2,
    kAnglegradientFieldNumber = 5,
    kTransformgradientFieldNumber = 6,
    kTypeFieldNumber = 1,
    kOpacityFieldNumber = 3,
    kAdvancedGradientFieldNumber = 4,
  };
  // repeated .TSD.GradientArchive.GradientStop stops = 2;
  int stops_size() const;
  private:
  int _internal_stops_size() const;
  public:
  void clear_stops();
  ::TSD::GradientArchive_GradientStop* mutable_stops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
      mutable_stops();
  private:
  const ::TSD::GradientArchive_GradientStop& _internal_stops(int index) const;
  ::TSD::GradientArchive_GradientStop* _internal_add_stops();
  public:
  const ::TSD::GradientArchive_GradientStop& stops(int index) const;
  ::TSD::GradientArchive_GradientStop* add_stops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
      stops() const;

  // optional .TSD.AngleGradientArchive anglegradient = 5;
  bool has_anglegradient() const;
  private:
  bool _internal_has_anglegradient() const;
  public:
  void clear_anglegradient();
  const ::TSD::AngleGradientArchive& anglegradient() const;
  PROTOBUF_NODISCARD ::TSD::AngleGradientArchive* release_anglegradient();
  ::TSD::AngleGradientArchive* mutable_anglegradient();
  void set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient);
  private:
  const ::TSD::AngleGradientArchive& _internal_anglegradient() const;
  ::TSD::AngleGradientArchive* _internal_mutable_anglegradient();
  public:
  void unsafe_arena_set_allocated_anglegradient(
      ::TSD::AngleGradientArchive* anglegradient);
  ::TSD::AngleGradientArchive* unsafe_arena_release_anglegradient();

  // optional .TSD.TransformGradientArchive transformgradient = 6;
  bool has_transformgradient() const;
  private:
  bool _internal_has_transformgradient() const;
  public:
  void clear_transformgradient();
  const ::TSD::TransformGradientArchive& transformgradient() const;
  PROTOBUF_NODISCARD ::TSD::TransformGradientArchive* release_transformgradient();
  ::TSD::TransformGradientArchive* mutable_transformgradient();
  void set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient);
  private:
  const ::TSD::TransformGradientArchive& _internal_transformgradient() const;
  ::TSD::TransformGradientArchive* _internal_mutable_transformgradient();
  public:
  void unsafe_arena_set_allocated_transformgradient(
      ::TSD::TransformGradientArchive* transformgradient);
  ::TSD::TransformGradientArchive* unsafe_arena_release_transformgradient();

  // optional .TSD.GradientArchive.GradientType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::GradientArchive_GradientType type() const;
  void set_type(::TSD::GradientArchive_GradientType value);
  private:
  ::TSD::GradientArchive_GradientType _internal_type() const;
  void _internal_set_type(::TSD::GradientArchive_GradientType value);
  public:

  // optional float opacity = 3;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // optional bool advancedGradient = 4;
  bool has_advancedgradient() const;
  private:
  bool _internal_has_advancedgradient() const;
  public:
  void clear_advancedgradient();
  bool advancedgradient() const;
  void set_advancedgradient(bool value);
  private:
  bool _internal_advancedgradient() const;
  void _internal_set_advancedgradient(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GradientArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop > stops_;
    ::TSD::AngleGradientArchive* anglegradient_;
    ::TSD::TransformGradientArchive* transformgradient_;
    int type_;
    float opacity_;
    bool advancedgradient_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageFillArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageFillArchive) */ {
 public:
  inline ImageFillArchive() : ImageFillArchive(nullptr) {}
  ~ImageFillArchive() override;
  explicit PROTOBUF_CONSTEXPR ImageFillArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageFillArchive(const ImageFillArchive& from);
  ImageFillArchive(ImageFillArchive&& from) noexcept
    : ImageFillArchive() {
    *this = ::std::move(from);
  }

  inline ImageFillArchive& operator=(const ImageFillArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageFillArchive& operator=(ImageFillArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageFillArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageFillArchive* internal_default_instance() {
    return reinterpret_cast<const ImageFillArchive*>(
               &_ImageFillArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImageFillArchive& a, ImageFillArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageFillArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageFillArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageFillArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageFillArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageFillArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageFillArchive& from) {
    ImageFillArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageFillArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageFillArchive";
  }
  protected:
  explicit ImageFillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageFillArchive_ImageFillTechnique ImageFillTechnique;
  static constexpr ImageFillTechnique NaturalSize =
    ImageFillArchive_ImageFillTechnique_NaturalSize;
  static constexpr ImageFillTechnique Stretch =
    ImageFillArchive_ImageFillTechnique_Stretch;
  static constexpr ImageFillTechnique Tile =
    ImageFillArchive_ImageFillTechnique_Tile;
  static constexpr ImageFillTechnique ScaleToFill =
    ImageFillArchive_ImageFillTechnique_ScaleToFill;
  static constexpr ImageFillTechnique ScaleToFit =
    ImageFillArchive_ImageFillTechnique_ScaleToFit;
  static inline bool ImageFillTechnique_IsValid(int value) {
    return ImageFillArchive_ImageFillTechnique_IsValid(value);
  }
  static constexpr ImageFillTechnique ImageFillTechnique_MIN =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MIN;
  static constexpr ImageFillTechnique ImageFillTechnique_MAX =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_MAX;
  static constexpr int ImageFillTechnique_ARRAYSIZE =
    ImageFillArchive_ImageFillTechnique_ImageFillTechnique_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageFillTechnique_descriptor() {
    return ImageFillArchive_ImageFillTechnique_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageFillTechnique_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageFillTechnique>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageFillTechnique_Name.");
    return ImageFillArchive_ImageFillTechnique_Name(enum_t_value);
  }
  static inline bool ImageFillTechnique_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageFillTechnique* value) {
    return ImageFillArchive_ImageFillTechnique_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseImagedataFieldNumber = 1,
    kTintFieldNumber = 3,
    kFillsizeFieldNumber = 4,
    kDatabaseOriginalimagedataFieldNumber = 5,
    kImagedataFieldNumber = 6,
    kOriginalimagedataFieldNumber = 7,
    kTechniqueFieldNumber = 2,
    kInterpretsUntaggedImageDataAsGenericFieldNumber = 8,
  };
  // optional .TSP.Reference database_imagedata = 1;
  bool has_database_imagedata() const;
  private:
  bool _internal_has_database_imagedata() const;
  public:
  void clear_database_imagedata();
  const ::TSP::Reference& database_imagedata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_imagedata();
  ::TSP::Reference* mutable_database_imagedata();
  void set_allocated_database_imagedata(::TSP::Reference* database_imagedata);
  private:
  const ::TSP::Reference& _internal_database_imagedata() const;
  ::TSP::Reference* _internal_mutable_database_imagedata();
  public:
  void unsafe_arena_set_allocated_database_imagedata(
      ::TSP::Reference* database_imagedata);
  ::TSP::Reference* unsafe_arena_release_database_imagedata();

  // optional .TSP.Color tint = 3;
  bool has_tint() const;
  private:
  bool _internal_has_tint() const;
  public:
  void clear_tint();
  const ::TSP::Color& tint() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_tint();
  ::TSP::Color* mutable_tint();
  void set_allocated_tint(::TSP::Color* tint);
  private:
  const ::TSP::Color& _internal_tint() const;
  ::TSP::Color* _internal_mutable_tint();
  public:
  void unsafe_arena_set_allocated_tint(
      ::TSP::Color* tint);
  ::TSP::Color* unsafe_arena_release_tint();

  // optional .TSP.Size fillsize = 4;
  bool has_fillsize() const;
  private:
  bool _internal_has_fillsize() const;
  public:
  void clear_fillsize();
  const ::TSP::Size& fillsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_fillsize();
  ::TSP::Size* mutable_fillsize();
  void set_allocated_fillsize(::TSP::Size* fillsize);
  private:
  const ::TSP::Size& _internal_fillsize() const;
  ::TSP::Size* _internal_mutable_fillsize();
  public:
  void unsafe_arena_set_allocated_fillsize(
      ::TSP::Size* fillsize);
  ::TSP::Size* unsafe_arena_release_fillsize();

  // optional .TSP.Reference database_originalimagedata = 5;
  bool has_database_originalimagedata() const;
  private:
  bool _internal_has_database_originalimagedata() const;
  public:
  void clear_database_originalimagedata();
  const ::TSP::Reference& database_originalimagedata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_originalimagedata();
  ::TSP::Reference* mutable_database_originalimagedata();
  void set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata);
  private:
  const ::TSP::Reference& _internal_database_originalimagedata() const;
  ::TSP::Reference* _internal_mutable_database_originalimagedata();
  public:
  void unsafe_arena_set_allocated_database_originalimagedata(
      ::TSP::Reference* database_originalimagedata);
  ::TSP::Reference* unsafe_arena_release_database_originalimagedata();

  // optional .TSP.DataReference imagedata = 6;
  bool has_imagedata() const;
  private:
  bool _internal_has_imagedata() const;
  public:
  void clear_imagedata();
  const ::TSP::DataReference& imagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_imagedata();
  ::TSP::DataReference* mutable_imagedata();
  void set_allocated_imagedata(::TSP::DataReference* imagedata);
  private:
  const ::TSP::DataReference& _internal_imagedata() const;
  ::TSP::DataReference* _internal_mutable_imagedata();
  public:
  void unsafe_arena_set_allocated_imagedata(
      ::TSP::DataReference* imagedata);
  ::TSP::DataReference* unsafe_arena_release_imagedata();

  // optional .TSP.DataReference originalimagedata = 7;
  bool has_originalimagedata() const;
  private:
  bool _internal_has_originalimagedata() const;
  public:
  void clear_originalimagedata();
  const ::TSP::DataReference& originalimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_originalimagedata();
  ::TSP::DataReference* mutable_originalimagedata();
  void set_allocated_originalimagedata(::TSP::DataReference* originalimagedata);
  private:
  const ::TSP::DataReference& _internal_originalimagedata() const;
  ::TSP::DataReference* _internal_mutable_originalimagedata();
  public:
  void unsafe_arena_set_allocated_originalimagedata(
      ::TSP::DataReference* originalimagedata);
  ::TSP::DataReference* unsafe_arena_release_originalimagedata();

  // optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
  bool has_technique() const;
  private:
  bool _internal_has_technique() const;
  public:
  void clear_technique();
  ::TSD::ImageFillArchive_ImageFillTechnique technique() const;
  void set_technique(::TSD::ImageFillArchive_ImageFillTechnique value);
  private:
  ::TSD::ImageFillArchive_ImageFillTechnique _internal_technique() const;
  void _internal_set_technique(::TSD::ImageFillArchive_ImageFillTechnique value);
  public:

  // optional bool interpretsUntaggedImageDataAsGeneric = 8;
  bool has_interpretsuntaggedimagedataasgeneric() const;
  private:
  bool _internal_has_interpretsuntaggedimagedataasgeneric() const;
  public:
  void clear_interpretsuntaggedimagedataasgeneric();
  bool interpretsuntaggedimagedataasgeneric() const;
  void set_interpretsuntaggedimagedataasgeneric(bool value);
  private:
  bool _internal_interpretsuntaggedimagedataasgeneric() const;
  void _internal_set_interpretsuntaggedimagedataasgeneric(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ImageFillArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* database_imagedata_;
    ::TSP::Color* tint_;
    ::TSP::Size* fillsize_;
    ::TSP::Reference* database_originalimagedata_;
    ::TSP::DataReference* imagedata_;
    ::TSP::DataReference* originalimagedata_;
    int technique_;
    bool interpretsuntaggedimagedataasgeneric_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FillArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FillArchive) */ {
 public:
  inline FillArchive() : FillArchive(nullptr) {}
  ~FillArchive() override;
  explicit PROTOBUF_CONSTEXPR FillArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FillArchive(const FillArchive& from);
  FillArchive(FillArchive&& from) noexcept
    : FillArchive() {
    *this = ::std::move(from);
  }

  inline FillArchive& operator=(const FillArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillArchive& operator=(FillArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FillArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FillArchive* internal_default_instance() {
    return reinterpret_cast<const FillArchive*>(
               &_FillArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FillArchive& a, FillArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FillArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FillArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FillArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FillArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FillArchive& from) {
    FillArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FillArchive";
  }
  protected:
  explicit FillArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kGradientFieldNumber = 2,
    kImageFieldNumber = 3,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.GradientArchive gradient = 2;
  bool has_gradient() const;
  private:
  bool _internal_has_gradient() const;
  public:
  void clear_gradient();
  const ::TSD::GradientArchive& gradient() const;
  PROTOBUF_NODISCARD ::TSD::GradientArchive* release_gradient();
  ::TSD::GradientArchive* mutable_gradient();
  void set_allocated_gradient(::TSD::GradientArchive* gradient);
  private:
  const ::TSD::GradientArchive& _internal_gradient() const;
  ::TSD::GradientArchive* _internal_mutable_gradient();
  public:
  void unsafe_arena_set_allocated_gradient(
      ::TSD::GradientArchive* gradient);
  ::TSD::GradientArchive* unsafe_arena_release_gradient();

  // optional .TSD.ImageFillArchive image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::TSD::ImageFillArchive& image() const;
  PROTOBUF_NODISCARD ::TSD::ImageFillArchive* release_image();
  ::TSD::ImageFillArchive* mutable_image();
  void set_allocated_image(::TSD::ImageFillArchive* image);
  private:
  const ::TSD::ImageFillArchive& _internal_image() const;
  ::TSD::ImageFillArchive* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::TSD::ImageFillArchive* image);
  ::TSD::ImageFillArchive* unsafe_arena_release_image();


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FillArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSD.FillArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Color* color_;
    ::TSD::GradientArchive* gradient_;
    ::TSD::ImageFillArchive* image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class StrokePatternArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.StrokePatternArchive) */ {
 public:
  inline StrokePatternArchive() : StrokePatternArchive(nullptr) {}
  ~StrokePatternArchive() override;
  explicit PROTOBUF_CONSTEXPR StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrokePatternArchive(const StrokePatternArchive& from);
  StrokePatternArchive(StrokePatternArchive&& from) noexcept
    : StrokePatternArchive() {
    *this = ::std::move(from);
  }

  inline StrokePatternArchive& operator=(const StrokePatternArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokePatternArchive& operator=(StrokePatternArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokePatternArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokePatternArchive* internal_default_instance() {
    return reinterpret_cast<const StrokePatternArchive*>(
               &_StrokePatternArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StrokePatternArchive& a, StrokePatternArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokePatternArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokePatternArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrokePatternArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrokePatternArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrokePatternArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrokePatternArchive& from) {
    StrokePatternArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrokePatternArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.StrokePatternArchive";
  }
  protected:
  explicit StrokePatternArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StrokePatternArchive_StrokePatternType StrokePatternType;
  static constexpr StrokePatternType TSDPattern =
    StrokePatternArchive_StrokePatternType_TSDPattern;
  static constexpr StrokePatternType TSDSolidPattern =
    StrokePatternArchive_StrokePatternType_TSDSolidPattern;
  static constexpr StrokePatternType TSDEmptyPattern =
    StrokePatternArchive_StrokePatternType_TSDEmptyPattern;
  static inline bool StrokePatternType_IsValid(int value) {
    return StrokePatternArchive_StrokePatternType_IsValid(value);
  }
  static constexpr StrokePatternType StrokePatternType_MIN =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MIN;
  static constexpr StrokePatternType StrokePatternType_MAX =
    StrokePatternArchive_StrokePatternType_StrokePatternType_MAX;
  static constexpr int StrokePatternType_ARRAYSIZE =
    StrokePatternArchive_StrokePatternType_StrokePatternType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StrokePatternType_descriptor() {
    return StrokePatternArchive_StrokePatternType_descriptor();
  }
  template<typename T>
  static inline const std::string& StrokePatternType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StrokePatternType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StrokePatternType_Name.");
    return StrokePatternArchive_StrokePatternType_Name(enum_t_value);
  }
  static inline bool StrokePatternType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StrokePatternType* value) {
    return StrokePatternArchive_StrokePatternType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 4,
    kTypeFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // repeated float pattern = 4;
  int pattern_size() const;
  private:
  int _internal_pattern_size() const;
  public:
  void clear_pattern();
  private:
  float _internal_pattern(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_pattern() const;
  void _internal_add_pattern(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_pattern();
  public:
  float pattern(int index) const;
  void set_pattern(int index, float value);
  void add_pattern(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      pattern() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_pattern();

  // optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::StrokePatternArchive_StrokePatternType type() const;
  void set_type(::TSD::StrokePatternArchive_StrokePatternType value);
  private:
  ::TSD::StrokePatternArchive_StrokePatternType _internal_type() const;
  void _internal_set_type(::TSD::StrokePatternArchive_StrokePatternType value);
  public:

  // optional float phase = 2;
  bool has_phase() const;
  private:
  bool _internal_has_phase() const;
  public:
  void clear_phase();
  float phase() const;
  void set_phase(float value);
  private:
  float _internal_phase() const;
  void _internal_set_phase(float value);
  public:

  // optional uint32 count = 3;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.StrokePatternArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > pattern_;
    int type_;
    float phase_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class StrokeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.StrokeArchive) */ {
 public:
  inline StrokeArchive() : StrokeArchive(nullptr) {}
  ~StrokeArchive() override;
  explicit PROTOBUF_CONSTEXPR StrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StrokeArchive(const StrokeArchive& from);
  StrokeArchive(StrokeArchive&& from) noexcept
    : StrokeArchive() {
    *this = ::std::move(from);
  }

  inline StrokeArchive& operator=(const StrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrokeArchive& operator=(StrokeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StrokeArchive* internal_default_instance() {
    return reinterpret_cast<const StrokeArchive*>(
               &_StrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StrokeArchive& a, StrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StrokeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StrokeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StrokeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StrokeArchive& from) {
    StrokeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrokeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.StrokeArchive";
  }
  protected:
  explicit StrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StrokeArchive_LineCap LineCap;
  static constexpr LineCap ButtCap =
    StrokeArchive_LineCap_ButtCap;
  static constexpr LineCap RoundCap =
    StrokeArchive_LineCap_RoundCap;
  static constexpr LineCap SquareCap =
    StrokeArchive_LineCap_SquareCap;
  static inline bool LineCap_IsValid(int value) {
    return StrokeArchive_LineCap_IsValid(value);
  }
  static constexpr LineCap LineCap_MIN =
    StrokeArchive_LineCap_LineCap_MIN;
  static constexpr LineCap LineCap_MAX =
    StrokeArchive_LineCap_LineCap_MAX;
  static constexpr int LineCap_ARRAYSIZE =
    StrokeArchive_LineCap_LineCap_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LineCap_descriptor() {
    return StrokeArchive_LineCap_descriptor();
  }
  template<typename T>
  static inline const std::string& LineCap_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LineCap>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LineCap_Name.");
    return StrokeArchive_LineCap_Name(enum_t_value);
  }
  static inline bool LineCap_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LineCap* value) {
    return StrokeArchive_LineCap_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kPatternFieldNumber = 6,
    kSmartStrokeFieldNumber = 7,
    kFrameFieldNumber = 8,
    kPatternedStrokeFieldNumber = 9,
    kWidthFieldNumber = 2,
    kCapFieldNumber = 3,
    kJoinFieldNumber = 4,
    kMiterLimitFieldNumber = 5,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.StrokePatternArchive pattern = 6;
  bool has_pattern() const;
  private:
  bool _internal_has_pattern() const;
  public:
  void clear_pattern();
  const ::TSD::StrokePatternArchive& pattern() const;
  PROTOBUF_NODISCARD ::TSD::StrokePatternArchive* release_pattern();
  ::TSD::StrokePatternArchive* mutable_pattern();
  void set_allocated_pattern(::TSD::StrokePatternArchive* pattern);
  private:
  const ::TSD::StrokePatternArchive& _internal_pattern() const;
  ::TSD::StrokePatternArchive* _internal_mutable_pattern();
  public:
  void unsafe_arena_set_allocated_pattern(
      ::TSD::StrokePatternArchive* pattern);
  ::TSD::StrokePatternArchive* unsafe_arena_release_pattern();

  // optional .TSD.SmartStrokeArchive smartStroke = 7;
  bool has_smartstroke() const;
  private:
  bool _internal_has_smartstroke() const;
  public:
  void clear_smartstroke();
  const ::TSD::SmartStrokeArchive& smartstroke() const;
  PROTOBUF_NODISCARD ::TSD::SmartStrokeArchive* release_smartstroke();
  ::TSD::SmartStrokeArchive* mutable_smartstroke();
  void set_allocated_smartstroke(::TSD::SmartStrokeArchive* smartstroke);
  private:
  const ::TSD::SmartStrokeArchive& _internal_smartstroke() const;
  ::TSD::SmartStrokeArchive* _internal_mutable_smartstroke();
  public:
  void unsafe_arena_set_allocated_smartstroke(
      ::TSD::SmartStrokeArchive* smartstroke);
  ::TSD::SmartStrokeArchive* unsafe_arena_release_smartstroke();

  // optional .TSD.FrameArchive frame = 8;
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;
  public:
  void clear_frame();
  const ::TSD::FrameArchive& frame() const;
  PROTOBUF_NODISCARD ::TSD::FrameArchive* release_frame();
  ::TSD::FrameArchive* mutable_frame();
  void set_allocated_frame(::TSD::FrameArchive* frame);
  private:
  const ::TSD::FrameArchive& _internal_frame() const;
  ::TSD::FrameArchive* _internal_mutable_frame();
  public:
  void unsafe_arena_set_allocated_frame(
      ::TSD::FrameArchive* frame);
  ::TSD::FrameArchive* unsafe_arena_release_frame();

  // optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
  bool has_patterned_stroke() const;
  private:
  bool _internal_has_patterned_stroke() const;
  public:
  void clear_patterned_stroke();
  const ::TSD::PatternedStrokeArchive& patterned_stroke() const;
  PROTOBUF_NODISCARD ::TSD::PatternedStrokeArchive* release_patterned_stroke();
  ::TSD::PatternedStrokeArchive* mutable_patterned_stroke();
  void set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke);
  private:
  const ::TSD::PatternedStrokeArchive& _internal_patterned_stroke() const;
  ::TSD::PatternedStrokeArchive* _internal_mutable_patterned_stroke();
  public:
  void unsafe_arena_set_allocated_patterned_stroke(
      ::TSD::PatternedStrokeArchive* patterned_stroke);
  ::TSD::PatternedStrokeArchive* unsafe_arena_release_patterned_stroke();

  // optional float width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional .TSD.StrokeArchive.LineCap cap = 3;
  bool has_cap() const;
  private:
  bool _internal_has_cap() const;
  public:
  void clear_cap();
  ::TSD::StrokeArchive_LineCap cap() const;
  void set_cap(::TSD::StrokeArchive_LineCap value);
  private:
  ::TSD::StrokeArchive_LineCap _internal_cap() const;
  void _internal_set_cap(::TSD::StrokeArchive_LineCap value);
  public:

  // optional .TSD.LineJoin join = 4;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  ::TSD::LineJoin join() const;
  void set_join(::TSD::LineJoin value);
  private:
  ::TSD::LineJoin _internal_join() const;
  void _internal_set_join(::TSD::LineJoin value);
  public:

  // optional float miterLimit = 5;
  bool has_miterlimit() const;
  private:
  bool _internal_has_miterlimit() const;
  public:
  void clear_miterlimit();
  float miterlimit() const;
  void set_miterlimit(float value);
  private:
  float _internal_miterlimit() const;
  void _internal_set_miterlimit(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.StrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Color* color_;
    ::TSD::StrokePatternArchive* pattern_;
    ::TSD::SmartStrokeArchive* smartstroke_;
    ::TSD::FrameArchive* frame_;
    ::TSD::PatternedStrokeArchive* patterned_stroke_;
    float width_;
    int cap_;
    int join_;
    float miterlimit_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class SmartStrokeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.SmartStrokeArchive) */ {
 public:
  inline SmartStrokeArchive() : SmartStrokeArchive(nullptr) {}
  ~SmartStrokeArchive() override;
  explicit PROTOBUF_CONSTEXPR SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SmartStrokeArchive(const SmartStrokeArchive& from);
  SmartStrokeArchive(SmartStrokeArchive&& from) noexcept
    : SmartStrokeArchive() {
    *this = ::std::move(from);
  }

  inline SmartStrokeArchive& operator=(const SmartStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmartStrokeArchive& operator=(SmartStrokeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SmartStrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SmartStrokeArchive* internal_default_instance() {
    return reinterpret_cast<const SmartStrokeArchive*>(
               &_SmartStrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SmartStrokeArchive& a, SmartStrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SmartStrokeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SmartStrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SmartStrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SmartStrokeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SmartStrokeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SmartStrokeArchive& from) {
    SmartStrokeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmartStrokeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.SmartStrokeArchive";
  }
  protected:
  explicit SmartStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeNameFieldNumber = 2,
    kParameterValuesFieldNumber = 4,
    kRandomSeedFieldNumber = 3,
  };
  // optional string strokeName = 2;
  bool has_strokename() const;
  private:
  bool _internal_has_strokename() const;
  public:
  void clear_strokename();
  const std::string& strokename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strokename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strokename();
  PROTOBUF_NODISCARD std::string* release_strokename();
  void set_allocated_strokename(std::string* strokename);
  private:
  const std::string& _internal_strokename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strokename(const std::string& value);
  std::string* _internal_mutable_strokename();
  public:

  // optional .TSP.ReferenceDictionary parameterValues = 4;
  bool has_parametervalues() const;
  private:
  bool _internal_has_parametervalues() const;
  public:
  void clear_parametervalues();
  const ::TSP::ReferenceDictionary& parametervalues() const;
  PROTOBUF_NODISCARD ::TSP::ReferenceDictionary* release_parametervalues();
  ::TSP::ReferenceDictionary* mutable_parametervalues();
  void set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues);
  private:
  const ::TSP::ReferenceDictionary& _internal_parametervalues() const;
  ::TSP::ReferenceDictionary* _internal_mutable_parametervalues();
  public:
  void unsafe_arena_set_allocated_parametervalues(
      ::TSP::ReferenceDictionary* parametervalues);
  ::TSP::ReferenceDictionary* unsafe_arena_release_parametervalues();

  // optional int32 randomSeed = 3;
  bool has_randomseed() const;
  private:
  bool _internal_has_randomseed() const;
  public:
  void clear_randomseed();
  int32_t randomseed() const;
  void set_randomseed(int32_t value);
  private:
  int32_t _internal_randomseed() const;
  void _internal_set_randomseed(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.SmartStrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strokename_;
    ::TSP::ReferenceDictionary* parametervalues_;
    int32_t randomseed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class FrameArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.FrameArchive) */ {
 public:
  inline FrameArchive() : FrameArchive(nullptr) {}
  ~FrameArchive() override;
  explicit PROTOBUF_CONSTEXPR FrameArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameArchive(const FrameArchive& from);
  FrameArchive(FrameArchive&& from) noexcept
    : FrameArchive() {
    *this = ::std::move(from);
  }

  inline FrameArchive& operator=(const FrameArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameArchive& operator=(FrameArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameArchive* internal_default_instance() {
    return reinterpret_cast<const FrameArchive*>(
               &_FrameArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FrameArchive& a, FrameArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameArchive& from) {
    FrameArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.FrameArchive";
  }
  protected:
  explicit FrameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kAssetScaleFieldNumber = 3,
  };
  // optional string frameName = 2;
  bool has_framename() const;
  private:
  bool _internal_has_framename() const;
  public:
  void clear_framename();
  const std::string& framename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_framename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_framename();
  PROTOBUF_NODISCARD std::string* release_framename();
  void set_allocated_framename(std::string* framename);
  private:
  const std::string& _internal_framename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_framename(const std::string& value);
  std::string* _internal_mutable_framename();
  public:

  // optional float assetScale = 3;
  bool has_assetscale() const;
  private:
  bool _internal_has_assetscale() const;
  public:
  void clear_assetscale();
  float assetscale() const;
  void set_assetscale(float value);
  private:
  float _internal_assetscale() const;
  void _internal_set_assetscale(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.FrameArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr framename_;
    float assetscale_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class PatternedStrokeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.PatternedStrokeArchive) */ {
 public:
  inline PatternedStrokeArchive() : PatternedStrokeArchive(nullptr) {}
  ~PatternedStrokeArchive() override;
  explicit PROTOBUF_CONSTEXPR PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PatternedStrokeArchive(const PatternedStrokeArchive& from);
  PatternedStrokeArchive(PatternedStrokeArchive&& from) noexcept
    : PatternedStrokeArchive() {
    *this = ::std::move(from);
  }

  inline PatternedStrokeArchive& operator=(const PatternedStrokeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PatternedStrokeArchive& operator=(PatternedStrokeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PatternedStrokeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PatternedStrokeArchive* internal_default_instance() {
    return reinterpret_cast<const PatternedStrokeArchive*>(
               &_PatternedStrokeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PatternedStrokeArchive& a, PatternedStrokeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PatternedStrokeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PatternedStrokeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PatternedStrokeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PatternedStrokeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PatternedStrokeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PatternedStrokeArchive& from) {
    PatternedStrokeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PatternedStrokeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.PatternedStrokeArchive";
  }
  protected:
  explicit PatternedStrokeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternNameFieldNumber = 2,
  };
  // optional string pattern_name = 2;
  bool has_pattern_name() const;
  private:
  bool _internal_has_pattern_name() const;
  public:
  void clear_pattern_name();
  const std::string& pattern_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern_name();
  PROTOBUF_NODISCARD std::string* release_pattern_name();
  void set_allocated_pattern_name(std::string* pattern_name);
  private:
  const std::string& _internal_pattern_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern_name(const std::string& value);
  std::string* _internal_mutable_pattern_name();
  public:

  // @@protoc_insertion_point(class_scope:TSD.PatternedStrokeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class LineEndArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.LineEndArchive) */ {
 public:
  inline LineEndArchive() : LineEndArchive(nullptr) {}
  ~LineEndArchive() override;
  explicit PROTOBUF_CONSTEXPR LineEndArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LineEndArchive(const LineEndArchive& from);
  LineEndArchive(LineEndArchive&& from) noexcept
    : LineEndArchive() {
    *this = ::std::move(from);
  }

  inline LineEndArchive& operator=(const LineEndArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineEndArchive& operator=(LineEndArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LineEndArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LineEndArchive* internal_default_instance() {
    return reinterpret_cast<const LineEndArchive*>(
               &_LineEndArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LineEndArchive& a, LineEndArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(LineEndArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineEndArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LineEndArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LineEndArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LineEndArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LineEndArchive& from) {
    LineEndArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineEndArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.LineEndArchive";
  }
  protected:
  explicit LineEndArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 5,
    kPathFieldNumber = 1,
    kEndPointFieldNumber = 3,
    kLineJoinFieldNumber = 2,
    kIsFilledFieldNumber = 4,
  };
  // optional string identifier = 5;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .TSP.Path path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::TSP::Path& path() const;
  PROTOBUF_NODISCARD ::TSP::Path* release_path();
  ::TSP::Path* mutable_path();
  void set_allocated_path(::TSP::Path* path);
  private:
  const ::TSP::Path& _internal_path() const;
  ::TSP::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::TSP::Path* path);
  ::TSP::Path* unsafe_arena_release_path();

  // optional .TSP.Point end_point = 3;
  bool has_end_point() const;
  private:
  bool _internal_has_end_point() const;
  public:
  void clear_end_point();
  const ::TSP::Point& end_point() const;
  PROTOBUF_NODISCARD ::TSP::Point* release_end_point();
  ::TSP::Point* mutable_end_point();
  void set_allocated_end_point(::TSP::Point* end_point);
  private:
  const ::TSP::Point& _internal_end_point() const;
  ::TSP::Point* _internal_mutable_end_point();
  public:
  void unsafe_arena_set_allocated_end_point(
      ::TSP::Point* end_point);
  ::TSP::Point* unsafe_arena_release_end_point();

  // optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
  bool has_line_join() const;
  private:
  bool _internal_has_line_join() const;
  public:
  void clear_line_join();
  ::TSD::LineJoin line_join() const;
  void set_line_join(::TSD::LineJoin value);
  private:
  ::TSD::LineJoin _internal_line_join() const;
  void _internal_set_line_join(::TSD::LineJoin value);
  public:

  // optional bool is_filled = 4;
  bool has_is_filled() const;
  private:
  bool _internal_has_is_filled() const;
  public:
  void clear_is_filled();
  bool is_filled() const;
  void set_is_filled(bool value);
  private:
  bool _internal_is_filled() const;
  void _internal_set_is_filled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.LineEndArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
    ::TSP::Path* path_;
    ::TSP::Point* end_point_;
    int line_join_;
    bool is_filled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShadowArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShadowArchive) */ {
 public:
  inline ShadowArchive() : ShadowArchive(nullptr) {}
  ~ShadowArchive() override;
  explicit PROTOBUF_CONSTEXPR ShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShadowArchive(const ShadowArchive& from);
  ShadowArchive(ShadowArchive&& from) noexcept
    : ShadowArchive() {
    *this = ::std::move(from);
  }

  inline ShadowArchive& operator=(const ShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShadowArchive& operator=(ShadowArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShadowArchive* internal_default_instance() {
    return reinterpret_cast<const ShadowArchive*>(
               &_ShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ShadowArchive& a, ShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShadowArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShadowArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShadowArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShadowArchive& from) {
    ShadowArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShadowArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShadowArchive";
  }
  protected:
  explicit ShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShadowArchive_ShadowType ShadowType;
  static constexpr ShadowType TSDDropShadow =
    ShadowArchive_ShadowType_TSDDropShadow;
  static constexpr ShadowType TSDContactShadow =
    ShadowArchive_ShadowType_TSDContactShadow;
  static constexpr ShadowType TSDCurvedShadow =
    ShadowArchive_ShadowType_TSDCurvedShadow;
  static inline bool ShadowType_IsValid(int value) {
    return ShadowArchive_ShadowType_IsValid(value);
  }
  static constexpr ShadowType ShadowType_MIN =
    ShadowArchive_ShadowType_ShadowType_MIN;
  static constexpr ShadowType ShadowType_MAX =
    ShadowArchive_ShadowType_ShadowType_MAX;
  static constexpr int ShadowType_ARRAYSIZE =
    ShadowArchive_ShadowType_ShadowType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShadowType_descriptor() {
    return ShadowArchive_ShadowType_descriptor();
  }
  template<typename T>
  static inline const std::string& ShadowType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShadowType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShadowType_Name.");
    return ShadowArchive_ShadowType_Name(enum_t_value);
  }
  static inline bool ShadowType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShadowType* value) {
    return ShadowArchive_ShadowType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kDropShadowFieldNumber = 8,
    kContactShadowFieldNumber = 9,
    kCurvedShadowFieldNumber = 10,
    kTypeFieldNumber = 7,
    kIsEnabledFieldNumber = 6,
    kAngleFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kRadiusFieldNumber = 4,
    kOpacityFieldNumber = 5,
  };
  // optional .TSP.Color color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // optional .TSD.DropShadowArchive dropShadow = 8;
  bool has_dropshadow() const;
  private:
  bool _internal_has_dropshadow() const;
  public:
  void clear_dropshadow();
  const ::TSD::DropShadowArchive& dropshadow() const;
  PROTOBUF_NODISCARD ::TSD::DropShadowArchive* release_dropshadow();
  ::TSD::DropShadowArchive* mutable_dropshadow();
  void set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow);
  private:
  const ::TSD::DropShadowArchive& _internal_dropshadow() const;
  ::TSD::DropShadowArchive* _internal_mutable_dropshadow();
  public:
  void unsafe_arena_set_allocated_dropshadow(
      ::TSD::DropShadowArchive* dropshadow);
  ::TSD::DropShadowArchive* unsafe_arena_release_dropshadow();

  // optional .TSD.ContactShadowArchive contactShadow = 9;
  bool has_contactshadow() const;
  private:
  bool _internal_has_contactshadow() const;
  public:
  void clear_contactshadow();
  const ::TSD::ContactShadowArchive& contactshadow() const;
  PROTOBUF_NODISCARD ::TSD::ContactShadowArchive* release_contactshadow();
  ::TSD::ContactShadowArchive* mutable_contactshadow();
  void set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow);
  private:
  const ::TSD::ContactShadowArchive& _internal_contactshadow() const;
  ::TSD::ContactShadowArchive* _internal_mutable_contactshadow();
  public:
  void unsafe_arena_set_allocated_contactshadow(
      ::TSD::ContactShadowArchive* contactshadow);
  ::TSD::ContactShadowArchive* unsafe_arena_release_contactshadow();

  // optional .TSD.CurvedShadowArchive curvedShadow = 10;
  bool has_curvedshadow() const;
  private:
  bool _internal_has_curvedshadow() const;
  public:
  void clear_curvedshadow();
  const ::TSD::CurvedShadowArchive& curvedshadow() const;
  PROTOBUF_NODISCARD ::TSD::CurvedShadowArchive* release_curvedshadow();
  ::TSD::CurvedShadowArchive* mutable_curvedshadow();
  void set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow);
  private:
  const ::TSD::CurvedShadowArchive& _internal_curvedshadow() const;
  ::TSD::CurvedShadowArchive* _internal_mutable_curvedshadow();
  public:
  void unsafe_arena_set_allocated_curvedshadow(
      ::TSD::CurvedShadowArchive* curvedshadow);
  ::TSD::CurvedShadowArchive* unsafe_arena_release_curvedshadow();

  // optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::ShadowArchive_ShadowType type() const;
  void set_type(::TSD::ShadowArchive_ShadowType value);
  private:
  ::TSD::ShadowArchive_ShadowType _internal_type() const;
  void _internal_set_type(::TSD::ShadowArchive_ShadowType value);
  public:

  // optional bool is_enabled = 6 [default = true];
  bool has_is_enabled() const;
  private:
  bool _internal_has_is_enabled() const;
  public:
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // optional float angle = 2 [default = 315];
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // optional float offset = 3 [default = 5];
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional int32 radius = 4 [default = 1];
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  int32_t radius() const;
  void set_radius(int32_t value);
  private:
  int32_t _internal_radius() const;
  void _internal_set_radius(int32_t value);
  public:

  // optional float opacity = 5 [default = 1];
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Color* color_;
    ::TSD::DropShadowArchive* dropshadow_;
    ::TSD::ContactShadowArchive* contactshadow_;
    ::TSD::CurvedShadowArchive* curvedshadow_;
    int type_;
    bool is_enabled_;
    float angle_;
    float offset_;
    int32_t radius_;
    float opacity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DropShadowArchive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:TSD.DropShadowArchive) */ {
 public:
  inline DropShadowArchive() : DropShadowArchive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DropShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropShadowArchive(const DropShadowArchive& from);
  DropShadowArchive(DropShadowArchive&& from) noexcept
    : DropShadowArchive() {
    *this = ::std::move(from);
  }

  inline DropShadowArchive& operator=(const DropShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropShadowArchive& operator=(DropShadowArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropShadowArchive* internal_default_instance() {
    return reinterpret_cast<const DropShadowArchive*>(
               &_DropShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DropShadowArchive& a, DropShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DropShadowArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropShadowArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DropShadowArchive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DropShadowArchive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DropShadowArchive";
  }
  protected:
  explicit DropShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TSD.DropShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ContactShadowArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ContactShadowArchive) */ {
 public:
  inline ContactShadowArchive() : ContactShadowArchive(nullptr) {}
  ~ContactShadowArchive() override;
  explicit PROTOBUF_CONSTEXPR ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContactShadowArchive(const ContactShadowArchive& from);
  ContactShadowArchive(ContactShadowArchive&& from) noexcept
    : ContactShadowArchive() {
    *this = ::std::move(from);
  }

  inline ContactShadowArchive& operator=(const ContactShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContactShadowArchive& operator=(ContactShadowArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContactShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContactShadowArchive* internal_default_instance() {
    return reinterpret_cast<const ContactShadowArchive*>(
               &_ContactShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ContactShadowArchive& a, ContactShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ContactShadowArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContactShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContactShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContactShadowArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContactShadowArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContactShadowArchive& from) {
    ContactShadowArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContactShadowArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ContactShadowArchive";
  }
  protected:
  explicit ContactShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 4,
    kHeightFieldNumber = 2,
  };
  // optional float offset = 4 [default = 0];
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional float height = 2 [default = 0.2];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ContactShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float offset_;
    float height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CurvedShadowArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CurvedShadowArchive) */ {
 public:
  inline CurvedShadowArchive() : CurvedShadowArchive(nullptr) {}
  ~CurvedShadowArchive() override;
  explicit PROTOBUF_CONSTEXPR CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurvedShadowArchive(const CurvedShadowArchive& from);
  CurvedShadowArchive(CurvedShadowArchive&& from) noexcept
    : CurvedShadowArchive() {
    *this = ::std::move(from);
  }

  inline CurvedShadowArchive& operator=(const CurvedShadowArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurvedShadowArchive& operator=(CurvedShadowArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurvedShadowArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurvedShadowArchive* internal_default_instance() {
    return reinterpret_cast<const CurvedShadowArchive*>(
               &_CurvedShadowArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CurvedShadowArchive& a, CurvedShadowArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CurvedShadowArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurvedShadowArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurvedShadowArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurvedShadowArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurvedShadowArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurvedShadowArchive& from) {
    CurvedShadowArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurvedShadowArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CurvedShadowArchive";
  }
  protected:
  explicit CurvedShadowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurveFieldNumber = 1,
  };
  // optional float curve = 1 [default = 0.6];
  bool has_curve() const;
  private:
  bool _internal_has_curve() const;
  public:
  void clear_curve();
  float curve() const;
  void set_curve(float value);
  private:
  float _internal_curve() const;
  void _internal_set_curve(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.CurvedShadowArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float curve_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ReflectionArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ReflectionArchive) */ {
 public:
  inline ReflectionArchive() : ReflectionArchive(nullptr) {}
  ~ReflectionArchive() override;
  explicit PROTOBUF_CONSTEXPR ReflectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReflectionArchive(const ReflectionArchive& from);
  ReflectionArchive(ReflectionArchive&& from) noexcept
    : ReflectionArchive() {
    *this = ::std::move(from);
  }

  inline ReflectionArchive& operator=(const ReflectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReflectionArchive& operator=(ReflectionArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReflectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReflectionArchive* internal_default_instance() {
    return reinterpret_cast<const ReflectionArchive*>(
               &_ReflectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ReflectionArchive& a, ReflectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReflectionArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReflectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReflectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReflectionArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReflectionArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReflectionArchive& from) {
    ReflectionArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReflectionArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ReflectionArchive";
  }
  protected:
  explicit ReflectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpacityFieldNumber = 1,
  };
  // optional float opacity = 1 [default = 0.5];
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ReflectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float opacity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageAdjustmentsArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageAdjustmentsArchive) */ {
 public:
  inline ImageAdjustmentsArchive() : ImageAdjustmentsArchive(nullptr) {}
  ~ImageAdjustmentsArchive() override;
  explicit PROTOBUF_CONSTEXPR ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageAdjustmentsArchive(const ImageAdjustmentsArchive& from);
  ImageAdjustmentsArchive(ImageAdjustmentsArchive&& from) noexcept
    : ImageAdjustmentsArchive() {
    *this = ::std::move(from);
  }

  inline ImageAdjustmentsArchive& operator=(const ImageAdjustmentsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageAdjustmentsArchive& operator=(ImageAdjustmentsArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageAdjustmentsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageAdjustmentsArchive* internal_default_instance() {
    return reinterpret_cast<const ImageAdjustmentsArchive*>(
               &_ImageAdjustmentsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ImageAdjustmentsArchive& a, ImageAdjustmentsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageAdjustmentsArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageAdjustmentsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageAdjustmentsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageAdjustmentsArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageAdjustmentsArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageAdjustmentsArchive& from) {
    ImageAdjustmentsArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageAdjustmentsArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageAdjustmentsArchive";
  }
  protected:
  explicit ImageAdjustmentsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExposureFieldNumber = 1,
    kSaturationFieldNumber = 2,
    kContrastFieldNumber = 3,
    kHighlightsFieldNumber = 4,
    kShadowsFieldNumber = 5,
    kSharpnessFieldNumber = 6,
    kDenoiseFieldNumber = 7,
    kTemperatureFieldNumber = 8,
    kTintFieldNumber = 9,
    kBottomLevelFieldNumber = 10,
    kGammaFieldNumber = 12,
    kEnhanceFieldNumber = 13,
    kRepresentsSageAdjustmentsFieldNumber = 14,
    kTopLevelFieldNumber = 11,
  };
  // optional float exposure = 1;
  bool has_exposure() const;
  private:
  bool _internal_has_exposure() const;
  public:
  void clear_exposure();
  float exposure() const;
  void set_exposure(float value);
  private:
  float _internal_exposure() const;
  void _internal_set_exposure(float value);
  public:

  // optional float saturation = 2;
  bool has_saturation() const;
  private:
  bool _internal_has_saturation() const;
  public:
  void clear_saturation();
  float saturation() const;
  void set_saturation(float value);
  private:
  float _internal_saturation() const;
  void _internal_set_saturation(float value);
  public:

  // optional float contrast = 3;
  bool has_contrast() const;
  private:
  bool _internal_has_contrast() const;
  public:
  void clear_contrast();
  float contrast() const;
  void set_contrast(float value);
  private:
  float _internal_contrast() const;
  void _internal_set_contrast(float value);
  public:

  // optional float highlights = 4;
  bool has_highlights() const;
  private:
  bool _internal_has_highlights() const;
  public:
  void clear_highlights();
  float highlights() const;
  void set_highlights(float value);
  private:
  float _internal_highlights() const;
  void _internal_set_highlights(float value);
  public:

  // optional float shadows = 5;
  bool has_shadows() const;
  private:
  bool _internal_has_shadows() const;
  public:
  void clear_shadows();
  float shadows() const;
  void set_shadows(float value);
  private:
  float _internal_shadows() const;
  void _internal_set_shadows(float value);
  public:

  // optional float sharpness = 6;
  bool has_sharpness() const;
  private:
  bool _internal_has_sharpness() const;
  public:
  void clear_sharpness();
  float sharpness() const;
  void set_sharpness(float value);
  private:
  float _internal_sharpness() const;
  void _internal_set_sharpness(float value);
  public:

  // optional float denoise = 7;
  bool has_denoise() const;
  private:
  bool _internal_has_denoise() const;
  public:
  void clear_denoise();
  float denoise() const;
  void set_denoise(float value);
  private:
  float _internal_denoise() const;
  void _internal_set_denoise(float value);
  public:

  // optional float temperature = 8;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // optional float tint = 9;
  bool has_tint() const;
  private:
  bool _internal_has_tint() const;
  public:
  void clear_tint();
  float tint() const;
  void set_tint(float value);
  private:
  float _internal_tint() const;
  void _internal_set_tint(float value);
  public:

  // optional float bottom_level = 10;
  bool has_bottom_level() const;
  private:
  bool _internal_has_bottom_level() const;
  public:
  void clear_bottom_level();
  float bottom_level() const;
  void set_bottom_level(float value);
  private:
  float _internal_bottom_level() const;
  void _internal_set_bottom_level(float value);
  public:

  // optional float gamma = 12;
  bool has_gamma() const;
  private:
  bool _internal_has_gamma() const;
  public:
  void clear_gamma();
  float gamma() const;
  void set_gamma(float value);
  private:
  float _internal_gamma() const;
  void _internal_set_gamma(float value);
  public:

  // optional bool enhance = 13 [default = false];
  bool has_enhance() const;
  private:
  bool _internal_has_enhance() const;
  public:
  void clear_enhance();
  bool enhance() const;
  void set_enhance(bool value);
  private:
  bool _internal_enhance() const;
  void _internal_set_enhance(bool value);
  public:

  // optional bool represents_sage_adjustments = 14 [default = false];
  bool has_represents_sage_adjustments() const;
  private:
  bool _internal_has_represents_sage_adjustments() const;
  public:
  void clear_represents_sage_adjustments();
  bool represents_sage_adjustments() const;
  void set_represents_sage_adjustments(bool value);
  private:
  bool _internal_represents_sage_adjustments() const;
  void _internal_set_represents_sage_adjustments(bool value);
  public:

  // optional float top_level = 11 [default = 1];
  bool has_top_level() const;
  private:
  bool _internal_has_top_level() const;
  public:
  void clear_top_level();
  float top_level() const;
  void set_top_level(float value);
  private:
  float _internal_top_level() const;
  void _internal_set_top_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ImageAdjustmentsArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float exposure_;
    float saturation_;
    float contrast_;
    float highlights_;
    float shadows_;
    float sharpness_;
    float denoise_;
    float temperature_;
    float tint_;
    float bottom_level_;
    float gamma_;
    bool enhance_;
    bool represents_sage_adjustments_;
    float top_level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeStylePropertiesArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeStylePropertiesArchive) */ {
 public:
  inline ShapeStylePropertiesArchive() : ShapeStylePropertiesArchive(nullptr) {}
  ~ShapeStylePropertiesArchive() override;
  explicit PROTOBUF_CONSTEXPR ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeStylePropertiesArchive(const ShapeStylePropertiesArchive& from);
  ShapeStylePropertiesArchive(ShapeStylePropertiesArchive&& from) noexcept
    : ShapeStylePropertiesArchive() {
    *this = ::std::move(from);
  }

  inline ShapeStylePropertiesArchive& operator=(const ShapeStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeStylePropertiesArchive& operator=(ShapeStylePropertiesArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeStylePropertiesArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeStylePropertiesArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeStylePropertiesArchive*>(
               &_ShapeStylePropertiesArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ShapeStylePropertiesArchive& a, ShapeStylePropertiesArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeStylePropertiesArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeStylePropertiesArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeStylePropertiesArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeStylePropertiesArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeStylePropertiesArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeStylePropertiesArchive& from) {
    ShapeStylePropertiesArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeStylePropertiesArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeStylePropertiesArchive";
  }
  protected:
  explicit ShapeStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFillFieldNumber = 1,
    kStrokeFieldNumber = 2,
    kShadowFieldNumber = 4,
    kReflectionFieldNumber = 5,
    kOpacityFieldNumber = 3,
  };
  // optional .TSD.FillArchive fill = 1;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::TSD::FillArchive& fill() const;
  PROTOBUF_NODISCARD ::TSD::FillArchive* release_fill();
  ::TSD::FillArchive* mutable_fill();
  void set_allocated_fill(::TSD::FillArchive* fill);
  private:
  const ::TSD::FillArchive& _internal_fill() const;
  ::TSD::FillArchive* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::TSD::FillArchive* fill);
  ::TSD::FillArchive* unsafe_arena_release_fill();

  // optional .TSD.StrokeArchive stroke = 2;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::TSD::StrokeArchive& stroke() const;
  PROTOBUF_NODISCARD ::TSD::StrokeArchive* release_stroke();
  ::TSD::StrokeArchive* mutable_stroke();
  void set_allocated_stroke(::TSD::StrokeArchive* stroke);
  private:
  const ::TSD::StrokeArchive& _internal_stroke() const;
  ::TSD::StrokeArchive* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::TSD::StrokeArchive* stroke);
  ::TSD::StrokeArchive* unsafe_arena_release_stroke();

  // optional .TSD.ShadowArchive shadow = 4;
  bool has_shadow() const;
  private:
  bool _internal_has_shadow() const;
  public:
  void clear_shadow();
  const ::TSD::ShadowArchive& shadow() const;
  PROTOBUF_NODISCARD ::TSD::ShadowArchive* release_shadow();
  ::TSD::ShadowArchive* mutable_shadow();
  void set_allocated_shadow(::TSD::ShadowArchive* shadow);
  private:
  const ::TSD::ShadowArchive& _internal_shadow() const;
  ::TSD::ShadowArchive* _internal_mutable_shadow();
  public:
  void unsafe_arena_set_allocated_shadow(
      ::TSD::ShadowArchive* shadow);
  ::TSD::ShadowArchive* unsafe_arena_release_shadow();

  // optional .TSD.ReflectionArchive reflection = 5;
  bool has_reflection() const;
  private:
  bool _internal_has_reflection() const;
  public:
  void clear_reflection();
  const ::TSD::ReflectionArchive& reflection() const;
  PROTOBUF_NODISCARD ::TSD::ReflectionArchive* release_reflection();
  ::TSD::ReflectionArchive* mutable_reflection();
  void set_allocated_reflection(::TSD::ReflectionArchive* reflection);
  private:
  const ::TSD::ReflectionArchive& _internal_reflection() const;
  ::TSD::ReflectionArchive* _internal_mutable_reflection();
  public:
  void unsafe_arena_set_allocated_reflection(
      ::TSD::ReflectionArchive* reflection);
  ::TSD::ReflectionArchive* unsafe_arena_release_reflection();

  // optional float opacity = 3;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShapeStylePropertiesArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::FillArchive* fill_;
    ::TSD::StrokeArchive* stroke_;
    ::TSD::ShadowArchive* shadow_;
    ::TSD::ReflectionArchive* reflection_;
    float opacity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeStyleArchive) */ {
 public:
  inline ShapeStyleArchive() : ShapeStyleArchive(nullptr) {}
  ~ShapeStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeStyleArchive(const ShapeStyleArchive& from);
  ShapeStyleArchive(ShapeStyleArchive&& from) noexcept
    : ShapeStyleArchive() {
    *this = ::std::move(from);
  }

  inline ShapeStyleArchive& operator=(const ShapeStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeStyleArchive& operator=(ShapeStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeStyleArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeStyleArchive*>(
               &_ShapeStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ShapeStyleArchive& a, ShapeStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeStyleArchive& from) {
    ShapeStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeStyleArchive";
  }
  protected:
  explicit ShapeStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kShapePropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
  bool has_shape_properties() const;
  private:
  bool _internal_has_shape_properties() const;
  public:
  void clear_shape_properties();
  const ::TSD::ShapeStylePropertiesArchive& shape_properties() const;
  PROTOBUF_NODISCARD ::TSD::ShapeStylePropertiesArchive* release_shape_properties();
  ::TSD::ShapeStylePropertiesArchive* mutable_shape_properties();
  void set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties);
  private:
  const ::TSD::ShapeStylePropertiesArchive& _internal_shape_properties() const;
  ::TSD::ShapeStylePropertiesArchive* _internal_mutable_shape_properties();
  public:
  void unsafe_arena_set_allocated_shape_properties(
      ::TSD::ShapeStylePropertiesArchive* shape_properties);
  ::TSD::ShapeStylePropertiesArchive* unsafe_arena_release_shape_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  uint32_t override_count() const;
  void set_override_count(uint32_t value);
  private:
  uint32_t _internal_override_count() const;
  void _internal_set_override_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ShapeStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
    ::TSD::ShapeStylePropertiesArchive* shape_properties_;
    uint32_t override_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MediaStylePropertiesArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MediaStylePropertiesArchive) */ {
 public:
  inline MediaStylePropertiesArchive() : MediaStylePropertiesArchive(nullptr) {}
  ~MediaStylePropertiesArchive() override;
  explicit PROTOBUF_CONSTEXPR MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaStylePropertiesArchive(const MediaStylePropertiesArchive& from);
  MediaStylePropertiesArchive(MediaStylePropertiesArchive&& from) noexcept
    : MediaStylePropertiesArchive() {
    *this = ::std::move(from);
  }

  inline MediaStylePropertiesArchive& operator=(const MediaStylePropertiesArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStylePropertiesArchive& operator=(MediaStylePropertiesArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStylePropertiesArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStylePropertiesArchive* internal_default_instance() {
    return reinterpret_cast<const MediaStylePropertiesArchive*>(
               &_MediaStylePropertiesArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MediaStylePropertiesArchive& a, MediaStylePropertiesArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStylePropertiesArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStylePropertiesArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaStylePropertiesArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaStylePropertiesArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaStylePropertiesArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaStylePropertiesArchive& from) {
    MediaStylePropertiesArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStylePropertiesArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MediaStylePropertiesArchive";
  }
  protected:
  explicit MediaStylePropertiesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrokeFieldNumber = 1,
    kShadowFieldNumber = 3,
    kReflectionFieldNumber = 4,
    kOpacityFieldNumber = 2,
  };
  // optional .TSD.StrokeArchive stroke = 1;
  bool has_stroke() const;
  private:
  bool _internal_has_stroke() const;
  public:
  void clear_stroke();
  const ::TSD::StrokeArchive& stroke() const;
  PROTOBUF_NODISCARD ::TSD::StrokeArchive* release_stroke();
  ::TSD::StrokeArchive* mutable_stroke();
  void set_allocated_stroke(::TSD::StrokeArchive* stroke);
  private:
  const ::TSD::StrokeArchive& _internal_stroke() const;
  ::TSD::StrokeArchive* _internal_mutable_stroke();
  public:
  void unsafe_arena_set_allocated_stroke(
      ::TSD::StrokeArchive* stroke);
  ::TSD::StrokeArchive* unsafe_arena_release_stroke();

  // optional .TSD.ShadowArchive shadow = 3;
  bool has_shadow() const;
  private:
  bool _internal_has_shadow() const;
  public:
  void clear_shadow();
  const ::TSD::ShadowArchive& shadow() const;
  PROTOBUF_NODISCARD ::TSD::ShadowArchive* release_shadow();
  ::TSD::ShadowArchive* mutable_shadow();
  void set_allocated_shadow(::TSD::ShadowArchive* shadow);
  private:
  const ::TSD::ShadowArchive& _internal_shadow() const;
  ::TSD::ShadowArchive* _internal_mutable_shadow();
  public:
  void unsafe_arena_set_allocated_shadow(
      ::TSD::ShadowArchive* shadow);
  ::TSD::ShadowArchive* unsafe_arena_release_shadow();

  // optional .TSD.ReflectionArchive reflection = 4;
  bool has_reflection() const;
  private:
  bool _internal_has_reflection() const;
  public:
  void clear_reflection();
  const ::TSD::ReflectionArchive& reflection() const;
  PROTOBUF_NODISCARD ::TSD::ReflectionArchive* release_reflection();
  ::TSD::ReflectionArchive* mutable_reflection();
  void set_allocated_reflection(::TSD::ReflectionArchive* reflection);
  private:
  const ::TSD::ReflectionArchive& _internal_reflection() const;
  ::TSD::ReflectionArchive* _internal_mutable_reflection();
  public:
  void unsafe_arena_set_allocated_reflection(
      ::TSD::ReflectionArchive* reflection);
  ::TSD::ReflectionArchive* unsafe_arena_release_reflection();

  // optional float opacity = 2;
  bool has_opacity() const;
  private:
  bool _internal_has_opacity() const;
  public:
  void clear_opacity();
  float opacity() const;
  void set_opacity(float value);
  private:
  float _internal_opacity() const;
  void _internal_set_opacity(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MediaStylePropertiesArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::StrokeArchive* stroke_;
    ::TSD::ShadowArchive* shadow_;
    ::TSD::ReflectionArchive* reflection_;
    float opacity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MediaStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MediaStyleArchive) */ {
 public:
  inline MediaStyleArchive() : MediaStyleArchive(nullptr) {}
  ~MediaStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MediaStyleArchive(const MediaStyleArchive& from);
  MediaStyleArchive(MediaStyleArchive&& from) noexcept
    : MediaStyleArchive() {
    *this = ::std::move(from);
  }

  inline MediaStyleArchive& operator=(const MediaStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStyleArchive& operator=(MediaStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MediaStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MediaStyleArchive* internal_default_instance() {
    return reinterpret_cast<const MediaStyleArchive*>(
               &_MediaStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MediaStyleArchive& a, MediaStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MediaStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MediaStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MediaStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MediaStyleArchive& from) {
    MediaStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MediaStyleArchive";
  }
  protected:
  explicit MediaStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kMediaPropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TSD.MediaStylePropertiesArchive media_properties = 11;
  bool has_media_properties() const;
  private:
  bool _internal_has_media_properties() const;
  public:
  void clear_media_properties();
  const ::TSD::MediaStylePropertiesArchive& media_properties() const;
  PROTOBUF_NODISCARD ::TSD::MediaStylePropertiesArchive* release_media_properties();
  ::TSD::MediaStylePropertiesArchive* mutable_media_properties();
  void set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties);
  private:
  const ::TSD::MediaStylePropertiesArchive& _internal_media_properties() const;
  ::TSD::MediaStylePropertiesArchive* _internal_mutable_media_properties();
  public:
  void unsafe_arena_set_allocated_media_properties(
      ::TSD::MediaStylePropertiesArchive* media_properties);
  ::TSD::MediaStylePropertiesArchive* unsafe_arena_release_media_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  uint32_t override_count() const;
  void set_override_count(uint32_t value);
  private:
  uint32_t _internal_override_count() const;
  void _internal_set_override_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MediaStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
    ::TSD::MediaStylePropertiesArchive* media_properties_;
    uint32_t override_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ThemePresetsArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ThemePresetsArchive) */ {
 public:
  inline ThemePresetsArchive() : ThemePresetsArchive(nullptr) {}
  ~ThemePresetsArchive() override;
  explicit PROTOBUF_CONSTEXPR ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemePresetsArchive(const ThemePresetsArchive& from);
  ThemePresetsArchive(ThemePresetsArchive&& from) noexcept
    : ThemePresetsArchive() {
    *this = ::std::move(from);
  }

  inline ThemePresetsArchive& operator=(const ThemePresetsArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemePresetsArchive& operator=(ThemePresetsArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemePresetsArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemePresetsArchive* internal_default_instance() {
    return reinterpret_cast<const ThemePresetsArchive*>(
               &_ThemePresetsArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ThemePresetsArchive& a, ThemePresetsArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemePresetsArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemePresetsArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThemePresetsArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThemePresetsArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThemePresetsArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThemePresetsArchive& from) {
    ThemePresetsArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemePresetsArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ThemePresetsArchive";
  }
  protected:
  explicit ThemePresetsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradientFillPresetsFieldNumber = 1,
    kImageFillPresetsFieldNumber = 2,
    kShadowPresetsFieldNumber = 3,
    kLineStylePresetsFieldNumber = 4,
    kShapeStylePresetsFieldNumber = 5,
    kTextboxStylePresetsFieldNumber = 6,
    kImageStylePresetsFieldNumber = 7,
    kMovieStylePresetsFieldNumber = 8,
  };
  // repeated .TSD.FillArchive gradient_fill_presets = 1;
  int gradient_fill_presets_size() const;
  private:
  int _internal_gradient_fill_presets_size() const;
  public:
  void clear_gradient_fill_presets();
  ::TSD::FillArchive* mutable_gradient_fill_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_gradient_fill_presets();
  private:
  const ::TSD::FillArchive& _internal_gradient_fill_presets(int index) const;
  ::TSD::FillArchive* _internal_add_gradient_fill_presets();
  public:
  const ::TSD::FillArchive& gradient_fill_presets(int index) const;
  ::TSD::FillArchive* add_gradient_fill_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
      gradient_fill_presets() const;

  // repeated .TSD.FillArchive image_fill_presets = 2;
  int image_fill_presets_size() const;
  private:
  int _internal_image_fill_presets_size() const;
  public:
  void clear_image_fill_presets();
  ::TSD::FillArchive* mutable_image_fill_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
      mutable_image_fill_presets();
  private:
  const ::TSD::FillArchive& _internal_image_fill_presets(int index) const;
  ::TSD::FillArchive* _internal_add_image_fill_presets();
  public:
  const ::TSD::FillArchive& image_fill_presets(int index) const;
  ::TSD::FillArchive* add_image_fill_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
      image_fill_presets() const;

  // repeated .TSD.ShadowArchive shadow_presets = 3;
  int shadow_presets_size() const;
  private:
  int _internal_shadow_presets_size() const;
  public:
  void clear_shadow_presets();
  ::TSD::ShadowArchive* mutable_shadow_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >*
      mutable_shadow_presets();
  private:
  const ::TSD::ShadowArchive& _internal_shadow_presets(int index) const;
  ::TSD::ShadowArchive* _internal_add_shadow_presets();
  public:
  const ::TSD::ShadowArchive& shadow_presets(int index) const;
  ::TSD::ShadowArchive* add_shadow_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >&
      shadow_presets() const;

  // repeated .TSP.Reference line_style_presets = 4;
  int line_style_presets_size() const;
  private:
  int _internal_line_style_presets_size() const;
  public:
  void clear_line_style_presets();
  ::TSP::Reference* mutable_line_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_line_style_presets();
  private:
  const ::TSP::Reference& _internal_line_style_presets(int index) const;
  ::TSP::Reference* _internal_add_line_style_presets();
  public:
  const ::TSP::Reference& line_style_presets(int index) const;
  ::TSP::Reference* add_line_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      line_style_presets() const;

  // repeated .TSP.Reference shape_style_presets = 5;
  int shape_style_presets_size() const;
  private:
  int _internal_shape_style_presets_size() const;
  public:
  void clear_shape_style_presets();
  ::TSP::Reference* mutable_shape_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_shape_style_presets();
  private:
  const ::TSP::Reference& _internal_shape_style_presets(int index) const;
  ::TSP::Reference* _internal_add_shape_style_presets();
  public:
  const ::TSP::Reference& shape_style_presets(int index) const;
  ::TSP::Reference* add_shape_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      shape_style_presets() const;

  // repeated .TSP.Reference textbox_style_presets = 6;
  int textbox_style_presets_size() const;
  private:
  int _internal_textbox_style_presets_size() const;
  public:
  void clear_textbox_style_presets();
  ::TSP::Reference* mutable_textbox_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_textbox_style_presets();
  private:
  const ::TSP::Reference& _internal_textbox_style_presets(int index) const;
  ::TSP::Reference* _internal_add_textbox_style_presets();
  public:
  const ::TSP::Reference& textbox_style_presets(int index) const;
  ::TSP::Reference* add_textbox_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      textbox_style_presets() const;

  // repeated .TSP.Reference image_style_presets = 7;
  int image_style_presets_size() const;
  private:
  int _internal_image_style_presets_size() const;
  public:
  void clear_image_style_presets();
  ::TSP::Reference* mutable_image_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_image_style_presets();
  private:
  const ::TSP::Reference& _internal_image_style_presets(int index) const;
  ::TSP::Reference* _internal_add_image_style_presets();
  public:
  const ::TSP::Reference& image_style_presets(int index) const;
  ::TSP::Reference* add_image_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      image_style_presets() const;

  // repeated .TSP.Reference movie_style_presets = 8;
  int movie_style_presets_size() const;
  private:
  int _internal_movie_style_presets_size() const;
  public:
  void clear_movie_style_presets();
  ::TSP::Reference* mutable_movie_style_presets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_movie_style_presets();
  private:
  const ::TSP::Reference& _internal_movie_style_presets(int index) const;
  ::TSP::Reference* _internal_add_movie_style_presets();
  public:
  const ::TSP::Reference& movie_style_presets(int index) const;
  ::TSP::Reference* add_movie_style_presets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      movie_style_presets() const;

  static const int kExtensionFieldNumber = 100;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::TSS::ThemeArchive,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::TSD::ThemePresetsArchive >, 11, false >
    extension;
  // @@protoc_insertion_point(class_scope:TSD.ThemePresetsArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive > gradient_fill_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive > image_fill_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive > shadow_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > line_style_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > shape_style_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > textbox_style_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > image_style_presets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > movie_style_presets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ThemeReplaceFillPresetCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ThemeReplaceFillPresetCommandArchive) */ {
 public:
  inline ThemeReplaceFillPresetCommandArchive() : ThemeReplaceFillPresetCommandArchive(nullptr) {}
  ~ThemeReplaceFillPresetCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThemeReplaceFillPresetCommandArchive(const ThemeReplaceFillPresetCommandArchive& from);
  ThemeReplaceFillPresetCommandArchive(ThemeReplaceFillPresetCommandArchive&& from) noexcept
    : ThemeReplaceFillPresetCommandArchive() {
    *this = ::std::move(from);
  }

  inline ThemeReplaceFillPresetCommandArchive& operator=(const ThemeReplaceFillPresetCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThemeReplaceFillPresetCommandArchive& operator=(ThemeReplaceFillPresetCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThemeReplaceFillPresetCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThemeReplaceFillPresetCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ThemeReplaceFillPresetCommandArchive*>(
               &_ThemeReplaceFillPresetCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ThemeReplaceFillPresetCommandArchive& a, ThemeReplaceFillPresetCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ThemeReplaceFillPresetCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThemeReplaceFillPresetCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThemeReplaceFillPresetCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThemeReplaceFillPresetCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThemeReplaceFillPresetCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThemeReplaceFillPresetCommandArchive& from) {
    ThemeReplaceFillPresetCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThemeReplaceFillPresetCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ThemeReplaceFillPresetCommandArchive";
  }
  protected:
  explicit ThemeReplaceFillPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kThemeFieldNumber = 2,
    kFillFieldNumber = 3,
    kOldFillFieldNumber = 4,
    kIndexFieldNumber = 5,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // required .TSP.Reference theme = 2;
  bool has_theme() const;
  private:
  bool _internal_has_theme() const;
  public:
  void clear_theme();
  const ::TSP::Reference& theme() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_theme();
  ::TSP::Reference* mutable_theme();
  void set_allocated_theme(::TSP::Reference* theme);
  private:
  const ::TSP::Reference& _internal_theme() const;
  ::TSP::Reference* _internal_mutable_theme();
  public:
  void unsafe_arena_set_allocated_theme(
      ::TSP::Reference* theme);
  ::TSP::Reference* unsafe_arena_release_theme();

  // required .TSD.FillArchive fill = 3;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::TSD::FillArchive& fill() const;
  PROTOBUF_NODISCARD ::TSD::FillArchive* release_fill();
  ::TSD::FillArchive* mutable_fill();
  void set_allocated_fill(::TSD::FillArchive* fill);
  private:
  const ::TSD::FillArchive& _internal_fill() const;
  ::TSD::FillArchive* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::TSD::FillArchive* fill);
  ::TSD::FillArchive* unsafe_arena_release_fill();

  // required .TSD.FillArchive old_fill = 4;
  bool has_old_fill() const;
  private:
  bool _internal_has_old_fill() const;
  public:
  void clear_old_fill();
  const ::TSD::FillArchive& old_fill() const;
  PROTOBUF_NODISCARD ::TSD::FillArchive* release_old_fill();
  ::TSD::FillArchive* mutable_old_fill();
  void set_allocated_old_fill(::TSD::FillArchive* old_fill);
  private:
  const ::TSD::FillArchive& _internal_old_fill() const;
  ::TSD::FillArchive* _internal_mutable_old_fill();
  public:
  void unsafe_arena_set_allocated_old_fill(
      ::TSD::FillArchive* old_fill);
  ::TSD::FillArchive* unsafe_arena_release_old_fill();

  // required uint32 index = 5;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ThemeReplaceFillPresetCommandArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* theme_;
    ::TSD::FillArchive* fill_;
    ::TSD::FillArchive* old_fill_;
    uint32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class DrawableArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.DrawableArchive) */ {
 public:
  inline DrawableArchive() : DrawableArchive(nullptr) {}
  ~DrawableArchive() override;
  explicit PROTOBUF_CONSTEXPR DrawableArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableArchive(const DrawableArchive& from);
  DrawableArchive(DrawableArchive&& from) noexcept
    : DrawableArchive() {
    *this = ::std::move(from);
  }

  inline DrawableArchive& operator=(const DrawableArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableArchive& operator=(DrawableArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawableArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawableArchive* internal_default_instance() {
    return reinterpret_cast<const DrawableArchive*>(
               &_DrawableArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(DrawableArchive& a, DrawableArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawableArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawableArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawableArchive& from) {
    DrawableArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawableArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.DrawableArchive";
  }
  protected:
  explicit DrawableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHyperlinkUrlFieldNumber = 4,
    kAccessibilityDescriptionFieldNumber = 8,
    kGeometryFieldNumber = 1,
    kParentFieldNumber = 2,
    kExteriorTextWrapFieldNumber = 3,
    kCommentFieldNumber = 6,
    kLockedFieldNumber = 5,
    kAspectRatioLockedFieldNumber = 7,
  };
  // optional string hyperlink_url = 4;
  bool has_hyperlink_url() const;
  private:
  bool _internal_has_hyperlink_url() const;
  public:
  void clear_hyperlink_url();
  const std::string& hyperlink_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hyperlink_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hyperlink_url();
  PROTOBUF_NODISCARD std::string* release_hyperlink_url();
  void set_allocated_hyperlink_url(std::string* hyperlink_url);
  private:
  const std::string& _internal_hyperlink_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hyperlink_url(const std::string& value);
  std::string* _internal_mutable_hyperlink_url();
  public:

  // optional string accessibility_description = 8;
  bool has_accessibility_description() const;
  private:
  bool _internal_has_accessibility_description() const;
  public:
  void clear_accessibility_description();
  const std::string& accessibility_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accessibility_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accessibility_description();
  PROTOBUF_NODISCARD std::string* release_accessibility_description();
  void set_allocated_accessibility_description(std::string* accessibility_description);
  private:
  const std::string& _internal_accessibility_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accessibility_description(const std::string& value);
  std::string* _internal_mutable_accessibility_description();
  public:

  // optional .TSD.GeometryArchive geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_NODISCARD ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::TSP::Reference& parent() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_parent();
  ::TSP::Reference* mutable_parent();
  void set_allocated_parent(::TSP::Reference* parent);
  private:
  const ::TSP::Reference& _internal_parent() const;
  ::TSP::Reference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::TSP::Reference* parent);
  ::TSP::Reference* unsafe_arena_release_parent();

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
  bool has_exterior_text_wrap() const;
  private:
  bool _internal_has_exterior_text_wrap() const;
  public:
  void clear_exterior_text_wrap();
  const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap() const;
  PROTOBUF_NODISCARD ::TSD::ExteriorTextWrapArchive* release_exterior_text_wrap();
  ::TSD::ExteriorTextWrapArchive* mutable_exterior_text_wrap();
  void set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap);
  private:
  const ::TSD::ExteriorTextWrapArchive& _internal_exterior_text_wrap() const;
  ::TSD::ExteriorTextWrapArchive* _internal_mutable_exterior_text_wrap();
  public:
  void unsafe_arena_set_allocated_exterior_text_wrap(
      ::TSD::ExteriorTextWrapArchive* exterior_text_wrap);
  ::TSD::ExteriorTextWrapArchive* unsafe_arena_release_exterior_text_wrap();

  // optional .TSP.Reference comment = 6;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const ::TSP::Reference& comment() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_comment();
  ::TSP::Reference* mutable_comment();
  void set_allocated_comment(::TSP::Reference* comment);
  private:
  const ::TSP::Reference& _internal_comment() const;
  ::TSP::Reference* _internal_mutable_comment();
  public:
  void unsafe_arena_set_allocated_comment(
      ::TSP::Reference* comment);
  ::TSP::Reference* unsafe_arena_release_comment();

  // optional bool locked = 5;
  bool has_locked() const;
  private:
  bool _internal_has_locked() const;
  public:
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // optional bool aspect_ratio_locked = 7;
  bool has_aspect_ratio_locked() const;
  private:
  bool _internal_has_aspect_ratio_locked() const;
  public:
  void clear_aspect_ratio_locked();
  bool aspect_ratio_locked() const;
  void set_aspect_ratio_locked(bool value);
  private:
  bool _internal_aspect_ratio_locked() const;
  void _internal_set_aspect_ratio_locked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.DrawableArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hyperlink_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accessibility_description_;
    ::TSD::GeometryArchive* geometry_;
    ::TSP::Reference* parent_;
    ::TSD::ExteriorTextWrapArchive* exterior_text_wrap_;
    ::TSP::Reference* comment_;
    bool locked_;
    bool aspect_ratio_locked_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ContainerArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ContainerArchive) */ {
 public:
  inline ContainerArchive() : ContainerArchive(nullptr) {}
  ~ContainerArchive() override;
  explicit PROTOBUF_CONSTEXPR ContainerArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainerArchive(const ContainerArchive& from);
  ContainerArchive(ContainerArchive&& from) noexcept
    : ContainerArchive() {
    *this = ::std::move(from);
  }

  inline ContainerArchive& operator=(const ContainerArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainerArchive& operator=(ContainerArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainerArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainerArchive* internal_default_instance() {
    return reinterpret_cast<const ContainerArchive*>(
               &_ContainerArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ContainerArchive& a, ContainerArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainerArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainerArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainerArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContainerArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContainerArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContainerArchive& from) {
    ContainerArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainerArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ContainerArchive";
  }
  protected:
  explicit ContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 3,
    kGeometryFieldNumber = 1,
    kParentFieldNumber = 2,
  };
  // repeated .TSP.Reference children = 3;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // optional .TSD.GeometryArchive geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::TSD::GeometryArchive& geometry() const;
  PROTOBUF_NODISCARD ::TSD::GeometryArchive* release_geometry();
  ::TSD::GeometryArchive* mutable_geometry();
  void set_allocated_geometry(::TSD::GeometryArchive* geometry);
  private:
  const ::TSD::GeometryArchive& _internal_geometry() const;
  ::TSD::GeometryArchive* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::TSD::GeometryArchive* geometry);
  ::TSD::GeometryArchive* unsafe_arena_release_geometry();

  // optional .TSP.Reference parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::TSP::Reference& parent() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_parent();
  ::TSP::Reference* mutable_parent();
  void set_allocated_parent(::TSP::Reference* parent);
  private:
  const ::TSP::Reference& _internal_parent() const;
  ::TSP::Reference* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::TSP::Reference* parent);
  ::TSP::Reference* unsafe_arena_release_parent();

  // @@protoc_insertion_point(class_scope:TSD.ContainerArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
    ::TSD::GeometryArchive* geometry_;
    ::TSP::Reference* parent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GroupArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GroupArchive) */ {
 public:
  inline GroupArchive() : GroupArchive(nullptr) {}
  ~GroupArchive() override;
  explicit PROTOBUF_CONSTEXPR GroupArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupArchive(const GroupArchive& from);
  GroupArchive(GroupArchive&& from) noexcept
    : GroupArchive() {
    *this = ::std::move(from);
  }

  inline GroupArchive& operator=(const GroupArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupArchive& operator=(GroupArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupArchive* internal_default_instance() {
    return reinterpret_cast<const GroupArchive*>(
               &_GroupArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GroupArchive& a, GroupArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupArchive& from) {
    GroupArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GroupArchive";
  }
  protected:
  explicit GroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // repeated .TSP.Reference children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSD.GroupArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
    ::TSD::DrawableArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ShapeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ShapeArchive) */ {
 public:
  inline ShapeArchive() : ShapeArchive(nullptr) {}
  ~ShapeArchive() override;
  explicit PROTOBUF_CONSTEXPR ShapeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeArchive(const ShapeArchive& from);
  ShapeArchive(ShapeArchive&& from) noexcept
    : ShapeArchive() {
    *this = ::std::move(from);
  }

  inline ShapeArchive& operator=(const ShapeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeArchive& operator=(ShapeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeArchive* internal_default_instance() {
    return reinterpret_cast<const ShapeArchive*>(
               &_ShapeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ShapeArchive& a, ShapeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeArchive& from) {
    ShapeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ShapeArchive";
  }
  protected:
  explicit ShapeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStyleFieldNumber = 2,
    kPathsourceFieldNumber = 3,
    kHeadLineEndFieldNumber = 4,
    kTailLineEndFieldNumber = 5,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference style = 2;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSD.PathSourceArchive pathsource = 3;
  bool has_pathsource() const;
  private:
  bool _internal_has_pathsource() const;
  public:
  void clear_pathsource();
  const ::TSD::PathSourceArchive& pathsource() const;
  PROTOBUF_NODISCARD ::TSD::PathSourceArchive* release_pathsource();
  ::TSD::PathSourceArchive* mutable_pathsource();
  void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);
  private:
  const ::TSD::PathSourceArchive& _internal_pathsource() const;
  ::TSD::PathSourceArchive* _internal_mutable_pathsource();
  public:
  void unsafe_arena_set_allocated_pathsource(
      ::TSD::PathSourceArchive* pathsource);
  ::TSD::PathSourceArchive* unsafe_arena_release_pathsource();

  // optional .TSD.LineEndArchive head_line_end = 4;
  bool has_head_line_end() const;
  private:
  bool _internal_has_head_line_end() const;
  public:
  void clear_head_line_end();
  const ::TSD::LineEndArchive& head_line_end() const;
  PROTOBUF_NODISCARD ::TSD::LineEndArchive* release_head_line_end();
  ::TSD::LineEndArchive* mutable_head_line_end();
  void set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_head_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_head_line_end();
  public:
  void unsafe_arena_set_allocated_head_line_end(
      ::TSD::LineEndArchive* head_line_end);
  ::TSD::LineEndArchive* unsafe_arena_release_head_line_end();

  // optional .TSD.LineEndArchive tail_line_end = 5;
  bool has_tail_line_end() const;
  private:
  bool _internal_has_tail_line_end() const;
  public:
  void clear_tail_line_end();
  const ::TSD::LineEndArchive& tail_line_end() const;
  PROTOBUF_NODISCARD ::TSD::LineEndArchive* release_tail_line_end();
  ::TSD::LineEndArchive* mutable_tail_line_end();
  void set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end);
  private:
  const ::TSD::LineEndArchive& _internal_tail_line_end() const;
  ::TSD::LineEndArchive* _internal_mutable_tail_line_end();
  public:
  void unsafe_arena_set_allocated_tail_line_end(
      ::TSD::LineEndArchive* tail_line_end);
  ::TSD::LineEndArchive* unsafe_arena_release_tail_line_end();

  // @@protoc_insertion_point(class_scope:TSD.ShapeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::DrawableArchive* super_;
    ::TSP::Reference* style_;
    ::TSD::PathSourceArchive* pathsource_;
    ::TSD::LineEndArchive* head_line_end_;
    ::TSD::LineEndArchive* tail_line_end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ConnectionLineArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ConnectionLineArchive) */ {
 public:
  inline ConnectionLineArchive() : ConnectionLineArchive(nullptr) {}
  ~ConnectionLineArchive() override;
  explicit PROTOBUF_CONSTEXPR ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConnectionLineArchive(const ConnectionLineArchive& from);
  ConnectionLineArchive(ConnectionLineArchive&& from) noexcept
    : ConnectionLineArchive() {
    *this = ::std::move(from);
  }

  inline ConnectionLineArchive& operator=(const ConnectionLineArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionLineArchive& operator=(ConnectionLineArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectionLineArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectionLineArchive* internal_default_instance() {
    return reinterpret_cast<const ConnectionLineArchive*>(
               &_ConnectionLineArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ConnectionLineArchive& a, ConnectionLineArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionLineArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionLineArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectionLineArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConnectionLineArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConnectionLineArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConnectionLineArchive& from) {
    ConnectionLineArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionLineArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ConnectionLineArchive";
  }
  protected:
  explicit ConnectionLineArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kConnectedFromFieldNumber = 2,
    kConnectedToFieldNumber = 3,
  };
  // required .TSD.ShapeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::ShapeArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::ShapeArchive* release_super();
  ::TSD::ShapeArchive* mutable_super();
  void set_allocated_super(::TSD::ShapeArchive* super);
  private:
  const ::TSD::ShapeArchive& _internal_super() const;
  ::TSD::ShapeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::ShapeArchive* super);
  ::TSD::ShapeArchive* unsafe_arena_release_super();

  // optional .TSP.Reference connected_from = 2;
  bool has_connected_from() const;
  private:
  bool _internal_has_connected_from() const;
  public:
  void clear_connected_from();
  const ::TSP::Reference& connected_from() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_connected_from();
  ::TSP::Reference* mutable_connected_from();
  void set_allocated_connected_from(::TSP::Reference* connected_from);
  private:
  const ::TSP::Reference& _internal_connected_from() const;
  ::TSP::Reference* _internal_mutable_connected_from();
  public:
  void unsafe_arena_set_allocated_connected_from(
      ::TSP::Reference* connected_from);
  ::TSP::Reference* unsafe_arena_release_connected_from();

  // optional .TSP.Reference connected_to = 3;
  bool has_connected_to() const;
  private:
  bool _internal_has_connected_to() const;
  public:
  void clear_connected_to();
  const ::TSP::Reference& connected_to() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_connected_to();
  ::TSP::Reference* mutable_connected_to();
  void set_allocated_connected_to(::TSP::Reference* connected_to);
  private:
  const ::TSP::Reference& _internal_connected_to() const;
  ::TSP::Reference* _internal_mutable_connected_to();
  public:
  void unsafe_arena_set_allocated_connected_to(
      ::TSP::Reference* connected_to);
  ::TSP::Reference* unsafe_arena_release_connected_to();

  // @@protoc_insertion_point(class_scope:TSD.ConnectionLineArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::ShapeArchive* super_;
    ::TSP::Reference* connected_from_;
    ::TSP::Reference* connected_to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ImageArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ImageArchive) */ {
 public:
  inline ImageArchive() : ImageArchive(nullptr) {}
  ~ImageArchive() override;
  explicit PROTOBUF_CONSTEXPR ImageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageArchive(const ImageArchive& from);
  ImageArchive(ImageArchive&& from) noexcept
    : ImageArchive() {
    *this = ::std::move(from);
  }

  inline ImageArchive& operator=(const ImageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageArchive& operator=(ImageArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageArchive* internal_default_instance() {
    return reinterpret_cast<const ImageArchive*>(
               &_ImageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ImageArchive& a, ImageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageArchive& from) {
    ImageArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ImageArchive";
  }
  protected:
  explicit ImageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDatabaseDataFieldNumber = 2,
    kStyleFieldNumber = 3,
    kOriginalSizeFieldNumber = 4,
    kMaskFieldNumber = 5,
    kDatabaseThumbnailDataFieldNumber = 6,
    kDatabaseOriginalDataFieldNumber = 8,
    kNaturalSizeFieldNumber = 9,
    kInstantAlphaPathFieldNumber = 10,
    kDataFieldNumber = 11,
    kThumbnailDataFieldNumber = 12,
    kOriginalDataFieldNumber = 13,
    kImageAdjustmentsFieldNumber = 14,
    kAdjustedImageDataFieldNumber = 15,
    kThumbnailAdjustedImageDataFieldNumber = 16,
    kEnhancedImageDataFieldNumber = 17,
    kFlagsFieldNumber = 7,
    kInterpretsUntaggedImageDataAsGenericFieldNumber = 18,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference database_data = 2;
  bool has_database_data() const;
  private:
  bool _internal_has_database_data() const;
  public:
  void clear_database_data();
  const ::TSP::Reference& database_data() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_data();
  ::TSP::Reference* mutable_database_data();
  void set_allocated_database_data(::TSP::Reference* database_data);
  private:
  const ::TSP::Reference& _internal_database_data() const;
  ::TSP::Reference* _internal_mutable_database_data();
  public:
  void unsafe_arena_set_allocated_database_data(
      ::TSP::Reference* database_data);
  ::TSP::Reference* unsafe_arena_release_database_data();

  // optional .TSP.Reference style = 3;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSP.Size originalSize = 4;
  bool has_originalsize() const;
  private:
  bool _internal_has_originalsize() const;
  public:
  void clear_originalsize();
  const ::TSP::Size& originalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_originalsize();
  ::TSP::Size* mutable_originalsize();
  void set_allocated_originalsize(::TSP::Size* originalsize);
  private:
  const ::TSP::Size& _internal_originalsize() const;
  ::TSP::Size* _internal_mutable_originalsize();
  public:
  void unsafe_arena_set_allocated_originalsize(
      ::TSP::Size* originalsize);
  ::TSP::Size* unsafe_arena_release_originalsize();

  // optional .TSP.Reference mask = 5;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const ::TSP::Reference& mask() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_mask();
  ::TSP::Reference* mutable_mask();
  void set_allocated_mask(::TSP::Reference* mask);
  private:
  const ::TSP::Reference& _internal_mask() const;
  ::TSP::Reference* _internal_mutable_mask();
  public:
  void unsafe_arena_set_allocated_mask(
      ::TSP::Reference* mask);
  ::TSP::Reference* unsafe_arena_release_mask();

  // optional .TSP.Reference database_thumbnailData = 6;
  bool has_database_thumbnaildata() const;
  private:
  bool _internal_has_database_thumbnaildata() const;
  public:
  void clear_database_thumbnaildata();
  const ::TSP::Reference& database_thumbnaildata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_thumbnaildata();
  ::TSP::Reference* mutable_database_thumbnaildata();
  void set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata);
  private:
  const ::TSP::Reference& _internal_database_thumbnaildata() const;
  ::TSP::Reference* _internal_mutable_database_thumbnaildata();
  public:
  void unsafe_arena_set_allocated_database_thumbnaildata(
      ::TSP::Reference* database_thumbnaildata);
  ::TSP::Reference* unsafe_arena_release_database_thumbnaildata();

  // optional .TSP.Reference database_originalData = 8;
  bool has_database_originaldata() const;
  private:
  bool _internal_has_database_originaldata() const;
  public:
  void clear_database_originaldata();
  const ::TSP::Reference& database_originaldata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_originaldata();
  ::TSP::Reference* mutable_database_originaldata();
  void set_allocated_database_originaldata(::TSP::Reference* database_originaldata);
  private:
  const ::TSP::Reference& _internal_database_originaldata() const;
  ::TSP::Reference* _internal_mutable_database_originaldata();
  public:
  void unsafe_arena_set_allocated_database_originaldata(
      ::TSP::Reference* database_originaldata);
  ::TSP::Reference* unsafe_arena_release_database_originaldata();

  // optional .TSP.Size naturalSize = 9;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.Path instantAlphaPath = 10;
  bool has_instantalphapath() const;
  private:
  bool _internal_has_instantalphapath() const;
  public:
  void clear_instantalphapath();
  const ::TSP::Path& instantalphapath() const;
  PROTOBUF_NODISCARD ::TSP::Path* release_instantalphapath();
  ::TSP::Path* mutable_instantalphapath();
  void set_allocated_instantalphapath(::TSP::Path* instantalphapath);
  private:
  const ::TSP::Path& _internal_instantalphapath() const;
  ::TSP::Path* _internal_mutable_instantalphapath();
  public:
  void unsafe_arena_set_allocated_instantalphapath(
      ::TSP::Path* instantalphapath);
  ::TSP::Path* unsafe_arena_release_instantalphapath();

  // optional .TSP.DataReference data = 11;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::TSP::DataReference& data() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_data();
  ::TSP::DataReference* mutable_data();
  void set_allocated_data(::TSP::DataReference* data);
  private:
  const ::TSP::DataReference& _internal_data() const;
  ::TSP::DataReference* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::TSP::DataReference* data);
  ::TSP::DataReference* unsafe_arena_release_data();

  // optional .TSP.DataReference thumbnailData = 12;
  bool has_thumbnaildata() const;
  private:
  bool _internal_has_thumbnaildata() const;
  public:
  void clear_thumbnaildata();
  const ::TSP::DataReference& thumbnaildata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_thumbnaildata();
  ::TSP::DataReference* mutable_thumbnaildata();
  void set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata);
  private:
  const ::TSP::DataReference& _internal_thumbnaildata() const;
  ::TSP::DataReference* _internal_mutable_thumbnaildata();
  public:
  void unsafe_arena_set_allocated_thumbnaildata(
      ::TSP::DataReference* thumbnaildata);
  ::TSP::DataReference* unsafe_arena_release_thumbnaildata();

  // optional .TSP.DataReference originalData = 13;
  bool has_originaldata() const;
  private:
  bool _internal_has_originaldata() const;
  public:
  void clear_originaldata();
  const ::TSP::DataReference& originaldata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_originaldata();
  ::TSP::DataReference* mutable_originaldata();
  void set_allocated_originaldata(::TSP::DataReference* originaldata);
  private:
  const ::TSP::DataReference& _internal_originaldata() const;
  ::TSP::DataReference* _internal_mutable_originaldata();
  public:
  void unsafe_arena_set_allocated_originaldata(
      ::TSP::DataReference* originaldata);
  ::TSP::DataReference* unsafe_arena_release_originaldata();

  // optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
  bool has_imageadjustments() const;
  private:
  bool _internal_has_imageadjustments() const;
  public:
  void clear_imageadjustments();
  const ::TSD::ImageAdjustmentsArchive& imageadjustments() const;
  PROTOBUF_NODISCARD ::TSD::ImageAdjustmentsArchive* release_imageadjustments();
  ::TSD::ImageAdjustmentsArchive* mutable_imageadjustments();
  void set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments);
  private:
  const ::TSD::ImageAdjustmentsArchive& _internal_imageadjustments() const;
  ::TSD::ImageAdjustmentsArchive* _internal_mutable_imageadjustments();
  public:
  void unsafe_arena_set_allocated_imageadjustments(
      ::TSD::ImageAdjustmentsArchive* imageadjustments);
  ::TSD::ImageAdjustmentsArchive* unsafe_arena_release_imageadjustments();

  // optional .TSP.DataReference adjustedImageData = 15;
  bool has_adjustedimagedata() const;
  private:
  bool _internal_has_adjustedimagedata() const;
  public:
  void clear_adjustedimagedata();
  const ::TSP::DataReference& adjustedimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_adjustedimagedata();
  ::TSP::DataReference* mutable_adjustedimagedata();
  void set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata);
  private:
  const ::TSP::DataReference& _internal_adjustedimagedata() const;
  ::TSP::DataReference* _internal_mutable_adjustedimagedata();
  public:
  void unsafe_arena_set_allocated_adjustedimagedata(
      ::TSP::DataReference* adjustedimagedata);
  ::TSP::DataReference* unsafe_arena_release_adjustedimagedata();

  // optional .TSP.DataReference thumbnailAdjustedImageData = 16;
  bool has_thumbnailadjustedimagedata() const;
  private:
  bool _internal_has_thumbnailadjustedimagedata() const;
  public:
  void clear_thumbnailadjustedimagedata();
  const ::TSP::DataReference& thumbnailadjustedimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_thumbnailadjustedimagedata();
  ::TSP::DataReference* mutable_thumbnailadjustedimagedata();
  void set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata);
  private:
  const ::TSP::DataReference& _internal_thumbnailadjustedimagedata() const;
  ::TSP::DataReference* _internal_mutable_thumbnailadjustedimagedata();
  public:
  void unsafe_arena_set_allocated_thumbnailadjustedimagedata(
      ::TSP::DataReference* thumbnailadjustedimagedata);
  ::TSP::DataReference* unsafe_arena_release_thumbnailadjustedimagedata();

  // optional .TSP.DataReference enhancedImageData = 17;
  bool has_enhancedimagedata() const;
  private:
  bool _internal_has_enhancedimagedata() const;
  public:
  void clear_enhancedimagedata();
  const ::TSP::DataReference& enhancedimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_enhancedimagedata();
  ::TSP::DataReference* mutable_enhancedimagedata();
  void set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata);
  private:
  const ::TSP::DataReference& _internal_enhancedimagedata() const;
  ::TSP::DataReference* _internal_mutable_enhancedimagedata();
  public:
  void unsafe_arena_set_allocated_enhancedimagedata(
      ::TSP::DataReference* enhancedimagedata);
  ::TSP::DataReference* unsafe_arena_release_enhancedimagedata();

  // optional uint32 flags = 7;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional bool interpretsUntaggedImageDataAsGeneric = 18;
  bool has_interpretsuntaggedimagedataasgeneric() const;
  private:
  bool _internal_has_interpretsuntaggedimagedataasgeneric() const;
  public:
  void clear_interpretsuntaggedimagedataasgeneric();
  bool interpretsuntaggedimagedataasgeneric() const;
  void set_interpretsuntaggedimagedataasgeneric(bool value);
  private:
  bool _internal_interpretsuntaggedimagedataasgeneric() const;
  void _internal_set_interpretsuntaggedimagedataasgeneric(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ImageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::DrawableArchive* super_;
    ::TSP::Reference* database_data_;
    ::TSP::Reference* style_;
    ::TSP::Size* originalsize_;
    ::TSP::Reference* mask_;
    ::TSP::Reference* database_thumbnaildata_;
    ::TSP::Reference* database_originaldata_;
    ::TSP::Size* naturalsize_;
    ::TSP::Path* instantalphapath_;
    ::TSP::DataReference* data_;
    ::TSP::DataReference* thumbnaildata_;
    ::TSP::DataReference* originaldata_;
    ::TSD::ImageAdjustmentsArchive* imageadjustments_;
    ::TSP::DataReference* adjustedimagedata_;
    ::TSP::DataReference* thumbnailadjustedimagedata_;
    ::TSP::DataReference* enhancedimagedata_;
    uint32_t flags_;
    bool interpretsuntaggedimagedataasgeneric_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MaskArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MaskArchive) */ {
 public:
  inline MaskArchive() : MaskArchive(nullptr) {}
  ~MaskArchive() override;
  explicit PROTOBUF_CONSTEXPR MaskArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MaskArchive(const MaskArchive& from);
  MaskArchive(MaskArchive&& from) noexcept
    : MaskArchive() {
    *this = ::std::move(from);
  }

  inline MaskArchive& operator=(const MaskArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MaskArchive& operator=(MaskArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MaskArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MaskArchive* internal_default_instance() {
    return reinterpret_cast<const MaskArchive*>(
               &_MaskArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MaskArchive& a, MaskArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MaskArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MaskArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MaskArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MaskArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MaskArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MaskArchive& from) {
    MaskArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaskArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MaskArchive";
  }
  protected:
  explicit MaskArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kPathsourceFieldNumber = 2,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSD.PathSourceArchive pathsource = 2;
  bool has_pathsource() const;
  private:
  bool _internal_has_pathsource() const;
  public:
  void clear_pathsource();
  const ::TSD::PathSourceArchive& pathsource() const;
  PROTOBUF_NODISCARD ::TSD::PathSourceArchive* release_pathsource();
  ::TSD::PathSourceArchive* mutable_pathsource();
  void set_allocated_pathsource(::TSD::PathSourceArchive* pathsource);
  private:
  const ::TSD::PathSourceArchive& _internal_pathsource() const;
  ::TSD::PathSourceArchive* _internal_mutable_pathsource();
  public:
  void unsafe_arena_set_allocated_pathsource(
      ::TSD::PathSourceArchive* pathsource);
  ::TSD::PathSourceArchive* unsafe_arena_release_pathsource();

  // @@protoc_insertion_point(class_scope:TSD.MaskArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::DrawableArchive* super_;
    ::TSD::PathSourceArchive* pathsource_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class MovieArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.MovieArchive) */ {
 public:
  inline MovieArchive() : MovieArchive(nullptr) {}
  ~MovieArchive() override;
  explicit PROTOBUF_CONSTEXPR MovieArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovieArchive(const MovieArchive& from);
  MovieArchive(MovieArchive&& from) noexcept
    : MovieArchive() {
    *this = ::std::move(from);
  }

  inline MovieArchive& operator=(const MovieArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovieArchive& operator=(MovieArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovieArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovieArchive* internal_default_instance() {
    return reinterpret_cast<const MovieArchive*>(
               &_MovieArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MovieArchive& a, MovieArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MovieArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovieArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MovieArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MovieArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovieArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MovieArchive& from) {
    MovieArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovieArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.MovieArchive";
  }
  protected:
  explicit MovieArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovieRemoteURLFieldNumber = 17,
    kSuperFieldNumber = 1,
    kDatabaseMovieDataFieldNumber = 2,
    kDatabasePosterImageDataFieldNumber = 10,
    kDatabaseAudioOnlyImageDataFieldNumber = 11,
    kMovieDataFieldNumber = 14,
    kPosterImageDataFieldNumber = 15,
    kAudioOnlyImageDataFieldNumber = 16,
    kStyleFieldNumber = 19,
    kOriginalSizeFieldNumber = 20,
    kNaturalSizeFieldNumber = 21,
    kImportedAuxiliaryMovieDataFieldNumber = 22,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kPosterTimeFieldNumber = 5,
    kLoopOptionFieldNumber = 6,
    kVolumeFieldNumber = 7,
    kAutoPlayFieldNumber = 8,
    kAudioOnlyFieldNumber = 9,
    kStreamingFieldNumber = 18,
    kPlayableStateFieldNumber = 12,
    kFlagsFieldNumber = 13,
  };
  // optional string movieRemoteURL = 17;
  bool has_movieremoteurl() const;
  private:
  bool _internal_has_movieremoteurl() const;
  public:
  void clear_movieremoteurl();
  const std::string& movieremoteurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_movieremoteurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_movieremoteurl();
  PROTOBUF_NODISCARD std::string* release_movieremoteurl();
  void set_allocated_movieremoteurl(std::string* movieremoteurl);
  private:
  const std::string& _internal_movieremoteurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_movieremoteurl(const std::string& value);
  std::string* _internal_mutable_movieremoteurl();
  public:

  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // optional .TSP.Reference database_movieData = 2;
  bool has_database_moviedata() const;
  private:
  bool _internal_has_database_moviedata() const;
  public:
  void clear_database_moviedata();
  const ::TSP::Reference& database_moviedata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_moviedata();
  ::TSP::Reference* mutable_database_moviedata();
  void set_allocated_database_moviedata(::TSP::Reference* database_moviedata);
  private:
  const ::TSP::Reference& _internal_database_moviedata() const;
  ::TSP::Reference* _internal_mutable_database_moviedata();
  public:
  void unsafe_arena_set_allocated_database_moviedata(
      ::TSP::Reference* database_moviedata);
  ::TSP::Reference* unsafe_arena_release_database_moviedata();

  // optional .TSP.Reference database_posterImageData = 10;
  bool has_database_posterimagedata() const;
  private:
  bool _internal_has_database_posterimagedata() const;
  public:
  void clear_database_posterimagedata();
  const ::TSP::Reference& database_posterimagedata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_posterimagedata();
  ::TSP::Reference* mutable_database_posterimagedata();
  void set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata);
  private:
  const ::TSP::Reference& _internal_database_posterimagedata() const;
  ::TSP::Reference* _internal_mutable_database_posterimagedata();
  public:
  void unsafe_arena_set_allocated_database_posterimagedata(
      ::TSP::Reference* database_posterimagedata);
  ::TSP::Reference* unsafe_arena_release_database_posterimagedata();

  // optional .TSP.Reference database_audioOnlyImageData = 11;
  bool has_database_audioonlyimagedata() const;
  private:
  bool _internal_has_database_audioonlyimagedata() const;
  public:
  void clear_database_audioonlyimagedata();
  const ::TSP::Reference& database_audioonlyimagedata() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_database_audioonlyimagedata();
  ::TSP::Reference* mutable_database_audioonlyimagedata();
  void set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata);
  private:
  const ::TSP::Reference& _internal_database_audioonlyimagedata() const;
  ::TSP::Reference* _internal_mutable_database_audioonlyimagedata();
  public:
  void unsafe_arena_set_allocated_database_audioonlyimagedata(
      ::TSP::Reference* database_audioonlyimagedata);
  ::TSP::Reference* unsafe_arena_release_database_audioonlyimagedata();

  // optional .TSP.DataReference movieData = 14;
  bool has_moviedata() const;
  private:
  bool _internal_has_moviedata() const;
  public:
  void clear_moviedata();
  const ::TSP::DataReference& moviedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_moviedata();
  ::TSP::DataReference* mutable_moviedata();
  void set_allocated_moviedata(::TSP::DataReference* moviedata);
  private:
  const ::TSP::DataReference& _internal_moviedata() const;
  ::TSP::DataReference* _internal_mutable_moviedata();
  public:
  void unsafe_arena_set_allocated_moviedata(
      ::TSP::DataReference* moviedata);
  ::TSP::DataReference* unsafe_arena_release_moviedata();

  // optional .TSP.DataReference posterImageData = 15;
  bool has_posterimagedata() const;
  private:
  bool _internal_has_posterimagedata() const;
  public:
  void clear_posterimagedata();
  const ::TSP::DataReference& posterimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_posterimagedata();
  ::TSP::DataReference* mutable_posterimagedata();
  void set_allocated_posterimagedata(::TSP::DataReference* posterimagedata);
  private:
  const ::TSP::DataReference& _internal_posterimagedata() const;
  ::TSP::DataReference* _internal_mutable_posterimagedata();
  public:
  void unsafe_arena_set_allocated_posterimagedata(
      ::TSP::DataReference* posterimagedata);
  ::TSP::DataReference* unsafe_arena_release_posterimagedata();

  // optional .TSP.DataReference audioOnlyImageData = 16;
  bool has_audioonlyimagedata() const;
  private:
  bool _internal_has_audioonlyimagedata() const;
  public:
  void clear_audioonlyimagedata();
  const ::TSP::DataReference& audioonlyimagedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_audioonlyimagedata();
  ::TSP::DataReference* mutable_audioonlyimagedata();
  void set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata);
  private:
  const ::TSP::DataReference& _internal_audioonlyimagedata() const;
  ::TSP::DataReference* _internal_mutable_audioonlyimagedata();
  public:
  void unsafe_arena_set_allocated_audioonlyimagedata(
      ::TSP::DataReference* audioonlyimagedata);
  ::TSP::DataReference* unsafe_arena_release_audioonlyimagedata();

  // optional .TSP.Reference style = 19;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  const ::TSP::Reference& style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_style();
  ::TSP::Reference* mutable_style();
  void set_allocated_style(::TSP::Reference* style);
  private:
  const ::TSP::Reference& _internal_style() const;
  ::TSP::Reference* _internal_mutable_style();
  public:
  void unsafe_arena_set_allocated_style(
      ::TSP::Reference* style);
  ::TSP::Reference* unsafe_arena_release_style();

  // optional .TSP.Size originalSize = 20;
  bool has_originalsize() const;
  private:
  bool _internal_has_originalsize() const;
  public:
  void clear_originalsize();
  const ::TSP::Size& originalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_originalsize();
  ::TSP::Size* mutable_originalsize();
  void set_allocated_originalsize(::TSP::Size* originalsize);
  private:
  const ::TSP::Size& _internal_originalsize() const;
  ::TSP::Size* _internal_mutable_originalsize();
  public:
  void unsafe_arena_set_allocated_originalsize(
      ::TSP::Size* originalsize);
  ::TSP::Size* unsafe_arena_release_originalsize();

  // optional .TSP.Size naturalSize = 21;
  bool has_naturalsize() const;
  private:
  bool _internal_has_naturalsize() const;
  public:
  void clear_naturalsize();
  const ::TSP::Size& naturalsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_naturalsize();
  ::TSP::Size* mutable_naturalsize();
  void set_allocated_naturalsize(::TSP::Size* naturalsize);
  private:
  const ::TSP::Size& _internal_naturalsize() const;
  ::TSP::Size* _internal_mutable_naturalsize();
  public:
  void unsafe_arena_set_allocated_naturalsize(
      ::TSP::Size* naturalsize);
  ::TSP::Size* unsafe_arena_release_naturalsize();

  // optional .TSP.DataReference importedAuxiliaryMovieData = 22;
  bool has_importedauxiliarymoviedata() const;
  private:
  bool _internal_has_importedauxiliarymoviedata() const;
  public:
  void clear_importedauxiliarymoviedata();
  const ::TSP::DataReference& importedauxiliarymoviedata() const;
  PROTOBUF_NODISCARD ::TSP::DataReference* release_importedauxiliarymoviedata();
  ::TSP::DataReference* mutable_importedauxiliarymoviedata();
  void set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata);
  private:
  const ::TSP::DataReference& _internal_importedauxiliarymoviedata() const;
  ::TSP::DataReference* _internal_mutable_importedauxiliarymoviedata();
  public:
  void unsafe_arena_set_allocated_importedauxiliarymoviedata(
      ::TSP::DataReference* importedauxiliarymoviedata);
  ::TSP::DataReference* unsafe_arena_release_importedauxiliarymoviedata();

  // optional float startTime = 3;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  float starttime() const;
  void set_starttime(float value);
  private:
  float _internal_starttime() const;
  void _internal_set_starttime(float value);
  public:

  // optional float endTime = 4;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  float endtime() const;
  void set_endtime(float value);
  private:
  float _internal_endtime() const;
  void _internal_set_endtime(float value);
  public:

  // optional float posterTime = 5;
  bool has_postertime() const;
  private:
  bool _internal_has_postertime() const;
  public:
  void clear_postertime();
  float postertime() const;
  void set_postertime(float value);
  private:
  float _internal_postertime() const;
  void _internal_set_postertime(float value);
  public:

  // optional uint32 loopOption = 6;
  bool has_loopoption() const;
  private:
  bool _internal_has_loopoption() const;
  public:
  void clear_loopoption();
  uint32_t loopoption() const;
  void set_loopoption(uint32_t value);
  private:
  uint32_t _internal_loopoption() const;
  void _internal_set_loopoption(uint32_t value);
  public:

  // optional float volume = 7;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  float volume() const;
  void set_volume(float value);
  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);
  public:

  // optional bool autoPlay = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_autoplay() const;
  private:
  bool _internal_has_autoplay() const;
  public:
  PROTOBUF_DEPRECATED void clear_autoplay();
  PROTOBUF_DEPRECATED bool autoplay() const;
  PROTOBUF_DEPRECATED void set_autoplay(bool value);
  private:
  bool _internal_autoplay() const;
  void _internal_set_autoplay(bool value);
  public:

  // optional bool audioOnly = 9;
  bool has_audioonly() const;
  private:
  bool _internal_has_audioonly() const;
  public:
  void clear_audioonly();
  bool audioonly() const;
  void set_audioonly(bool value);
  private:
  bool _internal_audioonly() const;
  void _internal_set_audioonly(bool value);
  public:

  // optional bool streaming = 18;
  bool has_streaming() const;
  private:
  bool _internal_has_streaming() const;
  public:
  void clear_streaming();
  bool streaming() const;
  void set_streaming(bool value);
  private:
  bool _internal_streaming() const;
  void _internal_set_streaming(bool value);
  public:

  // optional uint32 playableState = 12;
  bool has_playablestate() const;
  private:
  bool _internal_has_playablestate() const;
  public:
  void clear_playablestate();
  uint32_t playablestate() const;
  void set_playablestate(uint32_t value);
  private:
  uint32_t _internal_playablestate() const;
  void _internal_set_playablestate(uint32_t value);
  public:

  // optional uint32 flags = 13;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.MovieArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr movieremoteurl_;
    ::TSD::DrawableArchive* super_;
    ::TSP::Reference* database_moviedata_;
    ::TSP::Reference* database_posterimagedata_;
    ::TSP::Reference* database_audioonlyimagedata_;
    ::TSP::DataReference* moviedata_;
    ::TSP::DataReference* posterimagedata_;
    ::TSP::DataReference* audioonlyimagedata_;
    ::TSP::Reference* style_;
    ::TSP::Size* originalsize_;
    ::TSP::Size* naturalsize_;
    ::TSP::DataReference* importedauxiliarymoviedata_;
    float starttime_;
    float endtime_;
    float postertime_;
    uint32_t loopoption_;
    float volume_;
    bool autoplay_;
    bool audioonly_;
    bool streaming_;
    uint32_t playablestate_;
    uint32_t flags_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class ExteriorTextWrapArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.ExteriorTextWrapArchive) */ {
 public:
  inline ExteriorTextWrapArchive() : ExteriorTextWrapArchive(nullptr) {}
  ~ExteriorTextWrapArchive() override;
  explicit PROTOBUF_CONSTEXPR ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExteriorTextWrapArchive(const ExteriorTextWrapArchive& from);
  ExteriorTextWrapArchive(ExteriorTextWrapArchive&& from) noexcept
    : ExteriorTextWrapArchive() {
    *this = ::std::move(from);
  }

  inline ExteriorTextWrapArchive& operator=(const ExteriorTextWrapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExteriorTextWrapArchive& operator=(ExteriorTextWrapArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExteriorTextWrapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExteriorTextWrapArchive* internal_default_instance() {
    return reinterpret_cast<const ExteriorTextWrapArchive*>(
               &_ExteriorTextWrapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ExteriorTextWrapArchive& a, ExteriorTextWrapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ExteriorTextWrapArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExteriorTextWrapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExteriorTextWrapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExteriorTextWrapArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExteriorTextWrapArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExteriorTextWrapArchive& from) {
    ExteriorTextWrapArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExteriorTextWrapArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.ExteriorTextWrapArchive";
  }
  protected:
  explicit ExteriorTextWrapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kFitTypeFieldNumber = 3,
    kMarginFieldNumber = 4,
    kAlphaThresholdFieldNumber = 5,
    kIsHtmlWrapFieldNumber = 6,
  };
  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 direction = 2;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  uint32_t direction() const;
  void set_direction(uint32_t value);
  private:
  uint32_t _internal_direction() const;
  void _internal_set_direction(uint32_t value);
  public:

  // optional uint32 fit_type = 3;
  bool has_fit_type() const;
  private:
  bool _internal_has_fit_type() const;
  public:
  void clear_fit_type();
  uint32_t fit_type() const;
  void set_fit_type(uint32_t value);
  private:
  uint32_t _internal_fit_type() const;
  void _internal_set_fit_type(uint32_t value);
  public:

  // optional float margin = 4;
  bool has_margin() const;
  private:
  bool _internal_has_margin() const;
  public:
  void clear_margin();
  float margin() const;
  void set_margin(float value);
  private:
  float _internal_margin() const;
  void _internal_set_margin(float value);
  public:

  // optional float alpha_threshold = 5;
  bool has_alpha_threshold() const;
  private:
  bool _internal_has_alpha_threshold() const;
  public:
  void clear_alpha_threshold();
  float alpha_threshold() const;
  void set_alpha_threshold(float value);
  private:
  float _internal_alpha_threshold() const;
  void _internal_set_alpha_threshold(float value);
  public:

  // optional bool is_html_wrap = 6;
  bool has_is_html_wrap() const;
  private:
  bool _internal_has_is_html_wrap() const;
  public:
  void clear_is_html_wrap();
  bool is_html_wrap() const;
  void set_is_html_wrap(bool value);
  private:
  bool _internal_is_html_wrap() const;
  void _internal_set_is_html_wrap(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.ExteriorTextWrapArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t type_;
    uint32_t direction_;
    uint32_t fit_type_;
    float margin_;
    float alpha_threshold_;
    bool is_html_wrap_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GuideArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GuideArchive) */ {
 public:
  inline GuideArchive() : GuideArchive(nullptr) {}
  ~GuideArchive() override;
  explicit PROTOBUF_CONSTEXPR GuideArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuideArchive(const GuideArchive& from);
  GuideArchive(GuideArchive&& from) noexcept
    : GuideArchive() {
    *this = ::std::move(from);
  }

  inline GuideArchive& operator=(const GuideArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideArchive& operator=(GuideArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideArchive* internal_default_instance() {
    return reinterpret_cast<const GuideArchive*>(
               &_GuideArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(GuideArchive& a, GuideArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GuideArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuideArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuideArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuideArchive& from) {
    GuideArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuideArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GuideArchive";
  }
  protected:
  explicit GuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuideArchive_GuideType GuideType;
  static constexpr GuideType Horizontal =
    GuideArchive_GuideType_Horizontal;
  static constexpr GuideType Vertical =
    GuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return GuideArchive_GuideType_IsValid(value);
  }
  static constexpr GuideType GuideType_MIN =
    GuideArchive_GuideType_GuideType_MIN;
  static constexpr GuideType GuideType_MAX =
    GuideArchive_GuideType_GuideType_MAX;
  static constexpr int GuideType_ARRAYSIZE =
    GuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GuideType_descriptor() {
    return GuideArchive_GuideType_descriptor();
  }
  template<typename T>
  static inline const std::string& GuideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GuideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GuideType_Name.");
    return GuideArchive_GuideType_Name(enum_t_value);
  }
  static inline bool GuideType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GuideType* value) {
    return GuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDynamicFieldNumber = 5,
    kInfiniteFieldNumber = 6,
  };
  // optional .TSD.GuideArchive.GuideType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::GuideArchive_GuideType type() const;
  void set_type(::TSD::GuideArchive_GuideType value);
  private:
  ::TSD::GuideArchive_GuideType _internal_type() const;
  void _internal_set_type(::TSD::GuideArchive_GuideType value);
  public:

  // optional float offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // optional float start = 3;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  float start() const;
  void set_start(float value);
  private:
  float _internal_start() const;
  void _internal_set_start(float value);
  public:

  // optional float end = 4;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  float end() const;
  void set_end(float value);
  private:
  float _internal_end() const;
  void _internal_set_end(float value);
  public:

  // optional bool dynamic = 5;
  bool has_dynamic() const;
  private:
  bool _internal_has_dynamic() const;
  public:
  void clear_dynamic();
  bool dynamic() const;
  void set_dynamic(bool value);
  private:
  bool _internal_dynamic() const;
  void _internal_set_dynamic(bool value);
  public:

  // optional bool infinite = 6;
  bool has_infinite() const;
  private:
  bool _internal_has_infinite() const;
  public:
  void clear_infinite();
  bool infinite() const;
  void set_infinite(bool value);
  private:
  bool _internal_infinite() const;
  void _internal_set_infinite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.GuideArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
    float offset_;
    float start_;
    float end_;
    bool dynamic_;
    bool infinite_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class UserDefinedGuideArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.UserDefinedGuideArchive) */ {
 public:
  inline UserDefinedGuideArchive() : UserDefinedGuideArchive(nullptr) {}
  ~UserDefinedGuideArchive() override;
  explicit PROTOBUF_CONSTEXPR UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDefinedGuideArchive(const UserDefinedGuideArchive& from);
  UserDefinedGuideArchive(UserDefinedGuideArchive&& from) noexcept
    : UserDefinedGuideArchive() {
    *this = ::std::move(from);
  }

  inline UserDefinedGuideArchive& operator=(const UserDefinedGuideArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDefinedGuideArchive& operator=(UserDefinedGuideArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDefinedGuideArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDefinedGuideArchive* internal_default_instance() {
    return reinterpret_cast<const UserDefinedGuideArchive*>(
               &_UserDefinedGuideArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(UserDefinedGuideArchive& a, UserDefinedGuideArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDefinedGuideArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDefinedGuideArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDefinedGuideArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDefinedGuideArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDefinedGuideArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserDefinedGuideArchive& from) {
    UserDefinedGuideArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDefinedGuideArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.UserDefinedGuideArchive";
  }
  protected:
  explicit UserDefinedGuideArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserDefinedGuideArchive_GuideType GuideType;
  static constexpr GuideType Horizontal =
    UserDefinedGuideArchive_GuideType_Horizontal;
  static constexpr GuideType Vertical =
    UserDefinedGuideArchive_GuideType_Vertical;
  static inline bool GuideType_IsValid(int value) {
    return UserDefinedGuideArchive_GuideType_IsValid(value);
  }
  static constexpr GuideType GuideType_MIN =
    UserDefinedGuideArchive_GuideType_GuideType_MIN;
  static constexpr GuideType GuideType_MAX =
    UserDefinedGuideArchive_GuideType_GuideType_MAX;
  static constexpr int GuideType_ARRAYSIZE =
    UserDefinedGuideArchive_GuideType_GuideType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GuideType_descriptor() {
    return UserDefinedGuideArchive_GuideType_descriptor();
  }
  template<typename T>
  static inline const std::string& GuideType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GuideType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GuideType_Name.");
    return UserDefinedGuideArchive_GuideType_Name(enum_t_value);
  }
  static inline bool GuideType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GuideType* value) {
    return UserDefinedGuideArchive_GuideType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPositionFieldNumber = 2,
  };
  // optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSD::UserDefinedGuideArchive_GuideType type() const;
  void set_type(::TSD::UserDefinedGuideArchive_GuideType value);
  private:
  ::TSD::UserDefinedGuideArchive_GuideType _internal_type() const;
  void _internal_set_type(::TSD::UserDefinedGuideArchive_GuideType value);
  public:

  // optional float position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  float position() const;
  void set_position(float value);
  private:
  float _internal_position() const;
  void _internal_set_position(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSD.UserDefinedGuideArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int type_;
    float position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class GuideStorageArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.GuideStorageArchive) */ {
 public:
  inline GuideStorageArchive() : GuideStorageArchive(nullptr) {}
  ~GuideStorageArchive() override;
  explicit PROTOBUF_CONSTEXPR GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuideStorageArchive(const GuideStorageArchive& from);
  GuideStorageArchive(GuideStorageArchive&& from) noexcept
    : GuideStorageArchive() {
    *this = ::std::move(from);
  }

  inline GuideStorageArchive& operator=(const GuideStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideStorageArchive& operator=(GuideStorageArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideStorageArchive* internal_default_instance() {
    return reinterpret_cast<const GuideStorageArchive*>(
               &_GuideStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(GuideStorageArchive& a, GuideStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(GuideStorageArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuideStorageArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuideStorageArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuideStorageArchive& from) {
    GuideStorageArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuideStorageArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.GuideStorageArchive";
  }
  protected:
  explicit GuideStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDefinedGuidesFieldNumber = 1,
  };
  // repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
  int userdefinedguides_size() const;
  private:
  int _internal_userdefinedguides_size() const;
  public:
  void clear_userdefinedguides();
  ::TSD::UserDefinedGuideArchive* mutable_userdefinedguides(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
      mutable_userdefinedguides();
  private:
  const ::TSD::UserDefinedGuideArchive& _internal_userdefinedguides(int index) const;
  ::TSD::UserDefinedGuideArchive* _internal_add_userdefinedguides();
  public:
  const ::TSD::UserDefinedGuideArchive& userdefinedguides(int index) const;
  ::TSD::UserDefinedGuideArchive* add_userdefinedguides();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
      userdefinedguides() const;

  // @@protoc_insertion_point(class_scope:TSD.GuideStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive > userdefinedguides_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CanvasSelectionArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CanvasSelectionArchive) */ {
 public:
  inline CanvasSelectionArchive() : CanvasSelectionArchive(nullptr) {}
  ~CanvasSelectionArchive() override;
  explicit PROTOBUF_CONSTEXPR CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CanvasSelectionArchive(const CanvasSelectionArchive& from);
  CanvasSelectionArchive(CanvasSelectionArchive&& from) noexcept
    : CanvasSelectionArchive() {
    *this = ::std::move(from);
  }

  inline CanvasSelectionArchive& operator=(const CanvasSelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanvasSelectionArchive& operator=(CanvasSelectionArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanvasSelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanvasSelectionArchive* internal_default_instance() {
    return reinterpret_cast<const CanvasSelectionArchive*>(
               &_CanvasSelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CanvasSelectionArchive& a, CanvasSelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CanvasSelectionArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanvasSelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanvasSelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CanvasSelectionArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CanvasSelectionArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CanvasSelectionArchive& from) {
    CanvasSelectionArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanvasSelectionArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CanvasSelectionArchive";
  }
  protected:
  explicit CanvasSelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
    kContainerFieldNumber = 2,
  };
  // repeated .TSP.Reference infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::TSP::Reference* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_infos();
  private:
  const ::TSP::Reference& _internal_infos(int index) const;
  ::TSP::Reference* _internal_add_infos();
  public:
  const ::TSP::Reference& infos(int index) const;
  ::TSP::Reference* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      infos() const;

  // optional .TSP.Reference container = 2;
  bool has_container() const;
  private:
  bool _internal_has_container() const;
  public:
  void clear_container();
  const ::TSP::Reference& container() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_container();
  ::TSP::Reference* mutable_container();
  void set_allocated_container(::TSP::Reference* container);
  private:
  const ::TSP::Reference& _internal_container() const;
  ::TSP::Reference* _internal_mutable_container();
  public:
  void unsafe_arena_set_allocated_container(
      ::TSP::Reference* container);
  ::TSP::Reference* unsafe_arena_release_container();

  // @@protoc_insertion_point(class_scope:TSD.CanvasSelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > infos_;
    ::TSP::Reference* container_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// -------------------------------------------------------------------

class CommentStorageArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSD.CommentStorageArchive) */ {
 public:
  inline CommentStorageArchive() : CommentStorageArchive(nullptr) {}
  ~CommentStorageArchive() override;
  explicit PROTOBUF_CONSTEXPR CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommentStorageArchive(const CommentStorageArchive& from);
  CommentStorageArchive(CommentStorageArchive&& from) noexcept
    : CommentStorageArchive() {
    *this = ::std::move(from);
  }

  inline CommentStorageArchive& operator=(const CommentStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommentStorageArchive& operator=(CommentStorageArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommentStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommentStorageArchive* internal_default_instance() {
    return reinterpret_cast<const CommentStorageArchive*>(
               &_CommentStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CommentStorageArchive& a, CommentStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommentStorageArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommentStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommentStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommentStorageArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommentStorageArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommentStorageArchive& from) {
    CommentStorageArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentStorageArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSD.CommentStorageArchive";
  }
  protected:
  explicit CommentStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kCreationDateFieldNumber = 2,
    kAuthorFieldNumber = 3,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .TSP.Date creation_date = 2;
  bool has_creation_date() const;
  private:
  bool _internal_has_creation_date() const;
  public:
  void clear_creation_date();
  const ::TSP::Date& creation_date() const;
  PROTOBUF_NODISCARD ::TSP::Date* release_creation_date();
  ::TSP::Date* mutable_creation_date();
  void set_allocated_creation_date(::TSP::Date* creation_date);
  private:
  const ::TSP::Date& _internal_creation_date() const;
  ::TSP::Date* _internal_mutable_creation_date();
  public:
  void unsafe_arena_set_allocated_creation_date(
      ::TSP::Date* creation_date);
  ::TSP::Date* unsafe_arena_release_creation_date();

  // optional .TSP.Reference author = 3;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::TSP::Reference& author() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_author();
  ::TSP::Reference* mutable_author();
  void set_allocated_author(::TSP::Reference* author);
  private:
  const ::TSP::Reference& _internal_author() const;
  ::TSP::Reference* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::TSP::Reference* author);
  ::TSP::Reference* unsafe_arena_release_author();

  // @@protoc_insertion_point(class_scope:TSD.CommentStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::TSP::Date* creation_date_;
    ::TSP::Reference* author_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSDArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EdgeInsetsArchive

// required float top = 1;
inline bool EdgeInsetsArchive::_internal_has_top() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_top() const {
  return _internal_has_top();
}
inline void EdgeInsetsArchive::clear_top() {
  _impl_.top_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float EdgeInsetsArchive::_internal_top() const {
  return _impl_.top_;
}
inline float EdgeInsetsArchive::top() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.top)
  return _internal_top();
}
inline void EdgeInsetsArchive::_internal_set_top(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.top_ = value;
}
inline void EdgeInsetsArchive::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.top)
}

// required float left = 2;
inline bool EdgeInsetsArchive::_internal_has_left() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_left() const {
  return _internal_has_left();
}
inline void EdgeInsetsArchive::clear_left() {
  _impl_.left_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float EdgeInsetsArchive::_internal_left() const {
  return _impl_.left_;
}
inline float EdgeInsetsArchive::left() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.left)
  return _internal_left();
}
inline void EdgeInsetsArchive::_internal_set_left(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.left_ = value;
}
inline void EdgeInsetsArchive::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.left)
}

// required float bottom = 3;
inline bool EdgeInsetsArchive::_internal_has_bottom() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_bottom() const {
  return _internal_has_bottom();
}
inline void EdgeInsetsArchive::clear_bottom() {
  _impl_.bottom_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float EdgeInsetsArchive::_internal_bottom() const {
  return _impl_.bottom_;
}
inline float EdgeInsetsArchive::bottom() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.bottom)
  return _internal_bottom();
}
inline void EdgeInsetsArchive::_internal_set_bottom(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bottom_ = value;
}
inline void EdgeInsetsArchive::set_bottom(float value) {
  _internal_set_bottom(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.bottom)
}

// required float right = 4;
inline bool EdgeInsetsArchive::_internal_has_right() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EdgeInsetsArchive::has_right() const {
  return _internal_has_right();
}
inline void EdgeInsetsArchive::clear_right() {
  _impl_.right_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float EdgeInsetsArchive::_internal_right() const {
  return _impl_.right_;
}
inline float EdgeInsetsArchive::right() const {
  // @@protoc_insertion_point(field_get:TSD.EdgeInsetsArchive.right)
  return _internal_right();
}
inline void EdgeInsetsArchive::_internal_set_right(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.right_ = value;
}
inline void EdgeInsetsArchive::set_right(float value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:TSD.EdgeInsetsArchive.right)
}

// -------------------------------------------------------------------

// GeometryArchive

// optional .TSP.Point position = 1;
inline bool GeometryArchive::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline bool GeometryArchive::has_position() const {
  return _internal_has_position();
}
inline const ::TSP::Point& GeometryArchive::_internal_position() const {
  const ::TSP::Point* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& GeometryArchive::position() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.position)
  return _internal_position();
}
inline void GeometryArchive::unsafe_arena_set_allocated_position(
    ::TSP::Point* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GeometryArchive.position)
}
inline ::TSP::Point* GeometryArchive::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* GeometryArchive::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:TSD.GeometryArchive.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::TSP::Point* GeometryArchive::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::TSP::Point* GeometryArchive::mutable_position() {
  ::TSP::Point* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:TSD.GeometryArchive.position)
  return _msg;
}
inline void GeometryArchive::set_allocated_position(::TSP::Point* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:TSD.GeometryArchive.position)
}

// optional .TSP.Size size = 2;
inline bool GeometryArchive::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_ != nullptr);
  return value;
}
inline bool GeometryArchive::has_size() const {
  return _internal_has_size();
}
inline const ::TSP::Size& GeometryArchive::_internal_size() const {
  const ::TSP::Size* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& GeometryArchive::size() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.size)
  return _internal_size();
}
inline void GeometryArchive::unsafe_arena_set_allocated_size(
    ::TSP::Size* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GeometryArchive.size)
}
inline ::TSP::Size* GeometryArchive::release_size() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* GeometryArchive::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:TSD.GeometryArchive.size)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::TSP::Size* GeometryArchive::_internal_mutable_size() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::TSP::Size* GeometryArchive::mutable_size() {
  ::TSP::Size* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:TSD.GeometryArchive.size)
  return _msg;
}
inline void GeometryArchive::set_allocated_size(::TSP::Size* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size));
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:TSD.GeometryArchive.size)
}

// optional uint32 flags = 3;
inline bool GeometryArchive::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GeometryArchive::has_flags() const {
  return _internal_has_flags();
}
inline void GeometryArchive::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GeometryArchive::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t GeometryArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.flags)
  return _internal_flags();
}
inline void GeometryArchive::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.flags_ = value;
}
inline void GeometryArchive::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.GeometryArchive.flags)
}

// optional float angle = 4;
inline bool GeometryArchive::_internal_has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GeometryArchive::has_angle() const {
  return _internal_has_angle();
}
inline void GeometryArchive::clear_angle() {
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float GeometryArchive::_internal_angle() const {
  return _impl_.angle_;
}
inline float GeometryArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.GeometryArchive.angle)
  return _internal_angle();
}
inline void GeometryArchive::_internal_set_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.angle_ = value;
}
inline void GeometryArchive::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.GeometryArchive.angle)
}

// -------------------------------------------------------------------

// PointPathSourceArchive

// optional .TSD.PointPathSourceArchive.PointPathSourceType type = 1;
inline bool PointPathSourceArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PointPathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void PointPathSourceArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TSD::PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::PointPathSourceArchive_PointPathSourceType >(_impl_.type_);
}
inline ::TSD::PointPathSourceArchive_PointPathSourceType PointPathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.type)
  return _internal_type();
}
inline void PointPathSourceArchive::_internal_set_type(::TSD::PointPathSourceArchive_PointPathSourceType value) {
  assert(::TSD::PointPathSourceArchive_PointPathSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void PointPathSourceArchive::set_type(::TSD::PointPathSourceArchive_PointPathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.PointPathSourceArchive.type)
}

// optional .TSP.Point point = 2;
inline bool PointPathSourceArchive::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline bool PointPathSourceArchive::has_point() const {
  return _internal_has_point();
}
inline const ::TSP::Point& PointPathSourceArchive::_internal_point() const {
  const ::TSP::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& PointPathSourceArchive::point() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.point)
  return _internal_point();
}
inline void PointPathSourceArchive::unsafe_arena_set_allocated_point(
    ::TSP::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PointPathSourceArchive.point)
}
inline ::TSP::Point* PointPathSourceArchive::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* PointPathSourceArchive::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:TSD.PointPathSourceArchive.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::TSP::Point* PointPathSourceArchive::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::TSP::Point* PointPathSourceArchive::mutable_point() {
  ::TSP::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:TSD.PointPathSourceArchive.point)
  return _msg;
}
inline void PointPathSourceArchive::set_allocated_point(::TSP::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point));
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:TSD.PointPathSourceArchive.point)
}

// optional .TSP.Size naturalSize = 3;
inline bool PointPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool PointPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& PointPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& PointPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.PointPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void PointPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PointPathSourceArchive.naturalSize)
}
inline ::TSP::Size* PointPathSourceArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* PointPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.PointPathSourceArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* PointPathSourceArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* PointPathSourceArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.PointPathSourceArchive.naturalSize)
  return _msg;
}
inline void PointPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.PointPathSourceArchive.naturalSize)
}

// -------------------------------------------------------------------

// ScalarPathSourceArchive

// optional .TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1;
inline bool ScalarPathSourceArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScalarPathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void ScalarPathSourceArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType >(_impl_.type_);
}
inline ::TSD::ScalarPathSourceArchive_ScalarPathSourceType ScalarPathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.type)
  return _internal_type();
}
inline void ScalarPathSourceArchive::_internal_set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value) {
  assert(::TSD::ScalarPathSourceArchive_ScalarPathSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void ScalarPathSourceArchive::set_type(::TSD::ScalarPathSourceArchive_ScalarPathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ScalarPathSourceArchive.type)
}

// optional float scalar = 2;
inline bool ScalarPathSourceArchive::_internal_has_scalar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScalarPathSourceArchive::has_scalar() const {
  return _internal_has_scalar();
}
inline void ScalarPathSourceArchive::clear_scalar() {
  _impl_.scalar_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ScalarPathSourceArchive::_internal_scalar() const {
  return _impl_.scalar_;
}
inline float ScalarPathSourceArchive::scalar() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.scalar)
  return _internal_scalar();
}
inline void ScalarPathSourceArchive::_internal_set_scalar(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.scalar_ = value;
}
inline void ScalarPathSourceArchive::set_scalar(float value) {
  _internal_set_scalar(value);
  // @@protoc_insertion_point(field_set:TSD.ScalarPathSourceArchive.scalar)
}

// optional .TSP.Size naturalSize = 3;
inline bool ScalarPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool ScalarPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& ScalarPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ScalarPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ScalarPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void ScalarPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ScalarPathSourceArchive.naturalSize)
}
inline ::TSP::Size* ScalarPathSourceArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* ScalarPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.ScalarPathSourceArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ScalarPathSourceArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* ScalarPathSourceArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.ScalarPathSourceArchive.naturalSize)
  return _msg;
}
inline void ScalarPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ScalarPathSourceArchive.naturalSize)
}

// -------------------------------------------------------------------

// BezierPathSourceArchive

// optional string path_string = 1 [deprecated = true];
inline bool BezierPathSourceArchive::_internal_has_path_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BezierPathSourceArchive::has_path_string() const {
  return _internal_has_path_string();
}
inline void BezierPathSourceArchive::clear_path_string() {
  _impl_.path_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BezierPathSourceArchive::path_string() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.path_string)
  return _internal_path_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BezierPathSourceArchive::set_path_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.BezierPathSourceArchive.path_string)
}
inline std::string* BezierPathSourceArchive::mutable_path_string() {
  std::string* _s = _internal_mutable_path_string();
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.path_string)
  return _s;
}
inline const std::string& BezierPathSourceArchive::_internal_path_string() const {
  return _impl_.path_string_.Get();
}
inline void BezierPathSourceArchive::_internal_set_path_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_string_.Set(value, GetArenaForAllocation());
}
inline std::string* BezierPathSourceArchive::_internal_mutable_path_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_string_.Mutable(GetArenaForAllocation());
}
inline std::string* BezierPathSourceArchive::release_path_string() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.path_string)
  if (!_internal_has_path_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_string_.IsDefault()) {
    _impl_.path_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BezierPathSourceArchive::set_allocated_path_string(std::string* path_string) {
  if (path_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_string_.SetAllocated(path_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_string_.IsDefault()) {
    _impl_.path_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.path_string)
}

// optional .TSP.Size naturalSize = 2;
inline bool BezierPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool BezierPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& BezierPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& BezierPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void BezierPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.BezierPathSourceArchive.naturalSize)
}
inline ::TSP::Size* BezierPathSourceArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* BezierPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* BezierPathSourceArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* BezierPathSourceArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.naturalSize)
  return _msg;
}
inline void BezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.naturalSize)
}

// optional .TSP.Path path = 3;
inline bool BezierPathSourceArchive::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_ != nullptr);
  return value;
}
inline bool BezierPathSourceArchive::has_path() const {
  return _internal_has_path();
}
inline const ::TSP::Path& BezierPathSourceArchive::_internal_path() const {
  const ::TSP::Path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& BezierPathSourceArchive::path() const {
  // @@protoc_insertion_point(field_get:TSD.BezierPathSourceArchive.path)
  return _internal_path();
}
inline void BezierPathSourceArchive::unsafe_arena_set_allocated_path(
    ::TSP::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.BezierPathSourceArchive.path)
}
inline ::TSP::Path* BezierPathSourceArchive::release_path() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Path* BezierPathSourceArchive::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:TSD.BezierPathSourceArchive.path)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::TSP::Path* BezierPathSourceArchive::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::TSP::Path* BezierPathSourceArchive::mutable_path() {
  ::TSP::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:TSD.BezierPathSourceArchive.path)
  return _msg;
}
inline void BezierPathSourceArchive::set_allocated_path(::TSP::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path));
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:TSD.BezierPathSourceArchive.path)
}

// -------------------------------------------------------------------

// CalloutPathSourceArchive

// optional .TSP.Size natural_size = 1;
inline bool CalloutPathSourceArchive::_internal_has_natural_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.natural_size_ != nullptr);
  return value;
}
inline bool CalloutPathSourceArchive::has_natural_size() const {
  return _internal_has_natural_size();
}
inline const ::TSP::Size& CalloutPathSourceArchive::_internal_natural_size() const {
  const ::TSP::Size* p = _impl_.natural_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& CalloutPathSourceArchive::natural_size() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.natural_size)
  return _internal_natural_size();
}
inline void CalloutPathSourceArchive::unsafe_arena_set_allocated_natural_size(
    ::TSP::Size* natural_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.natural_size_);
  }
  _impl_.natural_size_ = natural_size;
  if (natural_size) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CalloutPathSourceArchive.natural_size)
}
inline ::TSP::Size* CalloutPathSourceArchive::release_natural_size() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.natural_size_;
  _impl_.natural_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* CalloutPathSourceArchive::unsafe_arena_release_natural_size() {
  // @@protoc_insertion_point(field_release:TSD.CalloutPathSourceArchive.natural_size)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.natural_size_;
  _impl_.natural_size_ = nullptr;
  return temp;
}
inline ::TSP::Size* CalloutPathSourceArchive::_internal_mutable_natural_size() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.natural_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.natural_size_ = p;
  }
  return _impl_.natural_size_;
}
inline ::TSP::Size* CalloutPathSourceArchive::mutable_natural_size() {
  ::TSP::Size* _msg = _internal_mutable_natural_size();
  // @@protoc_insertion_point(field_mutable:TSD.CalloutPathSourceArchive.natural_size)
  return _msg;
}
inline void CalloutPathSourceArchive::set_allocated_natural_size(::TSP::Size* natural_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.natural_size_);
  }
  if (natural_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size));
    if (message_arena != submessage_arena) {
      natural_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, natural_size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.natural_size_ = natural_size;
  // @@protoc_insertion_point(field_set_allocated:TSD.CalloutPathSourceArchive.natural_size)
}

// optional .TSP.Point tail_position = 2;
inline bool CalloutPathSourceArchive::_internal_has_tail_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tail_position_ != nullptr);
  return value;
}
inline bool CalloutPathSourceArchive::has_tail_position() const {
  return _internal_has_tail_position();
}
inline const ::TSP::Point& CalloutPathSourceArchive::_internal_tail_position() const {
  const ::TSP::Point* p = _impl_.tail_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& CalloutPathSourceArchive::tail_position() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.tail_position)
  return _internal_tail_position();
}
inline void CalloutPathSourceArchive::unsafe_arena_set_allocated_tail_position(
    ::TSP::Point* tail_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tail_position_);
  }
  _impl_.tail_position_ = tail_position;
  if (tail_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CalloutPathSourceArchive.tail_position)
}
inline ::TSP::Point* CalloutPathSourceArchive::release_tail_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.tail_position_;
  _impl_.tail_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* CalloutPathSourceArchive::unsafe_arena_release_tail_position() {
  // @@protoc_insertion_point(field_release:TSD.CalloutPathSourceArchive.tail_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.tail_position_;
  _impl_.tail_position_ = nullptr;
  return temp;
}
inline ::TSP::Point* CalloutPathSourceArchive::_internal_mutable_tail_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tail_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.tail_position_ = p;
  }
  return _impl_.tail_position_;
}
inline ::TSP::Point* CalloutPathSourceArchive::mutable_tail_position() {
  ::TSP::Point* _msg = _internal_mutable_tail_position();
  // @@protoc_insertion_point(field_mutable:TSD.CalloutPathSourceArchive.tail_position)
  return _msg;
}
inline void CalloutPathSourceArchive::set_allocated_tail_position(::TSP::Point* tail_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tail_position_);
  }
  if (tail_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_position));
    if (message_arena != submessage_arena) {
      tail_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tail_position_ = tail_position;
  // @@protoc_insertion_point(field_set_allocated:TSD.CalloutPathSourceArchive.tail_position)
}

// optional float tail_size = 3;
inline bool CalloutPathSourceArchive::_internal_has_tail_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_tail_size() const {
  return _internal_has_tail_size();
}
inline void CalloutPathSourceArchive::clear_tail_size() {
  _impl_.tail_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CalloutPathSourceArchive::_internal_tail_size() const {
  return _impl_.tail_size_;
}
inline float CalloutPathSourceArchive::tail_size() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.tail_size)
  return _internal_tail_size();
}
inline void CalloutPathSourceArchive::_internal_set_tail_size(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tail_size_ = value;
}
inline void CalloutPathSourceArchive::set_tail_size(float value) {
  _internal_set_tail_size(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.tail_size)
}

// optional float corner_radius = 4;
inline bool CalloutPathSourceArchive::_internal_has_corner_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_corner_radius() const {
  return _internal_has_corner_radius();
}
inline void CalloutPathSourceArchive::clear_corner_radius() {
  _impl_.corner_radius_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float CalloutPathSourceArchive::_internal_corner_radius() const {
  return _impl_.corner_radius_;
}
inline float CalloutPathSourceArchive::corner_radius() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.corner_radius)
  return _internal_corner_radius();
}
inline void CalloutPathSourceArchive::_internal_set_corner_radius(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.corner_radius_ = value;
}
inline void CalloutPathSourceArchive::set_corner_radius(float value) {
  _internal_set_corner_radius(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.corner_radius)
}

// optional bool center_tail = 5;
inline bool CalloutPathSourceArchive::_internal_has_center_tail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CalloutPathSourceArchive::has_center_tail() const {
  return _internal_has_center_tail();
}
inline void CalloutPathSourceArchive::clear_center_tail() {
  _impl_.center_tail_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CalloutPathSourceArchive::_internal_center_tail() const {
  return _impl_.center_tail_;
}
inline bool CalloutPathSourceArchive::center_tail() const {
  // @@protoc_insertion_point(field_get:TSD.CalloutPathSourceArchive.center_tail)
  return _internal_center_tail();
}
inline void CalloutPathSourceArchive::_internal_set_center_tail(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.center_tail_ = value;
}
inline void CalloutPathSourceArchive::set_center_tail(bool value) {
  _internal_set_center_tail(value);
  // @@protoc_insertion_point(field_set:TSD.CalloutPathSourceArchive.center_tail)
}

// -------------------------------------------------------------------

// ConnectionLinePathSourceArchive

// required .TSD.BezierPathSourceArchive super = 1;
inline bool ConnectionLinePathSourceArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_super() const {
  return _internal_has_super();
}
inline void ConnectionLinePathSourceArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::BezierPathSourceArchive& ConnectionLinePathSourceArchive::_internal_super() const {
  const ::TSD::BezierPathSourceArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::BezierPathSourceArchive&>(
      ::TSD::_BezierPathSourceArchive_default_instance_);
}
inline const ::TSD::BezierPathSourceArchive& ConnectionLinePathSourceArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.super)
  return _internal_super();
}
inline void ConnectionLinePathSourceArchive::unsafe_arena_set_allocated_super(
    ::TSD::BezierPathSourceArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLinePathSourceArchive.super)
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::BezierPathSourceArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLinePathSourceArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::BezierPathSourceArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::BezierPathSourceArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::BezierPathSourceArchive* ConnectionLinePathSourceArchive::mutable_super() {
  ::TSD::BezierPathSourceArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLinePathSourceArchive.super)
  return _msg;
}
inline void ConnectionLinePathSourceArchive::set_allocated_super(::TSD::BezierPathSourceArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLinePathSourceArchive.super)
}

// optional .TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2;
inline bool ConnectionLinePathSourceArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_type() const {
  return _internal_has_type();
}
inline void ConnectionLinePathSourceArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::_internal_type() const {
  return static_cast< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType >(_impl_.type_);
}
inline ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType ConnectionLinePathSourceArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.type)
  return _internal_type();
}
inline void ConnectionLinePathSourceArchive::_internal_set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  assert(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void ConnectionLinePathSourceArchive::set_type(::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.type)
}

// optional float outset_from = 3;
inline bool ConnectionLinePathSourceArchive::_internal_has_outset_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_outset_from() const {
  return _internal_has_outset_from();
}
inline void ConnectionLinePathSourceArchive::clear_outset_from() {
  _impl_.outset_from_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ConnectionLinePathSourceArchive::_internal_outset_from() const {
  return _impl_.outset_from_;
}
inline float ConnectionLinePathSourceArchive::outset_from() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.outset_from)
  return _internal_outset_from();
}
inline void ConnectionLinePathSourceArchive::_internal_set_outset_from(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.outset_from_ = value;
}
inline void ConnectionLinePathSourceArchive::set_outset_from(float value) {
  _internal_set_outset_from(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.outset_from)
}

// optional float outset_to = 4;
inline bool ConnectionLinePathSourceArchive::_internal_has_outset_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectionLinePathSourceArchive::has_outset_to() const {
  return _internal_has_outset_to();
}
inline void ConnectionLinePathSourceArchive::clear_outset_to() {
  _impl_.outset_to_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ConnectionLinePathSourceArchive::_internal_outset_to() const {
  return _impl_.outset_to_;
}
inline float ConnectionLinePathSourceArchive::outset_to() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLinePathSourceArchive.outset_to)
  return _internal_outset_to();
}
inline void ConnectionLinePathSourceArchive::_internal_set_outset_to(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.outset_to_ = value;
}
inline void ConnectionLinePathSourceArchive::set_outset_to(float value) {
  _internal_set_outset_to(value);
  // @@protoc_insertion_point(field_set:TSD.ConnectionLinePathSourceArchive.outset_to)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Node

// required .TSP.Point inControlPoint = 1;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_incontrolpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.incontrolpoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_incontrolpoint() const {
  return _internal_has_incontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_incontrolpoint() const {
  const ::TSP::Point* p = _impl_.incontrolpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::incontrolpoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  return _internal_incontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_incontrolpoint(
    ::TSP::Point* incontrolpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.incontrolpoint_);
  }
  _impl_.incontrolpoint_ = incontrolpoint;
  if (incontrolpoint) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_incontrolpoint() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.incontrolpoint_;
  _impl_.incontrolpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_incontrolpoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.incontrolpoint_;
  _impl_.incontrolpoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_incontrolpoint() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.incontrolpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.incontrolpoint_ = p;
  }
  return _impl_.incontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_incontrolpoint() {
  ::TSP::Point* _msg = _internal_mutable_incontrolpoint();
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
  return _msg;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_incontrolpoint(::TSP::Point* incontrolpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.incontrolpoint_);
  }
  if (incontrolpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(incontrolpoint));
    if (message_arena != submessage_arena) {
      incontrolpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, incontrolpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.incontrolpoint_ = incontrolpoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.inControlPoint)
}

// required .TSP.Point nodePoint = 2;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_nodepoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nodepoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_nodepoint() const {
  return _internal_has_nodepoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_nodepoint() const {
  const ::TSP::Point* p = _impl_.nodepoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::nodepoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  return _internal_nodepoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_nodepoint(
    ::TSP::Point* nodepoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodepoint_);
  }
  _impl_.nodepoint_ = nodepoint;
  if (nodepoint) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_nodepoint() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.nodepoint_;
  _impl_.nodepoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_nodepoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.nodepoint_;
  _impl_.nodepoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_nodepoint() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.nodepoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.nodepoint_ = p;
  }
  return _impl_.nodepoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_nodepoint() {
  ::TSP::Point* _msg = _internal_mutable_nodepoint();
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
  return _msg;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_nodepoint(::TSP::Point* nodepoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nodepoint_);
  }
  if (nodepoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodepoint));
    if (message_arena != submessage_arena) {
      nodepoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodepoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.nodepoint_ = nodepoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.nodePoint)
}

// required .TSP.Point outControlPoint = 3;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_outcontrolpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outcontrolpoint_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_outcontrolpoint() const {
  return _internal_has_outcontrolpoint();
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::_internal_outcontrolpoint() const {
  const ::TSP::Point* p = _impl_.outcontrolpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& EditableBezierPathSourceArchive_Node::outcontrolpoint() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  return _internal_outcontrolpoint();
}
inline void EditableBezierPathSourceArchive_Node::unsafe_arena_set_allocated_outcontrolpoint(
    ::TSP::Point* outcontrolpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outcontrolpoint_);
  }
  _impl_.outcontrolpoint_ = outcontrolpoint;
  if (outcontrolpoint) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::release_outcontrolpoint() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = _impl_.outcontrolpoint_;
  _impl_.outcontrolpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::unsafe_arena_release_outcontrolpoint() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = _impl_.outcontrolpoint_;
  _impl_.outcontrolpoint_ = nullptr;
  return temp;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::_internal_mutable_outcontrolpoint() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.outcontrolpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.outcontrolpoint_ = p;
  }
  return _impl_.outcontrolpoint_;
}
inline ::TSP::Point* EditableBezierPathSourceArchive_Node::mutable_outcontrolpoint() {
  ::TSP::Point* _msg = _internal_mutable_outcontrolpoint();
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
  return _msg;
}
inline void EditableBezierPathSourceArchive_Node::set_allocated_outcontrolpoint(::TSP::Point* outcontrolpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outcontrolpoint_);
  }
  if (outcontrolpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outcontrolpoint));
    if (message_arena != submessage_arena) {
      outcontrolpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outcontrolpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.outcontrolpoint_ = outcontrolpoint;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.Node.outControlPoint)
}

// required .TSD.EditableBezierPathSourceArchive.NodeType type = 4;
inline bool EditableBezierPathSourceArchive_Node::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EditableBezierPathSourceArchive_Node::has_type() const {
  return _internal_has_type();
}
inline void EditableBezierPathSourceArchive_Node::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TSD::EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_Node::_internal_type() const {
  return static_cast< ::TSD::EditableBezierPathSourceArchive_NodeType >(_impl_.type_);
}
inline ::TSD::EditableBezierPathSourceArchive_NodeType EditableBezierPathSourceArchive_Node::type() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Node.type)
  return _internal_type();
}
inline void EditableBezierPathSourceArchive_Node::_internal_set_type(::TSD::EditableBezierPathSourceArchive_NodeType value) {
  assert(::TSD::EditableBezierPathSourceArchive_NodeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void EditableBezierPathSourceArchive_Node::set_type(::TSD::EditableBezierPathSourceArchive_NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.EditableBezierPathSourceArchive.Node.type)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive_Subpath

// repeated .TSD.EditableBezierPathSourceArchive.Node nodes = 1;
inline int EditableBezierPathSourceArchive_Subpath::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int EditableBezierPathSourceArchive_Subpath::nodes_size() const {
  return _internal_nodes_size();
}
inline void EditableBezierPathSourceArchive_Subpath::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >*
EditableBezierPathSourceArchive_Subpath::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return &_impl_.nodes_;
}
inline const ::TSD::EditableBezierPathSourceArchive_Node& EditableBezierPathSourceArchive_Subpath::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::TSD::EditableBezierPathSourceArchive_Node& EditableBezierPathSourceArchive_Subpath::nodes(int index) const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _internal_nodes(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::TSD::EditableBezierPathSourceArchive_Node* EditableBezierPathSourceArchive_Subpath::add_nodes() {
  ::TSD::EditableBezierPathSourceArchive_Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Node >&
EditableBezierPathSourceArchive_Subpath::nodes() const {
  // @@protoc_insertion_point(field_list:TSD.EditableBezierPathSourceArchive.Subpath.nodes)
  return _impl_.nodes_;
}

// required bool closed = 2;
inline bool EditableBezierPathSourceArchive_Subpath::_internal_has_closed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EditableBezierPathSourceArchive_Subpath::has_closed() const {
  return _internal_has_closed();
}
inline void EditableBezierPathSourceArchive_Subpath::clear_closed() {
  _impl_.closed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EditableBezierPathSourceArchive_Subpath::_internal_closed() const {
  return _impl_.closed_;
}
inline bool EditableBezierPathSourceArchive_Subpath::closed() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.Subpath.closed)
  return _internal_closed();
}
inline void EditableBezierPathSourceArchive_Subpath::_internal_set_closed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.closed_ = value;
}
inline void EditableBezierPathSourceArchive_Subpath::set_closed(bool value) {
  _internal_set_closed(value);
  // @@protoc_insertion_point(field_set:TSD.EditableBezierPathSourceArchive.Subpath.closed)
}

// -------------------------------------------------------------------

// EditableBezierPathSourceArchive

// repeated .TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1;
inline int EditableBezierPathSourceArchive::_internal_subpaths_size() const {
  return _impl_.subpaths_.size();
}
inline int EditableBezierPathSourceArchive::subpaths_size() const {
  return _internal_subpaths_size();
}
inline void EditableBezierPathSourceArchive::clear_subpaths() {
  _impl_.subpaths_.Clear();
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::mutable_subpaths(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.subpaths)
  return _impl_.subpaths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >*
EditableBezierPathSourceArchive::mutable_subpaths() {
  // @@protoc_insertion_point(field_mutable_list:TSD.EditableBezierPathSourceArchive.subpaths)
  return &_impl_.subpaths_;
}
inline const ::TSD::EditableBezierPathSourceArchive_Subpath& EditableBezierPathSourceArchive::_internal_subpaths(int index) const {
  return _impl_.subpaths_.Get(index);
}
inline const ::TSD::EditableBezierPathSourceArchive_Subpath& EditableBezierPathSourceArchive::subpaths(int index) const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.subpaths)
  return _internal_subpaths(index);
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::_internal_add_subpaths() {
  return _impl_.subpaths_.Add();
}
inline ::TSD::EditableBezierPathSourceArchive_Subpath* EditableBezierPathSourceArchive::add_subpaths() {
  ::TSD::EditableBezierPathSourceArchive_Subpath* _add = _internal_add_subpaths();
  // @@protoc_insertion_point(field_add:TSD.EditableBezierPathSourceArchive.subpaths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::EditableBezierPathSourceArchive_Subpath >&
EditableBezierPathSourceArchive::subpaths() const {
  // @@protoc_insertion_point(field_list:TSD.EditableBezierPathSourceArchive.subpaths)
  return _impl_.subpaths_;
}

// optional .TSP.Size naturalSize = 2;
inline bool EditableBezierPathSourceArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool EditableBezierPathSourceArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& EditableBezierPathSourceArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& EditableBezierPathSourceArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.EditableBezierPathSourceArchive.naturalSize)
  return _internal_naturalsize();
}
inline void EditableBezierPathSourceArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.EditableBezierPathSourceArchive.naturalSize)
}
inline ::TSP::Size* EditableBezierPathSourceArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.EditableBezierPathSourceArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* EditableBezierPathSourceArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.EditableBezierPathSourceArchive.naturalSize)
  return _msg;
}
inline void EditableBezierPathSourceArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.EditableBezierPathSourceArchive.naturalSize)
}

// -------------------------------------------------------------------

// PathSourceArchive

// optional bool horizontalFlip = 1;
inline bool PathSourceArchive::_internal_has_horizontalflip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PathSourceArchive::has_horizontalflip() const {
  return _internal_has_horizontalflip();
}
inline void PathSourceArchive::clear_horizontalflip() {
  _impl_.horizontalflip_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool PathSourceArchive::_internal_horizontalflip() const {
  return _impl_.horizontalflip_;
}
inline bool PathSourceArchive::horizontalflip() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.horizontalFlip)
  return _internal_horizontalflip();
}
inline void PathSourceArchive::_internal_set_horizontalflip(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.horizontalflip_ = value;
}
inline void PathSourceArchive::set_horizontalflip(bool value) {
  _internal_set_horizontalflip(value);
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.horizontalFlip)
}

// optional bool verticalFlip = 2;
inline bool PathSourceArchive::_internal_has_verticalflip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PathSourceArchive::has_verticalflip() const {
  return _internal_has_verticalflip();
}
inline void PathSourceArchive::clear_verticalflip() {
  _impl_.verticalflip_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool PathSourceArchive::_internal_verticalflip() const {
  return _impl_.verticalflip_;
}
inline bool PathSourceArchive::verticalflip() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.verticalFlip)
  return _internal_verticalflip();
}
inline void PathSourceArchive::_internal_set_verticalflip(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.verticalflip_ = value;
}
inline void PathSourceArchive::set_verticalflip(bool value) {
  _internal_set_verticalflip(value);
  // @@protoc_insertion_point(field_set:TSD.PathSourceArchive.verticalFlip)
}

// optional .TSD.PointPathSourceArchive point_path_source = 3;
inline bool PathSourceArchive::_internal_has_point_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_point_path_source() const {
  return _internal_has_point_path_source();
}
inline void PathSourceArchive::clear_point_path_source() {
  if (_impl_.point_path_source_ != nullptr) _impl_.point_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::PointPathSourceArchive& PathSourceArchive::_internal_point_path_source() const {
  const ::TSD::PointPathSourceArchive* p = _impl_.point_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PointPathSourceArchive&>(
      ::TSD::_PointPathSourceArchive_default_instance_);
}
inline const ::TSD::PointPathSourceArchive& PathSourceArchive::point_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.point_path_source)
  return _internal_point_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_point_path_source(
    ::TSD::PointPathSourceArchive* point_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_path_source_);
  }
  _impl_.point_path_source_ = point_path_source;
  if (point_path_source) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.point_path_source)
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::release_point_path_source() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::PointPathSourceArchive* temp = _impl_.point_path_source_;
  _impl_.point_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::unsafe_arena_release_point_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.point_path_source)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::PointPathSourceArchive* temp = _impl_.point_path_source_;
  _impl_.point_path_source_ = nullptr;
  return temp;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::_internal_mutable_point_path_source() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PointPathSourceArchive>(GetArenaForAllocation());
    _impl_.point_path_source_ = p;
  }
  return _impl_.point_path_source_;
}
inline ::TSD::PointPathSourceArchive* PathSourceArchive::mutable_point_path_source() {
  ::TSD::PointPathSourceArchive* _msg = _internal_mutable_point_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.point_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_point_path_source(::TSD::PointPathSourceArchive* point_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_path_source_;
  }
  if (point_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_path_source);
    if (message_arena != submessage_arena) {
      point_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_path_source_ = point_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.point_path_source)
}

// optional .TSD.ScalarPathSourceArchive scalar_path_source = 4;
inline bool PathSourceArchive::_internal_has_scalar_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scalar_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_scalar_path_source() const {
  return _internal_has_scalar_path_source();
}
inline void PathSourceArchive::clear_scalar_path_source() {
  if (_impl_.scalar_path_source_ != nullptr) _impl_.scalar_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::ScalarPathSourceArchive& PathSourceArchive::_internal_scalar_path_source() const {
  const ::TSD::ScalarPathSourceArchive* p = _impl_.scalar_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ScalarPathSourceArchive&>(
      ::TSD::_ScalarPathSourceArchive_default_instance_);
}
inline const ::TSD::ScalarPathSourceArchive& PathSourceArchive::scalar_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.scalar_path_source)
  return _internal_scalar_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_scalar_path_source(
    ::TSD::ScalarPathSourceArchive* scalar_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scalar_path_source_);
  }
  _impl_.scalar_path_source_ = scalar_path_source;
  if (scalar_path_source) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.scalar_path_source)
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::release_scalar_path_source() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ScalarPathSourceArchive* temp = _impl_.scalar_path_source_;
  _impl_.scalar_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::unsafe_arena_release_scalar_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.scalar_path_source)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ScalarPathSourceArchive* temp = _impl_.scalar_path_source_;
  _impl_.scalar_path_source_ = nullptr;
  return temp;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::_internal_mutable_scalar_path_source() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.scalar_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ScalarPathSourceArchive>(GetArenaForAllocation());
    _impl_.scalar_path_source_ = p;
  }
  return _impl_.scalar_path_source_;
}
inline ::TSD::ScalarPathSourceArchive* PathSourceArchive::mutable_scalar_path_source() {
  ::TSD::ScalarPathSourceArchive* _msg = _internal_mutable_scalar_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.scalar_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_scalar_path_source(::TSD::ScalarPathSourceArchive* scalar_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scalar_path_source_;
  }
  if (scalar_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scalar_path_source);
    if (message_arena != submessage_arena) {
      scalar_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scalar_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.scalar_path_source_ = scalar_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.scalar_path_source)
}

// optional .TSD.BezierPathSourceArchive bezier_path_source = 5;
inline bool PathSourceArchive::_internal_has_bezier_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bezier_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_bezier_path_source() const {
  return _internal_has_bezier_path_source();
}
inline void PathSourceArchive::clear_bezier_path_source() {
  if (_impl_.bezier_path_source_ != nullptr) _impl_.bezier_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::BezierPathSourceArchive& PathSourceArchive::_internal_bezier_path_source() const {
  const ::TSD::BezierPathSourceArchive* p = _impl_.bezier_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::BezierPathSourceArchive&>(
      ::TSD::_BezierPathSourceArchive_default_instance_);
}
inline const ::TSD::BezierPathSourceArchive& PathSourceArchive::bezier_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.bezier_path_source)
  return _internal_bezier_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_bezier_path_source(
    ::TSD::BezierPathSourceArchive* bezier_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bezier_path_source_);
  }
  _impl_.bezier_path_source_ = bezier_path_source;
  if (bezier_path_source) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.bezier_path_source)
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::release_bezier_path_source() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::BezierPathSourceArchive* temp = _impl_.bezier_path_source_;
  _impl_.bezier_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::unsafe_arena_release_bezier_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.bezier_path_source)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::BezierPathSourceArchive* temp = _impl_.bezier_path_source_;
  _impl_.bezier_path_source_ = nullptr;
  return temp;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::_internal_mutable_bezier_path_source() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.bezier_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::BezierPathSourceArchive>(GetArenaForAllocation());
    _impl_.bezier_path_source_ = p;
  }
  return _impl_.bezier_path_source_;
}
inline ::TSD::BezierPathSourceArchive* PathSourceArchive::mutable_bezier_path_source() {
  ::TSD::BezierPathSourceArchive* _msg = _internal_mutable_bezier_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.bezier_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_bezier_path_source(::TSD::BezierPathSourceArchive* bezier_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bezier_path_source_;
  }
  if (bezier_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bezier_path_source);
    if (message_arena != submessage_arena) {
      bezier_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bezier_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.bezier_path_source_ = bezier_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.bezier_path_source)
}

// optional .TSD.CalloutPathSourceArchive callout_path_source = 6;
inline bool PathSourceArchive::_internal_has_callout_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.callout_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_callout_path_source() const {
  return _internal_has_callout_path_source();
}
inline void PathSourceArchive::clear_callout_path_source() {
  if (_impl_.callout_path_source_ != nullptr) _impl_.callout_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::CalloutPathSourceArchive& PathSourceArchive::_internal_callout_path_source() const {
  const ::TSD::CalloutPathSourceArchive* p = _impl_.callout_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::CalloutPathSourceArchive&>(
      ::TSD::_CalloutPathSourceArchive_default_instance_);
}
inline const ::TSD::CalloutPathSourceArchive& PathSourceArchive::callout_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.callout_path_source)
  return _internal_callout_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_callout_path_source(
    ::TSD::CalloutPathSourceArchive* callout_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.callout_path_source_);
  }
  _impl_.callout_path_source_ = callout_path_source;
  if (callout_path_source) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.callout_path_source)
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::release_callout_path_source() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::CalloutPathSourceArchive* temp = _impl_.callout_path_source_;
  _impl_.callout_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::unsafe_arena_release_callout_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.callout_path_source)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::CalloutPathSourceArchive* temp = _impl_.callout_path_source_;
  _impl_.callout_path_source_ = nullptr;
  return temp;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::_internal_mutable_callout_path_source() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.callout_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::CalloutPathSourceArchive>(GetArenaForAllocation());
    _impl_.callout_path_source_ = p;
  }
  return _impl_.callout_path_source_;
}
inline ::TSD::CalloutPathSourceArchive* PathSourceArchive::mutable_callout_path_source() {
  ::TSD::CalloutPathSourceArchive* _msg = _internal_mutable_callout_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.callout_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_callout_path_source(::TSD::CalloutPathSourceArchive* callout_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.callout_path_source_;
  }
  if (callout_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(callout_path_source);
    if (message_arena != submessage_arena) {
      callout_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callout_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.callout_path_source_ = callout_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.callout_path_source)
}

// optional .TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7;
inline bool PathSourceArchive::_internal_has_connection_line_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connection_line_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_connection_line_path_source() const {
  return _internal_has_connection_line_path_source();
}
inline void PathSourceArchive::clear_connection_line_path_source() {
  if (_impl_.connection_line_path_source_ != nullptr) _impl_.connection_line_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::ConnectionLinePathSourceArchive& PathSourceArchive::_internal_connection_line_path_source() const {
  const ::TSD::ConnectionLinePathSourceArchive* p = _impl_.connection_line_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ConnectionLinePathSourceArchive&>(
      ::TSD::_ConnectionLinePathSourceArchive_default_instance_);
}
inline const ::TSD::ConnectionLinePathSourceArchive& PathSourceArchive::connection_line_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.connection_line_path_source)
  return _internal_connection_line_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_connection_line_path_source(
    ::TSD::ConnectionLinePathSourceArchive* connection_line_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connection_line_path_source_);
  }
  _impl_.connection_line_path_source_ = connection_line_path_source;
  if (connection_line_path_source) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.connection_line_path_source)
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::release_connection_line_path_source() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::ConnectionLinePathSourceArchive* temp = _impl_.connection_line_path_source_;
  _impl_.connection_line_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::unsafe_arena_release_connection_line_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.connection_line_path_source)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::ConnectionLinePathSourceArchive* temp = _impl_.connection_line_path_source_;
  _impl_.connection_line_path_source_ = nullptr;
  return temp;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::_internal_mutable_connection_line_path_source() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.connection_line_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ConnectionLinePathSourceArchive>(GetArenaForAllocation());
    _impl_.connection_line_path_source_ = p;
  }
  return _impl_.connection_line_path_source_;
}
inline ::TSD::ConnectionLinePathSourceArchive* PathSourceArchive::mutable_connection_line_path_source() {
  ::TSD::ConnectionLinePathSourceArchive* _msg = _internal_mutable_connection_line_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.connection_line_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_connection_line_path_source(::TSD::ConnectionLinePathSourceArchive* connection_line_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.connection_line_path_source_;
  }
  if (connection_line_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(connection_line_path_source);
    if (message_arena != submessage_arena) {
      connection_line_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_line_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.connection_line_path_source_ = connection_line_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.connection_line_path_source)
}

// optional .TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8;
inline bool PathSourceArchive::_internal_has_editable_bezier_path_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.editable_bezier_path_source_ != nullptr);
  return value;
}
inline bool PathSourceArchive::has_editable_bezier_path_source() const {
  return _internal_has_editable_bezier_path_source();
}
inline void PathSourceArchive::clear_editable_bezier_path_source() {
  if (_impl_.editable_bezier_path_source_ != nullptr) _impl_.editable_bezier_path_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::TSD::EditableBezierPathSourceArchive& PathSourceArchive::_internal_editable_bezier_path_source() const {
  const ::TSD::EditableBezierPathSourceArchive* p = _impl_.editable_bezier_path_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::EditableBezierPathSourceArchive&>(
      ::TSD::_EditableBezierPathSourceArchive_default_instance_);
}
inline const ::TSD::EditableBezierPathSourceArchive& PathSourceArchive::editable_bezier_path_source() const {
  // @@protoc_insertion_point(field_get:TSD.PathSourceArchive.editable_bezier_path_source)
  return _internal_editable_bezier_path_source();
}
inline void PathSourceArchive::unsafe_arena_set_allocated_editable_bezier_path_source(
    ::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editable_bezier_path_source_);
  }
  _impl_.editable_bezier_path_source_ = editable_bezier_path_source;
  if (editable_bezier_path_source) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.PathSourceArchive.editable_bezier_path_source)
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::release_editable_bezier_path_source() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSD::EditableBezierPathSourceArchive* temp = _impl_.editable_bezier_path_source_;
  _impl_.editable_bezier_path_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::unsafe_arena_release_editable_bezier_path_source() {
  // @@protoc_insertion_point(field_release:TSD.PathSourceArchive.editable_bezier_path_source)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSD::EditableBezierPathSourceArchive* temp = _impl_.editable_bezier_path_source_;
  _impl_.editable_bezier_path_source_ = nullptr;
  return temp;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::_internal_mutable_editable_bezier_path_source() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.editable_bezier_path_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::EditableBezierPathSourceArchive>(GetArenaForAllocation());
    _impl_.editable_bezier_path_source_ = p;
  }
  return _impl_.editable_bezier_path_source_;
}
inline ::TSD::EditableBezierPathSourceArchive* PathSourceArchive::mutable_editable_bezier_path_source() {
  ::TSD::EditableBezierPathSourceArchive* _msg = _internal_mutable_editable_bezier_path_source();
  // @@protoc_insertion_point(field_mutable:TSD.PathSourceArchive.editable_bezier_path_source)
  return _msg;
}
inline void PathSourceArchive::set_allocated_editable_bezier_path_source(::TSD::EditableBezierPathSourceArchive* editable_bezier_path_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.editable_bezier_path_source_;
  }
  if (editable_bezier_path_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(editable_bezier_path_source);
    if (message_arena != submessage_arena) {
      editable_bezier_path_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editable_bezier_path_source, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.editable_bezier_path_source_ = editable_bezier_path_source;
  // @@protoc_insertion_point(field_set_allocated:TSD.PathSourceArchive.editable_bezier_path_source)
}

// -------------------------------------------------------------------

// AngleGradientArchive

// optional float gradientangle = 2;
inline bool AngleGradientArchive::_internal_has_gradientangle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AngleGradientArchive::has_gradientangle() const {
  return _internal_has_gradientangle();
}
inline void AngleGradientArchive::clear_gradientangle() {
  _impl_.gradientangle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float AngleGradientArchive::_internal_gradientangle() const {
  return _impl_.gradientangle_;
}
inline float AngleGradientArchive::gradientangle() const {
  // @@protoc_insertion_point(field_get:TSD.AngleGradientArchive.gradientangle)
  return _internal_gradientangle();
}
inline void AngleGradientArchive::_internal_set_gradientangle(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gradientangle_ = value;
}
inline void AngleGradientArchive::set_gradientangle(float value) {
  _internal_set_gradientangle(value);
  // @@protoc_insertion_point(field_set:TSD.AngleGradientArchive.gradientangle)
}

// -------------------------------------------------------------------

// TransformGradientArchive

// optional .TSP.Point start = 1;
inline bool TransformGradientArchive::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_start() const {
  return _internal_has_start();
}
inline const ::TSP::Point& TransformGradientArchive::_internal_start() const {
  const ::TSP::Point* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& TransformGradientArchive::start() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.start)
  return _internal_start();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_start(
    ::TSP::Point* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.start)
}
inline ::TSP::Point* TransformGradientArchive::release_start() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.start)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Point* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_start() {
  ::TSP::Point* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.start)
  return _msg;
}
inline void TransformGradientArchive::set_allocated_start(::TSP::Point* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.start)
}

// optional .TSP.Point end = 2;
inline bool TransformGradientArchive::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_end() const {
  return _internal_has_end();
}
inline const ::TSP::Point& TransformGradientArchive::_internal_end() const {
  const ::TSP::Point* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& TransformGradientArchive::end() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.end)
  return _internal_end();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_end(
    ::TSP::Point* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.end)
}
inline ::TSP::Point* TransformGradientArchive::release_end() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.end)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Point* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::TSP::Point* TransformGradientArchive::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::TSP::Point* TransformGradientArchive::mutable_end() {
  ::TSP::Point* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.end)
  return _msg;
}
inline void TransformGradientArchive::set_allocated_end(::TSP::Point* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.end)
}

// optional .TSP.Size baseNaturalSize = 3;
inline bool TransformGradientArchive::_internal_has_basenaturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.basenaturalsize_ != nullptr);
  return value;
}
inline bool TransformGradientArchive::has_basenaturalsize() const {
  return _internal_has_basenaturalsize();
}
inline const ::TSP::Size& TransformGradientArchive::_internal_basenaturalsize() const {
  const ::TSP::Size* p = _impl_.basenaturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& TransformGradientArchive::basenaturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.TransformGradientArchive.baseNaturalSize)
  return _internal_basenaturalsize();
}
inline void TransformGradientArchive::unsafe_arena_set_allocated_basenaturalsize(
    ::TSP::Size* basenaturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basenaturalsize_);
  }
  _impl_.basenaturalsize_ = basenaturalsize;
  if (basenaturalsize) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.TransformGradientArchive.baseNaturalSize)
}
inline ::TSP::Size* TransformGradientArchive::release_basenaturalsize() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.basenaturalsize_;
  _impl_.basenaturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* TransformGradientArchive::unsafe_arena_release_basenaturalsize() {
  // @@protoc_insertion_point(field_release:TSD.TransformGradientArchive.baseNaturalSize)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.basenaturalsize_;
  _impl_.basenaturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* TransformGradientArchive::_internal_mutable_basenaturalsize() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.basenaturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.basenaturalsize_ = p;
  }
  return _impl_.basenaturalsize_;
}
inline ::TSP::Size* TransformGradientArchive::mutable_basenaturalsize() {
  ::TSP::Size* _msg = _internal_mutable_basenaturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.TransformGradientArchive.baseNaturalSize)
  return _msg;
}
inline void TransformGradientArchive::set_allocated_basenaturalsize(::TSP::Size* basenaturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.basenaturalsize_);
  }
  if (basenaturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basenaturalsize));
    if (message_arena != submessage_arena) {
      basenaturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basenaturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.basenaturalsize_ = basenaturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.TransformGradientArchive.baseNaturalSize)
}

// -------------------------------------------------------------------

// GradientArchive_GradientStop

// optional .TSP.Color color = 1;
inline bool GradientArchive_GradientStop::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool GradientArchive_GradientStop::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& GradientArchive_GradientStop::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& GradientArchive_GradientStop::color() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.color)
  return _internal_color();
}
inline void GradientArchive_GradientStop::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.GradientStop.color)
}
inline ::TSP::Color* GradientArchive_GradientStop::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* GradientArchive_GradientStop::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.GradientStop.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* GradientArchive_GradientStop::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* GradientArchive_GradientStop::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.GradientStop.color)
  return _msg;
}
inline void GradientArchive_GradientStop::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.GradientStop.color)
}

// optional float fraction = 2;
inline bool GradientArchive_GradientStop::_internal_has_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GradientArchive_GradientStop::has_fraction() const {
  return _internal_has_fraction();
}
inline void GradientArchive_GradientStop::clear_fraction() {
  _impl_.fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float GradientArchive_GradientStop::_internal_fraction() const {
  return _impl_.fraction_;
}
inline float GradientArchive_GradientStop::fraction() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.fraction)
  return _internal_fraction();
}
inline void GradientArchive_GradientStop::_internal_set_fraction(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fraction_ = value;
}
inline void GradientArchive_GradientStop::set_fraction(float value) {
  _internal_set_fraction(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.GradientStop.fraction)
}

// optional float inflection = 3;
inline bool GradientArchive_GradientStop::_internal_has_inflection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GradientArchive_GradientStop::has_inflection() const {
  return _internal_has_inflection();
}
inline void GradientArchive_GradientStop::clear_inflection() {
  _impl_.inflection_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float GradientArchive_GradientStop::_internal_inflection() const {
  return _impl_.inflection_;
}
inline float GradientArchive_GradientStop::inflection() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.GradientStop.inflection)
  return _internal_inflection();
}
inline void GradientArchive_GradientStop::_internal_set_inflection(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.inflection_ = value;
}
inline void GradientArchive_GradientStop::set_inflection(float value) {
  _internal_set_inflection(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.GradientStop.inflection)
}

// -------------------------------------------------------------------

// GradientArchive

// optional .TSD.GradientArchive.GradientType type = 1;
inline bool GradientArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GradientArchive::has_type() const {
  return _internal_has_type();
}
inline void GradientArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TSD::GradientArchive_GradientType GradientArchive::_internal_type() const {
  return static_cast< ::TSD::GradientArchive_GradientType >(_impl_.type_);
}
inline ::TSD::GradientArchive_GradientType GradientArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.type)
  return _internal_type();
}
inline void GradientArchive::_internal_set_type(::TSD::GradientArchive_GradientType value) {
  assert(::TSD::GradientArchive_GradientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}
inline void GradientArchive::set_type(::TSD::GradientArchive_GradientType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.type)
}

// repeated .TSD.GradientArchive.GradientStop stops = 2;
inline int GradientArchive::_internal_stops_size() const {
  return _impl_.stops_.size();
}
inline int GradientArchive::stops_size() const {
  return _internal_stops_size();
}
inline void GradientArchive::clear_stops() {
  _impl_.stops_.Clear();
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.stops)
  return _impl_.stops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >*
GradientArchive::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GradientArchive.stops)
  return &_impl_.stops_;
}
inline const ::TSD::GradientArchive_GradientStop& GradientArchive::_internal_stops(int index) const {
  return _impl_.stops_.Get(index);
}
inline const ::TSD::GradientArchive_GradientStop& GradientArchive::stops(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.stops)
  return _internal_stops(index);
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::_internal_add_stops() {
  return _impl_.stops_.Add();
}
inline ::TSD::GradientArchive_GradientStop* GradientArchive::add_stops() {
  ::TSD::GradientArchive_GradientStop* _add = _internal_add_stops();
  // @@protoc_insertion_point(field_add:TSD.GradientArchive.stops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::GradientArchive_GradientStop >&
GradientArchive::stops() const {
  // @@protoc_insertion_point(field_list:TSD.GradientArchive.stops)
  return _impl_.stops_;
}

// optional float opacity = 3;
inline bool GradientArchive::_internal_has_opacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GradientArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void GradientArchive::clear_opacity() {
  _impl_.opacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float GradientArchive::_internal_opacity() const {
  return _impl_.opacity_;
}
inline float GradientArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.opacity)
  return _internal_opacity();
}
inline void GradientArchive::_internal_set_opacity(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.opacity_ = value;
}
inline void GradientArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.opacity)
}

// optional bool advancedGradient = 4;
inline bool GradientArchive::_internal_has_advancedgradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GradientArchive::has_advancedgradient() const {
  return _internal_has_advancedgradient();
}
inline void GradientArchive::clear_advancedgradient() {
  _impl_.advancedgradient_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool GradientArchive::_internal_advancedgradient() const {
  return _impl_.advancedgradient_;
}
inline bool GradientArchive::advancedgradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.advancedGradient)
  return _internal_advancedgradient();
}
inline void GradientArchive::_internal_set_advancedgradient(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.advancedgradient_ = value;
}
inline void GradientArchive::set_advancedgradient(bool value) {
  _internal_set_advancedgradient(value);
  // @@protoc_insertion_point(field_set:TSD.GradientArchive.advancedGradient)
}

// optional .TSD.AngleGradientArchive anglegradient = 5;
inline bool GradientArchive::_internal_has_anglegradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.anglegradient_ != nullptr);
  return value;
}
inline bool GradientArchive::has_anglegradient() const {
  return _internal_has_anglegradient();
}
inline void GradientArchive::clear_anglegradient() {
  if (_impl_.anglegradient_ != nullptr) _impl_.anglegradient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::AngleGradientArchive& GradientArchive::_internal_anglegradient() const {
  const ::TSD::AngleGradientArchive* p = _impl_.anglegradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::AngleGradientArchive&>(
      ::TSD::_AngleGradientArchive_default_instance_);
}
inline const ::TSD::AngleGradientArchive& GradientArchive::anglegradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.anglegradient)
  return _internal_anglegradient();
}
inline void GradientArchive::unsafe_arena_set_allocated_anglegradient(
    ::TSD::AngleGradientArchive* anglegradient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.anglegradient_);
  }
  _impl_.anglegradient_ = anglegradient;
  if (anglegradient) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.anglegradient)
}
inline ::TSD::AngleGradientArchive* GradientArchive::release_anglegradient() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::AngleGradientArchive* temp = _impl_.anglegradient_;
  _impl_.anglegradient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::AngleGradientArchive* GradientArchive::unsafe_arena_release_anglegradient() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.anglegradient)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::AngleGradientArchive* temp = _impl_.anglegradient_;
  _impl_.anglegradient_ = nullptr;
  return temp;
}
inline ::TSD::AngleGradientArchive* GradientArchive::_internal_mutable_anglegradient() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.anglegradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::AngleGradientArchive>(GetArenaForAllocation());
    _impl_.anglegradient_ = p;
  }
  return _impl_.anglegradient_;
}
inline ::TSD::AngleGradientArchive* GradientArchive::mutable_anglegradient() {
  ::TSD::AngleGradientArchive* _msg = _internal_mutable_anglegradient();
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.anglegradient)
  return _msg;
}
inline void GradientArchive::set_allocated_anglegradient(::TSD::AngleGradientArchive* anglegradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.anglegradient_;
  }
  if (anglegradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(anglegradient);
    if (message_arena != submessage_arena) {
      anglegradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anglegradient, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.anglegradient_ = anglegradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.anglegradient)
}

// optional .TSD.TransformGradientArchive transformgradient = 6;
inline bool GradientArchive::_internal_has_transformgradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transformgradient_ != nullptr);
  return value;
}
inline bool GradientArchive::has_transformgradient() const {
  return _internal_has_transformgradient();
}
inline void GradientArchive::clear_transformgradient() {
  if (_impl_.transformgradient_ != nullptr) _impl_.transformgradient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::TransformGradientArchive& GradientArchive::_internal_transformgradient() const {
  const ::TSD::TransformGradientArchive* p = _impl_.transformgradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::TransformGradientArchive&>(
      ::TSD::_TransformGradientArchive_default_instance_);
}
inline const ::TSD::TransformGradientArchive& GradientArchive::transformgradient() const {
  // @@protoc_insertion_point(field_get:TSD.GradientArchive.transformgradient)
  return _internal_transformgradient();
}
inline void GradientArchive::unsafe_arena_set_allocated_transformgradient(
    ::TSD::TransformGradientArchive* transformgradient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transformgradient_);
  }
  _impl_.transformgradient_ = transformgradient;
  if (transformgradient) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GradientArchive.transformgradient)
}
inline ::TSD::TransformGradientArchive* GradientArchive::release_transformgradient() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::TransformGradientArchive* temp = _impl_.transformgradient_;
  _impl_.transformgradient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::TransformGradientArchive* GradientArchive::unsafe_arena_release_transformgradient() {
  // @@protoc_insertion_point(field_release:TSD.GradientArchive.transformgradient)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::TransformGradientArchive* temp = _impl_.transformgradient_;
  _impl_.transformgradient_ = nullptr;
  return temp;
}
inline ::TSD::TransformGradientArchive* GradientArchive::_internal_mutable_transformgradient() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transformgradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::TransformGradientArchive>(GetArenaForAllocation());
    _impl_.transformgradient_ = p;
  }
  return _impl_.transformgradient_;
}
inline ::TSD::TransformGradientArchive* GradientArchive::mutable_transformgradient() {
  ::TSD::TransformGradientArchive* _msg = _internal_mutable_transformgradient();
  // @@protoc_insertion_point(field_mutable:TSD.GradientArchive.transformgradient)
  return _msg;
}
inline void GradientArchive::set_allocated_transformgradient(::TSD::TransformGradientArchive* transformgradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.transformgradient_;
  }
  if (transformgradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transformgradient);
    if (message_arena != submessage_arena) {
      transformgradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transformgradient, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transformgradient_ = transformgradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.GradientArchive.transformgradient)
}

// -------------------------------------------------------------------

// ImageFillArchive

// optional .TSP.DataReference imagedata = 6;
inline bool ImageFillArchive::_internal_has_imagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.imagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_imagedata() const {
  return _internal_has_imagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::_internal_imagedata() const {
  const ::TSP::DataReference* p = _impl_.imagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageFillArchive::imagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.imagedata)
  return _internal_imagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_imagedata(
    ::TSP::DataReference* imagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.imagedata_);
  }
  _impl_.imagedata_ = imagedata;
  if (imagedata) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.imagedata)
}
inline ::TSP::DataReference* ImageFillArchive::release_imagedata() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::DataReference* temp = _impl_.imagedata_;
  _impl_.imagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::unsafe_arena_release_imagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.imagedata)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::DataReference* temp = _impl_.imagedata_;
  _impl_.imagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::_internal_mutable_imagedata() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.imagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.imagedata_ = p;
  }
  return _impl_.imagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_imagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_imagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.imagedata)
  return _msg;
}
inline void ImageFillArchive::set_allocated_imagedata(::TSP::DataReference* imagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.imagedata_);
  }
  if (imagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(imagedata));
    if (message_arena != submessage_arena) {
      imagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.imagedata_ = imagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.imagedata)
}

// optional .TSD.ImageFillArchive.ImageFillTechnique technique = 2 [default = NaturalSize];
inline bool ImageFillArchive::_internal_has_technique() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImageFillArchive::has_technique() const {
  return _internal_has_technique();
}
inline void ImageFillArchive::clear_technique() {
  _impl_.technique_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::TSD::ImageFillArchive_ImageFillTechnique ImageFillArchive::_internal_technique() const {
  return static_cast< ::TSD::ImageFillArchive_ImageFillTechnique >(_impl_.technique_);
}
inline ::TSD::ImageFillArchive_ImageFillTechnique ImageFillArchive::technique() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.technique)
  return _internal_technique();
}
inline void ImageFillArchive::_internal_set_technique(::TSD::ImageFillArchive_ImageFillTechnique value) {
  assert(::TSD::ImageFillArchive_ImageFillTechnique_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.technique_ = value;
}
inline void ImageFillArchive::set_technique(::TSD::ImageFillArchive_ImageFillTechnique value) {
  _internal_set_technique(value);
  // @@protoc_insertion_point(field_set:TSD.ImageFillArchive.technique)
}

// optional .TSP.Color tint = 3;
inline bool ImageFillArchive::_internal_has_tint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tint_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_tint() const {
  return _internal_has_tint();
}
inline const ::TSP::Color& ImageFillArchive::_internal_tint() const {
  const ::TSP::Color* p = _impl_.tint_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& ImageFillArchive::tint() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.tint)
  return _internal_tint();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_tint(
    ::TSP::Color* tint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tint_);
  }
  _impl_.tint_ = tint;
  if (tint) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.tint)
}
inline ::TSP::Color* ImageFillArchive::release_tint() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.tint_;
  _impl_.tint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* ImageFillArchive::unsafe_arena_release_tint() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.tint)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.tint_;
  _impl_.tint_ = nullptr;
  return temp;
}
inline ::TSP::Color* ImageFillArchive::_internal_mutable_tint() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tint_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.tint_ = p;
  }
  return _impl_.tint_;
}
inline ::TSP::Color* ImageFillArchive::mutable_tint() {
  ::TSP::Color* _msg = _internal_mutable_tint();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.tint)
  return _msg;
}
inline void ImageFillArchive::set_allocated_tint(::TSP::Color* tint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tint_);
  }
  if (tint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tint));
    if (message_arena != submessage_arena) {
      tint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tint_ = tint;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.tint)
}

// optional .TSP.Size fillsize = 4;
inline bool ImageFillArchive::_internal_has_fillsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fillsize_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_fillsize() const {
  return _internal_has_fillsize();
}
inline const ::TSP::Size& ImageFillArchive::_internal_fillsize() const {
  const ::TSP::Size* p = _impl_.fillsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageFillArchive::fillsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.fillsize)
  return _internal_fillsize();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_fillsize(
    ::TSP::Size* fillsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fillsize_);
  }
  _impl_.fillsize_ = fillsize;
  if (fillsize) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.fillsize)
}
inline ::TSP::Size* ImageFillArchive::release_fillsize() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.fillsize_;
  _impl_.fillsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* ImageFillArchive::unsafe_arena_release_fillsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.fillsize)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.fillsize_;
  _impl_.fillsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageFillArchive::_internal_mutable_fillsize() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.fillsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.fillsize_ = p;
  }
  return _impl_.fillsize_;
}
inline ::TSP::Size* ImageFillArchive::mutable_fillsize() {
  ::TSP::Size* _msg = _internal_mutable_fillsize();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.fillsize)
  return _msg;
}
inline void ImageFillArchive::set_allocated_fillsize(::TSP::Size* fillsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fillsize_);
  }
  if (fillsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fillsize));
    if (message_arena != submessage_arena) {
      fillsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fillsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fillsize_ = fillsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.fillsize)
}

// optional .TSP.DataReference originalimagedata = 7;
inline bool ImageFillArchive::_internal_has_originalimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originalimagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_originalimagedata() const {
  return _internal_has_originalimagedata();
}
inline const ::TSP::DataReference& ImageFillArchive::_internal_originalimagedata() const {
  const ::TSP::DataReference* p = _impl_.originalimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageFillArchive::originalimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.originalimagedata)
  return _internal_originalimagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_originalimagedata(
    ::TSP::DataReference* originalimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalimagedata_);
  }
  _impl_.originalimagedata_ = originalimagedata;
  if (originalimagedata) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.originalimagedata)
}
inline ::TSP::DataReference* ImageFillArchive::release_originalimagedata() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = _impl_.originalimagedata_;
  _impl_.originalimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::unsafe_arena_release_originalimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.originalimagedata)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = _impl_.originalimagedata_;
  _impl_.originalimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageFillArchive::_internal_mutable_originalimagedata() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.originalimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.originalimagedata_ = p;
  }
  return _impl_.originalimagedata_;
}
inline ::TSP::DataReference* ImageFillArchive::mutable_originalimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_originalimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.originalimagedata)
  return _msg;
}
inline void ImageFillArchive::set_allocated_originalimagedata(::TSP::DataReference* originalimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalimagedata_);
  }
  if (originalimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalimagedata));
    if (message_arena != submessage_arena) {
      originalimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.originalimagedata_ = originalimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.originalimagedata)
}

// optional bool interpretsUntaggedImageDataAsGeneric = 8;
inline bool ImageFillArchive::_internal_has_interpretsuntaggedimagedataasgeneric() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageFillArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return _internal_has_interpretsuntaggedimagedataasgeneric();
}
inline void ImageFillArchive::clear_interpretsuntaggedimagedataasgeneric() {
  _impl_.interpretsuntaggedimagedataasgeneric_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ImageFillArchive::_internal_interpretsuntaggedimagedataasgeneric() const {
  return _impl_.interpretsuntaggedimagedataasgeneric_;
}
inline bool ImageFillArchive::interpretsuntaggedimagedataasgeneric() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.interpretsUntaggedImageDataAsGeneric)
  return _internal_interpretsuntaggedimagedataasgeneric();
}
inline void ImageFillArchive::_internal_set_interpretsuntaggedimagedataasgeneric(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.interpretsuntaggedimagedataasgeneric_ = value;
}
inline void ImageFillArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  _internal_set_interpretsuntaggedimagedataasgeneric(value);
  // @@protoc_insertion_point(field_set:TSD.ImageFillArchive.interpretsUntaggedImageDataAsGeneric)
}

// optional .TSP.Reference database_imagedata = 1;
inline bool ImageFillArchive::_internal_has_database_imagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_imagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_database_imagedata() const {
  return _internal_has_database_imagedata();
}
inline const ::TSP::Reference& ImageFillArchive::_internal_database_imagedata() const {
  const ::TSP::Reference* p = _impl_.database_imagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageFillArchive::database_imagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.database_imagedata)
  return _internal_database_imagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_database_imagedata(
    ::TSP::Reference* database_imagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_imagedata_);
  }
  _impl_.database_imagedata_ = database_imagedata;
  if (database_imagedata) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.database_imagedata)
}
inline ::TSP::Reference* ImageFillArchive::release_database_imagedata() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.database_imagedata_;
  _impl_.database_imagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::unsafe_arena_release_database_imagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.database_imagedata)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.database_imagedata_;
  _impl_.database_imagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::_internal_mutable_database_imagedata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.database_imagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_imagedata_ = p;
  }
  return _impl_.database_imagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_imagedata() {
  ::TSP::Reference* _msg = _internal_mutable_database_imagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.database_imagedata)
  return _msg;
}
inline void ImageFillArchive::set_allocated_database_imagedata(::TSP::Reference* database_imagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_imagedata_);
  }
  if (database_imagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_imagedata));
    if (message_arena != submessage_arena) {
      database_imagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_imagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.database_imagedata_ = database_imagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.database_imagedata)
}

// optional .TSP.Reference database_originalimagedata = 5;
inline bool ImageFillArchive::_internal_has_database_originalimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_originalimagedata_ != nullptr);
  return value;
}
inline bool ImageFillArchive::has_database_originalimagedata() const {
  return _internal_has_database_originalimagedata();
}
inline const ::TSP::Reference& ImageFillArchive::_internal_database_originalimagedata() const {
  const ::TSP::Reference* p = _impl_.database_originalimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageFillArchive::database_originalimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageFillArchive.database_originalimagedata)
  return _internal_database_originalimagedata();
}
inline void ImageFillArchive::unsafe_arena_set_allocated_database_originalimagedata(
    ::TSP::Reference* database_originalimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_originalimagedata_);
  }
  _impl_.database_originalimagedata_ = database_originalimagedata;
  if (database_originalimagedata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageFillArchive.database_originalimagedata)
}
inline ::TSP::Reference* ImageFillArchive::release_database_originalimagedata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.database_originalimagedata_;
  _impl_.database_originalimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::unsafe_arena_release_database_originalimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageFillArchive.database_originalimagedata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.database_originalimagedata_;
  _impl_.database_originalimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageFillArchive::_internal_mutable_database_originalimagedata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.database_originalimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_originalimagedata_ = p;
  }
  return _impl_.database_originalimagedata_;
}
inline ::TSP::Reference* ImageFillArchive::mutable_database_originalimagedata() {
  ::TSP::Reference* _msg = _internal_mutable_database_originalimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageFillArchive.database_originalimagedata)
  return _msg;
}
inline void ImageFillArchive::set_allocated_database_originalimagedata(::TSP::Reference* database_originalimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_originalimagedata_);
  }
  if (database_originalimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originalimagedata));
    if (message_arena != submessage_arena) {
      database_originalimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_originalimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.database_originalimagedata_ = database_originalimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageFillArchive.database_originalimagedata)
}

// -------------------------------------------------------------------

// FillArchive

// optional .TSP.Color color = 1;
inline bool FillArchive::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool FillArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& FillArchive::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& FillArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.color)
  return _internal_color();
}
inline void FillArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.color)
}
inline ::TSP::Color* FillArchive::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* FillArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* FillArchive::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* FillArchive::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.color)
  return _msg;
}
inline void FillArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.color)
}

// optional .TSD.GradientArchive gradient = 2;
inline bool FillArchive::_internal_has_gradient() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.gradient_ != nullptr);
  return value;
}
inline bool FillArchive::has_gradient() const {
  return _internal_has_gradient();
}
inline void FillArchive::clear_gradient() {
  if (_impl_.gradient_ != nullptr) _impl_.gradient_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::GradientArchive& FillArchive::_internal_gradient() const {
  const ::TSD::GradientArchive* p = _impl_.gradient_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GradientArchive&>(
      ::TSD::_GradientArchive_default_instance_);
}
inline const ::TSD::GradientArchive& FillArchive::gradient() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.gradient)
  return _internal_gradient();
}
inline void FillArchive::unsafe_arena_set_allocated_gradient(
    ::TSD::GradientArchive* gradient) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.gradient_);
  }
  _impl_.gradient_ = gradient;
  if (gradient) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.gradient)
}
inline ::TSD::GradientArchive* FillArchive::release_gradient() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GradientArchive* temp = _impl_.gradient_;
  _impl_.gradient_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::GradientArchive* FillArchive::unsafe_arena_release_gradient() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.gradient)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::GradientArchive* temp = _impl_.gradient_;
  _impl_.gradient_ = nullptr;
  return temp;
}
inline ::TSD::GradientArchive* FillArchive::_internal_mutable_gradient() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.gradient_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GradientArchive>(GetArenaForAllocation());
    _impl_.gradient_ = p;
  }
  return _impl_.gradient_;
}
inline ::TSD::GradientArchive* FillArchive::mutable_gradient() {
  ::TSD::GradientArchive* _msg = _internal_mutable_gradient();
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.gradient)
  return _msg;
}
inline void FillArchive::set_allocated_gradient(::TSD::GradientArchive* gradient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.gradient_;
  }
  if (gradient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gradient);
    if (message_arena != submessage_arena) {
      gradient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gradient, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.gradient_ = gradient;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.gradient)
}

// optional .TSD.ImageFillArchive image = 3;
inline bool FillArchive::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool FillArchive::has_image() const {
  return _internal_has_image();
}
inline void FillArchive::clear_image() {
  if (_impl_.image_ != nullptr) _impl_.image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ImageFillArchive& FillArchive::_internal_image() const {
  const ::TSD::ImageFillArchive* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ImageFillArchive&>(
      ::TSD::_ImageFillArchive_default_instance_);
}
inline const ::TSD::ImageFillArchive& FillArchive::image() const {
  // @@protoc_insertion_point(field_get:TSD.FillArchive.image)
  return _internal_image();
}
inline void FillArchive::unsafe_arena_set_allocated_image(
    ::TSD::ImageFillArchive* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.FillArchive.image)
}
inline ::TSD::ImageFillArchive* FillArchive::release_image() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ImageFillArchive* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ImageFillArchive* FillArchive::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:TSD.FillArchive.image)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ImageFillArchive* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::TSD::ImageFillArchive* FillArchive::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ImageFillArchive>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::TSD::ImageFillArchive* FillArchive::mutable_image() {
  ::TSD::ImageFillArchive* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:TSD.FillArchive.image)
  return _msg;
}
inline void FillArchive::set_allocated_image(::TSD::ImageFillArchive* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:TSD.FillArchive.image)
}

// -------------------------------------------------------------------

// StrokePatternArchive

// optional .TSD.StrokePatternArchive.StrokePatternType type = 1;
inline bool StrokePatternArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_type() const {
  return _internal_has_type();
}
inline void StrokePatternArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::StrokePatternArchive_StrokePatternType StrokePatternArchive::_internal_type() const {
  return static_cast< ::TSD::StrokePatternArchive_StrokePatternType >(_impl_.type_);
}
inline ::TSD::StrokePatternArchive_StrokePatternType StrokePatternArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.type)
  return _internal_type();
}
inline void StrokePatternArchive::_internal_set_type(::TSD::StrokePatternArchive_StrokePatternType value) {
  assert(::TSD::StrokePatternArchive_StrokePatternType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void StrokePatternArchive::set_type(::TSD::StrokePatternArchive_StrokePatternType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.type)
}

// optional float phase = 2;
inline bool StrokePatternArchive::_internal_has_phase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_phase() const {
  return _internal_has_phase();
}
inline void StrokePatternArchive::clear_phase() {
  _impl_.phase_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float StrokePatternArchive::_internal_phase() const {
  return _impl_.phase_;
}
inline float StrokePatternArchive::phase() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.phase)
  return _internal_phase();
}
inline void StrokePatternArchive::_internal_set_phase(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.phase_ = value;
}
inline void StrokePatternArchive::set_phase(float value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.phase)
}

// optional uint32 count = 3;
inline bool StrokePatternArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StrokePatternArchive::has_count() const {
  return _internal_has_count();
}
inline void StrokePatternArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StrokePatternArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t StrokePatternArchive::count() const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.count)
  return _internal_count();
}
inline void StrokePatternArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.count_ = value;
}
inline void StrokePatternArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.count)
}

// repeated float pattern = 4;
inline int StrokePatternArchive::_internal_pattern_size() const {
  return _impl_.pattern_.size();
}
inline int StrokePatternArchive::pattern_size() const {
  return _internal_pattern_size();
}
inline void StrokePatternArchive::clear_pattern() {
  _impl_.pattern_.Clear();
}
inline float StrokePatternArchive::_internal_pattern(int index) const {
  return _impl_.pattern_.Get(index);
}
inline float StrokePatternArchive::pattern(int index) const {
  // @@protoc_insertion_point(field_get:TSD.StrokePatternArchive.pattern)
  return _internal_pattern(index);
}
inline void StrokePatternArchive::set_pattern(int index, float value) {
  _impl_.pattern_.Set(index, value);
  // @@protoc_insertion_point(field_set:TSD.StrokePatternArchive.pattern)
}
inline void StrokePatternArchive::_internal_add_pattern(float value) {
  _impl_.pattern_.Add(value);
}
inline void StrokePatternArchive::add_pattern(float value) {
  _internal_add_pattern(value);
  // @@protoc_insertion_point(field_add:TSD.StrokePatternArchive.pattern)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
StrokePatternArchive::_internal_pattern() const {
  return _impl_.pattern_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
StrokePatternArchive::pattern() const {
  // @@protoc_insertion_point(field_list:TSD.StrokePatternArchive.pattern)
  return _internal_pattern();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
StrokePatternArchive::_internal_mutable_pattern() {
  return &_impl_.pattern_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
StrokePatternArchive::mutable_pattern() {
  // @@protoc_insertion_point(field_mutable_list:TSD.StrokePatternArchive.pattern)
  return _internal_mutable_pattern();
}

// -------------------------------------------------------------------

// StrokeArchive

// optional .TSP.Color color = 1;
inline bool StrokeArchive::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& StrokeArchive::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& StrokeArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.color)
  return _internal_color();
}
inline void StrokeArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.color)
}
inline ::TSP::Color* StrokeArchive::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* StrokeArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* StrokeArchive::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* StrokeArchive::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.color)
  return _msg;
}
inline void StrokeArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.color)
}

// optional float width = 2;
inline bool StrokeArchive::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StrokeArchive::has_width() const {
  return _internal_has_width();
}
inline void StrokeArchive::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float StrokeArchive::_internal_width() const {
  return _impl_.width_;
}
inline float StrokeArchive::width() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.width)
  return _internal_width();
}
inline void StrokeArchive::_internal_set_width(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.width_ = value;
}
inline void StrokeArchive::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.width)
}

// optional .TSD.StrokeArchive.LineCap cap = 3;
inline bool StrokeArchive::_internal_has_cap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StrokeArchive::has_cap() const {
  return _internal_has_cap();
}
inline void StrokeArchive::clear_cap() {
  _impl_.cap_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::TSD::StrokeArchive_LineCap StrokeArchive::_internal_cap() const {
  return static_cast< ::TSD::StrokeArchive_LineCap >(_impl_.cap_);
}
inline ::TSD::StrokeArchive_LineCap StrokeArchive::cap() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.cap)
  return _internal_cap();
}
inline void StrokeArchive::_internal_set_cap(::TSD::StrokeArchive_LineCap value) {
  assert(::TSD::StrokeArchive_LineCap_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cap_ = value;
}
inline void StrokeArchive::set_cap(::TSD::StrokeArchive_LineCap value) {
  _internal_set_cap(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.cap)
}

// optional .TSD.LineJoin join = 4;
inline bool StrokeArchive::_internal_has_join() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StrokeArchive::has_join() const {
  return _internal_has_join();
}
inline void StrokeArchive::clear_join() {
  _impl_.join_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::TSD::LineJoin StrokeArchive::_internal_join() const {
  return static_cast< ::TSD::LineJoin >(_impl_.join_);
}
inline ::TSD::LineJoin StrokeArchive::join() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.join)
  return _internal_join();
}
inline void StrokeArchive::_internal_set_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.join_ = value;
}
inline void StrokeArchive::set_join(::TSD::LineJoin value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.join)
}

// optional float miterLimit = 5;
inline bool StrokeArchive::_internal_has_miterlimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StrokeArchive::has_miterlimit() const {
  return _internal_has_miterlimit();
}
inline void StrokeArchive::clear_miterlimit() {
  _impl_.miterlimit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float StrokeArchive::_internal_miterlimit() const {
  return _impl_.miterlimit_;
}
inline float StrokeArchive::miterlimit() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.miterLimit)
  return _internal_miterlimit();
}
inline void StrokeArchive::_internal_set_miterlimit(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.miterlimit_ = value;
}
inline void StrokeArchive::set_miterlimit(float value) {
  _internal_set_miterlimit(value);
  // @@protoc_insertion_point(field_set:TSD.StrokeArchive.miterLimit)
}

// optional .TSD.StrokePatternArchive pattern = 6;
inline bool StrokeArchive::_internal_has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pattern_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_pattern() const {
  return _internal_has_pattern();
}
inline void StrokeArchive::clear_pattern() {
  if (_impl_.pattern_ != nullptr) _impl_.pattern_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::StrokePatternArchive& StrokeArchive::_internal_pattern() const {
  const ::TSD::StrokePatternArchive* p = _impl_.pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokePatternArchive&>(
      ::TSD::_StrokePatternArchive_default_instance_);
}
inline const ::TSD::StrokePatternArchive& StrokeArchive::pattern() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.pattern)
  return _internal_pattern();
}
inline void StrokeArchive::unsafe_arena_set_allocated_pattern(
    ::TSD::StrokePatternArchive* pattern) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pattern_);
  }
  _impl_.pattern_ = pattern;
  if (pattern) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.pattern)
}
inline ::TSD::StrokePatternArchive* StrokeArchive::release_pattern() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = _impl_.pattern_;
  _impl_.pattern_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::unsafe_arena_release_pattern() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.pattern)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokePatternArchive* temp = _impl_.pattern_;
  _impl_.pattern_ = nullptr;
  return temp;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::_internal_mutable_pattern() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokePatternArchive>(GetArenaForAllocation());
    _impl_.pattern_ = p;
  }
  return _impl_.pattern_;
}
inline ::TSD::StrokePatternArchive* StrokeArchive::mutable_pattern() {
  ::TSD::StrokePatternArchive* _msg = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.pattern)
  return _msg;
}
inline void StrokeArchive::set_allocated_pattern(::TSD::StrokePatternArchive* pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pattern_;
  }
  if (pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pattern);
    if (message_arena != submessage_arena) {
      pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pattern, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_ = pattern;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.pattern)
}

// optional .TSD.SmartStrokeArchive smartStroke = 7;
inline bool StrokeArchive::_internal_has_smartstroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.smartstroke_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_smartstroke() const {
  return _internal_has_smartstroke();
}
inline void StrokeArchive::clear_smartstroke() {
  if (_impl_.smartstroke_ != nullptr) _impl_.smartstroke_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::SmartStrokeArchive& StrokeArchive::_internal_smartstroke() const {
  const ::TSD::SmartStrokeArchive* p = _impl_.smartstroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::SmartStrokeArchive&>(
      ::TSD::_SmartStrokeArchive_default_instance_);
}
inline const ::TSD::SmartStrokeArchive& StrokeArchive::smartstroke() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.smartStroke)
  return _internal_smartstroke();
}
inline void StrokeArchive::unsafe_arena_set_allocated_smartstroke(
    ::TSD::SmartStrokeArchive* smartstroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.smartstroke_);
  }
  _impl_.smartstroke_ = smartstroke;
  if (smartstroke) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.smartStroke)
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::release_smartstroke() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::SmartStrokeArchive* temp = _impl_.smartstroke_;
  _impl_.smartstroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::unsafe_arena_release_smartstroke() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.smartStroke)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::SmartStrokeArchive* temp = _impl_.smartstroke_;
  _impl_.smartstroke_ = nullptr;
  return temp;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::_internal_mutable_smartstroke() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.smartstroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::SmartStrokeArchive>(GetArenaForAllocation());
    _impl_.smartstroke_ = p;
  }
  return _impl_.smartstroke_;
}
inline ::TSD::SmartStrokeArchive* StrokeArchive::mutable_smartstroke() {
  ::TSD::SmartStrokeArchive* _msg = _internal_mutable_smartstroke();
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.smartStroke)
  return _msg;
}
inline void StrokeArchive::set_allocated_smartstroke(::TSD::SmartStrokeArchive* smartstroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.smartstroke_;
  }
  if (smartstroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smartstroke);
    if (message_arena != submessage_arena) {
      smartstroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smartstroke, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.smartstroke_ = smartstroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.smartStroke)
}

// optional .TSD.FrameArchive frame = 8;
inline bool StrokeArchive::_internal_has_frame() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.frame_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_frame() const {
  return _internal_has_frame();
}
inline void StrokeArchive::clear_frame() {
  if (_impl_.frame_ != nullptr) _impl_.frame_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::FrameArchive& StrokeArchive::_internal_frame() const {
  const ::TSD::FrameArchive* p = _impl_.frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FrameArchive&>(
      ::TSD::_FrameArchive_default_instance_);
}
inline const ::TSD::FrameArchive& StrokeArchive::frame() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.frame)
  return _internal_frame();
}
inline void StrokeArchive::unsafe_arena_set_allocated_frame(
    ::TSD::FrameArchive* frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.frame_);
  }
  _impl_.frame_ = frame;
  if (frame) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.frame)
}
inline ::TSD::FrameArchive* StrokeArchive::release_frame() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::FrameArchive* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::FrameArchive* StrokeArchive::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.frame)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::FrameArchive* temp = _impl_.frame_;
  _impl_.frame_ = nullptr;
  return temp;
}
inline ::TSD::FrameArchive* StrokeArchive::_internal_mutable_frame() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FrameArchive>(GetArenaForAllocation());
    _impl_.frame_ = p;
  }
  return _impl_.frame_;
}
inline ::TSD::FrameArchive* StrokeArchive::mutable_frame() {
  ::TSD::FrameArchive* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.frame)
  return _msg;
}
inline void StrokeArchive::set_allocated_frame(::TSD::FrameArchive* frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.frame_;
  }
  if (frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame);
    if (message_arena != submessage_arena) {
      frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.frame)
}

// optional .TSD.PatternedStrokeArchive patterned_stroke = 9;
inline bool StrokeArchive::_internal_has_patterned_stroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.patterned_stroke_ != nullptr);
  return value;
}
inline bool StrokeArchive::has_patterned_stroke() const {
  return _internal_has_patterned_stroke();
}
inline void StrokeArchive::clear_patterned_stroke() {
  if (_impl_.patterned_stroke_ != nullptr) _impl_.patterned_stroke_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::PatternedStrokeArchive& StrokeArchive::_internal_patterned_stroke() const {
  const ::TSD::PatternedStrokeArchive* p = _impl_.patterned_stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PatternedStrokeArchive&>(
      ::TSD::_PatternedStrokeArchive_default_instance_);
}
inline const ::TSD::PatternedStrokeArchive& StrokeArchive::patterned_stroke() const {
  // @@protoc_insertion_point(field_get:TSD.StrokeArchive.patterned_stroke)
  return _internal_patterned_stroke();
}
inline void StrokeArchive::unsafe_arena_set_allocated_patterned_stroke(
    ::TSD::PatternedStrokeArchive* patterned_stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.patterned_stroke_);
  }
  _impl_.patterned_stroke_ = patterned_stroke;
  if (patterned_stroke) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.StrokeArchive.patterned_stroke)
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::release_patterned_stroke() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::PatternedStrokeArchive* temp = _impl_.patterned_stroke_;
  _impl_.patterned_stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::unsafe_arena_release_patterned_stroke() {
  // @@protoc_insertion_point(field_release:TSD.StrokeArchive.patterned_stroke)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::PatternedStrokeArchive* temp = _impl_.patterned_stroke_;
  _impl_.patterned_stroke_ = nullptr;
  return temp;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::_internal_mutable_patterned_stroke() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.patterned_stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PatternedStrokeArchive>(GetArenaForAllocation());
    _impl_.patterned_stroke_ = p;
  }
  return _impl_.patterned_stroke_;
}
inline ::TSD::PatternedStrokeArchive* StrokeArchive::mutable_patterned_stroke() {
  ::TSD::PatternedStrokeArchive* _msg = _internal_mutable_patterned_stroke();
  // @@protoc_insertion_point(field_mutable:TSD.StrokeArchive.patterned_stroke)
  return _msg;
}
inline void StrokeArchive::set_allocated_patterned_stroke(::TSD::PatternedStrokeArchive* patterned_stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.patterned_stroke_;
  }
  if (patterned_stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(patterned_stroke);
    if (message_arena != submessage_arena) {
      patterned_stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, patterned_stroke, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.patterned_stroke_ = patterned_stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.StrokeArchive.patterned_stroke)
}

// -------------------------------------------------------------------

// SmartStrokeArchive

// optional string strokeName = 2;
inline bool SmartStrokeArchive::_internal_has_strokename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SmartStrokeArchive::has_strokename() const {
  return _internal_has_strokename();
}
inline void SmartStrokeArchive::clear_strokename() {
  _impl_.strokename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SmartStrokeArchive::strokename() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.strokeName)
  return _internal_strokename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SmartStrokeArchive::set_strokename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.strokename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.SmartStrokeArchive.strokeName)
}
inline std::string* SmartStrokeArchive::mutable_strokename() {
  std::string* _s = _internal_mutable_strokename();
  // @@protoc_insertion_point(field_mutable:TSD.SmartStrokeArchive.strokeName)
  return _s;
}
inline const std::string& SmartStrokeArchive::_internal_strokename() const {
  return _impl_.strokename_.Get();
}
inline void SmartStrokeArchive::_internal_set_strokename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.strokename_.Set(value, GetArenaForAllocation());
}
inline std::string* SmartStrokeArchive::_internal_mutable_strokename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.strokename_.Mutable(GetArenaForAllocation());
}
inline std::string* SmartStrokeArchive::release_strokename() {
  // @@protoc_insertion_point(field_release:TSD.SmartStrokeArchive.strokeName)
  if (!_internal_has_strokename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.strokename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strokename_.IsDefault()) {
    _impl_.strokename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SmartStrokeArchive::set_allocated_strokename(std::string* strokename) {
  if (strokename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.strokename_.SetAllocated(strokename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.strokename_.IsDefault()) {
    _impl_.strokename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.SmartStrokeArchive.strokeName)
}

// optional int32 randomSeed = 3;
inline bool SmartStrokeArchive::_internal_has_randomseed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SmartStrokeArchive::has_randomseed() const {
  return _internal_has_randomseed();
}
inline void SmartStrokeArchive::clear_randomseed() {
  _impl_.randomseed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SmartStrokeArchive::_internal_randomseed() const {
  return _impl_.randomseed_;
}
inline int32_t SmartStrokeArchive::randomseed() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.randomSeed)
  return _internal_randomseed();
}
inline void SmartStrokeArchive::_internal_set_randomseed(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.randomseed_ = value;
}
inline void SmartStrokeArchive::set_randomseed(int32_t value) {
  _internal_set_randomseed(value);
  // @@protoc_insertion_point(field_set:TSD.SmartStrokeArchive.randomSeed)
}

// optional .TSP.ReferenceDictionary parameterValues = 4;
inline bool SmartStrokeArchive::_internal_has_parametervalues() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parametervalues_ != nullptr);
  return value;
}
inline bool SmartStrokeArchive::has_parametervalues() const {
  return _internal_has_parametervalues();
}
inline const ::TSP::ReferenceDictionary& SmartStrokeArchive::_internal_parametervalues() const {
  const ::TSP::ReferenceDictionary* p = _impl_.parametervalues_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::ReferenceDictionary&>(
      ::TSP::_ReferenceDictionary_default_instance_);
}
inline const ::TSP::ReferenceDictionary& SmartStrokeArchive::parametervalues() const {
  // @@protoc_insertion_point(field_get:TSD.SmartStrokeArchive.parameterValues)
  return _internal_parametervalues();
}
inline void SmartStrokeArchive::unsafe_arena_set_allocated_parametervalues(
    ::TSP::ReferenceDictionary* parametervalues) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parametervalues_);
  }
  _impl_.parametervalues_ = parametervalues;
  if (parametervalues) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.SmartStrokeArchive.parameterValues)
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::release_parametervalues() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::ReferenceDictionary* temp = _impl_.parametervalues_;
  _impl_.parametervalues_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::unsafe_arena_release_parametervalues() {
  // @@protoc_insertion_point(field_release:TSD.SmartStrokeArchive.parameterValues)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::ReferenceDictionary* temp = _impl_.parametervalues_;
  _impl_.parametervalues_ = nullptr;
  return temp;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::_internal_mutable_parametervalues() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.parametervalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::ReferenceDictionary>(GetArenaForAllocation());
    _impl_.parametervalues_ = p;
  }
  return _impl_.parametervalues_;
}
inline ::TSP::ReferenceDictionary* SmartStrokeArchive::mutable_parametervalues() {
  ::TSP::ReferenceDictionary* _msg = _internal_mutable_parametervalues();
  // @@protoc_insertion_point(field_mutable:TSD.SmartStrokeArchive.parameterValues)
  return _msg;
}
inline void SmartStrokeArchive::set_allocated_parametervalues(::TSP::ReferenceDictionary* parametervalues) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parametervalues_);
  }
  if (parametervalues) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parametervalues));
    if (message_arena != submessage_arena) {
      parametervalues = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parametervalues, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parametervalues_ = parametervalues;
  // @@protoc_insertion_point(field_set_allocated:TSD.SmartStrokeArchive.parameterValues)
}

// -------------------------------------------------------------------

// FrameArchive

// optional string frameName = 2;
inline bool FrameArchive::_internal_has_framename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FrameArchive::has_framename() const {
  return _internal_has_framename();
}
inline void FrameArchive::clear_framename() {
  _impl_.framename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameArchive::framename() const {
  // @@protoc_insertion_point(field_get:TSD.FrameArchive.frameName)
  return _internal_framename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameArchive::set_framename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.framename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.FrameArchive.frameName)
}
inline std::string* FrameArchive::mutable_framename() {
  std::string* _s = _internal_mutable_framename();
  // @@protoc_insertion_point(field_mutable:TSD.FrameArchive.frameName)
  return _s;
}
inline const std::string& FrameArchive::_internal_framename() const {
  return _impl_.framename_.Get();
}
inline void FrameArchive::_internal_set_framename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.framename_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameArchive::_internal_mutable_framename() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.framename_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameArchive::release_framename() {
  // @@protoc_insertion_point(field_release:TSD.FrameArchive.frameName)
  if (!_internal_has_framename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.framename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.framename_.IsDefault()) {
    _impl_.framename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FrameArchive::set_allocated_framename(std::string* framename) {
  if (framename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.framename_.SetAllocated(framename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.framename_.IsDefault()) {
    _impl_.framename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.FrameArchive.frameName)
}

// optional float assetScale = 3;
inline bool FrameArchive::_internal_has_assetscale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameArchive::has_assetscale() const {
  return _internal_has_assetscale();
}
inline void FrameArchive::clear_assetscale() {
  _impl_.assetscale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FrameArchive::_internal_assetscale() const {
  return _impl_.assetscale_;
}
inline float FrameArchive::assetscale() const {
  // @@protoc_insertion_point(field_get:TSD.FrameArchive.assetScale)
  return _internal_assetscale();
}
inline void FrameArchive::_internal_set_assetscale(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.assetscale_ = value;
}
inline void FrameArchive::set_assetscale(float value) {
  _internal_set_assetscale(value);
  // @@protoc_insertion_point(field_set:TSD.FrameArchive.assetScale)
}

// -------------------------------------------------------------------

// PatternedStrokeArchive

// optional string pattern_name = 2;
inline bool PatternedStrokeArchive::_internal_has_pattern_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PatternedStrokeArchive::has_pattern_name() const {
  return _internal_has_pattern_name();
}
inline void PatternedStrokeArchive::clear_pattern_name() {
  _impl_.pattern_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PatternedStrokeArchive::pattern_name() const {
  // @@protoc_insertion_point(field_get:TSD.PatternedStrokeArchive.pattern_name)
  return _internal_pattern_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PatternedStrokeArchive::set_pattern_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.pattern_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.PatternedStrokeArchive.pattern_name)
}
inline std::string* PatternedStrokeArchive::mutable_pattern_name() {
  std::string* _s = _internal_mutable_pattern_name();
  // @@protoc_insertion_point(field_mutable:TSD.PatternedStrokeArchive.pattern_name)
  return _s;
}
inline const std::string& PatternedStrokeArchive::_internal_pattern_name() const {
  return _impl_.pattern_name_.Get();
}
inline void PatternedStrokeArchive::_internal_set_pattern_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pattern_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PatternedStrokeArchive::_internal_mutable_pattern_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pattern_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PatternedStrokeArchive::release_pattern_name() {
  // @@protoc_insertion_point(field_release:TSD.PatternedStrokeArchive.pattern_name)
  if (!_internal_has_pattern_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.pattern_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pattern_name_.IsDefault()) {
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PatternedStrokeArchive::set_allocated_pattern_name(std::string* pattern_name) {
  if (pattern_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pattern_name_.SetAllocated(pattern_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pattern_name_.IsDefault()) {
    _impl_.pattern_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.PatternedStrokeArchive.pattern_name)
}

// -------------------------------------------------------------------

// LineEndArchive

// optional .TSP.Path path = 1;
inline bool LineEndArchive::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_ != nullptr);
  return value;
}
inline bool LineEndArchive::has_path() const {
  return _internal_has_path();
}
inline const ::TSP::Path& LineEndArchive::_internal_path() const {
  const ::TSP::Path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& LineEndArchive::path() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.path)
  return _internal_path();
}
inline void LineEndArchive::unsafe_arena_set_allocated_path(
    ::TSP::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.LineEndArchive.path)
}
inline ::TSP::Path* LineEndArchive::release_path() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Path* LineEndArchive::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.path)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::TSP::Path* LineEndArchive::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::TSP::Path* LineEndArchive::mutable_path() {
  ::TSP::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.path)
  return _msg;
}
inline void LineEndArchive::set_allocated_path(::TSP::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path));
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.path)
}

// optional .TSD.LineJoin line_join = 2 [default = MiterJoin];
inline bool LineEndArchive::_internal_has_line_join() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LineEndArchive::has_line_join() const {
  return _internal_has_line_join();
}
inline void LineEndArchive::clear_line_join() {
  _impl_.line_join_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TSD::LineJoin LineEndArchive::_internal_line_join() const {
  return static_cast< ::TSD::LineJoin >(_impl_.line_join_);
}
inline ::TSD::LineJoin LineEndArchive::line_join() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.line_join)
  return _internal_line_join();
}
inline void LineEndArchive::_internal_set_line_join(::TSD::LineJoin value) {
  assert(::TSD::LineJoin_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.line_join_ = value;
}
inline void LineEndArchive::set_line_join(::TSD::LineJoin value) {
  _internal_set_line_join(value);
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.line_join)
}

// optional .TSP.Point end_point = 3;
inline bool LineEndArchive::_internal_has_end_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_point_ != nullptr);
  return value;
}
inline bool LineEndArchive::has_end_point() const {
  return _internal_has_end_point();
}
inline const ::TSP::Point& LineEndArchive::_internal_end_point() const {
  const ::TSP::Point* p = _impl_.end_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Point&>(
      ::TSP::_Point_default_instance_);
}
inline const ::TSP::Point& LineEndArchive::end_point() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.end_point)
  return _internal_end_point();
}
inline void LineEndArchive::unsafe_arena_set_allocated_end_point(
    ::TSP::Point* end_point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_point_);
  }
  _impl_.end_point_ = end_point;
  if (end_point) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.LineEndArchive.end_point)
}
inline ::TSP::Point* LineEndArchive::release_end_point() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = _impl_.end_point_;
  _impl_.end_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Point* LineEndArchive::unsafe_arena_release_end_point() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.end_point)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Point* temp = _impl_.end_point_;
  _impl_.end_point_ = nullptr;
  return temp;
}
inline ::TSP::Point* LineEndArchive::_internal_mutable_end_point() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.end_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Point>(GetArenaForAllocation());
    _impl_.end_point_ = p;
  }
  return _impl_.end_point_;
}
inline ::TSP::Point* LineEndArchive::mutable_end_point() {
  ::TSP::Point* _msg = _internal_mutable_end_point();
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.end_point)
  return _msg;
}
inline void LineEndArchive::set_allocated_end_point(::TSP::Point* end_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_point_);
  }
  if (end_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_point));
    if (message_arena != submessage_arena) {
      end_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.end_point_ = end_point;
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.end_point)
}

// optional bool is_filled = 4;
inline bool LineEndArchive::_internal_has_is_filled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LineEndArchive::has_is_filled() const {
  return _internal_has_is_filled();
}
inline void LineEndArchive::clear_is_filled() {
  _impl_.is_filled_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool LineEndArchive::_internal_is_filled() const {
  return _impl_.is_filled_;
}
inline bool LineEndArchive::is_filled() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.is_filled)
  return _internal_is_filled();
}
inline void LineEndArchive::_internal_set_is_filled(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_filled_ = value;
}
inline void LineEndArchive::set_is_filled(bool value) {
  _internal_set_is_filled(value);
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.is_filled)
}

// optional string identifier = 5;
inline bool LineEndArchive::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LineEndArchive::has_identifier() const {
  return _internal_has_identifier();
}
inline void LineEndArchive::clear_identifier() {
  _impl_.identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LineEndArchive::identifier() const {
  // @@protoc_insertion_point(field_get:TSD.LineEndArchive.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LineEndArchive::set_identifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.LineEndArchive.identifier)
}
inline std::string* LineEndArchive::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:TSD.LineEndArchive.identifier)
  return _s;
}
inline const std::string& LineEndArchive::_internal_identifier() const {
  return _impl_.identifier_.Get();
}
inline void LineEndArchive::_internal_set_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* LineEndArchive::_internal_mutable_identifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* LineEndArchive::release_identifier() {
  // @@protoc_insertion_point(field_release:TSD.LineEndArchive.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identifier_.IsDefault()) {
    _impl_.identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LineEndArchive::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identifier_.IsDefault()) {
    _impl_.identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.LineEndArchive.identifier)
}

// -------------------------------------------------------------------

// ShadowArchive

// optional .TSP.Color color = 1;
inline bool ShadowArchive::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& ShadowArchive::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& ShadowArchive::color() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.color)
  return _internal_color();
}
inline void ShadowArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.color)
}
inline ::TSP::Color* ShadowArchive::release_color() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* ShadowArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.color)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* ShadowArchive::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* ShadowArchive::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.color)
  return _msg;
}
inline void ShadowArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.color)
}

// optional float angle = 2 [default = 315];
inline bool ShadowArchive::_internal_has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShadowArchive::has_angle() const {
  return _internal_has_angle();
}
inline void ShadowArchive::clear_angle() {
  _impl_.angle_ = 315;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float ShadowArchive::_internal_angle() const {
  return _impl_.angle_;
}
inline float ShadowArchive::angle() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.angle)
  return _internal_angle();
}
inline void ShadowArchive::_internal_set_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.angle_ = value;
}
inline void ShadowArchive::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.angle)
}

// optional float offset = 3 [default = 5];
inline bool ShadowArchive::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShadowArchive::has_offset() const {
  return _internal_has_offset();
}
inline void ShadowArchive::clear_offset() {
  _impl_.offset_ = 5;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float ShadowArchive::_internal_offset() const {
  return _impl_.offset_;
}
inline float ShadowArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.offset)
  return _internal_offset();
}
inline void ShadowArchive::_internal_set_offset(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.offset_ = value;
}
inline void ShadowArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.offset)
}

// optional int32 radius = 4 [default = 1];
inline bool ShadowArchive::_internal_has_radius() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ShadowArchive::has_radius() const {
  return _internal_has_radius();
}
inline void ShadowArchive::clear_radius() {
  _impl_.radius_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t ShadowArchive::_internal_radius() const {
  return _impl_.radius_;
}
inline int32_t ShadowArchive::radius() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.radius)
  return _internal_radius();
}
inline void ShadowArchive::_internal_set_radius(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.radius_ = value;
}
inline void ShadowArchive::set_radius(int32_t value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.radius)
}

// optional float opacity = 5 [default = 1];
inline bool ShadowArchive::_internal_has_opacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ShadowArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ShadowArchive::clear_opacity() {
  _impl_.opacity_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float ShadowArchive::_internal_opacity() const {
  return _impl_.opacity_;
}
inline float ShadowArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.opacity)
  return _internal_opacity();
}
inline void ShadowArchive::_internal_set_opacity(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.opacity_ = value;
}
inline void ShadowArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.opacity)
}

// optional bool is_enabled = 6 [default = true];
inline bool ShadowArchive::_internal_has_is_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShadowArchive::has_is_enabled() const {
  return _internal_has_is_enabled();
}
inline void ShadowArchive::clear_is_enabled() {
  _impl_.is_enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ShadowArchive::_internal_is_enabled() const {
  return _impl_.is_enabled_;
}
inline bool ShadowArchive::is_enabled() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.is_enabled)
  return _internal_is_enabled();
}
inline void ShadowArchive::_internal_set_is_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_enabled_ = value;
}
inline void ShadowArchive::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.is_enabled)
}

// optional .TSD.ShadowArchive.ShadowType type = 7 [default = TSDDropShadow];
inline bool ShadowArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShadowArchive::has_type() const {
  return _internal_has_type();
}
inline void ShadowArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TSD::ShadowArchive_ShadowType ShadowArchive::_internal_type() const {
  return static_cast< ::TSD::ShadowArchive_ShadowType >(_impl_.type_);
}
inline ::TSD::ShadowArchive_ShadowType ShadowArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.type)
  return _internal_type();
}
inline void ShadowArchive::_internal_set_type(::TSD::ShadowArchive_ShadowType value) {
  assert(::TSD::ShadowArchive_ShadowType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void ShadowArchive::set_type(::TSD::ShadowArchive_ShadowType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ShadowArchive.type)
}

// optional .TSD.DropShadowArchive dropShadow = 8;
inline bool ShadowArchive::_internal_has_dropshadow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dropshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_dropshadow() const {
  return _internal_has_dropshadow();
}
inline void ShadowArchive::clear_dropshadow() {
  if (_impl_.dropshadow_ != nullptr) _impl_.dropshadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::DropShadowArchive& ShadowArchive::_internal_dropshadow() const {
  const ::TSD::DropShadowArchive* p = _impl_.dropshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DropShadowArchive&>(
      ::TSD::_DropShadowArchive_default_instance_);
}
inline const ::TSD::DropShadowArchive& ShadowArchive::dropshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.dropShadow)
  return _internal_dropshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_dropshadow(
    ::TSD::DropShadowArchive* dropshadow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dropshadow_);
  }
  _impl_.dropshadow_ = dropshadow;
  if (dropshadow) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.dropShadow)
}
inline ::TSD::DropShadowArchive* ShadowArchive::release_dropshadow() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::DropShadowArchive* temp = _impl_.dropshadow_;
  _impl_.dropshadow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DropShadowArchive* ShadowArchive::unsafe_arena_release_dropshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.dropShadow)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::DropShadowArchive* temp = _impl_.dropshadow_;
  _impl_.dropshadow_ = nullptr;
  return temp;
}
inline ::TSD::DropShadowArchive* ShadowArchive::_internal_mutable_dropshadow() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dropshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DropShadowArchive>(GetArenaForAllocation());
    _impl_.dropshadow_ = p;
  }
  return _impl_.dropshadow_;
}
inline ::TSD::DropShadowArchive* ShadowArchive::mutable_dropshadow() {
  ::TSD::DropShadowArchive* _msg = _internal_mutable_dropshadow();
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.dropShadow)
  return _msg;
}
inline void ShadowArchive::set_allocated_dropshadow(::TSD::DropShadowArchive* dropshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dropshadow_;
  }
  if (dropshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dropshadow);
    if (message_arena != submessage_arena) {
      dropshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dropshadow, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dropshadow_ = dropshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.dropShadow)
}

// optional .TSD.ContactShadowArchive contactShadow = 9;
inline bool ShadowArchive::_internal_has_contactshadow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.contactshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_contactshadow() const {
  return _internal_has_contactshadow();
}
inline void ShadowArchive::clear_contactshadow() {
  if (_impl_.contactshadow_ != nullptr) _impl_.contactshadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ContactShadowArchive& ShadowArchive::_internal_contactshadow() const {
  const ::TSD::ContactShadowArchive* p = _impl_.contactshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ContactShadowArchive&>(
      ::TSD::_ContactShadowArchive_default_instance_);
}
inline const ::TSD::ContactShadowArchive& ShadowArchive::contactshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.contactShadow)
  return _internal_contactshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_contactshadow(
    ::TSD::ContactShadowArchive* contactshadow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.contactshadow_);
  }
  _impl_.contactshadow_ = contactshadow;
  if (contactshadow) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.contactShadow)
}
inline ::TSD::ContactShadowArchive* ShadowArchive::release_contactshadow() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ContactShadowArchive* temp = _impl_.contactshadow_;
  _impl_.contactshadow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::unsafe_arena_release_contactshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.contactShadow)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ContactShadowArchive* temp = _impl_.contactshadow_;
  _impl_.contactshadow_ = nullptr;
  return temp;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::_internal_mutable_contactshadow() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.contactshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ContactShadowArchive>(GetArenaForAllocation());
    _impl_.contactshadow_ = p;
  }
  return _impl_.contactshadow_;
}
inline ::TSD::ContactShadowArchive* ShadowArchive::mutable_contactshadow() {
  ::TSD::ContactShadowArchive* _msg = _internal_mutable_contactshadow();
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.contactShadow)
  return _msg;
}
inline void ShadowArchive::set_allocated_contactshadow(::TSD::ContactShadowArchive* contactshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.contactshadow_;
  }
  if (contactshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(contactshadow);
    if (message_arena != submessage_arena) {
      contactshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, contactshadow, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contactshadow_ = contactshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.contactShadow)
}

// optional .TSD.CurvedShadowArchive curvedShadow = 10;
inline bool ShadowArchive::_internal_has_curvedshadow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curvedshadow_ != nullptr);
  return value;
}
inline bool ShadowArchive::has_curvedshadow() const {
  return _internal_has_curvedshadow();
}
inline void ShadowArchive::clear_curvedshadow() {
  if (_impl_.curvedshadow_ != nullptr) _impl_.curvedshadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::CurvedShadowArchive& ShadowArchive::_internal_curvedshadow() const {
  const ::TSD::CurvedShadowArchive* p = _impl_.curvedshadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::CurvedShadowArchive&>(
      ::TSD::_CurvedShadowArchive_default_instance_);
}
inline const ::TSD::CurvedShadowArchive& ShadowArchive::curvedshadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShadowArchive.curvedShadow)
  return _internal_curvedshadow();
}
inline void ShadowArchive::unsafe_arena_set_allocated_curvedshadow(
    ::TSD::CurvedShadowArchive* curvedshadow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.curvedshadow_);
  }
  _impl_.curvedshadow_ = curvedshadow;
  if (curvedshadow) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShadowArchive.curvedShadow)
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::release_curvedshadow() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::CurvedShadowArchive* temp = _impl_.curvedshadow_;
  _impl_.curvedshadow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::unsafe_arena_release_curvedshadow() {
  // @@protoc_insertion_point(field_release:TSD.ShadowArchive.curvedShadow)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::CurvedShadowArchive* temp = _impl_.curvedshadow_;
  _impl_.curvedshadow_ = nullptr;
  return temp;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::_internal_mutable_curvedshadow() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.curvedshadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::CurvedShadowArchive>(GetArenaForAllocation());
    _impl_.curvedshadow_ = p;
  }
  return _impl_.curvedshadow_;
}
inline ::TSD::CurvedShadowArchive* ShadowArchive::mutable_curvedshadow() {
  ::TSD::CurvedShadowArchive* _msg = _internal_mutable_curvedshadow();
  // @@protoc_insertion_point(field_mutable:TSD.ShadowArchive.curvedShadow)
  return _msg;
}
inline void ShadowArchive::set_allocated_curvedshadow(::TSD::CurvedShadowArchive* curvedshadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.curvedshadow_;
  }
  if (curvedshadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(curvedshadow);
    if (message_arena != submessage_arena) {
      curvedshadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curvedshadow, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.curvedshadow_ = curvedshadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShadowArchive.curvedShadow)
}

// -------------------------------------------------------------------

// DropShadowArchive

// -------------------------------------------------------------------

// ContactShadowArchive

// optional float height = 2 [default = 0.2];
inline bool ContactShadowArchive::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContactShadowArchive::has_height() const {
  return _internal_has_height();
}
inline void ContactShadowArchive::clear_height() {
  _impl_.height_ = 0.2f;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ContactShadowArchive::_internal_height() const {
  return _impl_.height_;
}
inline float ContactShadowArchive::height() const {
  // @@protoc_insertion_point(field_get:TSD.ContactShadowArchive.height)
  return _internal_height();
}
inline void ContactShadowArchive::_internal_set_height(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void ContactShadowArchive::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TSD.ContactShadowArchive.height)
}

// optional float offset = 4 [default = 0];
inline bool ContactShadowArchive::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContactShadowArchive::has_offset() const {
  return _internal_has_offset();
}
inline void ContactShadowArchive::clear_offset() {
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ContactShadowArchive::_internal_offset() const {
  return _impl_.offset_;
}
inline float ContactShadowArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.ContactShadowArchive.offset)
  return _internal_offset();
}
inline void ContactShadowArchive::_internal_set_offset(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offset_ = value;
}
inline void ContactShadowArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.ContactShadowArchive.offset)
}

// -------------------------------------------------------------------

// CurvedShadowArchive

// optional float curve = 1 [default = 0.6];
inline bool CurvedShadowArchive::_internal_has_curve() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CurvedShadowArchive::has_curve() const {
  return _internal_has_curve();
}
inline void CurvedShadowArchive::clear_curve() {
  _impl_.curve_ = 0.6f;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CurvedShadowArchive::_internal_curve() const {
  return _impl_.curve_;
}
inline float CurvedShadowArchive::curve() const {
  // @@protoc_insertion_point(field_get:TSD.CurvedShadowArchive.curve)
  return _internal_curve();
}
inline void CurvedShadowArchive::_internal_set_curve(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.curve_ = value;
}
inline void CurvedShadowArchive::set_curve(float value) {
  _internal_set_curve(value);
  // @@protoc_insertion_point(field_set:TSD.CurvedShadowArchive.curve)
}

// -------------------------------------------------------------------

// ReflectionArchive

// optional float opacity = 1 [default = 0.5];
inline bool ReflectionArchive::_internal_has_opacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReflectionArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ReflectionArchive::clear_opacity() {
  _impl_.opacity_ = 0.5f;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ReflectionArchive::_internal_opacity() const {
  return _impl_.opacity_;
}
inline float ReflectionArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ReflectionArchive.opacity)
  return _internal_opacity();
}
inline void ReflectionArchive::_internal_set_opacity(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.opacity_ = value;
}
inline void ReflectionArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ReflectionArchive.opacity)
}

// -------------------------------------------------------------------

// ImageAdjustmentsArchive

// optional float exposure = 1;
inline bool ImageAdjustmentsArchive::_internal_has_exposure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_exposure() const {
  return _internal_has_exposure();
}
inline void ImageAdjustmentsArchive::clear_exposure() {
  _impl_.exposure_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float ImageAdjustmentsArchive::_internal_exposure() const {
  return _impl_.exposure_;
}
inline float ImageAdjustmentsArchive::exposure() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.exposure)
  return _internal_exposure();
}
inline void ImageAdjustmentsArchive::_internal_set_exposure(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.exposure_ = value;
}
inline void ImageAdjustmentsArchive::set_exposure(float value) {
  _internal_set_exposure(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.exposure)
}

// optional float saturation = 2;
inline bool ImageAdjustmentsArchive::_internal_has_saturation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_saturation() const {
  return _internal_has_saturation();
}
inline void ImageAdjustmentsArchive::clear_saturation() {
  _impl_.saturation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ImageAdjustmentsArchive::_internal_saturation() const {
  return _impl_.saturation_;
}
inline float ImageAdjustmentsArchive::saturation() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.saturation)
  return _internal_saturation();
}
inline void ImageAdjustmentsArchive::_internal_set_saturation(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.saturation_ = value;
}
inline void ImageAdjustmentsArchive::set_saturation(float value) {
  _internal_set_saturation(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.saturation)
}

// optional float contrast = 3;
inline bool ImageAdjustmentsArchive::_internal_has_contrast() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_contrast() const {
  return _internal_has_contrast();
}
inline void ImageAdjustmentsArchive::clear_contrast() {
  _impl_.contrast_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float ImageAdjustmentsArchive::_internal_contrast() const {
  return _impl_.contrast_;
}
inline float ImageAdjustmentsArchive::contrast() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.contrast)
  return _internal_contrast();
}
inline void ImageAdjustmentsArchive::_internal_set_contrast(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.contrast_ = value;
}
inline void ImageAdjustmentsArchive::set_contrast(float value) {
  _internal_set_contrast(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.contrast)
}

// optional float highlights = 4;
inline bool ImageAdjustmentsArchive::_internal_has_highlights() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_highlights() const {
  return _internal_has_highlights();
}
inline void ImageAdjustmentsArchive::clear_highlights() {
  _impl_.highlights_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ImageAdjustmentsArchive::_internal_highlights() const {
  return _impl_.highlights_;
}
inline float ImageAdjustmentsArchive::highlights() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.highlights)
  return _internal_highlights();
}
inline void ImageAdjustmentsArchive::_internal_set_highlights(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.highlights_ = value;
}
inline void ImageAdjustmentsArchive::set_highlights(float value) {
  _internal_set_highlights(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.highlights)
}

// optional float shadows = 5;
inline bool ImageAdjustmentsArchive::_internal_has_shadows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_shadows() const {
  return _internal_has_shadows();
}
inline void ImageAdjustmentsArchive::clear_shadows() {
  _impl_.shadows_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ImageAdjustmentsArchive::_internal_shadows() const {
  return _impl_.shadows_;
}
inline float ImageAdjustmentsArchive::shadows() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.shadows)
  return _internal_shadows();
}
inline void ImageAdjustmentsArchive::_internal_set_shadows(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.shadows_ = value;
}
inline void ImageAdjustmentsArchive::set_shadows(float value) {
  _internal_set_shadows(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.shadows)
}

// optional float sharpness = 6;
inline bool ImageAdjustmentsArchive::_internal_has_sharpness() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_sharpness() const {
  return _internal_has_sharpness();
}
inline void ImageAdjustmentsArchive::clear_sharpness() {
  _impl_.sharpness_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float ImageAdjustmentsArchive::_internal_sharpness() const {
  return _impl_.sharpness_;
}
inline float ImageAdjustmentsArchive::sharpness() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.sharpness)
  return _internal_sharpness();
}
inline void ImageAdjustmentsArchive::_internal_set_sharpness(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sharpness_ = value;
}
inline void ImageAdjustmentsArchive::set_sharpness(float value) {
  _internal_set_sharpness(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.sharpness)
}

// optional float denoise = 7;
inline bool ImageAdjustmentsArchive::_internal_has_denoise() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_denoise() const {
  return _internal_has_denoise();
}
inline void ImageAdjustmentsArchive::clear_denoise() {
  _impl_.denoise_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float ImageAdjustmentsArchive::_internal_denoise() const {
  return _impl_.denoise_;
}
inline float ImageAdjustmentsArchive::denoise() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.denoise)
  return _internal_denoise();
}
inline void ImageAdjustmentsArchive::_internal_set_denoise(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.denoise_ = value;
}
inline void ImageAdjustmentsArchive::set_denoise(float value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.denoise)
}

// optional float temperature = 8;
inline bool ImageAdjustmentsArchive::_internal_has_temperature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_temperature() const {
  return _internal_has_temperature();
}
inline void ImageAdjustmentsArchive::clear_temperature() {
  _impl_.temperature_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float ImageAdjustmentsArchive::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float ImageAdjustmentsArchive::temperature() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.temperature)
  return _internal_temperature();
}
inline void ImageAdjustmentsArchive::_internal_set_temperature(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.temperature_ = value;
}
inline void ImageAdjustmentsArchive::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.temperature)
}

// optional float tint = 9;
inline bool ImageAdjustmentsArchive::_internal_has_tint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_tint() const {
  return _internal_has_tint();
}
inline void ImageAdjustmentsArchive::clear_tint() {
  _impl_.tint_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float ImageAdjustmentsArchive::_internal_tint() const {
  return _impl_.tint_;
}
inline float ImageAdjustmentsArchive::tint() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.tint)
  return _internal_tint();
}
inline void ImageAdjustmentsArchive::_internal_set_tint(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.tint_ = value;
}
inline void ImageAdjustmentsArchive::set_tint(float value) {
  _internal_set_tint(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.tint)
}

// optional float bottom_level = 10;
inline bool ImageAdjustmentsArchive::_internal_has_bottom_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_bottom_level() const {
  return _internal_has_bottom_level();
}
inline void ImageAdjustmentsArchive::clear_bottom_level() {
  _impl_.bottom_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float ImageAdjustmentsArchive::_internal_bottom_level() const {
  return _impl_.bottom_level_;
}
inline float ImageAdjustmentsArchive::bottom_level() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.bottom_level)
  return _internal_bottom_level();
}
inline void ImageAdjustmentsArchive::_internal_set_bottom_level(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.bottom_level_ = value;
}
inline void ImageAdjustmentsArchive::set_bottom_level(float value) {
  _internal_set_bottom_level(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.bottom_level)
}

// optional float top_level = 11 [default = 1];
inline bool ImageAdjustmentsArchive::_internal_has_top_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_top_level() const {
  return _internal_has_top_level();
}
inline void ImageAdjustmentsArchive::clear_top_level() {
  _impl_.top_level_ = 1;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float ImageAdjustmentsArchive::_internal_top_level() const {
  return _impl_.top_level_;
}
inline float ImageAdjustmentsArchive::top_level() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.top_level)
  return _internal_top_level();
}
inline void ImageAdjustmentsArchive::_internal_set_top_level(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.top_level_ = value;
}
inline void ImageAdjustmentsArchive::set_top_level(float value) {
  _internal_set_top_level(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.top_level)
}

// optional float gamma = 12;
inline bool ImageAdjustmentsArchive::_internal_has_gamma() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_gamma() const {
  return _internal_has_gamma();
}
inline void ImageAdjustmentsArchive::clear_gamma() {
  _impl_.gamma_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float ImageAdjustmentsArchive::_internal_gamma() const {
  return _impl_.gamma_;
}
inline float ImageAdjustmentsArchive::gamma() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.gamma)
  return _internal_gamma();
}
inline void ImageAdjustmentsArchive::_internal_set_gamma(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.gamma_ = value;
}
inline void ImageAdjustmentsArchive::set_gamma(float value) {
  _internal_set_gamma(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.gamma)
}

// optional bool enhance = 13 [default = false];
inline bool ImageAdjustmentsArchive::_internal_has_enhance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_enhance() const {
  return _internal_has_enhance();
}
inline void ImageAdjustmentsArchive::clear_enhance() {
  _impl_.enhance_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ImageAdjustmentsArchive::_internal_enhance() const {
  return _impl_.enhance_;
}
inline bool ImageAdjustmentsArchive::enhance() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.enhance)
  return _internal_enhance();
}
inline void ImageAdjustmentsArchive::_internal_set_enhance(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.enhance_ = value;
}
inline void ImageAdjustmentsArchive::set_enhance(bool value) {
  _internal_set_enhance(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.enhance)
}

// optional bool represents_sage_adjustments = 14 [default = false];
inline bool ImageAdjustmentsArchive::_internal_has_represents_sage_adjustments() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ImageAdjustmentsArchive::has_represents_sage_adjustments() const {
  return _internal_has_represents_sage_adjustments();
}
inline void ImageAdjustmentsArchive::clear_represents_sage_adjustments() {
  _impl_.represents_sage_adjustments_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ImageAdjustmentsArchive::_internal_represents_sage_adjustments() const {
  return _impl_.represents_sage_adjustments_;
}
inline bool ImageAdjustmentsArchive::represents_sage_adjustments() const {
  // @@protoc_insertion_point(field_get:TSD.ImageAdjustmentsArchive.represents_sage_adjustments)
  return _internal_represents_sage_adjustments();
}
inline void ImageAdjustmentsArchive::_internal_set_represents_sage_adjustments(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.represents_sage_adjustments_ = value;
}
inline void ImageAdjustmentsArchive::set_represents_sage_adjustments(bool value) {
  _internal_set_represents_sage_adjustments(value);
  // @@protoc_insertion_point(field_set:TSD.ImageAdjustmentsArchive.represents_sage_adjustments)
}

// -------------------------------------------------------------------

// ShapeStylePropertiesArchive

// optional .TSD.FillArchive fill = 1;
inline bool ShapeStylePropertiesArchive::_internal_has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_fill() const {
  return _internal_has_fill();
}
inline void ShapeStylePropertiesArchive::clear_fill() {
  if (_impl_.fill_ != nullptr) _impl_.fill_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::FillArchive& ShapeStylePropertiesArchive::_internal_fill() const {
  const ::TSD::FillArchive* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ShapeStylePropertiesArchive::fill() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.fill)
  return _internal_fill();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_fill(
    ::TSD::FillArchive* fill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = fill;
  if (fill) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.fill)
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::release_fill() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.fill)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::_internal_mutable_fill() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArenaForAllocation());
    _impl_.fill_ = p;
  }
  return _impl_.fill_;
}
inline ::TSD::FillArchive* ShapeStylePropertiesArchive::mutable_fill() {
  ::TSD::FillArchive* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.fill)
  return _msg;
}
inline void ShapeStylePropertiesArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.fill)
}

// optional .TSD.StrokeArchive stroke = 2;
inline bool ShapeStylePropertiesArchive::_internal_has_stroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stroke_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_stroke() const {
  return _internal_has_stroke();
}
inline void ShapeStylePropertiesArchive::clear_stroke() {
  if (_impl_.stroke_ != nullptr) _impl_.stroke_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::StrokeArchive& ShapeStylePropertiesArchive::_internal_stroke() const {
  const ::TSD::StrokeArchive* p = _impl_.stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokeArchive&>(
      ::TSD::_StrokeArchive_default_instance_);
}
inline const ::TSD::StrokeArchive& ShapeStylePropertiesArchive::stroke() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.stroke)
  return _internal_stroke();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_stroke(
    ::TSD::StrokeArchive* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stroke_);
  }
  _impl_.stroke_ = stroke;
  if (stroke) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.stroke)
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::release_stroke() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokeArchive* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.stroke)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::StrokeArchive* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
  return temp;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::_internal_mutable_stroke() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokeArchive>(GetArenaForAllocation());
    _impl_.stroke_ = p;
  }
  return _impl_.stroke_;
}
inline ::TSD::StrokeArchive* ShapeStylePropertiesArchive::mutable_stroke() {
  ::TSD::StrokeArchive* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.stroke)
  return _msg;
}
inline void ShapeStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.stroke)
}

// optional float opacity = 3;
inline bool ShapeStylePropertiesArchive::_internal_has_opacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShapeStylePropertiesArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void ShapeStylePropertiesArchive::clear_opacity() {
  _impl_.opacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ShapeStylePropertiesArchive::_internal_opacity() const {
  return _impl_.opacity_;
}
inline float ShapeStylePropertiesArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.opacity)
  return _internal_opacity();
}
inline void ShapeStylePropertiesArchive::_internal_set_opacity(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.opacity_ = value;
}
inline void ShapeStylePropertiesArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.ShapeStylePropertiesArchive.opacity)
}

// optional .TSD.ShadowArchive shadow = 4;
inline bool ShapeStylePropertiesArchive::_internal_has_shadow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shadow_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_shadow() const {
  return _internal_has_shadow();
}
inline void ShapeStylePropertiesArchive::clear_shadow() {
  if (_impl_.shadow_ != nullptr) _impl_.shadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ShadowArchive& ShapeStylePropertiesArchive::_internal_shadow() const {
  const ::TSD::ShadowArchive* p = _impl_.shadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShadowArchive&>(
      ::TSD::_ShadowArchive_default_instance_);
}
inline const ::TSD::ShadowArchive& ShapeStylePropertiesArchive::shadow() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.shadow)
  return _internal_shadow();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_shadow(
    ::TSD::ShadowArchive* shadow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shadow_);
  }
  _impl_.shadow_ = shadow;
  if (shadow) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.shadow)
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::release_shadow() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ShadowArchive* temp = _impl_.shadow_;
  _impl_.shadow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::unsafe_arena_release_shadow() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.shadow)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ShadowArchive* temp = _impl_.shadow_;
  _impl_.shadow_ = nullptr;
  return temp;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::_internal_mutable_shadow() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.shadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShadowArchive>(GetArenaForAllocation());
    _impl_.shadow_ = p;
  }
  return _impl_.shadow_;
}
inline ::TSD::ShadowArchive* ShapeStylePropertiesArchive::mutable_shadow() {
  ::TSD::ShadowArchive* _msg = _internal_mutable_shadow();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.shadow)
  return _msg;
}
inline void ShapeStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shadow_;
  }
  if (shadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shadow);
    if (message_arena != submessage_arena) {
      shadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shadow, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.shadow_ = shadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.shadow)
}

// optional .TSD.ReflectionArchive reflection = 5;
inline bool ShapeStylePropertiesArchive::_internal_has_reflection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reflection_ != nullptr);
  return value;
}
inline bool ShapeStylePropertiesArchive::has_reflection() const {
  return _internal_has_reflection();
}
inline void ShapeStylePropertiesArchive::clear_reflection() {
  if (_impl_.reflection_ != nullptr) _impl_.reflection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::ReflectionArchive& ShapeStylePropertiesArchive::_internal_reflection() const {
  const ::TSD::ReflectionArchive* p = _impl_.reflection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ReflectionArchive&>(
      ::TSD::_ReflectionArchive_default_instance_);
}
inline const ::TSD::ReflectionArchive& ShapeStylePropertiesArchive::reflection() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStylePropertiesArchive.reflection)
  return _internal_reflection();
}
inline void ShapeStylePropertiesArchive::unsafe_arena_set_allocated_reflection(
    ::TSD::ReflectionArchive* reflection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reflection_);
  }
  _impl_.reflection_ = reflection;
  if (reflection) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStylePropertiesArchive.reflection)
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::release_reflection() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::ReflectionArchive* temp = _impl_.reflection_;
  _impl_.reflection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::unsafe_arena_release_reflection() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStylePropertiesArchive.reflection)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::ReflectionArchive* temp = _impl_.reflection_;
  _impl_.reflection_ = nullptr;
  return temp;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::_internal_mutable_reflection() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.reflection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ReflectionArchive>(GetArenaForAllocation());
    _impl_.reflection_ = p;
  }
  return _impl_.reflection_;
}
inline ::TSD::ReflectionArchive* ShapeStylePropertiesArchive::mutable_reflection() {
  ::TSD::ReflectionArchive* _msg = _internal_mutable_reflection();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStylePropertiesArchive.reflection)
  return _msg;
}
inline void ShapeStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reflection_;
  }
  if (reflection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reflection);
    if (message_arena != submessage_arena) {
      reflection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reflection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.reflection_ = reflection;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStylePropertiesArchive.reflection)
}

// -------------------------------------------------------------------

// ShapeStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool ShapeStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ShapeStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& ShapeStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& ShapeStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.super)
  return _internal_super();
}
inline void ShapeStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStyleArchive.super)
}
inline ::TSS::StyleArchive* ShapeStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* ShapeStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStyleArchive.super)
  return _msg;
}
inline void ShapeStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool ShapeStyleArchive::_internal_has_override_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShapeStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void ShapeStyleArchive::clear_override_count() {
  _impl_.override_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ShapeStyleArchive::_internal_override_count() const {
  return _impl_.override_count_;
}
inline uint32_t ShapeStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.override_count)
  return _internal_override_count();
}
inline void ShapeStyleArchive::_internal_set_override_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.override_count_ = value;
}
inline void ShapeStyleArchive::set_override_count(uint32_t value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TSD.ShapeStyleArchive.override_count)
}

// optional .TSD.ShapeStylePropertiesArchive shape_properties = 11;
inline bool ShapeStyleArchive::_internal_has_shape_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_properties_ != nullptr);
  return value;
}
inline bool ShapeStyleArchive::has_shape_properties() const {
  return _internal_has_shape_properties();
}
inline void ShapeStyleArchive::clear_shape_properties() {
  if (_impl_.shape_properties_ != nullptr) _impl_.shape_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleArchive::_internal_shape_properties() const {
  const ::TSD::ShapeStylePropertiesArchive* p = _impl_.shape_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShapeStylePropertiesArchive&>(
      ::TSD::_ShapeStylePropertiesArchive_default_instance_);
}
inline const ::TSD::ShapeStylePropertiesArchive& ShapeStyleArchive::shape_properties() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeStyleArchive.shape_properties)
  return _internal_shape_properties();
}
inline void ShapeStyleArchive::unsafe_arena_set_allocated_shape_properties(
    ::TSD::ShapeStylePropertiesArchive* shape_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shape_properties_);
  }
  _impl_.shape_properties_ = shape_properties;
  if (shape_properties) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeStyleArchive.shape_properties)
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::release_shape_properties() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ShapeStylePropertiesArchive* temp = _impl_.shape_properties_;
  _impl_.shape_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::unsafe_arena_release_shape_properties() {
  // @@protoc_insertion_point(field_release:TSD.ShapeStyleArchive.shape_properties)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ShapeStylePropertiesArchive* temp = _impl_.shape_properties_;
  _impl_.shape_properties_ = nullptr;
  return temp;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::_internal_mutable_shape_properties() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shape_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShapeStylePropertiesArchive>(GetArenaForAllocation());
    _impl_.shape_properties_ = p;
  }
  return _impl_.shape_properties_;
}
inline ::TSD::ShapeStylePropertiesArchive* ShapeStyleArchive::mutable_shape_properties() {
  ::TSD::ShapeStylePropertiesArchive* _msg = _internal_mutable_shape_properties();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeStyleArchive.shape_properties)
  return _msg;
}
inline void ShapeStyleArchive::set_allocated_shape_properties(::TSD::ShapeStylePropertiesArchive* shape_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shape_properties_;
  }
  if (shape_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape_properties);
    if (message_arena != submessage_arena) {
      shape_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.shape_properties_ = shape_properties;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeStyleArchive.shape_properties)
}

// -------------------------------------------------------------------

// MediaStylePropertiesArchive

// optional .TSD.StrokeArchive stroke = 1;
inline bool MediaStylePropertiesArchive::_internal_has_stroke() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stroke_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_stroke() const {
  return _internal_has_stroke();
}
inline void MediaStylePropertiesArchive::clear_stroke() {
  if (_impl_.stroke_ != nullptr) _impl_.stroke_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::StrokeArchive& MediaStylePropertiesArchive::_internal_stroke() const {
  const ::TSD::StrokeArchive* p = _impl_.stroke_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::StrokeArchive&>(
      ::TSD::_StrokeArchive_default_instance_);
}
inline const ::TSD::StrokeArchive& MediaStylePropertiesArchive::stroke() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.stroke)
  return _internal_stroke();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_stroke(
    ::TSD::StrokeArchive* stroke) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stroke_);
  }
  _impl_.stroke_ = stroke;
  if (stroke) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.stroke)
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::release_stroke() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::StrokeArchive* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::unsafe_arena_release_stroke() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.stroke)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::StrokeArchive* temp = _impl_.stroke_;
  _impl_.stroke_ = nullptr;
  return temp;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::_internal_mutable_stroke() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stroke_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::StrokeArchive>(GetArenaForAllocation());
    _impl_.stroke_ = p;
  }
  return _impl_.stroke_;
}
inline ::TSD::StrokeArchive* MediaStylePropertiesArchive::mutable_stroke() {
  ::TSD::StrokeArchive* _msg = _internal_mutable_stroke();
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.stroke)
  return _msg;
}
inline void MediaStylePropertiesArchive::set_allocated_stroke(::TSD::StrokeArchive* stroke) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stroke_;
  }
  if (stroke) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stroke);
    if (message_arena != submessage_arena) {
      stroke = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.stroke)
}

// optional float opacity = 2;
inline bool MediaStylePropertiesArchive::_internal_has_opacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MediaStylePropertiesArchive::has_opacity() const {
  return _internal_has_opacity();
}
inline void MediaStylePropertiesArchive::clear_opacity() {
  _impl_.opacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float MediaStylePropertiesArchive::_internal_opacity() const {
  return _impl_.opacity_;
}
inline float MediaStylePropertiesArchive::opacity() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.opacity)
  return _internal_opacity();
}
inline void MediaStylePropertiesArchive::_internal_set_opacity(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.opacity_ = value;
}
inline void MediaStylePropertiesArchive::set_opacity(float value) {
  _internal_set_opacity(value);
  // @@protoc_insertion_point(field_set:TSD.MediaStylePropertiesArchive.opacity)
}

// optional .TSD.ShadowArchive shadow = 3;
inline bool MediaStylePropertiesArchive::_internal_has_shadow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shadow_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_shadow() const {
  return _internal_has_shadow();
}
inline void MediaStylePropertiesArchive::clear_shadow() {
  if (_impl_.shadow_ != nullptr) _impl_.shadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::ShadowArchive& MediaStylePropertiesArchive::_internal_shadow() const {
  const ::TSD::ShadowArchive* p = _impl_.shadow_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShadowArchive&>(
      ::TSD::_ShadowArchive_default_instance_);
}
inline const ::TSD::ShadowArchive& MediaStylePropertiesArchive::shadow() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.shadow)
  return _internal_shadow();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_shadow(
    ::TSD::ShadowArchive* shadow) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.shadow_);
  }
  _impl_.shadow_ = shadow;
  if (shadow) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.shadow)
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::release_shadow() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ShadowArchive* temp = _impl_.shadow_;
  _impl_.shadow_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::unsafe_arena_release_shadow() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.shadow)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::ShadowArchive* temp = _impl_.shadow_;
  _impl_.shadow_ = nullptr;
  return temp;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::_internal_mutable_shadow() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.shadow_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShadowArchive>(GetArenaForAllocation());
    _impl_.shadow_ = p;
  }
  return _impl_.shadow_;
}
inline ::TSD::ShadowArchive* MediaStylePropertiesArchive::mutable_shadow() {
  ::TSD::ShadowArchive* _msg = _internal_mutable_shadow();
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.shadow)
  return _msg;
}
inline void MediaStylePropertiesArchive::set_allocated_shadow(::TSD::ShadowArchive* shadow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.shadow_;
  }
  if (shadow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shadow);
    if (message_arena != submessage_arena) {
      shadow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shadow, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.shadow_ = shadow;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.shadow)
}

// optional .TSD.ReflectionArchive reflection = 4;
inline bool MediaStylePropertiesArchive::_internal_has_reflection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reflection_ != nullptr);
  return value;
}
inline bool MediaStylePropertiesArchive::has_reflection() const {
  return _internal_has_reflection();
}
inline void MediaStylePropertiesArchive::clear_reflection() {
  if (_impl_.reflection_ != nullptr) _impl_.reflection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::ReflectionArchive& MediaStylePropertiesArchive::_internal_reflection() const {
  const ::TSD::ReflectionArchive* p = _impl_.reflection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ReflectionArchive&>(
      ::TSD::_ReflectionArchive_default_instance_);
}
inline const ::TSD::ReflectionArchive& MediaStylePropertiesArchive::reflection() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStylePropertiesArchive.reflection)
  return _internal_reflection();
}
inline void MediaStylePropertiesArchive::unsafe_arena_set_allocated_reflection(
    ::TSD::ReflectionArchive* reflection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reflection_);
  }
  _impl_.reflection_ = reflection;
  if (reflection) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStylePropertiesArchive.reflection)
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::release_reflection() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ReflectionArchive* temp = _impl_.reflection_;
  _impl_.reflection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::unsafe_arena_release_reflection() {
  // @@protoc_insertion_point(field_release:TSD.MediaStylePropertiesArchive.reflection)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::ReflectionArchive* temp = _impl_.reflection_;
  _impl_.reflection_ = nullptr;
  return temp;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::_internal_mutable_reflection() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.reflection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ReflectionArchive>(GetArenaForAllocation());
    _impl_.reflection_ = p;
  }
  return _impl_.reflection_;
}
inline ::TSD::ReflectionArchive* MediaStylePropertiesArchive::mutable_reflection() {
  ::TSD::ReflectionArchive* _msg = _internal_mutable_reflection();
  // @@protoc_insertion_point(field_mutable:TSD.MediaStylePropertiesArchive.reflection)
  return _msg;
}
inline void MediaStylePropertiesArchive::set_allocated_reflection(::TSD::ReflectionArchive* reflection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.reflection_;
  }
  if (reflection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reflection);
    if (message_arena != submessage_arena) {
      reflection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reflection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.reflection_ = reflection;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStylePropertiesArchive.reflection)
}

// -------------------------------------------------------------------

// MediaStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool MediaStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MediaStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& MediaStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& MediaStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.super)
  return _internal_super();
}
inline void MediaStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStyleArchive.super)
}
inline ::TSS::StyleArchive* MediaStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* MediaStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MediaStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* MediaStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* MediaStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.MediaStyleArchive.super)
  return _msg;
}
inline void MediaStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool MediaStyleArchive::_internal_has_override_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MediaStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void MediaStyleArchive::clear_override_count() {
  _impl_.override_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MediaStyleArchive::_internal_override_count() const {
  return _impl_.override_count_;
}
inline uint32_t MediaStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.override_count)
  return _internal_override_count();
}
inline void MediaStyleArchive::_internal_set_override_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.override_count_ = value;
}
inline void MediaStyleArchive::set_override_count(uint32_t value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TSD.MediaStyleArchive.override_count)
}

// optional .TSD.MediaStylePropertiesArchive media_properties = 11;
inline bool MediaStyleArchive::_internal_has_media_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.media_properties_ != nullptr);
  return value;
}
inline bool MediaStyleArchive::has_media_properties() const {
  return _internal_has_media_properties();
}
inline void MediaStyleArchive::clear_media_properties() {
  if (_impl_.media_properties_ != nullptr) _impl_.media_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleArchive::_internal_media_properties() const {
  const ::TSD::MediaStylePropertiesArchive* p = _impl_.media_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::MediaStylePropertiesArchive&>(
      ::TSD::_MediaStylePropertiesArchive_default_instance_);
}
inline const ::TSD::MediaStylePropertiesArchive& MediaStyleArchive::media_properties() const {
  // @@protoc_insertion_point(field_get:TSD.MediaStyleArchive.media_properties)
  return _internal_media_properties();
}
inline void MediaStyleArchive::unsafe_arena_set_allocated_media_properties(
    ::TSD::MediaStylePropertiesArchive* media_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.media_properties_);
  }
  _impl_.media_properties_ = media_properties;
  if (media_properties) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MediaStyleArchive.media_properties)
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::release_media_properties() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::MediaStylePropertiesArchive* temp = _impl_.media_properties_;
  _impl_.media_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::unsafe_arena_release_media_properties() {
  // @@protoc_insertion_point(field_release:TSD.MediaStyleArchive.media_properties)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::MediaStylePropertiesArchive* temp = _impl_.media_properties_;
  _impl_.media_properties_ = nullptr;
  return temp;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::_internal_mutable_media_properties() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.media_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::MediaStylePropertiesArchive>(GetArenaForAllocation());
    _impl_.media_properties_ = p;
  }
  return _impl_.media_properties_;
}
inline ::TSD::MediaStylePropertiesArchive* MediaStyleArchive::mutable_media_properties() {
  ::TSD::MediaStylePropertiesArchive* _msg = _internal_mutable_media_properties();
  // @@protoc_insertion_point(field_mutable:TSD.MediaStyleArchive.media_properties)
  return _msg;
}
inline void MediaStyleArchive::set_allocated_media_properties(::TSD::MediaStylePropertiesArchive* media_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.media_properties_;
  }
  if (media_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(media_properties);
    if (message_arena != submessage_arena) {
      media_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, media_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.media_properties_ = media_properties;
  // @@protoc_insertion_point(field_set_allocated:TSD.MediaStyleArchive.media_properties)
}

// -------------------------------------------------------------------

// ThemePresetsArchive

// repeated .TSD.FillArchive gradient_fill_presets = 1;
inline int ThemePresetsArchive::_internal_gradient_fill_presets_size() const {
  return _impl_.gradient_fill_presets_.size();
}
inline int ThemePresetsArchive::gradient_fill_presets_size() const {
  return _internal_gradient_fill_presets_size();
}
inline void ThemePresetsArchive::clear_gradient_fill_presets() {
  _impl_.gradient_fill_presets_.Clear();
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_gradient_fill_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _impl_.gradient_fill_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_gradient_fill_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.gradient_fill_presets)
  return &_impl_.gradient_fill_presets_;
}
inline const ::TSD::FillArchive& ThemePresetsArchive::_internal_gradient_fill_presets(int index) const {
  return _impl_.gradient_fill_presets_.Get(index);
}
inline const ::TSD::FillArchive& ThemePresetsArchive::gradient_fill_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _internal_gradient_fill_presets(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::_internal_add_gradient_fill_presets() {
  return _impl_.gradient_fill_presets_.Add();
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_gradient_fill_presets() {
  ::TSD::FillArchive* _add = _internal_add_gradient_fill_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::gradient_fill_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.gradient_fill_presets)
  return _impl_.gradient_fill_presets_;
}

// repeated .TSD.FillArchive image_fill_presets = 2;
inline int ThemePresetsArchive::_internal_image_fill_presets_size() const {
  return _impl_.image_fill_presets_.size();
}
inline int ThemePresetsArchive::image_fill_presets_size() const {
  return _internal_image_fill_presets_size();
}
inline void ThemePresetsArchive::clear_image_fill_presets() {
  _impl_.image_fill_presets_.Clear();
}
inline ::TSD::FillArchive* ThemePresetsArchive::mutable_image_fill_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.image_fill_presets)
  return _impl_.image_fill_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >*
ThemePresetsArchive::mutable_image_fill_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.image_fill_presets)
  return &_impl_.image_fill_presets_;
}
inline const ::TSD::FillArchive& ThemePresetsArchive::_internal_image_fill_presets(int index) const {
  return _impl_.image_fill_presets_.Get(index);
}
inline const ::TSD::FillArchive& ThemePresetsArchive::image_fill_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.image_fill_presets)
  return _internal_image_fill_presets(index);
}
inline ::TSD::FillArchive* ThemePresetsArchive::_internal_add_image_fill_presets() {
  return _impl_.image_fill_presets_.Add();
}
inline ::TSD::FillArchive* ThemePresetsArchive::add_image_fill_presets() {
  ::TSD::FillArchive* _add = _internal_add_image_fill_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.image_fill_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::FillArchive >&
ThemePresetsArchive::image_fill_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.image_fill_presets)
  return _impl_.image_fill_presets_;
}

// repeated .TSD.ShadowArchive shadow_presets = 3;
inline int ThemePresetsArchive::_internal_shadow_presets_size() const {
  return _impl_.shadow_presets_.size();
}
inline int ThemePresetsArchive::shadow_presets_size() const {
  return _internal_shadow_presets_size();
}
inline void ThemePresetsArchive::clear_shadow_presets() {
  _impl_.shadow_presets_.Clear();
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::mutable_shadow_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.shadow_presets)
  return _impl_.shadow_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >*
ThemePresetsArchive::mutable_shadow_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.shadow_presets)
  return &_impl_.shadow_presets_;
}
inline const ::TSD::ShadowArchive& ThemePresetsArchive::_internal_shadow_presets(int index) const {
  return _impl_.shadow_presets_.Get(index);
}
inline const ::TSD::ShadowArchive& ThemePresetsArchive::shadow_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.shadow_presets)
  return _internal_shadow_presets(index);
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::_internal_add_shadow_presets() {
  return _impl_.shadow_presets_.Add();
}
inline ::TSD::ShadowArchive* ThemePresetsArchive::add_shadow_presets() {
  ::TSD::ShadowArchive* _add = _internal_add_shadow_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.shadow_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::ShadowArchive >&
ThemePresetsArchive::shadow_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.shadow_presets)
  return _impl_.shadow_presets_;
}

// repeated .TSP.Reference line_style_presets = 4;
inline int ThemePresetsArchive::_internal_line_style_presets_size() const {
  return _impl_.line_style_presets_.size();
}
inline int ThemePresetsArchive::line_style_presets_size() const {
  return _internal_line_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_line_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.line_style_presets)
  return _impl_.line_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_line_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.line_style_presets)
  return &_impl_.line_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_line_style_presets(int index) const {
  return _impl_.line_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::line_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.line_style_presets)
  return _internal_line_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_line_style_presets() {
  return _impl_.line_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_line_style_presets() {
  ::TSP::Reference* _add = _internal_add_line_style_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.line_style_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::line_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.line_style_presets)
  return _impl_.line_style_presets_;
}

// repeated .TSP.Reference shape_style_presets = 5;
inline int ThemePresetsArchive::_internal_shape_style_presets_size() const {
  return _impl_.shape_style_presets_.size();
}
inline int ThemePresetsArchive::shape_style_presets_size() const {
  return _internal_shape_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_shape_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.shape_style_presets)
  return _impl_.shape_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_shape_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.shape_style_presets)
  return &_impl_.shape_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_shape_style_presets(int index) const {
  return _impl_.shape_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::shape_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.shape_style_presets)
  return _internal_shape_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_shape_style_presets() {
  return _impl_.shape_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_shape_style_presets() {
  ::TSP::Reference* _add = _internal_add_shape_style_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.shape_style_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::shape_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.shape_style_presets)
  return _impl_.shape_style_presets_;
}

// repeated .TSP.Reference textbox_style_presets = 6;
inline int ThemePresetsArchive::_internal_textbox_style_presets_size() const {
  return _impl_.textbox_style_presets_.size();
}
inline int ThemePresetsArchive::textbox_style_presets_size() const {
  return _internal_textbox_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_textbox_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.textbox_style_presets)
  return _impl_.textbox_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_textbox_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.textbox_style_presets)
  return &_impl_.textbox_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_textbox_style_presets(int index) const {
  return _impl_.textbox_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::textbox_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.textbox_style_presets)
  return _internal_textbox_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_textbox_style_presets() {
  return _impl_.textbox_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_textbox_style_presets() {
  ::TSP::Reference* _add = _internal_add_textbox_style_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.textbox_style_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::textbox_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.textbox_style_presets)
  return _impl_.textbox_style_presets_;
}

// repeated .TSP.Reference image_style_presets = 7;
inline int ThemePresetsArchive::_internal_image_style_presets_size() const {
  return _impl_.image_style_presets_.size();
}
inline int ThemePresetsArchive::image_style_presets_size() const {
  return _internal_image_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_image_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.image_style_presets)
  return _impl_.image_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_image_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.image_style_presets)
  return &_impl_.image_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_image_style_presets(int index) const {
  return _impl_.image_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::image_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.image_style_presets)
  return _internal_image_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_image_style_presets() {
  return _impl_.image_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_image_style_presets() {
  ::TSP::Reference* _add = _internal_add_image_style_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.image_style_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::image_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.image_style_presets)
  return _impl_.image_style_presets_;
}

// repeated .TSP.Reference movie_style_presets = 8;
inline int ThemePresetsArchive::_internal_movie_style_presets_size() const {
  return _impl_.movie_style_presets_.size();
}
inline int ThemePresetsArchive::movie_style_presets_size() const {
  return _internal_movie_style_presets_size();
}
inline ::TSP::Reference* ThemePresetsArchive::mutable_movie_style_presets(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ThemePresetsArchive.movie_style_presets)
  return _impl_.movie_style_presets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ThemePresetsArchive::mutable_movie_style_presets() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ThemePresetsArchive.movie_style_presets)
  return &_impl_.movie_style_presets_;
}
inline const ::TSP::Reference& ThemePresetsArchive::_internal_movie_style_presets(int index) const {
  return _impl_.movie_style_presets_.Get(index);
}
inline const ::TSP::Reference& ThemePresetsArchive::movie_style_presets(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ThemePresetsArchive.movie_style_presets)
  return _internal_movie_style_presets(index);
}
inline ::TSP::Reference* ThemePresetsArchive::_internal_add_movie_style_presets() {
  return _impl_.movie_style_presets_.Add();
}
inline ::TSP::Reference* ThemePresetsArchive::add_movie_style_presets() {
  ::TSP::Reference* _add = _internal_add_movie_style_presets();
  // @@protoc_insertion_point(field_add:TSD.ThemePresetsArchive.movie_style_presets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ThemePresetsArchive::movie_style_presets() const {
  // @@protoc_insertion_point(field_list:TSD.ThemePresetsArchive.movie_style_presets)
  return _impl_.movie_style_presets_;
}

// -------------------------------------------------------------------

// ThemeReplaceFillPresetCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSK::CommandArchive& ThemeReplaceFillPresetCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ThemeReplaceFillPresetCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.super)
  return _internal_super();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.super)
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ThemeReplaceFillPresetCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.super)
  return _msg;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.super)
}

// required .TSP.Reference theme = 2;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_theme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.theme_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_theme() const {
  return _internal_has_theme();
}
inline const ::TSP::Reference& ThemeReplaceFillPresetCommandArchive::_internal_theme() const {
  const ::TSP::Reference* p = _impl_.theme_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ThemeReplaceFillPresetCommandArchive::theme() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  return _internal_theme();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_theme(
    ::TSP::Reference* theme) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  _impl_.theme_ = theme;
  if (theme) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.theme)
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::release_theme() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_theme() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::_internal_mutable_theme() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.theme_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.theme_ = p;
  }
  return _impl_.theme_;
}
inline ::TSP::Reference* ThemeReplaceFillPresetCommandArchive::mutable_theme() {
  ::TSP::Reference* _msg = _internal_mutable_theme();
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.theme)
  return _msg;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_theme(::TSP::Reference* theme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  if (theme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(theme));
    if (message_arena != submessage_arena) {
      theme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.theme_ = theme;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.theme)
}

// required .TSD.FillArchive fill = 3;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fill_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_fill() const {
  return _internal_has_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_fill() {
  if (_impl_.fill_ != nullptr) _impl_.fill_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::_internal_fill() const {
  const ::TSD::FillArchive* p = _impl_.fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::fill() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  return _internal_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_fill(
    ::TSD::FillArchive* fill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fill_);
  }
  _impl_.fill_ = fill;
  if (fill) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.fill)
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_fill() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::FillArchive* temp = _impl_.fill_;
  _impl_.fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_fill() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArenaForAllocation());
    _impl_.fill_ = p;
  }
  return _impl_.fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_fill() {
  ::TSD::FillArchive* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.fill)
  return _msg;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_fill(::TSD::FillArchive* fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fill_;
  }
  if (fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fill);
    if (message_arena != submessage_arena) {
      fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.fill)
}

// required .TSD.FillArchive old_fill = 4;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_old_fill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_fill_ != nullptr);
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_old_fill() const {
  return _internal_has_old_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_old_fill() {
  if (_impl_.old_fill_ != nullptr) _impl_.old_fill_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::_internal_old_fill() const {
  const ::TSD::FillArchive* p = _impl_.old_fill_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::FillArchive&>(
      ::TSD::_FillArchive_default_instance_);
}
inline const ::TSD::FillArchive& ThemeReplaceFillPresetCommandArchive::old_fill() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  return _internal_old_fill();
}
inline void ThemeReplaceFillPresetCommandArchive::unsafe_arena_set_allocated_old_fill(
    ::TSD::FillArchive* old_fill) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_fill_);
  }
  _impl_.old_fill_ = old_fill;
  if (old_fill) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::release_old_fill() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::FillArchive* temp = _impl_.old_fill_;
  _impl_.old_fill_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::unsafe_arena_release_old_fill() {
  // @@protoc_insertion_point(field_release:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::FillArchive* temp = _impl_.old_fill_;
  _impl_.old_fill_ = nullptr;
  return temp;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::_internal_mutable_old_fill() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.old_fill_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::FillArchive>(GetArenaForAllocation());
    _impl_.old_fill_ = p;
  }
  return _impl_.old_fill_;
}
inline ::TSD::FillArchive* ThemeReplaceFillPresetCommandArchive::mutable_old_fill() {
  ::TSD::FillArchive* _msg = _internal_mutable_old_fill();
  // @@protoc_insertion_point(field_mutable:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
  return _msg;
}
inline void ThemeReplaceFillPresetCommandArchive::set_allocated_old_fill(::TSD::FillArchive* old_fill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.old_fill_;
  }
  if (old_fill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(old_fill);
    if (message_arena != submessage_arena) {
      old_fill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_fill, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.old_fill_ = old_fill;
  // @@protoc_insertion_point(field_set_allocated:TSD.ThemeReplaceFillPresetCommandArchive.old_fill)
}

// required uint32 index = 5;
inline bool ThemeReplaceFillPresetCommandArchive::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ThemeReplaceFillPresetCommandArchive::has_index() const {
  return _internal_has_index();
}
inline void ThemeReplaceFillPresetCommandArchive::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ThemeReplaceFillPresetCommandArchive::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t ThemeReplaceFillPresetCommandArchive::index() const {
  // @@protoc_insertion_point(field_get:TSD.ThemeReplaceFillPresetCommandArchive.index)
  return _internal_index();
}
inline void ThemeReplaceFillPresetCommandArchive::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.index_ = value;
}
inline void ThemeReplaceFillPresetCommandArchive::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:TSD.ThemeReplaceFillPresetCommandArchive.index)
}

// -------------------------------------------------------------------

// DrawableArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool DrawableArchive::_internal_has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_geometry() const {
  return _internal_has_geometry();
}
inline void DrawableArchive::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::GeometryArchive& DrawableArchive::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& DrawableArchive::geometry() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.geometry)
  return _internal_geometry();
}
inline void DrawableArchive::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.geometry)
}
inline ::TSD::GeometryArchive* DrawableArchive::release_geometry() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::GeometryArchive* DrawableArchive::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.geometry)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* DrawableArchive::_internal_mutable_geometry() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::TSD::GeometryArchive* DrawableArchive::mutable_geometry() {
  ::TSD::GeometryArchive* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.geometry)
  return _msg;
}
inline void DrawableArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.geometry)
}

// optional .TSP.Reference parent = 2;
inline bool DrawableArchive::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_parent() const {
  return _internal_has_parent();
}
inline const ::TSP::Reference& DrawableArchive::_internal_parent() const {
  const ::TSP::Reference* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::parent() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.parent)
  return _internal_parent();
}
inline void DrawableArchive::unsafe_arena_set_allocated_parent(
    ::TSP::Reference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.parent)
}
inline ::TSP::Reference* DrawableArchive::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.parent)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::TSP::Reference* DrawableArchive::mutable_parent() {
  ::TSP::Reference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.parent)
  return _msg;
}
inline void DrawableArchive::set_allocated_parent(::TSP::Reference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.parent)
}

// optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 3;
inline bool DrawableArchive::_internal_has_exterior_text_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exterior_text_wrap_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_exterior_text_wrap() const {
  return _internal_has_exterior_text_wrap();
}
inline void DrawableArchive::clear_exterior_text_wrap() {
  if (_impl_.exterior_text_wrap_ != nullptr) _impl_.exterior_text_wrap_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::ExteriorTextWrapArchive& DrawableArchive::_internal_exterior_text_wrap() const {
  const ::TSD::ExteriorTextWrapArchive* p = _impl_.exterior_text_wrap_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ExteriorTextWrapArchive&>(
      ::TSD::_ExteriorTextWrapArchive_default_instance_);
}
inline const ::TSD::ExteriorTextWrapArchive& DrawableArchive::exterior_text_wrap() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.exterior_text_wrap)
  return _internal_exterior_text_wrap();
}
inline void DrawableArchive::unsafe_arena_set_allocated_exterior_text_wrap(
    ::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exterior_text_wrap_);
  }
  _impl_.exterior_text_wrap_ = exterior_text_wrap;
  if (exterior_text_wrap) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.exterior_text_wrap)
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::release_exterior_text_wrap() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::ExteriorTextWrapArchive* temp = _impl_.exterior_text_wrap_;
  _impl_.exterior_text_wrap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::unsafe_arena_release_exterior_text_wrap() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.exterior_text_wrap)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::ExteriorTextWrapArchive* temp = _impl_.exterior_text_wrap_;
  _impl_.exterior_text_wrap_ = nullptr;
  return temp;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::_internal_mutable_exterior_text_wrap() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.exterior_text_wrap_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ExteriorTextWrapArchive>(GetArenaForAllocation());
    _impl_.exterior_text_wrap_ = p;
  }
  return _impl_.exterior_text_wrap_;
}
inline ::TSD::ExteriorTextWrapArchive* DrawableArchive::mutable_exterior_text_wrap() {
  ::TSD::ExteriorTextWrapArchive* _msg = _internal_mutable_exterior_text_wrap();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.exterior_text_wrap)
  return _msg;
}
inline void DrawableArchive::set_allocated_exterior_text_wrap(::TSD::ExteriorTextWrapArchive* exterior_text_wrap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exterior_text_wrap_;
  }
  if (exterior_text_wrap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exterior_text_wrap);
    if (message_arena != submessage_arena) {
      exterior_text_wrap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exterior_text_wrap, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.exterior_text_wrap_ = exterior_text_wrap;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.exterior_text_wrap)
}

// optional string hyperlink_url = 4;
inline bool DrawableArchive::_internal_has_hyperlink_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DrawableArchive::has_hyperlink_url() const {
  return _internal_has_hyperlink_url();
}
inline void DrawableArchive::clear_hyperlink_url() {
  _impl_.hyperlink_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DrawableArchive::hyperlink_url() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.hyperlink_url)
  return _internal_hyperlink_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DrawableArchive::set_hyperlink_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hyperlink_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.hyperlink_url)
}
inline std::string* DrawableArchive::mutable_hyperlink_url() {
  std::string* _s = _internal_mutable_hyperlink_url();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.hyperlink_url)
  return _s;
}
inline const std::string& DrawableArchive::_internal_hyperlink_url() const {
  return _impl_.hyperlink_url_.Get();
}
inline void DrawableArchive::_internal_set_hyperlink_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hyperlink_url_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableArchive::_internal_mutable_hyperlink_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hyperlink_url_.Mutable(GetArenaForAllocation());
}
inline std::string* DrawableArchive::release_hyperlink_url() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.hyperlink_url)
  if (!_internal_has_hyperlink_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hyperlink_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hyperlink_url_.IsDefault()) {
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DrawableArchive::set_allocated_hyperlink_url(std::string* hyperlink_url) {
  if (hyperlink_url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hyperlink_url_.SetAllocated(hyperlink_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hyperlink_url_.IsDefault()) {
    _impl_.hyperlink_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.hyperlink_url)
}

// optional bool locked = 5;
inline bool DrawableArchive::_internal_has_locked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DrawableArchive::has_locked() const {
  return _internal_has_locked();
}
inline void DrawableArchive::clear_locked() {
  _impl_.locked_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool DrawableArchive::_internal_locked() const {
  return _impl_.locked_;
}
inline bool DrawableArchive::locked() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.locked)
  return _internal_locked();
}
inline void DrawableArchive::_internal_set_locked(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.locked_ = value;
}
inline void DrawableArchive::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.locked)
}

// optional .TSP.Reference comment = 6;
inline bool DrawableArchive::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.comment_ != nullptr);
  return value;
}
inline bool DrawableArchive::has_comment() const {
  return _internal_has_comment();
}
inline const ::TSP::Reference& DrawableArchive::_internal_comment() const {
  const ::TSP::Reference* p = _impl_.comment_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DrawableArchive::comment() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.comment)
  return _internal_comment();
}
inline void DrawableArchive::unsafe_arena_set_allocated_comment(
    ::TSP::Reference* comment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_);
  }
  _impl_.comment_ = comment;
  if (comment) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.DrawableArchive.comment)
}
inline ::TSP::Reference* DrawableArchive::release_comment() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DrawableArchive::unsafe_arena_release_comment() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.comment)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.comment_;
  _impl_.comment_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DrawableArchive::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.comment_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.comment_ = p;
  }
  return _impl_.comment_;
}
inline ::TSP::Reference* DrawableArchive::mutable_comment() {
  ::TSP::Reference* _msg = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.comment)
  return _msg;
}
inline void DrawableArchive::set_allocated_comment(::TSP::Reference* comment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_);
  }
  if (comment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment));
    if (message_arena != submessage_arena) {
      comment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.comment_ = comment;
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.comment)
}

// optional bool aspect_ratio_locked = 7;
inline bool DrawableArchive::_internal_has_aspect_ratio_locked() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DrawableArchive::has_aspect_ratio_locked() const {
  return _internal_has_aspect_ratio_locked();
}
inline void DrawableArchive::clear_aspect_ratio_locked() {
  _impl_.aspect_ratio_locked_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool DrawableArchive::_internal_aspect_ratio_locked() const {
  return _impl_.aspect_ratio_locked_;
}
inline bool DrawableArchive::aspect_ratio_locked() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.aspect_ratio_locked)
  return _internal_aspect_ratio_locked();
}
inline void DrawableArchive::_internal_set_aspect_ratio_locked(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.aspect_ratio_locked_ = value;
}
inline void DrawableArchive::set_aspect_ratio_locked(bool value) {
  _internal_set_aspect_ratio_locked(value);
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.aspect_ratio_locked)
}

// optional string accessibility_description = 8;
inline bool DrawableArchive::_internal_has_accessibility_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DrawableArchive::has_accessibility_description() const {
  return _internal_has_accessibility_description();
}
inline void DrawableArchive::clear_accessibility_description() {
  _impl_.accessibility_description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DrawableArchive::accessibility_description() const {
  // @@protoc_insertion_point(field_get:TSD.DrawableArchive.accessibility_description)
  return _internal_accessibility_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DrawableArchive::set_accessibility_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.accessibility_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.DrawableArchive.accessibility_description)
}
inline std::string* DrawableArchive::mutable_accessibility_description() {
  std::string* _s = _internal_mutable_accessibility_description();
  // @@protoc_insertion_point(field_mutable:TSD.DrawableArchive.accessibility_description)
  return _s;
}
inline const std::string& DrawableArchive::_internal_accessibility_description() const {
  return _impl_.accessibility_description_.Get();
}
inline void DrawableArchive::_internal_set_accessibility_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.accessibility_description_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableArchive::_internal_mutable_accessibility_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.accessibility_description_.Mutable(GetArenaForAllocation());
}
inline std::string* DrawableArchive::release_accessibility_description() {
  // @@protoc_insertion_point(field_release:TSD.DrawableArchive.accessibility_description)
  if (!_internal_has_accessibility_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.accessibility_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accessibility_description_.IsDefault()) {
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DrawableArchive::set_allocated_accessibility_description(std::string* accessibility_description) {
  if (accessibility_description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.accessibility_description_.SetAllocated(accessibility_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accessibility_description_.IsDefault()) {
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.DrawableArchive.accessibility_description)
}

// -------------------------------------------------------------------

// ContainerArchive

// optional .TSD.GeometryArchive geometry = 1;
inline bool ContainerArchive::_internal_has_geometry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.geometry_ != nullptr);
  return value;
}
inline bool ContainerArchive::has_geometry() const {
  return _internal_has_geometry();
}
inline void ContainerArchive::clear_geometry() {
  if (_impl_.geometry_ != nullptr) _impl_.geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::GeometryArchive& ContainerArchive::_internal_geometry() const {
  const ::TSD::GeometryArchive* p = _impl_.geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::GeometryArchive&>(
      ::TSD::_GeometryArchive_default_instance_);
}
inline const ::TSD::GeometryArchive& ContainerArchive::geometry() const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.geometry)
  return _internal_geometry();
}
inline void ContainerArchive::unsafe_arena_set_allocated_geometry(
    ::TSD::GeometryArchive* geometry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.geometry_);
  }
  _impl_.geometry_ = geometry;
  if (geometry) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ContainerArchive.geometry)
}
inline ::TSD::GeometryArchive* ContainerArchive::release_geometry() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::GeometryArchive* ContainerArchive::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:TSD.ContainerArchive.geometry)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::GeometryArchive* temp = _impl_.geometry_;
  _impl_.geometry_ = nullptr;
  return temp;
}
inline ::TSD::GeometryArchive* ContainerArchive::_internal_mutable_geometry() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::GeometryArchive>(GetArenaForAllocation());
    _impl_.geometry_ = p;
  }
  return _impl_.geometry_;
}
inline ::TSD::GeometryArchive* ContainerArchive::mutable_geometry() {
  ::TSD::GeometryArchive* _msg = _internal_mutable_geometry();
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.geometry)
  return _msg;
}
inline void ContainerArchive::set_allocated_geometry(::TSD::GeometryArchive* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:TSD.ContainerArchive.geometry)
}

// optional .TSP.Reference parent = 2;
inline bool ContainerArchive::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parent_ != nullptr);
  return value;
}
inline bool ContainerArchive::has_parent() const {
  return _internal_has_parent();
}
inline const ::TSP::Reference& ContainerArchive::_internal_parent() const {
  const ::TSP::Reference* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ContainerArchive::parent() const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.parent)
  return _internal_parent();
}
inline void ContainerArchive::unsafe_arena_set_allocated_parent(
    ::TSP::Reference* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ContainerArchive.parent)
}
inline ::TSP::Reference* ContainerArchive::release_parent() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ContainerArchive::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:TSD.ContainerArchive.parent)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ContainerArchive::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::TSP::Reference* ContainerArchive::mutable_parent() {
  ::TSP::Reference* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.parent)
  return _msg;
}
inline void ContainerArchive::set_allocated_parent(::TSP::Reference* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent));
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:TSD.ContainerArchive.parent)
}

// repeated .TSP.Reference children = 3;
inline int ContainerArchive::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int ContainerArchive::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* ContainerArchive::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.ContainerArchive.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ContainerArchive::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TSD.ContainerArchive.children)
  return &_impl_.children_;
}
inline const ::TSP::Reference& ContainerArchive::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::TSP::Reference& ContainerArchive::children(int index) const {
  // @@protoc_insertion_point(field_get:TSD.ContainerArchive.children)
  return _internal_children(index);
}
inline ::TSP::Reference* ContainerArchive::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::TSP::Reference* ContainerArchive::add_children() {
  ::TSP::Reference* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:TSD.ContainerArchive.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ContainerArchive::children() const {
  // @@protoc_insertion_point(field_list:TSD.ContainerArchive.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// GroupArchive

// required .TSD.DrawableArchive super = 1;
inline bool GroupArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool GroupArchive::has_super() const {
  return _internal_has_super();
}
inline void GroupArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& GroupArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& GroupArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.GroupArchive.super)
  return _internal_super();
}
inline void GroupArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.GroupArchive.super)
}
inline ::TSD::DrawableArchive* GroupArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* GroupArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.GroupArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* GroupArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* GroupArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.GroupArchive.super)
  return _msg;
}
inline void GroupArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.GroupArchive.super)
}

// repeated .TSP.Reference children = 2;
inline int GroupArchive::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int GroupArchive::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* GroupArchive::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GroupArchive.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
GroupArchive::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GroupArchive.children)
  return &_impl_.children_;
}
inline const ::TSP::Reference& GroupArchive::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::TSP::Reference& GroupArchive::children(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GroupArchive.children)
  return _internal_children(index);
}
inline ::TSP::Reference* GroupArchive::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::TSP::Reference* GroupArchive::add_children() {
  ::TSP::Reference* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:TSD.GroupArchive.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
GroupArchive::children() const {
  // @@protoc_insertion_point(field_list:TSD.GroupArchive.children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// ShapeArchive

// required .TSD.DrawableArchive super = 1;
inline bool ShapeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_super() const {
  return _internal_has_super();
}
inline void ShapeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& ShapeArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& ShapeArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.super)
  return _internal_super();
}
inline void ShapeArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.super)
}
inline ::TSD::DrawableArchive* ShapeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* ShapeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* ShapeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* ShapeArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.super)
  return _msg;
}
inline void ShapeArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.super)
}

// optional .TSP.Reference style = 2;
inline bool ShapeArchive::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.style_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& ShapeArchive::_internal_style() const {
  const ::TSP::Reference* p = _impl_.style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ShapeArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.style)
  return _internal_style();
}
inline void ShapeArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  _impl_.style_ = style;
  if (style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.style)
}
inline ::TSP::Reference* ShapeArchive::release_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ShapeArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ShapeArchive::_internal_mutable_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.style_ = p;
  }
  return _impl_.style_;
}
inline ::TSP::Reference* ShapeArchive::mutable_style() {
  ::TSP::Reference* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.style)
  return _msg;
}
inline void ShapeArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style));
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.style)
}

// optional .TSD.PathSourceArchive pathsource = 3;
inline bool ShapeArchive::_internal_has_pathsource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathsource_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_pathsource() const {
  return _internal_has_pathsource();
}
inline void ShapeArchive::clear_pathsource() {
  if (_impl_.pathsource_ != nullptr) _impl_.pathsource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSD::PathSourceArchive& ShapeArchive::_internal_pathsource() const {
  const ::TSD::PathSourceArchive* p = _impl_.pathsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PathSourceArchive&>(
      ::TSD::_PathSourceArchive_default_instance_);
}
inline const ::TSD::PathSourceArchive& ShapeArchive::pathsource() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.pathsource)
  return _internal_pathsource();
}
inline void ShapeArchive::unsafe_arena_set_allocated_pathsource(
    ::TSD::PathSourceArchive* pathsource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathsource_);
  }
  _impl_.pathsource_ = pathsource;
  if (pathsource) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.pathsource)
}
inline ::TSD::PathSourceArchive* ShapeArchive::release_pathsource() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::PathSourceArchive* temp = _impl_.pathsource_;
  _impl_.pathsource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::PathSourceArchive* ShapeArchive::unsafe_arena_release_pathsource() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.pathsource)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSD::PathSourceArchive* temp = _impl_.pathsource_;
  _impl_.pathsource_ = nullptr;
  return temp;
}
inline ::TSD::PathSourceArchive* ShapeArchive::_internal_mutable_pathsource() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.pathsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PathSourceArchive>(GetArenaForAllocation());
    _impl_.pathsource_ = p;
  }
  return _impl_.pathsource_;
}
inline ::TSD::PathSourceArchive* ShapeArchive::mutable_pathsource() {
  ::TSD::PathSourceArchive* _msg = _internal_mutable_pathsource();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.pathsource)
  return _msg;
}
inline void ShapeArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pathsource_;
  }
  if (pathsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pathsource);
    if (message_arena != submessage_arena) {
      pathsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathsource, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.pathsource_ = pathsource;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.pathsource)
}

// optional .TSD.LineEndArchive head_line_end = 4;
inline bool ShapeArchive::_internal_has_head_line_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.head_line_end_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_head_line_end() const {
  return _internal_has_head_line_end();
}
inline void ShapeArchive::clear_head_line_end() {
  if (_impl_.head_line_end_ != nullptr) _impl_.head_line_end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSD::LineEndArchive& ShapeArchive::_internal_head_line_end() const {
  const ::TSD::LineEndArchive* p = _impl_.head_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeArchive::head_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.head_line_end)
  return _internal_head_line_end();
}
inline void ShapeArchive::unsafe_arena_set_allocated_head_line_end(
    ::TSD::LineEndArchive* head_line_end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_line_end_);
  }
  _impl_.head_line_end_ = head_line_end;
  if (head_line_end) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.head_line_end)
}
inline ::TSD::LineEndArchive* ShapeArchive::release_head_line_end() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::LineEndArchive* temp = _impl_.head_line_end_;
  _impl_.head_line_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::unsafe_arena_release_head_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.head_line_end)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSD::LineEndArchive* temp = _impl_.head_line_end_;
  _impl_.head_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::_internal_mutable_head_line_end() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.head_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArenaForAllocation());
    _impl_.head_line_end_ = p;
  }
  return _impl_.head_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_head_line_end() {
  ::TSD::LineEndArchive* _msg = _internal_mutable_head_line_end();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.head_line_end)
  return _msg;
}
inline void ShapeArchive::set_allocated_head_line_end(::TSD::LineEndArchive* head_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_line_end_;
  }
  if (head_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head_line_end);
    if (message_arena != submessage_arena) {
      head_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head_line_end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.head_line_end_ = head_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.head_line_end)
}

// optional .TSD.LineEndArchive tail_line_end = 5;
inline bool ShapeArchive::_internal_has_tail_line_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tail_line_end_ != nullptr);
  return value;
}
inline bool ShapeArchive::has_tail_line_end() const {
  return _internal_has_tail_line_end();
}
inline void ShapeArchive::clear_tail_line_end() {
  if (_impl_.tail_line_end_ != nullptr) _impl_.tail_line_end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TSD::LineEndArchive& ShapeArchive::_internal_tail_line_end() const {
  const ::TSD::LineEndArchive* p = _impl_.tail_line_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::LineEndArchive&>(
      ::TSD::_LineEndArchive_default_instance_);
}
inline const ::TSD::LineEndArchive& ShapeArchive::tail_line_end() const {
  // @@protoc_insertion_point(field_get:TSD.ShapeArchive.tail_line_end)
  return _internal_tail_line_end();
}
inline void ShapeArchive::unsafe_arena_set_allocated_tail_line_end(
    ::TSD::LineEndArchive* tail_line_end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tail_line_end_);
  }
  _impl_.tail_line_end_ = tail_line_end;
  if (tail_line_end) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ShapeArchive.tail_line_end)
}
inline ::TSD::LineEndArchive* ShapeArchive::release_tail_line_end() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = _impl_.tail_line_end_;
  _impl_.tail_line_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::unsafe_arena_release_tail_line_end() {
  // @@protoc_insertion_point(field_release:TSD.ShapeArchive.tail_line_end)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSD::LineEndArchive* temp = _impl_.tail_line_end_;
  _impl_.tail_line_end_ = nullptr;
  return temp;
}
inline ::TSD::LineEndArchive* ShapeArchive::_internal_mutable_tail_line_end() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.tail_line_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::LineEndArchive>(GetArenaForAllocation());
    _impl_.tail_line_end_ = p;
  }
  return _impl_.tail_line_end_;
}
inline ::TSD::LineEndArchive* ShapeArchive::mutable_tail_line_end() {
  ::TSD::LineEndArchive* _msg = _internal_mutable_tail_line_end();
  // @@protoc_insertion_point(field_mutable:TSD.ShapeArchive.tail_line_end)
  return _msg;
}
inline void ShapeArchive::set_allocated_tail_line_end(::TSD::LineEndArchive* tail_line_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tail_line_end_;
  }
  if (tail_line_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tail_line_end);
    if (message_arena != submessage_arena) {
      tail_line_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_line_end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.tail_line_end_ = tail_line_end;
  // @@protoc_insertion_point(field_set_allocated:TSD.ShapeArchive.tail_line_end)
}

// -------------------------------------------------------------------

// ConnectionLineArchive

// required .TSD.ShapeArchive super = 1;
inline bool ConnectionLineArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_super() const {
  return _internal_has_super();
}
inline void ConnectionLineArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::ShapeArchive& ConnectionLineArchive::_internal_super() const {
  const ::TSD::ShapeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ShapeArchive&>(
      ::TSD::_ShapeArchive_default_instance_);
}
inline const ::TSD::ShapeArchive& ConnectionLineArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.super)
  return _internal_super();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_super(
    ::TSD::ShapeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.super)
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::ShapeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ShapeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::ShapeArchive* ConnectionLineArchive::mutable_super() {
  ::TSD::ShapeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.super)
  return _msg;
}
inline void ConnectionLineArchive::set_allocated_super(::TSD::ShapeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.super)
}

// optional .TSP.Reference connected_from = 2;
inline bool ConnectionLineArchive::_internal_has_connected_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connected_from_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_from() const {
  return _internal_has_connected_from();
}
inline const ::TSP::Reference& ConnectionLineArchive::_internal_connected_from() const {
  const ::TSP::Reference* p = _impl_.connected_from_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_from() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_from)
  return _internal_connected_from();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_from(
    ::TSP::Reference* connected_from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_from_);
  }
  _impl_.connected_from_ = connected_from;
  if (connected_from) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_from)
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_from() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.connected_from_;
  _impl_.connected_from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::unsafe_arena_release_connected_from() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_from)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.connected_from_;
  _impl_.connected_from_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::_internal_mutable_connected_from() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.connected_from_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.connected_from_ = p;
  }
  return _impl_.connected_from_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_from() {
  ::TSP::Reference* _msg = _internal_mutable_connected_from();
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_from)
  return _msg;
}
inline void ConnectionLineArchive::set_allocated_connected_from(::TSP::Reference* connected_from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_from_);
  }
  if (connected_from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_from));
    if (message_arena != submessage_arena) {
      connected_from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_from, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.connected_from_ = connected_from;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_from)
}

// optional .TSP.Reference connected_to = 3;
inline bool ConnectionLineArchive::_internal_has_connected_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.connected_to_ != nullptr);
  return value;
}
inline bool ConnectionLineArchive::has_connected_to() const {
  return _internal_has_connected_to();
}
inline const ::TSP::Reference& ConnectionLineArchive::_internal_connected_to() const {
  const ::TSP::Reference* p = _impl_.connected_to_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConnectionLineArchive::connected_to() const {
  // @@protoc_insertion_point(field_get:TSD.ConnectionLineArchive.connected_to)
  return _internal_connected_to();
}
inline void ConnectionLineArchive::unsafe_arena_set_allocated_connected_to(
    ::TSP::Reference* connected_to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_to_);
  }
  _impl_.connected_to_ = connected_to;
  if (connected_to) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ConnectionLineArchive.connected_to)
}
inline ::TSP::Reference* ConnectionLineArchive::release_connected_to() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.connected_to_;
  _impl_.connected_to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::unsafe_arena_release_connected_to() {
  // @@protoc_insertion_point(field_release:TSD.ConnectionLineArchive.connected_to)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.connected_to_;
  _impl_.connected_to_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConnectionLineArchive::_internal_mutable_connected_to() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.connected_to_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.connected_to_ = p;
  }
  return _impl_.connected_to_;
}
inline ::TSP::Reference* ConnectionLineArchive::mutable_connected_to() {
  ::TSP::Reference* _msg = _internal_mutable_connected_to();
  // @@protoc_insertion_point(field_mutable:TSD.ConnectionLineArchive.connected_to)
  return _msg;
}
inline void ConnectionLineArchive::set_allocated_connected_to(::TSP::Reference* connected_to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.connected_to_);
  }
  if (connected_to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connected_to));
    if (message_arena != submessage_arena) {
      connected_to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connected_to, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.connected_to_ = connected_to;
  // @@protoc_insertion_point(field_set_allocated:TSD.ConnectionLineArchive.connected_to)
}

// -------------------------------------------------------------------

// ImageArchive

// required .TSD.DrawableArchive super = 1;
inline bool ImageArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ImageArchive::has_super() const {
  return _internal_has_super();
}
inline void ImageArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& ImageArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& ImageArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.super)
  return _internal_super();
}
inline void ImageArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.super)
}
inline ::TSD::DrawableArchive* ImageArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* ImageArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* ImageArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* ImageArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.super)
  return _msg;
}
inline void ImageArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.super)
}

// optional .TSP.DataReference data = 11;
inline bool ImageArchive::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline bool ImageArchive::has_data() const {
  return _internal_has_data();
}
inline const ::TSP::DataReference& ImageArchive::_internal_data() const {
  const ::TSP::DataReference* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::data() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.data)
  return _internal_data();
}
inline void ImageArchive::unsafe_arena_set_allocated_data(
    ::TSP::DataReference* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.data)
}
inline ::TSP::DataReference* ImageArchive::release_data() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.data)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::DataReference* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::TSP::DataReference* ImageArchive::mutable_data() {
  ::TSP::DataReference* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.data)
  return _msg;
}
inline void ImageArchive::set_allocated_data(::TSP::DataReference* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data));
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.data)
}

// optional .TSP.Reference style = 3;
inline bool ImageArchive::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.style_ != nullptr);
  return value;
}
inline bool ImageArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& ImageArchive::_internal_style() const {
  const ::TSP::Reference* p = _impl_.style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.style)
  return _internal_style();
}
inline void ImageArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  _impl_.style_ = style;
  if (style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.style)
}
inline ::TSP::Reference* ImageArchive::release_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.style_ = p;
  }
  return _impl_.style_;
}
inline ::TSP::Reference* ImageArchive::mutable_style() {
  ::TSP::Reference* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.style)
  return _msg;
}
inline void ImageArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style));
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.style)
}

// optional .TSP.Size originalSize = 4;
inline bool ImageArchive::_internal_has_originalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originalsize_ != nullptr);
  return value;
}
inline bool ImageArchive::has_originalsize() const {
  return _internal_has_originalsize();
}
inline const ::TSP::Size& ImageArchive::_internal_originalsize() const {
  const ::TSP::Size* p = _impl_.originalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageArchive::originalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.originalSize)
  return _internal_originalsize();
}
inline void ImageArchive::unsafe_arena_set_allocated_originalsize(
    ::TSP::Size* originalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsize_);
  }
  _impl_.originalsize_ = originalsize;
  if (originalsize) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.originalSize)
}
inline ::TSP::Size* ImageArchive::release_originalsize() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = _impl_.originalsize_;
  _impl_.originalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* ImageArchive::unsafe_arena_release_originalsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.originalSize)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = _impl_.originalsize_;
  _impl_.originalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageArchive::_internal_mutable_originalsize() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.originalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.originalsize_ = p;
  }
  return _impl_.originalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_originalsize() {
  ::TSP::Size* _msg = _internal_mutable_originalsize();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.originalSize)
  return _msg;
}
inline void ImageArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsize_);
  }
  if (originalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize));
    if (message_arena != submessage_arena) {
      originalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.originalsize_ = originalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.originalSize)
}

// optional .TSP.Reference mask = 5;
inline bool ImageArchive::_internal_has_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mask_ != nullptr);
  return value;
}
inline bool ImageArchive::has_mask() const {
  return _internal_has_mask();
}
inline const ::TSP::Reference& ImageArchive::_internal_mask() const {
  const ::TSP::Reference* p = _impl_.mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::mask() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.mask)
  return _internal_mask();
}
inline void ImageArchive::unsafe_arena_set_allocated_mask(
    ::TSP::Reference* mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mask_);
  }
  _impl_.mask_ = mask;
  if (mask) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.mask)
}
inline ::TSP::Reference* ImageArchive::release_mask() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_mask() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.mask)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.mask_;
  _impl_.mask_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_mask() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.mask_ = p;
  }
  return _impl_.mask_;
}
inline ::TSP::Reference* ImageArchive::mutable_mask() {
  ::TSP::Reference* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.mask)
  return _msg;
}
inline void ImageArchive::set_allocated_mask(::TSP::Reference* mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mask_);
  }
  if (mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask));
    if (message_arena != submessage_arena) {
      mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.mask)
}

// optional .TSP.DataReference thumbnailData = 12;
inline bool ImageArchive::_internal_has_thumbnaildata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.thumbnaildata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_thumbnaildata() const {
  return _internal_has_thumbnaildata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_thumbnaildata() const {
  const ::TSP::DataReference* p = _impl_.thumbnaildata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::thumbnaildata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.thumbnailData)
  return _internal_thumbnaildata();
}
inline void ImageArchive::unsafe_arena_set_allocated_thumbnaildata(
    ::TSP::DataReference* thumbnaildata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thumbnaildata_);
  }
  _impl_.thumbnaildata_ = thumbnaildata;
  if (thumbnaildata) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.thumbnailData)
}
inline ::TSP::DataReference* ImageArchive::release_thumbnaildata() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::DataReference* temp = _impl_.thumbnaildata_;
  _impl_.thumbnaildata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_thumbnaildata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.thumbnailData)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::DataReference* temp = _impl_.thumbnaildata_;
  _impl_.thumbnaildata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_thumbnaildata() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.thumbnaildata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.thumbnaildata_ = p;
  }
  return _impl_.thumbnaildata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnaildata() {
  ::TSP::DataReference* _msg = _internal_mutable_thumbnaildata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.thumbnailData)
  return _msg;
}
inline void ImageArchive::set_allocated_thumbnaildata(::TSP::DataReference* thumbnaildata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thumbnaildata_);
  }
  if (thumbnaildata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnaildata));
    if (message_arena != submessage_arena) {
      thumbnaildata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnaildata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.thumbnaildata_ = thumbnaildata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.thumbnailData)
}

// optional uint32 flags = 7;
inline bool ImageArchive::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ImageArchive::has_flags() const {
  return _internal_has_flags();
}
inline void ImageArchive::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t ImageArchive::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t ImageArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.flags)
  return _internal_flags();
}
inline void ImageArchive::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.flags_ = value;
}
inline void ImageArchive::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.ImageArchive.flags)
}

// optional .TSP.DataReference originalData = 13;
inline bool ImageArchive::_internal_has_originaldata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originaldata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_originaldata() const {
  return _internal_has_originaldata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_originaldata() const {
  const ::TSP::DataReference* p = _impl_.originaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::originaldata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.originalData)
  return _internal_originaldata();
}
inline void ImageArchive::unsafe_arena_set_allocated_originaldata(
    ::TSP::DataReference* originaldata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originaldata_);
  }
  _impl_.originaldata_ = originaldata;
  if (originaldata) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.originalData)
}
inline ::TSP::DataReference* ImageArchive::release_originaldata() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = _impl_.originaldata_;
  _impl_.originaldata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_originaldata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.originalData)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = _impl_.originaldata_;
  _impl_.originaldata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_originaldata() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.originaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.originaldata_ = p;
  }
  return _impl_.originaldata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_originaldata() {
  ::TSP::DataReference* _msg = _internal_mutable_originaldata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.originalData)
  return _msg;
}
inline void ImageArchive::set_allocated_originaldata(::TSP::DataReference* originaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originaldata_);
  }
  if (originaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originaldata));
    if (message_arena != submessage_arena) {
      originaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originaldata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.originaldata_ = originaldata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.originalData)
}

// optional .TSP.Size naturalSize = 9;
inline bool ImageArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool ImageArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& ImageArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& ImageArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.naturalSize)
  return _internal_naturalsize();
}
inline void ImageArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.naturalSize)
}
inline ::TSP::Size* ImageArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* ImageArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* ImageArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* ImageArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.naturalSize)
  return _msg;
}
inline void ImageArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.naturalSize)
}

// optional .TSP.Path instantAlphaPath = 10;
inline bool ImageArchive::_internal_has_instantalphapath() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.instantalphapath_ != nullptr);
  return value;
}
inline bool ImageArchive::has_instantalphapath() const {
  return _internal_has_instantalphapath();
}
inline const ::TSP::Path& ImageArchive::_internal_instantalphapath() const {
  const ::TSP::Path* p = _impl_.instantalphapath_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Path&>(
      ::TSP::_Path_default_instance_);
}
inline const ::TSP::Path& ImageArchive::instantalphapath() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.instantAlphaPath)
  return _internal_instantalphapath();
}
inline void ImageArchive::unsafe_arena_set_allocated_instantalphapath(
    ::TSP::Path* instantalphapath) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantalphapath_);
  }
  _impl_.instantalphapath_ = instantalphapath;
  if (instantalphapath) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.instantAlphaPath)
}
inline ::TSP::Path* ImageArchive::release_instantalphapath() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Path* temp = _impl_.instantalphapath_;
  _impl_.instantalphapath_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Path* ImageArchive::unsafe_arena_release_instantalphapath() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.instantAlphaPath)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Path* temp = _impl_.instantalphapath_;
  _impl_.instantalphapath_ = nullptr;
  return temp;
}
inline ::TSP::Path* ImageArchive::_internal_mutable_instantalphapath() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.instantalphapath_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Path>(GetArenaForAllocation());
    _impl_.instantalphapath_ = p;
  }
  return _impl_.instantalphapath_;
}
inline ::TSP::Path* ImageArchive::mutable_instantalphapath() {
  ::TSP::Path* _msg = _internal_mutable_instantalphapath();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.instantAlphaPath)
  return _msg;
}
inline void ImageArchive::set_allocated_instantalphapath(::TSP::Path* instantalphapath) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.instantalphapath_);
  }
  if (instantalphapath) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instantalphapath));
    if (message_arena != submessage_arena) {
      instantalphapath = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instantalphapath, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.instantalphapath_ = instantalphapath;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.instantAlphaPath)
}

// optional .TSD.ImageAdjustmentsArchive imageAdjustments = 14;
inline bool ImageArchive::_internal_has_imageadjustments() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.imageadjustments_ != nullptr);
  return value;
}
inline bool ImageArchive::has_imageadjustments() const {
  return _internal_has_imageadjustments();
}
inline void ImageArchive::clear_imageadjustments() {
  if (_impl_.imageadjustments_ != nullptr) _impl_.imageadjustments_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::TSD::ImageAdjustmentsArchive& ImageArchive::_internal_imageadjustments() const {
  const ::TSD::ImageAdjustmentsArchive* p = _impl_.imageadjustments_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::ImageAdjustmentsArchive&>(
      ::TSD::_ImageAdjustmentsArchive_default_instance_);
}
inline const ::TSD::ImageAdjustmentsArchive& ImageArchive::imageadjustments() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.imageAdjustments)
  return _internal_imageadjustments();
}
inline void ImageArchive::unsafe_arena_set_allocated_imageadjustments(
    ::TSD::ImageAdjustmentsArchive* imageadjustments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.imageadjustments_);
  }
  _impl_.imageadjustments_ = imageadjustments;
  if (imageadjustments) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.imageAdjustments)
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::release_imageadjustments() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSD::ImageAdjustmentsArchive* temp = _impl_.imageadjustments_;
  _impl_.imageadjustments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::unsafe_arena_release_imageadjustments() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.imageAdjustments)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSD::ImageAdjustmentsArchive* temp = _impl_.imageadjustments_;
  _impl_.imageadjustments_ = nullptr;
  return temp;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::_internal_mutable_imageadjustments() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.imageadjustments_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::ImageAdjustmentsArchive>(GetArenaForAllocation());
    _impl_.imageadjustments_ = p;
  }
  return _impl_.imageadjustments_;
}
inline ::TSD::ImageAdjustmentsArchive* ImageArchive::mutable_imageadjustments() {
  ::TSD::ImageAdjustmentsArchive* _msg = _internal_mutable_imageadjustments();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.imageAdjustments)
  return _msg;
}
inline void ImageArchive::set_allocated_imageadjustments(::TSD::ImageAdjustmentsArchive* imageadjustments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.imageadjustments_;
  }
  if (imageadjustments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(imageadjustments);
    if (message_arena != submessage_arena) {
      imageadjustments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, imageadjustments, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.imageadjustments_ = imageadjustments;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.imageAdjustments)
}

// optional .TSP.DataReference enhancedImageData = 17;
inline bool ImageArchive::_internal_has_enhancedimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.enhancedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_enhancedimagedata() const {
  return _internal_has_enhancedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_enhancedimagedata() const {
  const ::TSP::DataReference* p = _impl_.enhancedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::enhancedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.enhancedImageData)
  return _internal_enhancedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_enhancedimagedata(
    ::TSP::DataReference* enhancedimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enhancedimagedata_);
  }
  _impl_.enhancedimagedata_ = enhancedimagedata;
  if (enhancedimagedata) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.enhancedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_enhancedimagedata() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::DataReference* temp = _impl_.enhancedimagedata_;
  _impl_.enhancedimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_enhancedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.enhancedImageData)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::DataReference* temp = _impl_.enhancedimagedata_;
  _impl_.enhancedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_enhancedimagedata() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.enhancedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.enhancedimagedata_ = p;
  }
  return _impl_.enhancedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_enhancedimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_enhancedimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.enhancedImageData)
  return _msg;
}
inline void ImageArchive::set_allocated_enhancedimagedata(::TSP::DataReference* enhancedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.enhancedimagedata_);
  }
  if (enhancedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enhancedimagedata));
    if (message_arena != submessage_arena) {
      enhancedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enhancedimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.enhancedimagedata_ = enhancedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.enhancedImageData)
}

// optional .TSP.DataReference adjustedImageData = 15;
inline bool ImageArchive::_internal_has_adjustedimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.adjustedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_adjustedimagedata() const {
  return _internal_has_adjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_adjustedimagedata() const {
  const ::TSP::DataReference* p = _impl_.adjustedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::adjustedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.adjustedImageData)
  return _internal_adjustedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_adjustedimagedata(
    ::TSP::DataReference* adjustedimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adjustedimagedata_);
  }
  _impl_.adjustedimagedata_ = adjustedimagedata;
  if (adjustedimagedata) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.adjustedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_adjustedimagedata() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::DataReference* temp = _impl_.adjustedimagedata_;
  _impl_.adjustedimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_adjustedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.adjustedImageData)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::DataReference* temp = _impl_.adjustedimagedata_;
  _impl_.adjustedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_adjustedimagedata() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.adjustedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.adjustedimagedata_ = p;
  }
  return _impl_.adjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_adjustedimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_adjustedimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.adjustedImageData)
  return _msg;
}
inline void ImageArchive::set_allocated_adjustedimagedata(::TSP::DataReference* adjustedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.adjustedimagedata_);
  }
  if (adjustedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adjustedimagedata));
    if (message_arena != submessage_arena) {
      adjustedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adjustedimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.adjustedimagedata_ = adjustedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.adjustedImageData)
}

// optional .TSP.DataReference thumbnailAdjustedImageData = 16;
inline bool ImageArchive::_internal_has_thumbnailadjustedimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.thumbnailadjustedimagedata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_thumbnailadjustedimagedata() const {
  return _internal_has_thumbnailadjustedimagedata();
}
inline const ::TSP::DataReference& ImageArchive::_internal_thumbnailadjustedimagedata() const {
  const ::TSP::DataReference* p = _impl_.thumbnailadjustedimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& ImageArchive::thumbnailadjustedimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.thumbnailAdjustedImageData)
  return _internal_thumbnailadjustedimagedata();
}
inline void ImageArchive::unsafe_arena_set_allocated_thumbnailadjustedimagedata(
    ::TSP::DataReference* thumbnailadjustedimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thumbnailadjustedimagedata_);
  }
  _impl_.thumbnailadjustedimagedata_ = thumbnailadjustedimagedata;
  if (thumbnailadjustedimagedata) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.thumbnailAdjustedImageData)
}
inline ::TSP::DataReference* ImageArchive::release_thumbnailadjustedimagedata() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::DataReference* temp = _impl_.thumbnailadjustedimagedata_;
  _impl_.thumbnailadjustedimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* ImageArchive::unsafe_arena_release_thumbnailadjustedimagedata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.thumbnailAdjustedImageData)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::DataReference* temp = _impl_.thumbnailadjustedimagedata_;
  _impl_.thumbnailadjustedimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* ImageArchive::_internal_mutable_thumbnailadjustedimagedata() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.thumbnailadjustedimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.thumbnailadjustedimagedata_ = p;
  }
  return _impl_.thumbnailadjustedimagedata_;
}
inline ::TSP::DataReference* ImageArchive::mutable_thumbnailadjustedimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_thumbnailadjustedimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.thumbnailAdjustedImageData)
  return _msg;
}
inline void ImageArchive::set_allocated_thumbnailadjustedimagedata(::TSP::DataReference* thumbnailadjustedimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.thumbnailadjustedimagedata_);
  }
  if (thumbnailadjustedimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnailadjustedimagedata));
    if (message_arena != submessage_arena) {
      thumbnailadjustedimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnailadjustedimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.thumbnailadjustedimagedata_ = thumbnailadjustedimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.thumbnailAdjustedImageData)
}

// optional bool interpretsUntaggedImageDataAsGeneric = 18;
inline bool ImageArchive::_internal_has_interpretsuntaggedimagedataasgeneric() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ImageArchive::has_interpretsuntaggedimagedataasgeneric() const {
  return _internal_has_interpretsuntaggedimagedataasgeneric();
}
inline void ImageArchive::clear_interpretsuntaggedimagedataasgeneric() {
  _impl_.interpretsuntaggedimagedataasgeneric_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool ImageArchive::_internal_interpretsuntaggedimagedataasgeneric() const {
  return _impl_.interpretsuntaggedimagedataasgeneric_;
}
inline bool ImageArchive::interpretsuntaggedimagedataasgeneric() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.interpretsUntaggedImageDataAsGeneric)
  return _internal_interpretsuntaggedimagedataasgeneric();
}
inline void ImageArchive::_internal_set_interpretsuntaggedimagedataasgeneric(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.interpretsuntaggedimagedataasgeneric_ = value;
}
inline void ImageArchive::set_interpretsuntaggedimagedataasgeneric(bool value) {
  _internal_set_interpretsuntaggedimagedataasgeneric(value);
  // @@protoc_insertion_point(field_set:TSD.ImageArchive.interpretsUntaggedImageDataAsGeneric)
}

// optional .TSP.Reference database_data = 2;
inline bool ImageArchive::_internal_has_database_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_data_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_data() const {
  return _internal_has_database_data();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_data() const {
  const ::TSP::Reference* p = _impl_.database_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_data() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_data)
  return _internal_database_data();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_data(
    ::TSP::Reference* database_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_data_);
  }
  _impl_.database_data_ = database_data;
  if (database_data) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_data)
}
inline ::TSP::Reference* ImageArchive::release_database_data() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.database_data_;
  _impl_.database_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_data() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_data)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.database_data_;
  _impl_.database_data_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.database_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_data_ = p;
  }
  return _impl_.database_data_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_data() {
  ::TSP::Reference* _msg = _internal_mutable_database_data();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_data)
  return _msg;
}
inline void ImageArchive::set_allocated_database_data(::TSP::Reference* database_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_data_);
  }
  if (database_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_data));
    if (message_arena != submessage_arena) {
      database_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.database_data_ = database_data;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_data)
}

// optional .TSP.Reference database_thumbnailData = 6;
inline bool ImageArchive::_internal_has_database_thumbnaildata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_thumbnaildata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_thumbnaildata() const {
  return _internal_has_database_thumbnaildata();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_thumbnaildata() const {
  const ::TSP::Reference* p = _impl_.database_thumbnaildata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_thumbnaildata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_thumbnailData)
  return _internal_database_thumbnaildata();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_thumbnaildata(
    ::TSP::Reference* database_thumbnaildata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_thumbnaildata_);
  }
  _impl_.database_thumbnaildata_ = database_thumbnaildata;
  if (database_thumbnaildata) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_thumbnailData)
}
inline ::TSP::Reference* ImageArchive::release_database_thumbnaildata() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.database_thumbnaildata_;
  _impl_.database_thumbnaildata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_thumbnaildata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_thumbnailData)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.database_thumbnaildata_;
  _impl_.database_thumbnaildata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_thumbnaildata() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.database_thumbnaildata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_thumbnaildata_ = p;
  }
  return _impl_.database_thumbnaildata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_thumbnaildata() {
  ::TSP::Reference* _msg = _internal_mutable_database_thumbnaildata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_thumbnailData)
  return _msg;
}
inline void ImageArchive::set_allocated_database_thumbnaildata(::TSP::Reference* database_thumbnaildata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_thumbnaildata_);
  }
  if (database_thumbnaildata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_thumbnaildata));
    if (message_arena != submessage_arena) {
      database_thumbnaildata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_thumbnaildata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.database_thumbnaildata_ = database_thumbnaildata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_thumbnailData)
}

// optional .TSP.Reference database_originalData = 8;
inline bool ImageArchive::_internal_has_database_originaldata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_originaldata_ != nullptr);
  return value;
}
inline bool ImageArchive::has_database_originaldata() const {
  return _internal_has_database_originaldata();
}
inline const ::TSP::Reference& ImageArchive::_internal_database_originaldata() const {
  const ::TSP::Reference* p = _impl_.database_originaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ImageArchive::database_originaldata() const {
  // @@protoc_insertion_point(field_get:TSD.ImageArchive.database_originalData)
  return _internal_database_originaldata();
}
inline void ImageArchive::unsafe_arena_set_allocated_database_originaldata(
    ::TSP::Reference* database_originaldata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_originaldata_);
  }
  _impl_.database_originaldata_ = database_originaldata;
  if (database_originaldata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.ImageArchive.database_originalData)
}
inline ::TSP::Reference* ImageArchive::release_database_originaldata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.database_originaldata_;
  _impl_.database_originaldata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ImageArchive::unsafe_arena_release_database_originaldata() {
  // @@protoc_insertion_point(field_release:TSD.ImageArchive.database_originalData)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.database_originaldata_;
  _impl_.database_originaldata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ImageArchive::_internal_mutable_database_originaldata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.database_originaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_originaldata_ = p;
  }
  return _impl_.database_originaldata_;
}
inline ::TSP::Reference* ImageArchive::mutable_database_originaldata() {
  ::TSP::Reference* _msg = _internal_mutable_database_originaldata();
  // @@protoc_insertion_point(field_mutable:TSD.ImageArchive.database_originalData)
  return _msg;
}
inline void ImageArchive::set_allocated_database_originaldata(::TSP::Reference* database_originaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_originaldata_);
  }
  if (database_originaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_originaldata));
    if (message_arena != submessage_arena) {
      database_originaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_originaldata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.database_originaldata_ = database_originaldata;
  // @@protoc_insertion_point(field_set_allocated:TSD.ImageArchive.database_originalData)
}

// -------------------------------------------------------------------

// MaskArchive

// required .TSD.DrawableArchive super = 1;
inline bool MaskArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MaskArchive::has_super() const {
  return _internal_has_super();
}
inline void MaskArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSD::DrawableArchive& MaskArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& MaskArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MaskArchive.super)
  return _internal_super();
}
inline void MaskArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MaskArchive.super)
}
inline ::TSD::DrawableArchive* MaskArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* MaskArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MaskArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* MaskArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* MaskArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.MaskArchive.super)
  return _msg;
}
inline void MaskArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MaskArchive.super)
}

// optional .TSD.PathSourceArchive pathsource = 2;
inline bool MaskArchive::_internal_has_pathsource() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pathsource_ != nullptr);
  return value;
}
inline bool MaskArchive::has_pathsource() const {
  return _internal_has_pathsource();
}
inline void MaskArchive::clear_pathsource() {
  if (_impl_.pathsource_ != nullptr) _impl_.pathsource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::PathSourceArchive& MaskArchive::_internal_pathsource() const {
  const ::TSD::PathSourceArchive* p = _impl_.pathsource_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::PathSourceArchive&>(
      ::TSD::_PathSourceArchive_default_instance_);
}
inline const ::TSD::PathSourceArchive& MaskArchive::pathsource() const {
  // @@protoc_insertion_point(field_get:TSD.MaskArchive.pathsource)
  return _internal_pathsource();
}
inline void MaskArchive::unsafe_arena_set_allocated_pathsource(
    ::TSD::PathSourceArchive* pathsource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pathsource_);
  }
  _impl_.pathsource_ = pathsource;
  if (pathsource) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MaskArchive.pathsource)
}
inline ::TSD::PathSourceArchive* MaskArchive::release_pathsource() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::PathSourceArchive* temp = _impl_.pathsource_;
  _impl_.pathsource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::PathSourceArchive* MaskArchive::unsafe_arena_release_pathsource() {
  // @@protoc_insertion_point(field_release:TSD.MaskArchive.pathsource)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::PathSourceArchive* temp = _impl_.pathsource_;
  _impl_.pathsource_ = nullptr;
  return temp;
}
inline ::TSD::PathSourceArchive* MaskArchive::_internal_mutable_pathsource() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pathsource_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::PathSourceArchive>(GetArenaForAllocation());
    _impl_.pathsource_ = p;
  }
  return _impl_.pathsource_;
}
inline ::TSD::PathSourceArchive* MaskArchive::mutable_pathsource() {
  ::TSD::PathSourceArchive* _msg = _internal_mutable_pathsource();
  // @@protoc_insertion_point(field_mutable:TSD.MaskArchive.pathsource)
  return _msg;
}
inline void MaskArchive::set_allocated_pathsource(::TSD::PathSourceArchive* pathsource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pathsource_;
  }
  if (pathsource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pathsource);
    if (message_arena != submessage_arena) {
      pathsource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathsource, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pathsource_ = pathsource;
  // @@protoc_insertion_point(field_set_allocated:TSD.MaskArchive.pathsource)
}

// -------------------------------------------------------------------

// MovieArchive

// required .TSD.DrawableArchive super = 1;
inline bool MovieArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool MovieArchive::has_super() const {
  return _internal_has_super();
}
inline void MovieArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSD::DrawableArchive& MovieArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& MovieArchive::super() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.super)
  return _internal_super();
}
inline void MovieArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.super)
}
inline ::TSD::DrawableArchive* MovieArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* MovieArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* MovieArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* MovieArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.super)
  return _msg;
}
inline void MovieArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.super)
}

// optional .TSP.DataReference movieData = 14;
inline bool MovieArchive::_internal_has_moviedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.moviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_moviedata() const {
  return _internal_has_moviedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_moviedata() const {
  const ::TSP::DataReference* p = _impl_.moviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::moviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.movieData)
  return _internal_moviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_moviedata(
    ::TSP::DataReference* moviedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.moviedata_);
  }
  _impl_.moviedata_ = moviedata;
  if (moviedata) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.movieData)
}
inline ::TSP::DataReference* MovieArchive::release_moviedata() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = _impl_.moviedata_;
  _impl_.moviedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_moviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.movieData)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::DataReference* temp = _impl_.moviedata_;
  _impl_.moviedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_moviedata() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.moviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.moviedata_ = p;
  }
  return _impl_.moviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_moviedata() {
  ::TSP::DataReference* _msg = _internal_mutable_moviedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.movieData)
  return _msg;
}
inline void MovieArchive::set_allocated_moviedata(::TSP::DataReference* moviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.moviedata_);
  }
  if (moviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moviedata));
    if (message_arena != submessage_arena) {
      moviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moviedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.moviedata_ = moviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.movieData)
}

// optional .TSP.DataReference importedAuxiliaryMovieData = 22;
inline bool MovieArchive::_internal_has_importedauxiliarymoviedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.importedauxiliarymoviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_importedauxiliarymoviedata() const {
  return _internal_has_importedauxiliarymoviedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_importedauxiliarymoviedata() const {
  const ::TSP::DataReference* p = _impl_.importedauxiliarymoviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::importedauxiliarymoviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.importedAuxiliaryMovieData)
  return _internal_importedauxiliarymoviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_importedauxiliarymoviedata(
    ::TSP::DataReference* importedauxiliarymoviedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.importedauxiliarymoviedata_);
  }
  _impl_.importedauxiliarymoviedata_ = importedauxiliarymoviedata;
  if (importedauxiliarymoviedata) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.importedAuxiliaryMovieData)
}
inline ::TSP::DataReference* MovieArchive::release_importedauxiliarymoviedata() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = _impl_.importedauxiliarymoviedata_;
  _impl_.importedauxiliarymoviedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_importedauxiliarymoviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.importedAuxiliaryMovieData)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::DataReference* temp = _impl_.importedauxiliarymoviedata_;
  _impl_.importedauxiliarymoviedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_importedauxiliarymoviedata() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.importedauxiliarymoviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.importedauxiliarymoviedata_ = p;
  }
  return _impl_.importedauxiliarymoviedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_importedauxiliarymoviedata() {
  ::TSP::DataReference* _msg = _internal_mutable_importedauxiliarymoviedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.importedAuxiliaryMovieData)
  return _msg;
}
inline void MovieArchive::set_allocated_importedauxiliarymoviedata(::TSP::DataReference* importedauxiliarymoviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.importedauxiliarymoviedata_);
  }
  if (importedauxiliarymoviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(importedauxiliarymoviedata));
    if (message_arena != submessage_arena) {
      importedauxiliarymoviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, importedauxiliarymoviedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.importedauxiliarymoviedata_ = importedauxiliarymoviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.importedAuxiliaryMovieData)
}

// optional string movieRemoteURL = 17;
inline bool MovieArchive::_internal_has_movieremoteurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MovieArchive::has_movieremoteurl() const {
  return _internal_has_movieremoteurl();
}
inline void MovieArchive::clear_movieremoteurl() {
  _impl_.movieremoteurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MovieArchive::movieremoteurl() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.movieRemoteURL)
  return _internal_movieremoteurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovieArchive::set_movieremoteurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.movieremoteurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.movieRemoteURL)
}
inline std::string* MovieArchive::mutable_movieremoteurl() {
  std::string* _s = _internal_mutable_movieremoteurl();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.movieRemoteURL)
  return _s;
}
inline const std::string& MovieArchive::_internal_movieremoteurl() const {
  return _impl_.movieremoteurl_.Get();
}
inline void MovieArchive::_internal_set_movieremoteurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.movieremoteurl_.Set(value, GetArenaForAllocation());
}
inline std::string* MovieArchive::_internal_mutable_movieremoteurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.movieremoteurl_.Mutable(GetArenaForAllocation());
}
inline std::string* MovieArchive::release_movieremoteurl() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.movieRemoteURL)
  if (!_internal_has_movieremoteurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.movieremoteurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.movieremoteurl_.IsDefault()) {
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MovieArchive::set_allocated_movieremoteurl(std::string* movieremoteurl) {
  if (movieremoteurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.movieremoteurl_.SetAllocated(movieremoteurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.movieremoteurl_.IsDefault()) {
    _impl_.movieremoteurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.movieRemoteURL)
}

// optional float startTime = 3;
inline bool MovieArchive::_internal_has_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MovieArchive::has_starttime() const {
  return _internal_has_starttime();
}
inline void MovieArchive::clear_starttime() {
  _impl_.starttime_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float MovieArchive::_internal_starttime() const {
  return _impl_.starttime_;
}
inline float MovieArchive::starttime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.startTime)
  return _internal_starttime();
}
inline void MovieArchive::_internal_set_starttime(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.starttime_ = value;
}
inline void MovieArchive::set_starttime(float value) {
  _internal_set_starttime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.startTime)
}

// optional float endTime = 4;
inline bool MovieArchive::_internal_has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MovieArchive::has_endtime() const {
  return _internal_has_endtime();
}
inline void MovieArchive::clear_endtime() {
  _impl_.endtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float MovieArchive::_internal_endtime() const {
  return _impl_.endtime_;
}
inline float MovieArchive::endtime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.endTime)
  return _internal_endtime();
}
inline void MovieArchive::_internal_set_endtime(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.endtime_ = value;
}
inline void MovieArchive::set_endtime(float value) {
  _internal_set_endtime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.endTime)
}

// optional float posterTime = 5;
inline bool MovieArchive::_internal_has_postertime() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MovieArchive::has_postertime() const {
  return _internal_has_postertime();
}
inline void MovieArchive::clear_postertime() {
  _impl_.postertime_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline float MovieArchive::_internal_postertime() const {
  return _impl_.postertime_;
}
inline float MovieArchive::postertime() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.posterTime)
  return _internal_postertime();
}
inline void MovieArchive::_internal_set_postertime(float value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.postertime_ = value;
}
inline void MovieArchive::set_postertime(float value) {
  _internal_set_postertime(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.posterTime)
}

// optional uint32 loopOption = 6;
inline bool MovieArchive::_internal_has_loopoption() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MovieArchive::has_loopoption() const {
  return _internal_has_loopoption();
}
inline void MovieArchive::clear_loopoption() {
  _impl_.loopoption_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t MovieArchive::_internal_loopoption() const {
  return _impl_.loopoption_;
}
inline uint32_t MovieArchive::loopoption() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.loopOption)
  return _internal_loopoption();
}
inline void MovieArchive::_internal_set_loopoption(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.loopoption_ = value;
}
inline void MovieArchive::set_loopoption(uint32_t value) {
  _internal_set_loopoption(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.loopOption)
}

// optional float volume = 7;
inline bool MovieArchive::_internal_has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MovieArchive::has_volume() const {
  return _internal_has_volume();
}
inline void MovieArchive::clear_volume() {
  _impl_.volume_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline float MovieArchive::_internal_volume() const {
  return _impl_.volume_;
}
inline float MovieArchive::volume() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.volume)
  return _internal_volume();
}
inline void MovieArchive::_internal_set_volume(float value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.volume_ = value;
}
inline void MovieArchive::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.volume)
}

// optional bool autoPlay = 8 [deprecated = true];
inline bool MovieArchive::_internal_has_autoplay() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MovieArchive::has_autoplay() const {
  return _internal_has_autoplay();
}
inline void MovieArchive::clear_autoplay() {
  _impl_.autoplay_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool MovieArchive::_internal_autoplay() const {
  return _impl_.autoplay_;
}
inline bool MovieArchive::autoplay() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.autoPlay)
  return _internal_autoplay();
}
inline void MovieArchive::_internal_set_autoplay(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.autoplay_ = value;
}
inline void MovieArchive::set_autoplay(bool value) {
  _internal_set_autoplay(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.autoPlay)
}

// optional bool audioOnly = 9;
inline bool MovieArchive::_internal_has_audioonly() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MovieArchive::has_audioonly() const {
  return _internal_has_audioonly();
}
inline void MovieArchive::clear_audioonly() {
  _impl_.audioonly_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool MovieArchive::_internal_audioonly() const {
  return _impl_.audioonly_;
}
inline bool MovieArchive::audioonly() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.audioOnly)
  return _internal_audioonly();
}
inline void MovieArchive::_internal_set_audioonly(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.audioonly_ = value;
}
inline void MovieArchive::set_audioonly(bool value) {
  _internal_set_audioonly(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.audioOnly)
}

// optional bool streaming = 18;
inline bool MovieArchive::_internal_has_streaming() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MovieArchive::has_streaming() const {
  return _internal_has_streaming();
}
inline void MovieArchive::clear_streaming() {
  _impl_.streaming_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool MovieArchive::_internal_streaming() const {
  return _impl_.streaming_;
}
inline bool MovieArchive::streaming() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.streaming)
  return _internal_streaming();
}
inline void MovieArchive::_internal_set_streaming(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.streaming_ = value;
}
inline void MovieArchive::set_streaming(bool value) {
  _internal_set_streaming(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.streaming)
}

// optional .TSP.DataReference posterImageData = 15;
inline bool MovieArchive::_internal_has_posterimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.posterimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_posterimagedata() const {
  return _internal_has_posterimagedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_posterimagedata() const {
  const ::TSP::DataReference* p = _impl_.posterimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::posterimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.posterImageData)
  return _internal_posterimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_posterimagedata(
    ::TSP::DataReference* posterimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posterimagedata_);
  }
  _impl_.posterimagedata_ = posterimagedata;
  if (posterimagedata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.posterImageData)
}
inline ::TSP::DataReference* MovieArchive::release_posterimagedata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::DataReference* temp = _impl_.posterimagedata_;
  _impl_.posterimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_posterimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.posterImageData)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::DataReference* temp = _impl_.posterimagedata_;
  _impl_.posterimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_posterimagedata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.posterimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.posterimagedata_ = p;
  }
  return _impl_.posterimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_posterimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_posterimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.posterImageData)
  return _msg;
}
inline void MovieArchive::set_allocated_posterimagedata(::TSP::DataReference* posterimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posterimagedata_);
  }
  if (posterimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posterimagedata));
    if (message_arena != submessage_arena) {
      posterimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posterimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.posterimagedata_ = posterimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.posterImageData)
}

// optional .TSP.DataReference audioOnlyImageData = 16;
inline bool MovieArchive::_internal_has_audioonlyimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audioonlyimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_audioonlyimagedata() const {
  return _internal_has_audioonlyimagedata();
}
inline const ::TSP::DataReference& MovieArchive::_internal_audioonlyimagedata() const {
  const ::TSP::DataReference* p = _impl_.audioonlyimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::DataReference&>(
      ::TSP::_DataReference_default_instance_);
}
inline const ::TSP::DataReference& MovieArchive::audioonlyimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.audioOnlyImageData)
  return _internal_audioonlyimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_audioonlyimagedata(
    ::TSP::DataReference* audioonlyimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audioonlyimagedata_);
  }
  _impl_.audioonlyimagedata_ = audioonlyimagedata;
  if (audioonlyimagedata) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.audioOnlyImageData)
}
inline ::TSP::DataReference* MovieArchive::release_audioonlyimagedata() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::DataReference* temp = _impl_.audioonlyimagedata_;
  _impl_.audioonlyimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::DataReference* MovieArchive::unsafe_arena_release_audioonlyimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.audioOnlyImageData)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::DataReference* temp = _impl_.audioonlyimagedata_;
  _impl_.audioonlyimagedata_ = nullptr;
  return temp;
}
inline ::TSP::DataReference* MovieArchive::_internal_mutable_audioonlyimagedata() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.audioonlyimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::DataReference>(GetArenaForAllocation());
    _impl_.audioonlyimagedata_ = p;
  }
  return _impl_.audioonlyimagedata_;
}
inline ::TSP::DataReference* MovieArchive::mutable_audioonlyimagedata() {
  ::TSP::DataReference* _msg = _internal_mutable_audioonlyimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.audioOnlyImageData)
  return _msg;
}
inline void MovieArchive::set_allocated_audioonlyimagedata(::TSP::DataReference* audioonlyimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audioonlyimagedata_);
  }
  if (audioonlyimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audioonlyimagedata));
    if (message_arena != submessage_arena) {
      audioonlyimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audioonlyimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.audioonlyimagedata_ = audioonlyimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.audioOnlyImageData)
}

// optional uint32 playableState = 12;
inline bool MovieArchive::_internal_has_playablestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool MovieArchive::has_playablestate() const {
  return _internal_has_playablestate();
}
inline void MovieArchive::clear_playablestate() {
  _impl_.playablestate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t MovieArchive::_internal_playablestate() const {
  return _impl_.playablestate_;
}
inline uint32_t MovieArchive::playablestate() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.playableState)
  return _internal_playablestate();
}
inline void MovieArchive::_internal_set_playablestate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.playablestate_ = value;
}
inline void MovieArchive::set_playablestate(uint32_t value) {
  _internal_set_playablestate(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.playableState)
}

// optional uint32 flags = 13;
inline bool MovieArchive::_internal_has_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool MovieArchive::has_flags() const {
  return _internal_has_flags();
}
inline void MovieArchive::clear_flags() {
  _impl_.flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t MovieArchive::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t MovieArchive::flags() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.flags)
  return _internal_flags();
}
inline void MovieArchive::_internal_set_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.flags_ = value;
}
inline void MovieArchive::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:TSD.MovieArchive.flags)
}

// optional .TSP.Reference database_movieData = 2;
inline bool MovieArchive::_internal_has_database_moviedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_moviedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_moviedata() const {
  return _internal_has_database_moviedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_moviedata() const {
  const ::TSP::Reference* p = _impl_.database_moviedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_moviedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_movieData)
  return _internal_database_moviedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_moviedata(
    ::TSP::Reference* database_moviedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_moviedata_);
  }
  _impl_.database_moviedata_ = database_moviedata;
  if (database_moviedata) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_movieData)
}
inline ::TSP::Reference* MovieArchive::release_database_moviedata() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.database_moviedata_;
  _impl_.database_moviedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_moviedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_movieData)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.database_moviedata_;
  _impl_.database_moviedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_moviedata() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.database_moviedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_moviedata_ = p;
  }
  return _impl_.database_moviedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_moviedata() {
  ::TSP::Reference* _msg = _internal_mutable_database_moviedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_movieData)
  return _msg;
}
inline void MovieArchive::set_allocated_database_moviedata(::TSP::Reference* database_moviedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_moviedata_);
  }
  if (database_moviedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_moviedata));
    if (message_arena != submessage_arena) {
      database_moviedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_moviedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.database_moviedata_ = database_moviedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_movieData)
}

// optional .TSP.Reference database_posterImageData = 10;
inline bool MovieArchive::_internal_has_database_posterimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_posterimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_posterimagedata() const {
  return _internal_has_database_posterimagedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_posterimagedata() const {
  const ::TSP::Reference* p = _impl_.database_posterimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_posterimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_posterImageData)
  return _internal_database_posterimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_posterimagedata(
    ::TSP::Reference* database_posterimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_posterimagedata_);
  }
  _impl_.database_posterimagedata_ = database_posterimagedata;
  if (database_posterimagedata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_posterImageData)
}
inline ::TSP::Reference* MovieArchive::release_database_posterimagedata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.database_posterimagedata_;
  _impl_.database_posterimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_posterimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_posterImageData)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.database_posterimagedata_;
  _impl_.database_posterimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_posterimagedata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.database_posterimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_posterimagedata_ = p;
  }
  return _impl_.database_posterimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_posterimagedata() {
  ::TSP::Reference* _msg = _internal_mutable_database_posterimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_posterImageData)
  return _msg;
}
inline void MovieArchive::set_allocated_database_posterimagedata(::TSP::Reference* database_posterimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_posterimagedata_);
  }
  if (database_posterimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_posterimagedata));
    if (message_arena != submessage_arena) {
      database_posterimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_posterimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.database_posterimagedata_ = database_posterimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_posterImageData)
}

// optional .TSP.Reference database_audioOnlyImageData = 11;
inline bool MovieArchive::_internal_has_database_audioonlyimagedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_audioonlyimagedata_ != nullptr);
  return value;
}
inline bool MovieArchive::has_database_audioonlyimagedata() const {
  return _internal_has_database_audioonlyimagedata();
}
inline const ::TSP::Reference& MovieArchive::_internal_database_audioonlyimagedata() const {
  const ::TSP::Reference* p = _impl_.database_audioonlyimagedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::database_audioonlyimagedata() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.database_audioOnlyImageData)
  return _internal_database_audioonlyimagedata();
}
inline void MovieArchive::unsafe_arena_set_allocated_database_audioonlyimagedata(
    ::TSP::Reference* database_audioonlyimagedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_audioonlyimagedata_);
  }
  _impl_.database_audioonlyimagedata_ = database_audioonlyimagedata;
  if (database_audioonlyimagedata) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.database_audioOnlyImageData)
}
inline ::TSP::Reference* MovieArchive::release_database_audioonlyimagedata() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.database_audioonlyimagedata_;
  _impl_.database_audioonlyimagedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_database_audioonlyimagedata() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.database_audioOnlyImageData)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.database_audioonlyimagedata_;
  _impl_.database_audioonlyimagedata_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_database_audioonlyimagedata() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.database_audioonlyimagedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.database_audioonlyimagedata_ = p;
  }
  return _impl_.database_audioonlyimagedata_;
}
inline ::TSP::Reference* MovieArchive::mutable_database_audioonlyimagedata() {
  ::TSP::Reference* _msg = _internal_mutable_database_audioonlyimagedata();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.database_audioOnlyImageData)
  return _msg;
}
inline void MovieArchive::set_allocated_database_audioonlyimagedata(::TSP::Reference* database_audioonlyimagedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.database_audioonlyimagedata_);
  }
  if (database_audioonlyimagedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_audioonlyimagedata));
    if (message_arena != submessage_arena) {
      database_audioonlyimagedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_audioonlyimagedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.database_audioonlyimagedata_ = database_audioonlyimagedata;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.database_audioOnlyImageData)
}

// optional .TSP.Reference style = 19;
inline bool MovieArchive::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.style_ != nullptr);
  return value;
}
inline bool MovieArchive::has_style() const {
  return _internal_has_style();
}
inline const ::TSP::Reference& MovieArchive::_internal_style() const {
  const ::TSP::Reference* p = _impl_.style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& MovieArchive::style() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.style)
  return _internal_style();
}
inline void MovieArchive::unsafe_arena_set_allocated_style(
    ::TSP::Reference* style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  _impl_.style_ = style;
  if (style) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.style)
}
inline ::TSP::Reference* MovieArchive::release_style() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* MovieArchive::unsafe_arena_release_style() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.style)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.style_;
  _impl_.style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* MovieArchive::_internal_mutable_style() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.style_ = p;
  }
  return _impl_.style_;
}
inline ::TSP::Reference* MovieArchive::mutable_style() {
  ::TSP::Reference* _msg = _internal_mutable_style();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.style)
  return _msg;
}
inline void MovieArchive::set_allocated_style(::TSP::Reference* style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.style_);
  }
  if (style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(style));
    if (message_arena != submessage_arena) {
      style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.style_ = style;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.style)
}

// optional .TSP.Size originalSize = 20;
inline bool MovieArchive::_internal_has_originalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.originalsize_ != nullptr);
  return value;
}
inline bool MovieArchive::has_originalsize() const {
  return _internal_has_originalsize();
}
inline const ::TSP::Size& MovieArchive::_internal_originalsize() const {
  const ::TSP::Size* p = _impl_.originalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& MovieArchive::originalsize() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.originalSize)
  return _internal_originalsize();
}
inline void MovieArchive::unsafe_arena_set_allocated_originalsize(
    ::TSP::Size* originalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsize_);
  }
  _impl_.originalsize_ = originalsize;
  if (originalsize) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.originalSize)
}
inline ::TSP::Size* MovieArchive::release_originalsize() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Size* temp = _impl_.originalsize_;
  _impl_.originalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* MovieArchive::unsafe_arena_release_originalsize() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.originalSize)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Size* temp = _impl_.originalsize_;
  _impl_.originalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* MovieArchive::_internal_mutable_originalsize() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.originalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.originalsize_ = p;
  }
  return _impl_.originalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_originalsize() {
  ::TSP::Size* _msg = _internal_mutable_originalsize();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.originalSize)
  return _msg;
}
inline void MovieArchive::set_allocated_originalsize(::TSP::Size* originalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.originalsize_);
  }
  if (originalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(originalsize));
    if (message_arena != submessage_arena) {
      originalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, originalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.originalsize_ = originalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.originalSize)
}

// optional .TSP.Size naturalSize = 21;
inline bool MovieArchive::_internal_has_naturalsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.naturalsize_ != nullptr);
  return value;
}
inline bool MovieArchive::has_naturalsize() const {
  return _internal_has_naturalsize();
}
inline const ::TSP::Size& MovieArchive::_internal_naturalsize() const {
  const ::TSP::Size* p = _impl_.naturalsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& MovieArchive::naturalsize() const {
  // @@protoc_insertion_point(field_get:TSD.MovieArchive.naturalSize)
  return _internal_naturalsize();
}
inline void MovieArchive::unsafe_arena_set_allocated_naturalsize(
    ::TSP::Size* naturalsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  _impl_.naturalsize_ = naturalsize;
  if (naturalsize) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.MovieArchive.naturalSize)
}
inline ::TSP::Size* MovieArchive::release_naturalsize() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* MovieArchive::unsafe_arena_release_naturalsize() {
  // @@protoc_insertion_point(field_release:TSD.MovieArchive.naturalSize)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Size* temp = _impl_.naturalsize_;
  _impl_.naturalsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* MovieArchive::_internal_mutable_naturalsize() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.naturalsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.naturalsize_ = p;
  }
  return _impl_.naturalsize_;
}
inline ::TSP::Size* MovieArchive::mutable_naturalsize() {
  ::TSP::Size* _msg = _internal_mutable_naturalsize();
  // @@protoc_insertion_point(field_mutable:TSD.MovieArchive.naturalSize)
  return _msg;
}
inline void MovieArchive::set_allocated_naturalsize(::TSP::Size* naturalsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.naturalsize_);
  }
  if (naturalsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(naturalsize));
    if (message_arena != submessage_arena) {
      naturalsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, naturalsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.naturalsize_ = naturalsize;
  // @@protoc_insertion_point(field_set_allocated:TSD.MovieArchive.naturalSize)
}

// -------------------------------------------------------------------

// ExteriorTextWrapArchive

// optional uint32 type = 1;
inline bool ExteriorTextWrapArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_type() const {
  return _internal_has_type();
}
inline void ExteriorTextWrapArchive::clear_type() {
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ExteriorTextWrapArchive::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t ExteriorTextWrapArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.type)
  return _internal_type();
}
inline void ExteriorTextWrapArchive::_internal_set_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void ExteriorTextWrapArchive::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.type)
}

// optional uint32 direction = 2;
inline bool ExteriorTextWrapArchive::_internal_has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_direction() const {
  return _internal_has_direction();
}
inline void ExteriorTextWrapArchive::clear_direction() {
  _impl_.direction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ExteriorTextWrapArchive::_internal_direction() const {
  return _impl_.direction_;
}
inline uint32_t ExteriorTextWrapArchive::direction() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.direction)
  return _internal_direction();
}
inline void ExteriorTextWrapArchive::_internal_set_direction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.direction_ = value;
}
inline void ExteriorTextWrapArchive::set_direction(uint32_t value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.direction)
}

// optional uint32 fit_type = 3;
inline bool ExteriorTextWrapArchive::_internal_has_fit_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_fit_type() const {
  return _internal_has_fit_type();
}
inline void ExteriorTextWrapArchive::clear_fit_type() {
  _impl_.fit_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ExteriorTextWrapArchive::_internal_fit_type() const {
  return _impl_.fit_type_;
}
inline uint32_t ExteriorTextWrapArchive::fit_type() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.fit_type)
  return _internal_fit_type();
}
inline void ExteriorTextWrapArchive::_internal_set_fit_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fit_type_ = value;
}
inline void ExteriorTextWrapArchive::set_fit_type(uint32_t value) {
  _internal_set_fit_type(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.fit_type)
}

// optional float margin = 4;
inline bool ExteriorTextWrapArchive::_internal_has_margin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_margin() const {
  return _internal_has_margin();
}
inline void ExteriorTextWrapArchive::clear_margin() {
  _impl_.margin_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ExteriorTextWrapArchive::_internal_margin() const {
  return _impl_.margin_;
}
inline float ExteriorTextWrapArchive::margin() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.margin)
  return _internal_margin();
}
inline void ExteriorTextWrapArchive::_internal_set_margin(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.margin_ = value;
}
inline void ExteriorTextWrapArchive::set_margin(float value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.margin)
}

// optional float alpha_threshold = 5;
inline bool ExteriorTextWrapArchive::_internal_has_alpha_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_alpha_threshold() const {
  return _internal_has_alpha_threshold();
}
inline void ExteriorTextWrapArchive::clear_alpha_threshold() {
  _impl_.alpha_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float ExteriorTextWrapArchive::_internal_alpha_threshold() const {
  return _impl_.alpha_threshold_;
}
inline float ExteriorTextWrapArchive::alpha_threshold() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.alpha_threshold)
  return _internal_alpha_threshold();
}
inline void ExteriorTextWrapArchive::_internal_set_alpha_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.alpha_threshold_ = value;
}
inline void ExteriorTextWrapArchive::set_alpha_threshold(float value) {
  _internal_set_alpha_threshold(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.alpha_threshold)
}

// optional bool is_html_wrap = 6;
inline bool ExteriorTextWrapArchive::_internal_has_is_html_wrap() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExteriorTextWrapArchive::has_is_html_wrap() const {
  return _internal_has_is_html_wrap();
}
inline void ExteriorTextWrapArchive::clear_is_html_wrap() {
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ExteriorTextWrapArchive::_internal_is_html_wrap() const {
  return _impl_.is_html_wrap_;
}
inline bool ExteriorTextWrapArchive::is_html_wrap() const {
  // @@protoc_insertion_point(field_get:TSD.ExteriorTextWrapArchive.is_html_wrap)
  return _internal_is_html_wrap();
}
inline void ExteriorTextWrapArchive::_internal_set_is_html_wrap(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_html_wrap_ = value;
}
inline void ExteriorTextWrapArchive::set_is_html_wrap(bool value) {
  _internal_set_is_html_wrap(value);
  // @@protoc_insertion_point(field_set:TSD.ExteriorTextWrapArchive.is_html_wrap)
}

// -------------------------------------------------------------------

// GuideArchive

// optional .TSD.GuideArchive.GuideType type = 1;
inline bool GuideArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuideArchive::has_type() const {
  return _internal_has_type();
}
inline void GuideArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::GuideArchive_GuideType GuideArchive::_internal_type() const {
  return static_cast< ::TSD::GuideArchive_GuideType >(_impl_.type_);
}
inline ::TSD::GuideArchive_GuideType GuideArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.type)
  return _internal_type();
}
inline void GuideArchive::_internal_set_type(::TSD::GuideArchive_GuideType value) {
  assert(::TSD::GuideArchive_GuideType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void GuideArchive::set_type(::TSD::GuideArchive_GuideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.type)
}

// optional float offset = 2;
inline bool GuideArchive::_internal_has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuideArchive::has_offset() const {
  return _internal_has_offset();
}
inline void GuideArchive::clear_offset() {
  _impl_.offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float GuideArchive::_internal_offset() const {
  return _impl_.offset_;
}
inline float GuideArchive::offset() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.offset)
  return _internal_offset();
}
inline void GuideArchive::_internal_set_offset(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.offset_ = value;
}
inline void GuideArchive::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.offset)
}

// optional float start = 3;
inline bool GuideArchive::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GuideArchive::has_start() const {
  return _internal_has_start();
}
inline void GuideArchive::clear_start() {
  _impl_.start_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float GuideArchive::_internal_start() const {
  return _impl_.start_;
}
inline float GuideArchive::start() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.start)
  return _internal_start();
}
inline void GuideArchive::_internal_set_start(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_ = value;
}
inline void GuideArchive::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.start)
}

// optional float end = 4;
inline bool GuideArchive::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GuideArchive::has_end() const {
  return _internal_has_end();
}
inline void GuideArchive::clear_end() {
  _impl_.end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float GuideArchive::_internal_end() const {
  return _impl_.end_;
}
inline float GuideArchive::end() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.end)
  return _internal_end();
}
inline void GuideArchive::_internal_set_end(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.end_ = value;
}
inline void GuideArchive::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.end)
}

// optional bool dynamic = 5;
inline bool GuideArchive::_internal_has_dynamic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GuideArchive::has_dynamic() const {
  return _internal_has_dynamic();
}
inline void GuideArchive::clear_dynamic() {
  _impl_.dynamic_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool GuideArchive::_internal_dynamic() const {
  return _impl_.dynamic_;
}
inline bool GuideArchive::dynamic() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.dynamic)
  return _internal_dynamic();
}
inline void GuideArchive::_internal_set_dynamic(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dynamic_ = value;
}
inline void GuideArchive::set_dynamic(bool value) {
  _internal_set_dynamic(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.dynamic)
}

// optional bool infinite = 6;
inline bool GuideArchive::_internal_has_infinite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GuideArchive::has_infinite() const {
  return _internal_has_infinite();
}
inline void GuideArchive::clear_infinite() {
  _impl_.infinite_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool GuideArchive::_internal_infinite() const {
  return _impl_.infinite_;
}
inline bool GuideArchive::infinite() const {
  // @@protoc_insertion_point(field_get:TSD.GuideArchive.infinite)
  return _internal_infinite();
}
inline void GuideArchive::_internal_set_infinite(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.infinite_ = value;
}
inline void GuideArchive::set_infinite(bool value) {
  _internal_set_infinite(value);
  // @@protoc_insertion_point(field_set:TSD.GuideArchive.infinite)
}

// -------------------------------------------------------------------

// UserDefinedGuideArchive

// optional .TSD.UserDefinedGuideArchive.GuideType type = 1;
inline bool UserDefinedGuideArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserDefinedGuideArchive::has_type() const {
  return _internal_has_type();
}
inline void UserDefinedGuideArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSD::UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::_internal_type() const {
  return static_cast< ::TSD::UserDefinedGuideArchive_GuideType >(_impl_.type_);
}
inline ::TSD::UserDefinedGuideArchive_GuideType UserDefinedGuideArchive::type() const {
  // @@protoc_insertion_point(field_get:TSD.UserDefinedGuideArchive.type)
  return _internal_type();
}
inline void UserDefinedGuideArchive::_internal_set_type(::TSD::UserDefinedGuideArchive_GuideType value) {
  assert(::TSD::UserDefinedGuideArchive_GuideType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void UserDefinedGuideArchive::set_type(::TSD::UserDefinedGuideArchive_GuideType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSD.UserDefinedGuideArchive.type)
}

// optional float position = 2;
inline bool UserDefinedGuideArchive::_internal_has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserDefinedGuideArchive::has_position() const {
  return _internal_has_position();
}
inline void UserDefinedGuideArchive::clear_position() {
  _impl_.position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float UserDefinedGuideArchive::_internal_position() const {
  return _impl_.position_;
}
inline float UserDefinedGuideArchive::position() const {
  // @@protoc_insertion_point(field_get:TSD.UserDefinedGuideArchive.position)
  return _internal_position();
}
inline void UserDefinedGuideArchive::_internal_set_position(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.position_ = value;
}
inline void UserDefinedGuideArchive::set_position(float value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:TSD.UserDefinedGuideArchive.position)
}

// -------------------------------------------------------------------

// GuideStorageArchive

// repeated .TSD.UserDefinedGuideArchive userDefinedGuides = 1;
inline int GuideStorageArchive::_internal_userdefinedguides_size() const {
  return _impl_.userdefinedguides_.size();
}
inline int GuideStorageArchive::userdefinedguides_size() const {
  return _internal_userdefinedguides_size();
}
inline void GuideStorageArchive::clear_userdefinedguides() {
  _impl_.userdefinedguides_.Clear();
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::mutable_userdefinedguides(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.GuideStorageArchive.userDefinedGuides)
  return _impl_.userdefinedguides_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >*
GuideStorageArchive::mutable_userdefinedguides() {
  // @@protoc_insertion_point(field_mutable_list:TSD.GuideStorageArchive.userDefinedGuides)
  return &_impl_.userdefinedguides_;
}
inline const ::TSD::UserDefinedGuideArchive& GuideStorageArchive::_internal_userdefinedguides(int index) const {
  return _impl_.userdefinedguides_.Get(index);
}
inline const ::TSD::UserDefinedGuideArchive& GuideStorageArchive::userdefinedguides(int index) const {
  // @@protoc_insertion_point(field_get:TSD.GuideStorageArchive.userDefinedGuides)
  return _internal_userdefinedguides(index);
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::_internal_add_userdefinedguides() {
  return _impl_.userdefinedguides_.Add();
}
inline ::TSD::UserDefinedGuideArchive* GuideStorageArchive::add_userdefinedguides() {
  ::TSD::UserDefinedGuideArchive* _add = _internal_add_userdefinedguides();
  // @@protoc_insertion_point(field_add:TSD.GuideStorageArchive.userDefinedGuides)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSD::UserDefinedGuideArchive >&
GuideStorageArchive::userdefinedguides() const {
  // @@protoc_insertion_point(field_list:TSD.GuideStorageArchive.userDefinedGuides)
  return _impl_.userdefinedguides_;
}

// -------------------------------------------------------------------

// CanvasSelectionArchive

// repeated .TSP.Reference infos = 1;
inline int CanvasSelectionArchive::_internal_infos_size() const {
  return _impl_.infos_.size();
}
inline int CanvasSelectionArchive::infos_size() const {
  return _internal_infos_size();
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:TSD.CanvasSelectionArchive.infos)
  return _impl_.infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CanvasSelectionArchive::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:TSD.CanvasSelectionArchive.infos)
  return &_impl_.infos_;
}
inline const ::TSP::Reference& CanvasSelectionArchive::_internal_infos(int index) const {
  return _impl_.infos_.Get(index);
}
inline const ::TSP::Reference& CanvasSelectionArchive::infos(int index) const {
  // @@protoc_insertion_point(field_get:TSD.CanvasSelectionArchive.infos)
  return _internal_infos(index);
}
inline ::TSP::Reference* CanvasSelectionArchive::_internal_add_infos() {
  return _impl_.infos_.Add();
}
inline ::TSP::Reference* CanvasSelectionArchive::add_infos() {
  ::TSP::Reference* _add = _internal_add_infos();
  // @@protoc_insertion_point(field_add:TSD.CanvasSelectionArchive.infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CanvasSelectionArchive::infos() const {
  // @@protoc_insertion_point(field_list:TSD.CanvasSelectionArchive.infos)
  return _impl_.infos_;
}

// optional .TSP.Reference container = 2;
inline bool CanvasSelectionArchive::_internal_has_container() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.container_ != nullptr);
  return value;
}
inline bool CanvasSelectionArchive::has_container() const {
  return _internal_has_container();
}
inline const ::TSP::Reference& CanvasSelectionArchive::_internal_container() const {
  const ::TSP::Reference* p = _impl_.container_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CanvasSelectionArchive::container() const {
  // @@protoc_insertion_point(field_get:TSD.CanvasSelectionArchive.container)
  return _internal_container();
}
inline void CanvasSelectionArchive::unsafe_arena_set_allocated_container(
    ::TSP::Reference* container) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.container_);
  }
  _impl_.container_ = container;
  if (container) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CanvasSelectionArchive.container)
}
inline ::TSP::Reference* CanvasSelectionArchive::release_container() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.container_;
  _impl_.container_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CanvasSelectionArchive::unsafe_arena_release_container() {
  // @@protoc_insertion_point(field_release:TSD.CanvasSelectionArchive.container)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.container_;
  _impl_.container_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CanvasSelectionArchive::_internal_mutable_container() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.container_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.container_ = p;
  }
  return _impl_.container_;
}
inline ::TSP::Reference* CanvasSelectionArchive::mutable_container() {
  ::TSP::Reference* _msg = _internal_mutable_container();
  // @@protoc_insertion_point(field_mutable:TSD.CanvasSelectionArchive.container)
  return _msg;
}
inline void CanvasSelectionArchive::set_allocated_container(::TSP::Reference* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.container_);
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(container));
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.container_ = container;
  // @@protoc_insertion_point(field_set_allocated:TSD.CanvasSelectionArchive.container)
}

// -------------------------------------------------------------------

// CommentStorageArchive

// optional string text = 1;
inline bool CommentStorageArchive::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommentStorageArchive::has_text() const {
  return _internal_has_text();
}
inline void CommentStorageArchive::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommentStorageArchive::text() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommentStorageArchive::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSD.CommentStorageArchive.text)
}
inline std::string* CommentStorageArchive::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.text)
  return _s;
}
inline const std::string& CommentStorageArchive::_internal_text() const {
  return _impl_.text_.Get();
}
inline void CommentStorageArchive::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* CommentStorageArchive::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* CommentStorageArchive::release_text() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommentStorageArchive::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.text)
}

// optional .TSP.Date creation_date = 2;
inline bool CommentStorageArchive::_internal_has_creation_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creation_date_ != nullptr);
  return value;
}
inline bool CommentStorageArchive::has_creation_date() const {
  return _internal_has_creation_date();
}
inline const ::TSP::Date& CommentStorageArchive::_internal_creation_date() const {
  const ::TSP::Date* p = _impl_.creation_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Date&>(
      ::TSP::_Date_default_instance_);
}
inline const ::TSP::Date& CommentStorageArchive::creation_date() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.creation_date)
  return _internal_creation_date();
}
inline void CommentStorageArchive::unsafe_arena_set_allocated_creation_date(
    ::TSP::Date* creation_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creation_date_);
  }
  _impl_.creation_date_ = creation_date;
  if (creation_date) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CommentStorageArchive.creation_date)
}
inline ::TSP::Date* CommentStorageArchive::release_creation_date() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Date* temp = _impl_.creation_date_;
  _impl_.creation_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Date* CommentStorageArchive::unsafe_arena_release_creation_date() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.creation_date)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Date* temp = _impl_.creation_date_;
  _impl_.creation_date_ = nullptr;
  return temp;
}
inline ::TSP::Date* CommentStorageArchive::_internal_mutable_creation_date() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.creation_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Date>(GetArenaForAllocation());
    _impl_.creation_date_ = p;
  }
  return _impl_.creation_date_;
}
inline ::TSP::Date* CommentStorageArchive::mutable_creation_date() {
  ::TSP::Date* _msg = _internal_mutable_creation_date();
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.creation_date)
  return _msg;
}
inline void CommentStorageArchive::set_allocated_creation_date(::TSP::Date* creation_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creation_date_);
  }
  if (creation_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_date));
    if (message_arena != submessage_arena) {
      creation_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creation_date, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.creation_date_ = creation_date;
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.creation_date)
}

// optional .TSP.Reference author = 3;
inline bool CommentStorageArchive::_internal_has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_ != nullptr);
  return value;
}
inline bool CommentStorageArchive::has_author() const {
  return _internal_has_author();
}
inline const ::TSP::Reference& CommentStorageArchive::_internal_author() const {
  const ::TSP::Reference* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommentStorageArchive::author() const {
  // @@protoc_insertion_point(field_get:TSD.CommentStorageArchive.author)
  return _internal_author();
}
inline void CommentStorageArchive::unsafe_arena_set_allocated_author(
    ::TSP::Reference* author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = author;
  if (author) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSD.CommentStorageArchive.author)
}
inline ::TSP::Reference* CommentStorageArchive::release_author() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.author_;
  _impl_.author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommentStorageArchive::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:TSD.CommentStorageArchive.author)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommentStorageArchive::_internal_mutable_author() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.author_ = p;
  }
  return _impl_.author_;
}
inline ::TSP::Reference* CommentStorageArchive::mutable_author() {
  ::TSP::Reference* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:TSD.CommentStorageArchive.author)
  return _msg;
}
inline void CommentStorageArchive::set_allocated_author(::TSP::Reference* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.author_);
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author));
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.author_ = author;
  // @@protoc_insertion_point(field_set_allocated:TSD.CommentStorageArchive.author)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSD

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TSD::PointPathSourceArchive_PointPathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::PointPathSourceArchive_PointPathSourceType>() {
  return ::TSD::PointPathSourceArchive_PointPathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ScalarPathSourceArchive_ScalarPathSourceType>() {
  return ::TSD::ScalarPathSourceArchive_ScalarPathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType>() {
  return ::TSD::ConnectionLinePathSourceArchive_ConnectionLinePathSourceType_descriptor();
}
template <> struct is_proto_enum< ::TSD::EditableBezierPathSourceArchive_NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::EditableBezierPathSourceArchive_NodeType>() {
  return ::TSD::EditableBezierPathSourceArchive_NodeType_descriptor();
}
template <> struct is_proto_enum< ::TSD::GradientArchive_GradientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GradientArchive_GradientType>() {
  return ::TSD::GradientArchive_GradientType_descriptor();
}
template <> struct is_proto_enum< ::TSD::ImageFillArchive_ImageFillTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ImageFillArchive_ImageFillTechnique>() {
  return ::TSD::ImageFillArchive_ImageFillTechnique_descriptor();
}
template <> struct is_proto_enum< ::TSD::StrokePatternArchive_StrokePatternType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokePatternArchive_StrokePatternType>() {
  return ::TSD::StrokePatternArchive_StrokePatternType_descriptor();
}
template <> struct is_proto_enum< ::TSD::StrokeArchive_LineCap> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::StrokeArchive_LineCap>() {
  return ::TSD::StrokeArchive_LineCap_descriptor();
}
template <> struct is_proto_enum< ::TSD::ShadowArchive_ShadowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::ShadowArchive_ShadowType>() {
  return ::TSD::ShadowArchive_ShadowType_descriptor();
}
template <> struct is_proto_enum< ::TSD::GuideArchive_GuideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::GuideArchive_GuideType>() {
  return ::TSD::GuideArchive_GuideType_descriptor();
}
template <> struct is_proto_enum< ::TSD::UserDefinedGuideArchive_GuideType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::UserDefinedGuideArchive_GuideType>() {
  return ::TSD::UserDefinedGuideArchive_GuideType_descriptor();
}
template <> struct is_proto_enum< ::TSD::LineJoin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSD::LineJoin>() {
  return ::TSD::LineJoin_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSDArchives_2eproto
