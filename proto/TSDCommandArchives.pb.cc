// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSDCommandArchives.proto

#include "TSDCommandArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSD {
PROTOBUF_CONSTEXPR ConnectionLineConnectCommandArchive::ConnectionLineConnectCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.connection_line_)*/nullptr
  , /*decltype(_impl_.connect_to_)*/nullptr
  , /*decltype(_impl_.connect_from_)*/nullptr
  , /*decltype(_impl_.old_connect_to_)*/nullptr
  , /*decltype(_impl_.old_connect_from_)*/nullptr} {}
struct ConnectionLineConnectCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConnectionLineConnectCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConnectionLineConnectCommandArchiveDefaultTypeInternal() {}
  union {
    ConnectionLineConnectCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConnectionLineConnectCommandArchiveDefaultTypeInternal _ConnectionLineConnectCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR GroupDrawablesCommandArchive::GroupDrawablesCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.group_)*/nullptr} {}
struct GroupDrawablesCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupDrawablesCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupDrawablesCommandArchiveDefaultTypeInternal() {}
  union {
    GroupDrawablesCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupDrawablesCommandArchiveDefaultTypeInternal _GroupDrawablesCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR UngroupGroupCommandArchive::UngroupGroupCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.drawables_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.group_)*/nullptr} {}
struct UngroupGroupCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UngroupGroupCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UngroupGroupCommandArchiveDefaultTypeInternal() {}
  union {
    UngroupGroupCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UngroupGroupCommandArchiveDefaultTypeInternal _UngroupGroupCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainerRemoveChildrenCommandArchive::ContainerRemoveChildrenCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.container_)*/nullptr
  , /*decltype(_impl_.children_indices_)*/nullptr} {}
struct ContainerRemoveChildrenCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerRemoveChildrenCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerRemoveChildrenCommandArchiveDefaultTypeInternal() {}
  union {
    ContainerRemoveChildrenCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerRemoveChildrenCommandArchiveDefaultTypeInternal _ContainerRemoveChildrenCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainerInsertChildrenCommandArchive::ContainerInsertChildrenCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.container_)*/nullptr
  , /*decltype(_impl_.index_)*/uint64_t{0u}} {}
struct ContainerInsertChildrenCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerInsertChildrenCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerInsertChildrenCommandArchiveDefaultTypeInternal() {}
  union {
    ContainerInsertChildrenCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerInsertChildrenCommandArchiveDefaultTypeInternal _ContainerInsertChildrenCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ContainerReorderChildrenCommandArchive::ContainerReorderChildrenCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.container_)*/nullptr
  , /*decltype(_impl_.children_indices_)*/nullptr} {}
struct ContainerReorderChildrenCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContainerReorderChildrenCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContainerReorderChildrenCommandArchiveDefaultTypeInternal() {}
  union {
    ContainerReorderChildrenCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContainerReorderChildrenCommandArchiveDefaultTypeInternal _ContainerReorderChildrenCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InfoGeometryCommandArchive::InfoGeometryCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.newgeometry_)*/nullptr
  , /*decltype(_impl_.oldgeometry_)*/nullptr
  , /*decltype(_impl_.shouldclearobjectplaceholderflag_)*/false
  , /*decltype(_impl_.didmatchobjectplaceholdergeometry_)*/false} {}
struct InfoGeometryCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoGeometryCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoGeometryCommandArchiveDefaultTypeInternal() {}
  union {
    InfoGeometryCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoGeometryCommandArchiveDefaultTypeInternal _InfoGeometryCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawablePathSourceCommandArchive::DrawablePathSourceCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.oldpathsource_)*/nullptr
  , /*decltype(_impl_.newpathsource_)*/nullptr} {}
struct DrawablePathSourceCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawablePathSourceCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawablePathSourceCommandArchiveDefaultTypeInternal() {}
  union {
    DrawablePathSourceCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawablePathSourceCommandArchiveDefaultTypeInternal _DrawablePathSourceCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InstantAlphaCommandArchive::InstantAlphaCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.image_)*/nullptr
  , /*decltype(_impl_.oldpath_)*/nullptr
  , /*decltype(_impl_.newpath_)*/nullptr} {}
struct InstantAlphaCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstantAlphaCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstantAlphaCommandArchiveDefaultTypeInternal() {}
  union {
    InstantAlphaCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstantAlphaCommandArchiveDefaultTypeInternal _InstantAlphaCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableShadowCommandArchive::DrawableShadowCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.oldshadow_)*/nullptr
  , /*decltype(_impl_.newshadow_)*/nullptr} {}
struct DrawableShadowCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableShadowCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableShadowCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableShadowCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableShadowCommandArchiveDefaultTypeInternal _DrawableShadowCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableApplyThemeCommandArchive::DrawableApplyThemeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr} {}
struct DrawableApplyThemeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableApplyThemeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableApplyThemeCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableApplyThemeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableApplyThemeCommandArchiveDefaultTypeInternal _DrawableApplyThemeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyledInfoSetStyleCommandArchive::StyledInfoSetStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr} {}
struct StyledInfoSetStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyledInfoSetStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyledInfoSetStyleCommandArchiveDefaultTypeInternal() {}
  union {
    StyledInfoSetStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyledInfoSetStyleCommandArchiveDefaultTypeInternal _StyledInfoSetStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapePathSourceFlipCommandArchive::ShapePathSourceFlipCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.newhorizontalflip_)*/false
  , /*decltype(_impl_.newverticalflip_)*/false
  , /*decltype(_impl_.oldhorizontalflip_)*/false
  , /*decltype(_impl_.oldverticalflip_)*/false} {}
struct ShapePathSourceFlipCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapePathSourceFlipCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapePathSourceFlipCommandArchiveDefaultTypeInternal() {}
  union {
    ShapePathSourceFlipCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapePathSourceFlipCommandArchiveDefaultTypeInternal _ShapePathSourceFlipCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.shape_properties_)*/nullptr} {}
struct ShapeStyleSetValueCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeStyleSetValueCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeStyleSetValueCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeStyleSetValueCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeStyleSetValueCommandArchiveDefaultTypeInternal _ShapeStyleSetValueCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.stylepreset_)*/nullptr
  , /*decltype(_impl_.colorpreset_)*/nullptr
  , /*decltype(_impl_.fillpreset_)*/nullptr
  , /*decltype(_impl_.shadowpreset_)*/nullptr} {}
struct ShapeApplyPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeApplyPresetCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeApplyPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeApplyPresetCommandArchiveDefaultTypeInternal _ShapeApplyPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeSetLineEndCommandArchive::ShapeSetLineEndCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.shape_)*/nullptr
  , /*decltype(_impl_.line_end_)*/nullptr
  , /*decltype(_impl_.is_head_line_end_)*/false} {}
struct ShapeSetLineEndCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeSetLineEndCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeSetLineEndCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeSetLineEndCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeSetLineEndCommandArchiveDefaultTypeInternal _ShapeSetLineEndCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MovieSetValueCommandArchive_PropertyValue::MovieSetValueCommandArchive_PropertyValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.posterimagedata_)*/nullptr
  , /*decltype(_impl_.media_)*/nullptr
  , /*decltype(_impl_.importedauxiliarymedia_)*/nullptr
  , /*decltype(_impl_.starttime_)*/0
  , /*decltype(_impl_.endtime_)*/0
  , /*decltype(_impl_.postertime_)*/0
  , /*decltype(_impl_.autoplay_)*/false
  , /*decltype(_impl_.loopoption_)*/0
  , /*decltype(_impl_.volume_)*/0} {}
struct MovieSetValueCommandArchive_PropertyValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieSetValueCommandArchive_PropertyValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieSetValueCommandArchive_PropertyValueDefaultTypeInternal() {}
  union {
    MovieSetValueCommandArchive_PropertyValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieSetValueCommandArchive_PropertyValueDefaultTypeInternal _MovieSetValueCommandArchive_PropertyValue_default_instance_;
PROTOBUF_CONSTEXPR MovieSetValueCommandArchive::MovieSetValueCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.deprecated_property_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.movie_)*/nullptr
  , /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.property_)*/0} {}
struct MovieSetValueCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MovieSetValueCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MovieSetValueCommandArchiveDefaultTypeInternal() {}
  union {
    MovieSetValueCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MovieSetValueCommandArchiveDefaultTypeInternal _MovieSetValueCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaStyleSetValueCommandArchive::MediaStyleSetValueCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.media_properties_)*/nullptr} {}
struct MediaStyleSetValueCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaStyleSetValueCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaStyleSetValueCommandArchiveDefaultTypeInternal() {}
  union {
    MediaStyleSetValueCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaStyleSetValueCommandArchiveDefaultTypeInternal _MediaStyleSetValueCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageMediaCommandArchive::ImageMediaCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.database_newimagedata_)*/nullptr
  , /*decltype(_impl_.database_oldimagedata_)*/nullptr
  , /*decltype(_impl_.database_oldoriginalimagedata_)*/nullptr
  , /*decltype(_impl_.oldnaturalsize_)*/nullptr
  , /*decltype(_impl_.database_neworiginalimagedata_)*/nullptr
  , /*decltype(_impl_.newimagedata_)*/nullptr
  , /*decltype(_impl_.oldimagedata_)*/nullptr
  , /*decltype(_impl_.oldoriginalimagedata_)*/nullptr
  , /*decltype(_impl_.neworiginalimagedata_)*/nullptr
  , /*decltype(_impl_.oldimageadjustments_)*/nullptr
  , /*decltype(_impl_.oldadjustedimagedata_)*/nullptr
  , /*decltype(_impl_.oldenhancedimagedata_)*/nullptr} {}
struct ImageMediaCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageMediaCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageMediaCommandArchiveDefaultTypeInternal() {}
  union {
    ImageMediaCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageMediaCommandArchiveDefaultTypeInternal _ImageMediaCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaOriginalSizeCommandArchive::MediaOriginalSizeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.neworiginalsize_)*/nullptr
  , /*decltype(_impl_.oldoriginalsize_)*/nullptr} {}
struct MediaOriginalSizeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaOriginalSizeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaOriginalSizeCommandArchiveDefaultTypeInternal() {}
  union {
    MediaOriginalSizeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaOriginalSizeCommandArchiveDefaultTypeInternal _MediaOriginalSizeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageMaskCommandArchive::ImageMaskCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.newmaskinfo_)*/nullptr
  , /*decltype(_impl_.oldmaskinfo_)*/nullptr} {}
struct ImageMaskCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageMaskCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageMaskCommandArchiveDefaultTypeInternal() {}
  union {
    ImageMaskCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageMaskCommandArchiveDefaultTypeInternal _ImageMaskCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaApplyPresetCommandArchive::MediaApplyPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.stylepreset_)*/nullptr
  , /*decltype(_impl_.shadowpreset_)*/nullptr} {}
struct MediaApplyPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaApplyPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaApplyPresetCommandArchiveDefaultTypeInternal() {}
  union {
    MediaApplyPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaApplyPresetCommandArchiveDefaultTypeInternal _MediaApplyPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageAdjustmentsCommandArchive::ImageAdjustmentsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_image_adjustments_)*/nullptr
  , /*decltype(_impl_.new_image_adjustments_)*/nullptr
  , /*decltype(_impl_.adjustedimagedata_)*/nullptr
  , /*decltype(_impl_.replacedadjustedimagedata_)*/nullptr
  , /*decltype(_impl_.enhancedimagedata_)*/nullptr
  , /*decltype(_impl_.replacedenhancedimagedata_)*/nullptr} {}
struct ImageAdjustmentsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageAdjustmentsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageAdjustmentsCommandArchiveDefaultTypeInternal() {}
  union {
    ImageAdjustmentsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageAdjustmentsCommandArchiveDefaultTypeInternal _ImageAdjustmentsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MediaFlagsCommandArchive::MediaFlagsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.flags_)*/0u} {}
struct MediaFlagsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MediaFlagsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MediaFlagsCommandArchiveDefaultTypeInternal() {}
  union {
    MediaFlagsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MediaFlagsCommandArchiveDefaultTypeInternal _MediaFlagsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawablesCommandGroupArchive::DrawablesCommandGroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.obsolete_selection_)*/nullptr
  , /*decltype(_impl_.modelforselection_)*/nullptr
  , /*decltype(_impl_.archivedselection_)*/nullptr
  , /*decltype(_impl_.fordrag_)*/false
  , /*decltype(_impl_.type_)*/1} {}
struct DrawablesCommandGroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawablesCommandGroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawablesCommandGroupArchiveDefaultTypeInternal() {}
  union {
    DrawablesCommandGroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawablesCommandGroupArchiveDefaultTypeInternal _DrawablesCommandGroupArchive_default_instance_;
PROTOBUF_CONSTEXPR ExteriorTextWrapCommandArchive_InfoAndWrap::ExteriorTextWrapCommandArchive_InfoAndWrap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.exterior_text_wrap_)*/nullptr} {}
struct ExteriorTextWrapCommandArchive_InfoAndWrapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExteriorTextWrapCommandArchive_InfoAndWrapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExteriorTextWrapCommandArchive_InfoAndWrapDefaultTypeInternal() {}
  union {
    ExteriorTextWrapCommandArchive_InfoAndWrap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExteriorTextWrapCommandArchive_InfoAndWrapDefaultTypeInternal _ExteriorTextWrapCommandArchive_InfoAndWrap_default_instance_;
PROTOBUF_CONSTEXPR ExteriorTextWrapCommandArchive::ExteriorTextWrapCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.info_and_wrap_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ExteriorTextWrapCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExteriorTextWrapCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExteriorTextWrapCommandArchiveDefaultTypeInternal() {}
  union {
    ExteriorTextWrapCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExteriorTextWrapCommandArchiveDefaultTypeInternal _ExteriorTextWrapCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableHyperlinkCommandArchive::DrawableHyperlinkCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.oldhyperlink_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.newhyperlink_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct DrawableHyperlinkCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableHyperlinkCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableHyperlinkCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableHyperlinkCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableHyperlinkCommandArchiveDefaultTypeInternal _DrawableHyperlinkCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSelectionBehaviorArchive::CommandSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.model_for_selection_)*/nullptr
  , /*decltype(_impl_.archived_selection_)*/nullptr
  , /*decltype(_impl_.archived_new_selection_)*/nullptr
  , /*decltype(_impl_.type_)*/1} {}
struct CommandSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    CommandSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSelectionBehaviorArchiveDefaultTypeInternal _CommandSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR ImageReplaceCommandArchive::ImageReplaceCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ImageReplaceCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageReplaceCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageReplaceCommandArchiveDefaultTypeInternal() {}
  union {
    ImageReplaceCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageReplaceCommandArchiveDefaultTypeInternal _ImageReplaceCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableLockCommandArchive::DrawableLockCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.lock_)*/false} {}
struct DrawableLockCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableLockCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableLockCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableLockCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableLockCommandArchiveDefaultTypeInternal _DrawableLockCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableInfoCommentCommandArchive::DrawableInfoCommentCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.old_comment_)*/nullptr
  , /*decltype(_impl_.new_comment_)*/nullptr} {}
struct DrawableInfoCommentCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableInfoCommentCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableInfoCommentCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableInfoCommentCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableInfoCommentCommandArchiveDefaultTypeInternal _DrawableInfoCommentCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CommentStorageApplyCommandArchive::CommentStorageApplyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.comment_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_comment_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.comment_storage_)*/nullptr} {}
struct CommentStorageApplyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommentStorageApplyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommentStorageApplyCommandArchiveDefaultTypeInternal() {}
  union {
    CommentStorageApplyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommentStorageApplyCommandArchiveDefaultTypeInternal _CommentStorageApplyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR GuideCommandArchive::GuideCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.old_guide_)*/nullptr
  , /*decltype(_impl_.new_guide_)*/nullptr
  , /*decltype(_impl_.mode_)*/1} {}
struct GuideCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuideCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuideCommandArchiveDefaultTypeInternal() {}
  union {
    GuideCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuideCommandArchiveDefaultTypeInternal _GuideCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableAspectRatioLockedCommandArchive::DrawableAspectRatioLockedCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.aspect_ratio_locked_)*/false} {}
struct DrawableAspectRatioLockedCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableAspectRatioLockedCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableAspectRatioLockedCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableAspectRatioLockedCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableAspectRatioLockedCommandArchiveDefaultTypeInternal _DrawableAspectRatioLockedCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR DrawableAccessibilityDescriptionCommandArchive::DrawableAccessibilityDescriptionCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.accessibility_description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.info_)*/nullptr} {}
struct DrawableAccessibilityDescriptionCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableAccessibilityDescriptionCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableAccessibilityDescriptionCommandArchiveDefaultTypeInternal() {}
  union {
    DrawableAccessibilityDescriptionCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableAccessibilityDescriptionCommandArchiveDefaultTypeInternal _DrawableAccessibilityDescriptionCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR PasteStyleCommandArchive::PasteStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.dest_info_)*/nullptr
  , /*decltype(_impl_.shape_style_)*/nullptr} {}
struct PasteStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PasteStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PasteStyleCommandArchiveDefaultTypeInternal() {}
  union {
    PasteStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasteStyleCommandArchiveDefaultTypeInternal _PasteStyleCommandArchive_default_instance_;
}  // namespace TSD
static ::_pb::Metadata file_level_metadata_TSDCommandArchives_2eproto[38];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSDCommandArchives_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSDCommandArchives_2eproto = nullptr;

const uint32_t TableStruct_TSDCommandArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.connection_line_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.connect_to_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.connect_from_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.old_connect_to_),
  PROTOBUF_FIELD_OFFSET(::TSD::ConnectionLineConnectCommandArchive, _impl_.old_connect_from_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::GroupDrawablesCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupDrawablesCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GroupDrawablesCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupDrawablesCommandArchive, _impl_.drawables_),
  PROTOBUF_FIELD_OFFSET(::TSD::GroupDrawablesCommandArchive, _impl_.group_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::UngroupGroupCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::UngroupGroupCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::UngroupGroupCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::UngroupGroupCommandArchive, _impl_.drawables_),
  PROTOBUF_FIELD_OFFSET(::TSD::UngroupGroupCommandArchive, _impl_.group_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _impl_.container_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerRemoveChildrenCommandArchive, _impl_.children_indices_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _impl_.container_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerInsertChildrenCommandArchive, _impl_.index_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _impl_.container_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TSD::ContainerReorderChildrenCommandArchive, _impl_.children_indices_),
  0,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.newgeometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.oldgeometry_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.shouldclearobjectplaceholderflag_),
  PROTOBUF_FIELD_OFFSET(::TSD::InfoGeometryCommandArchive, _impl_.didmatchobjectplaceholdergeometry_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _impl_.oldpathsource_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablePathSourceCommandArchive, _impl_.newpathsource_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _impl_.image_),
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _impl_.oldpath_),
  PROTOBUF_FIELD_OFFSET(::TSD::InstantAlphaCommandArchive, _impl_.newpath_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _impl_.oldshadow_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableShadowCommandArchive, _impl_.newshadow_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableApplyThemeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableApplyThemeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableApplyThemeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableApplyThemeCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableApplyThemeCommandArchive, _impl_.style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::StyledInfoSetStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::StyledInfoSetStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::StyledInfoSetStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::StyledInfoSetStyleCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::StyledInfoSetStyleCommandArchive, _impl_.style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.newhorizontalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.newverticalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.oldhorizontalflip_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapePathSourceFlipCommandArchive, _impl_.oldverticalflip_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleSetValueCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleSetValueCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleSetValueCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeStyleSetValueCommandArchive, _impl_.shape_properties_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_.stylepreset_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_.colorpreset_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_.fillpreset_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeApplyPresetCommandArchive, _impl_.shadowpreset_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _impl_.shape_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _impl_.line_end_),
  PROTOBUF_FIELD_OFFSET(::TSD::ShapeSetLineEndCommandArchive, _impl_.is_head_line_end_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.endtime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.postertime_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.posterimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.autoplay_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.loopoption_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.media_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive_PropertyValue, _impl_.importedauxiliarymedia_),
  3,
  4,
  5,
  0,
  6,
  7,
  8,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_.movie_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_.deprecated_property_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_.property_),
  PROTOBUF_FIELD_OFFSET(::TSD::MovieSetValueCommandArchive, _impl_.value_),
  1,
  2,
  0,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleSetValueCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleSetValueCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleSetValueCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaStyleSetValueCommandArchive, _impl_.media_properties_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.newimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldoriginalimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldnaturalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.neworiginalimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldimageadjustments_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldadjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.oldenhancedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.database_newimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.database_oldimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.database_oldoriginalimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMediaCommandArchive, _impl_.database_neworiginalimagedata_),
  0,
  1,
  7,
  8,
  9,
  5,
  10,
  11,
  12,
  13,
  2,
  3,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _impl_.neworiginalsize_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaOriginalSizeCommandArchive, _impl_.oldoriginalsize_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _impl_.newmaskinfo_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageMaskCommandArchive, _impl_.oldmaskinfo_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaApplyPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaApplyPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaApplyPresetCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaApplyPresetCommandArchive, _impl_.stylepreset_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaApplyPresetCommandArchive, _impl_.shadowpreset_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.old_image_adjustments_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.new_image_adjustments_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.adjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.replacedadjustedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.enhancedimagedata_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageAdjustmentsCommandArchive, _impl_.replacedenhancedimagedata_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TSD::MediaFlagsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaFlagsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::MediaFlagsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaFlagsCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::MediaFlagsCommandArchive, _impl_.flags_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.obsolete_selection_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.modelforselection_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.fordrag_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawablesCommandGroupArchive, _impl_.archivedselection_),
  0,
  1,
  2,
  5,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap, _impl_.exterior_text_wrap_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::ExteriorTextWrapCommandArchive, _impl_.info_and_wrap_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _impl_.oldhyperlink_url_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableHyperlinkCommandArchive, _impl_.newhyperlink_url_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _impl_.model_for_selection_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _impl_.archived_selection_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommandSelectionBehaviorArchive, _impl_.archived_new_selection_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::ImageReplaceCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::ImageReplaceCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::ImageReplaceCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableLockCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableLockCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableLockCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableLockCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableLockCommandArchive, _impl_.lock_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _impl_.old_comment_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableInfoCommentCommandArchive, _impl_.new_comment_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _impl_.comment_storage_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _impl_.comment_string_),
  PROTOBUF_FIELD_OFFSET(::TSD::CommentStorageApplyCommandArchive, _impl_.old_comment_string_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_.old_guide_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_.new_guide_),
  PROTOBUF_FIELD_OFFSET(::TSD::GuideCommandArchive, _impl_.mode_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAspectRatioLockedCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAspectRatioLockedCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAspectRatioLockedCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAspectRatioLockedCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAspectRatioLockedCommandArchive, _impl_.aspect_ratio_locked_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAccessibilityDescriptionCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAccessibilityDescriptionCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAccessibilityDescriptionCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAccessibilityDescriptionCommandArchive, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::TSD::DrawableAccessibilityDescriptionCommandArchive, _impl_.accessibility_description_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TSD::PasteStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSD::PasteStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSD::PasteStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSD::PasteStyleCommandArchive, _impl_.dest_info_),
  PROTOBUF_FIELD_OFFSET(::TSD::PasteStyleCommandArchive, _impl_.shape_style_),
  0,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 12, -1, sizeof(::TSD::ConnectionLineConnectCommandArchive)},
  { 18, 27, -1, sizeof(::TSD::GroupDrawablesCommandArchive)},
  { 30, 39, -1, sizeof(::TSD::UngroupGroupCommandArchive)},
  { 42, 52, -1, sizeof(::TSD::ContainerRemoveChildrenCommandArchive)},
  { 56, 66, -1, sizeof(::TSD::ContainerInsertChildrenCommandArchive)},
  { 70, 80, -1, sizeof(::TSD::ContainerReorderChildrenCommandArchive)},
  { 84, 96, -1, sizeof(::TSD::InfoGeometryCommandArchive)},
  { 102, 112, -1, sizeof(::TSD::DrawablePathSourceCommandArchive)},
  { 116, 126, -1, sizeof(::TSD::InstantAlphaCommandArchive)},
  { 130, 140, -1, sizeof(::TSD::DrawableShadowCommandArchive)},
  { 144, 153, -1, sizeof(::TSD::DrawableApplyThemeCommandArchive)},
  { 156, 165, -1, sizeof(::TSD::StyledInfoSetStyleCommandArchive)},
  { 168, 180, -1, sizeof(::TSD::ShapePathSourceFlipCommandArchive)},
  { 186, 194, -1, sizeof(::TSD::ShapeStyleSetValueCommandArchive)},
  { 196, 207, -1, sizeof(::TSD::ShapeApplyPresetCommandArchive)},
  { 212, 222, -1, sizeof(::TSD::ShapeSetLineEndCommandArchive)},
  { 226, 241, -1, sizeof(::TSD::MovieSetValueCommandArchive_PropertyValue)},
  { 250, 261, -1, sizeof(::TSD::MovieSetValueCommandArchive)},
  { 266, 274, -1, sizeof(::TSD::MediaStyleSetValueCommandArchive)},
  { 276, 296, -1, sizeof(::TSD::ImageMediaCommandArchive)},
  { 310, 320, -1, sizeof(::TSD::MediaOriginalSizeCommandArchive)},
  { 324, 334, -1, sizeof(::TSD::ImageMaskCommandArchive)},
  { 338, 347, -1, sizeof(::TSD::MediaApplyPresetCommandArchive)},
  { 350, 363, -1, sizeof(::TSD::ImageAdjustmentsCommandArchive)},
  { 370, 379, -1, sizeof(::TSD::MediaFlagsCommandArchive)},
  { 382, 394, -1, sizeof(::TSD::DrawablesCommandGroupArchive)},
  { 400, 408, -1, sizeof(::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap)},
  { 410, 418, -1, sizeof(::TSD::ExteriorTextWrapCommandArchive)},
  { 420, 430, -1, sizeof(::TSD::DrawableHyperlinkCommandArchive)},
  { 434, 444, -1, sizeof(::TSD::CommandSelectionBehaviorArchive)},
  { 448, 455, -1, sizeof(::TSD::ImageReplaceCommandArchive)},
  { 456, 465, -1, sizeof(::TSD::DrawableLockCommandArchive)},
  { 468, 478, -1, sizeof(::TSD::DrawableInfoCommentCommandArchive)},
  { 482, 492, -1, sizeof(::TSD::CommentStorageApplyCommandArchive)},
  { 496, 507, -1, sizeof(::TSD::GuideCommandArchive)},
  { 512, 521, -1, sizeof(::TSD::DrawableAspectRatioLockedCommandArchive)},
  { 524, 533, -1, sizeof(::TSD::DrawableAccessibilityDescriptionCommandArchive)},
  { 536, 545, -1, sizeof(::TSD::PasteStyleCommandArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSD::_ConnectionLineConnectCommandArchive_default_instance_._instance,
  &::TSD::_GroupDrawablesCommandArchive_default_instance_._instance,
  &::TSD::_UngroupGroupCommandArchive_default_instance_._instance,
  &::TSD::_ContainerRemoveChildrenCommandArchive_default_instance_._instance,
  &::TSD::_ContainerInsertChildrenCommandArchive_default_instance_._instance,
  &::TSD::_ContainerReorderChildrenCommandArchive_default_instance_._instance,
  &::TSD::_InfoGeometryCommandArchive_default_instance_._instance,
  &::TSD::_DrawablePathSourceCommandArchive_default_instance_._instance,
  &::TSD::_InstantAlphaCommandArchive_default_instance_._instance,
  &::TSD::_DrawableShadowCommandArchive_default_instance_._instance,
  &::TSD::_DrawableApplyThemeCommandArchive_default_instance_._instance,
  &::TSD::_StyledInfoSetStyleCommandArchive_default_instance_._instance,
  &::TSD::_ShapePathSourceFlipCommandArchive_default_instance_._instance,
  &::TSD::_ShapeStyleSetValueCommandArchive_default_instance_._instance,
  &::TSD::_ShapeApplyPresetCommandArchive_default_instance_._instance,
  &::TSD::_ShapeSetLineEndCommandArchive_default_instance_._instance,
  &::TSD::_MovieSetValueCommandArchive_PropertyValue_default_instance_._instance,
  &::TSD::_MovieSetValueCommandArchive_default_instance_._instance,
  &::TSD::_MediaStyleSetValueCommandArchive_default_instance_._instance,
  &::TSD::_ImageMediaCommandArchive_default_instance_._instance,
  &::TSD::_MediaOriginalSizeCommandArchive_default_instance_._instance,
  &::TSD::_ImageMaskCommandArchive_default_instance_._instance,
  &::TSD::_MediaApplyPresetCommandArchive_default_instance_._instance,
  &::TSD::_ImageAdjustmentsCommandArchive_default_instance_._instance,
  &::TSD::_MediaFlagsCommandArchive_default_instance_._instance,
  &::TSD::_DrawablesCommandGroupArchive_default_instance_._instance,
  &::TSD::_ExteriorTextWrapCommandArchive_InfoAndWrap_default_instance_._instance,
  &::TSD::_ExteriorTextWrapCommandArchive_default_instance_._instance,
  &::TSD::_DrawableHyperlinkCommandArchive_default_instance_._instance,
  &::TSD::_CommandSelectionBehaviorArchive_default_instance_._instance,
  &::TSD::_ImageReplaceCommandArchive_default_instance_._instance,
  &::TSD::_DrawableLockCommandArchive_default_instance_._instance,
  &::TSD::_DrawableInfoCommentCommandArchive_default_instance_._instance,
  &::TSD::_CommentStorageApplyCommandArchive_default_instance_._instance,
  &::TSD::_GuideCommandArchive_default_instance_._instance,
  &::TSD::_DrawableAspectRatioLockedCommandArchive_default_instance_._instance,
  &::TSD::_DrawableAccessibilityDescriptionCommandArchive_default_instance_._instance,
  &::TSD::_PasteStyleCommandArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSDCommandArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030TSDCommandArchives.proto\022\003TSD\032\021TSPMess"
  "ages.proto\032\021TSKArchives.proto\032\021TSSArchiv"
  "es.proto\032\021TSDArchives.proto\"\216\002\n#Connecti"
  "onLineConnectCommandArchive\022\"\n\005super\030\001 \002"
  "(\0132\023.TSK.CommandArchive\022\'\n\017connection_li"
  "ne\030\002 \002(\0132\016.TSP.Reference\022\"\n\nconnect_to\030\003"
  " \001(\0132\016.TSP.Reference\022$\n\014connect_from\030\004 \001"
  "(\0132\016.TSP.Reference\022&\n\016old_connect_to\030\005 \001"
  "(\0132\016.TSP.Reference\022(\n\020old_connect_from\030\006"
  " \001(\0132\016.TSP.Reference\"\204\001\n\034GroupDrawablesC"
  "ommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Comma"
  "ndArchive\022!\n\tdrawables\030\002 \003(\0132\016.TSP.Refer"
  "ence\022\035\n\005group\030\003 \001(\0132\016.TSP.Reference\"\202\001\n\032"
  "UngroupGroupCommandArchive\022\"\n\005super\030\001 \002("
  "\0132\023.TSK.CommandArchive\022!\n\tdrawables\030\002 \003("
  "\0132\016.TSP.Reference\022\035\n\005group\030\003 \001(\0132\016.TSP.R"
  "eference\"\271\001\n%ContainerRemoveChildrenComm"
  "andArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandA"
  "rchive\022!\n\tcontainer\030\002 \001(\0132\016.TSP.Referenc"
  "e\022 \n\010children\030\003 \003(\0132\016.TSP.Reference\022\'\n\020c"
  "hildren_indices\030\004 \001(\0132\r.TSP.IndexSet\"\237\001\n"
  "%ContainerInsertChildrenCommandArchive\022\""
  "\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022!\n\tco"
  "ntainer\030\002 \001(\0132\016.TSP.Reference\022 \n\010childre"
  "n\030\003 \003(\0132\016.TSP.Reference\022\r\n\005index\030\004 \001(\004\"\272"
  "\001\n&ContainerReorderChildrenCommandArchiv"
  "e\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022!\n"
  "\tcontainer\030\002 \001(\0132\016.TSP.Reference\022 \n\010chil"
  "dren\030\003 \003(\0132\016.TSP.Reference\022\'\n\020children_i"
  "ndices\030\004 \001(\0132\r.TSP.IndexSet\"\211\002\n\032InfoGeom"
  "etryCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK."
  "CommandArchive\022\034\n\004info\030\002 \001(\0132\016.TSP.Refer"
  "ence\022)\n\013newGeometry\030\003 \001(\0132\024.TSD.Geometry"
  "Archive\022)\n\013oldGeometry\030\004 \001(\0132\024.TSD.Geome"
  "tryArchive\022(\n shouldClearObjectPlacehold"
  "erFlag\030\005 \001(\010\022)\n!didMatchObjectPlaceholde"
  "rGeometry\030\006 \001(\010\"\302\001\n DrawablePathSourceCo"
  "mmandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Comman"
  "dArchive\022\034\n\004info\030\002 \001(\0132\016.TSP.Reference\022-"
  "\n\roldpathsource\030\003 \001(\0132\026.TSD.PathSourceAr"
  "chive\022-\n\rnewpathsource\030\004 \001(\0132\026.TSD.PathS"
  "ourceArchive\"\227\001\n\032InstantAlphaCommandArch"
  "ive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022"
  "\035\n\005image\030\002 \001(\0132\016.TSP.Reference\022\032\n\007oldpat"
  "h\030\003 \001(\0132\t.TSP.Path\022\032\n\007newpath\030\004 \001(\0132\t.TS"
  "P.Path\"\256\001\n\034DrawableShadowCommandArchive\022"
  "\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\034\n\004i"
  "nfo\030\002 \001(\0132\016.TSP.Reference\022%\n\toldshadow\030\003"
  " \001(\0132\022.TSD.ShadowArchive\022%\n\tnewshadow\030\004 "
  "\001(\0132\022.TSD.ShadowArchive\"\222\001\n DrawableAppl"
  "yThemeCommandArchive\0221\n\005super\030\001 \002(\0132\".TS"
  "S.ApplyThemeChildCommandArchive\022\034\n\004info\030"
  "\002 \001(\0132\016.TSP.Reference\022\035\n\005style\030\003 \001(\0132\016.T"
  "SP.Reference\"\203\001\n StyledInfoSetStyleComma"
  "ndArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandAr"
  "chive\022\034\n\004info\030\002 \001(\0132\016.TSP.Reference\022\035\n\005s"
  "tyle\030\003 \001(\0132\016.TSP.Reference\"\315\001\n!ShapePath"
  "SourceFlipCommandArchive\022\"\n\005super\030\001 \002(\0132"
  "\023.TSK.CommandArchive\022\034\n\004info\030\002 \001(\0132\016.TSP"
  ".Reference\022\031\n\021newHorizontalFlip\030\003 \001(\010\022\027\n"
  "\017newVerticalFlip\030\004 \001(\010\022\031\n\021oldHorizontalF"
  "lip\030\005 \001(\010\022\027\n\017oldVerticalFlip\030\006 \001(\010\"\224\001\n S"
  "hapeStyleSetValueCommandArchive\0224\n\005super"
  "\030\001 \002(\0132%.TSD.StyledInfoSetStyleCommandAr"
  "chive\022:\n\020shape_properties\030\004 \001(\0132 .TSD.Sh"
  "apeStylePropertiesArchive\"\354\001\n\036ShapeApply"
  "PresetCommandArchive\0224\n\005super\030\001 \002(\0132%.TS"
  "D.StyledInfoSetStyleCommandArchive\022#\n\013st"
  "ylepreset\030\n \001(\0132\016.TSP.Reference\022\037\n\013color"
  "preset\030\013 \001(\0132\n.TSP.Color\022$\n\nfillpreset\030\014"
  " \001(\0132\020.TSD.FillArchive\022(\n\014shadowpreset\030\r"
  " \001(\0132\022.TSD.ShadowArchive\"\243\001\n\035ShapeSetLin"
  "eEndCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK."
  "CommandArchive\022\035\n\005shape\030\002 \001(\0132\016.TSP.Refe"
  "rence\022%\n\010line_end\030\003 \001(\0132\023.TSD.LineEndArc"
  "hive\022\030\n\020is_head_line_end\030\004 \001(\010\"\265\004\n\033Movie"
  "SetValueCommandArchive\022\"\n\005super\030\001 \002(\0132\023."
  "TSK.CommandArchive\022\035\n\005movie\030\002 \001(\0132\016.TSP."
  "Reference\022\033\n\023deprecated_property\030\003 \001(\t\022\020"
  "\n\010property\030\004 \001(\005\022=\n\005value\030\005 \001(\0132..TSD.Mo"
  "vieSetValueCommandArchive.PropertyValue\032"
  "\256\002\n\rPropertyValue\022\021\n\tstarttime\030\001 \001(\001\022\017\n\007"
  "endtime\030\002 \001(\001\022\022\n\npostertime\030\003 \001(\001\022+\n\017pos"
  "terimagedata\030\004 \001(\0132\022.TSP.DataReference\022\020"
  "\n\010autoplay\030\005 \001(\010\022\?\n\nloopOption\030\006 \001(\0162+.T"
  "SD.MovieSetValueCommandArchive.LoopOptio"
  "n\022\016\n\006volume\030\007 \001(\002\022!\n\005media\030\010 \001(\0132\022.TSP.D"
  "ataReference\0222\n\026importedauxiliarymedia\030\t"
  " \001(\0132\022.TSP.DataReference\"4\n\nLoopOption\022\010"
  "\n\004None\020\000\022\n\n\006Repeat\020\001\022\020\n\014BackAndForth\020\002\"\224"
  "\001\n MediaStyleSetValueCommandArchive\0224\n\005s"
  "uper\030\001 \002(\0132%.TSD.StyledInfoSetStyleComma"
  "ndArchive\022:\n\020media_properties\030\004 \001(\0132 .TS"
  "D.MediaStylePropertiesArchive\"\242\005\n\030ImageM"
  "ediaCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK."
  "CommandArchive\022\034\n\004info\030\002 \001(\0132\016.TSP.Refer"
  "ence\022(\n\014newImageData\030\010 \001(\0132\022.TSP.DataRef"
  "erence\022(\n\014oldImageData\030\t \001(\0132\022.TSP.DataR"
  "eference\0220\n\024oldOriginalImageData\030\n \001(\0132\022"
  ".TSP.DataReference\022!\n\016oldNaturalSize\030\006 \001"
  "(\0132\t.TSP.Size\0220\n\024newOriginalImageData\030\013 "
  "\001(\0132\022.TSP.DataReference\0229\n\023oldImageAdjus"
  "tments\030\014 \001(\0132\034.TSD.ImageAdjustmentsArchi"
  "ve\0220\n\024oldAdjustedImageData\030\r \001(\0132\022.TSP.D"
  "ataReference\0220\n\024oldEnhancedImageData\030\016 \001"
  "(\0132\022.TSP.DataReference\022-\n\025database_newIm"
  "ageData\030\003 \001(\0132\016.TSP.Reference\022-\n\025databas"
  "e_oldImageData\030\004 \001(\0132\016.TSP.Reference\0225\n\035"
  "database_oldOriginalImageData\030\005 \001(\0132\016.TS"
  "P.Reference\0225\n\035database_newOriginalImage"
  "Data\030\007 \001(\0132\016.TSP.Reference\"\253\001\n\037MediaOrig"
  "inalSizeCommandArchive\022\"\n\005super\030\001 \002(\0132\023."
  "TSK.CommandArchive\022\034\n\004info\030\002 \001(\0132\016.TSP.R"
  "eference\022\"\n\017newOriginalSize\030\003 \001(\0132\t.TSP."
  "Size\022\"\n\017oldOriginalSize\030\004 \001(\0132\t.TSP.Size"
  "\"\245\001\n\027ImageMaskCommandArchive\022\"\n\005super\030\001 "
  "\002(\0132\023.TSK.CommandArchive\022\034\n\004info\030\002 \001(\0132\016"
  ".TSP.Reference\022#\n\013newMaskInfo\030\003 \001(\0132\016.TS"
  "P.Reference\022#\n\013oldMaskInfo\030\004 \001(\0132\016.TSP.R"
  "eference\"\245\001\n\036MediaApplyPresetCommandArch"
  "ive\0224\n\005super\030\001 \002(\0132%.TSD.StyledInfoSetSt"
  "yleCommandArchive\022#\n\013stylepreset\030\n \001(\0132\016"
  ".TSP.Reference\022(\n\014shadowpreset\030\013 \001(\0132\022.T"
  "SD.ShadowArchive\"\212\003\n\036ImageAdjustmentsCom"
  "mandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Command"
  "Archive\022;\n\025old_image_adjustments\030\002 \001(\0132\034"
  ".TSD.ImageAdjustmentsArchive\022;\n\025new_imag"
  "e_adjustments\030\003 \001(\0132\034.TSD.ImageAdjustmen"
  "tsArchive\022-\n\021adjustedImageData\030\004 \001(\0132\022.T"
  "SP.DataReference\0225\n\031replacedAdjustedImag"
  "eData\030\005 \001(\0132\022.TSP.DataReference\022-\n\021enhan"
  "cedImageData\030\006 \001(\0132\022.TSP.DataReference\0225"
  "\n\031replacedEnhancedImageData\030\007 \001(\0132\022.TSP."
  "DataReference\"k\n\030MediaFlagsCommandArchiv"
  "e\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\034\n"
  "\004info\030\002 \001(\0132\016.TSP.Reference\022\r\n\005flags\030\003 \001"
  "(\r\"\377\002\n\034DrawablesCommandGroupArchive\022\'\n\005s"
  "uper\030\001 \002(\0132\030.TSK.CommandGroupArchive\0227\n\022"
  "obsolete_selection\030\002 \001(\0132\033.TSD.CanvasSel"
  "ectionArchive\022)\n\021modelforselection\030\003 \001(\013"
  "2\016.TSP.Reference\022I\n\004type\030\004 \001(\0162;.TSD.Dra"
  "wablesCommandGroupArchive.DrawablesComma"
  "ndGroupType\022\017\n\007forDrag\030\005 \001(\010\022)\n\021archived"
  "selection\030\006 \001(\0132\016.TSP.Reference\"K\n\031Drawa"
  "blesCommandGroupType\022\020\n\014Constructive\020\001\022\017"
  "\n\013Destructive\020\002\022\013\n\007InPlace\020\003\"\363\001\n\036Exterio"
  "rTextWrapCommandArchive\022\"\n\005super\030\001 \002(\0132\023"
  ".TSK.CommandArchive\022F\n\rinfo_and_wrap\030\002 \003"
  "(\0132/.TSD.ExteriorTextWrapCommandArchive."
  "InfoAndWrap\032e\n\013InfoAndWrap\022\034\n\004info\030\001 \001(\013"
  "2\016.TSP.Reference\0228\n\022exterior_text_wrap\030\002"
  " \001(\0132\034.TSD.ExteriorTextWrapArchive\"\227\001\n\037D"
  "rawableHyperlinkCommandArchive\022\"\n\005super\030"
  "\001 \002(\0132\023.TSK.CommandArchive\022\034\n\004info\030\002 \001(\013"
  "2\016.TSP.Reference\022\030\n\020oldhyperlink_url\030\003 \001"
  "(\t\022\030\n\020newhyperlink_url\030\004 \001(\t\"\330\002\n\037Command"
  "SelectionBehaviorArchive\022+\n\023model_for_se"
  "lection\030\002 \001(\0132\016.TSP.Reference\022O\n\004type\030\003 "
  "\001(\0162A.TSD.CommandSelectionBehaviorArchiv"
  "e.CommandSelectionBehaviorType\022*\n\022archiv"
  "ed_selection\030\004 \001(\0132\016.TSP.Reference\022.\n\026ar"
  "chived_new_selection\030\005 \001(\0132\016.TSP.Referen"
  "ce\"[\n\034CommandSelectionBehaviorType\022\020\n\014Co"
  "nstructive\020\001\022\017\n\013Destructive\020\002\022\013\n\007InPlace"
  "\020\003\022\013\n\007Replace\020\004\"@\n\032ImageReplaceCommandAr"
  "chive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchiv"
  "e\"l\n\032DrawableLockCommandArchive\022\"\n\005super"
  "\030\001 \002(\0132\023.TSK.CommandArchive\022\034\n\004info\030\002 \001("
  "\0132\016.TSP.Reference\022\014\n\004lock\030\003 \001(\010\"\257\001\n!Draw"
  "ableInfoCommentCommandArchive\022\"\n\005super\030\001"
  " \002(\0132\023.TSK.CommandArchive\022\034\n\004info\030\002 \001(\0132"
  "\016.TSP.Reference\022#\n\013old_comment\030\003 \001(\0132\016.T"
  "SP.Reference\022#\n\013new_comment\030\004 \001(\0132\016.TSP."
  "Reference\"\244\001\n!CommentStorageApplyCommand"
  "Archive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArch"
  "ive\022\'\n\017comment_storage\030\002 \002(\0132\016.TSP.Refer"
  "ence\022\026\n\016comment_string\030\003 \002(\t\022\032\n\022old_comm"
  "ent_string\030\004 \002(\t\"\253\002\n\023GuideCommandArchive"
  "\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\037\n\007"
  "storage\030\002 \001(\0132\016.TSP.Reference\022/\n\told_gui"
  "de\030\003 \001(\0132\034.TSD.UserDefinedGuideArchive\022/"
  "\n\tnew_guide\030\004 \001(\0132\034.TSD.UserDefinedGuide"
  "Archive\0227\n\004mode\030\005 \001(\0162).TSD.GuideCommand"
  "Archive.GuideCommandMode\"4\n\020GuideCommand"
  "Mode\022\007\n\003Add\020\001\022\013\n\007Replace\020\002\022\n\n\006Delete\020\003\"\210"
  "\001\n\'DrawableAspectRatioLockedCommandArchi"
  "ve\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\034"
  "\n\004info\030\002 \001(\0132\016.TSP.Reference\022\033\n\023aspect_r"
  "atio_locked\030\003 \001(\010\"\225\001\n.DrawableAccessibil"
  "ityDescriptionCommandArchive\022\"\n\005super\030\001 "
  "\002(\0132\023.TSK.CommandArchive\022\034\n\004info\030\002 \001(\0132\016"
  ".TSP.Reference\022!\n\031accessibility_descript"
  "ion\030\003 \001(\t\"\206\001\n\030PasteStyleCommandArchive\022\""
  "\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022!\n\tde"
  "st_info\030\002 \002(\0132\016.TSP.Reference\022#\n\013shape_s"
  "tyle\030\003 \001(\0132\016.TSP.Reference"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSDCommandArchives_2eproto_deps[4] = {
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSDCommandArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSDCommandArchives_2eproto = {
    false, false, 7826, descriptor_table_protodef_TSDCommandArchives_2eproto,
    "TSDCommandArchives.proto",
    &descriptor_table_TSDCommandArchives_2eproto_once, descriptor_table_TSDCommandArchives_2eproto_deps, 4, 38,
    schemas, file_default_instances, TableStruct_TSDCommandArchives_2eproto::offsets,
    file_level_metadata_TSDCommandArchives_2eproto, file_level_enum_descriptors_TSDCommandArchives_2eproto,
    file_level_service_descriptors_TSDCommandArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSDCommandArchives_2eproto_getter() {
  return &descriptor_table_TSDCommandArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSDCommandArchives_2eproto(&descriptor_table_TSDCommandArchives_2eproto);
namespace TSD {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MovieSetValueCommandArchive_LoopOption_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDCommandArchives_2eproto);
  return file_level_enum_descriptors_TSDCommandArchives_2eproto[0];
}
bool MovieSetValueCommandArchive_LoopOption_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive::None;
constexpr MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive::Repeat;
constexpr MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive::BackAndForth;
constexpr MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive::LoopOption_MIN;
constexpr MovieSetValueCommandArchive_LoopOption MovieSetValueCommandArchive::LoopOption_MAX;
constexpr int MovieSetValueCommandArchive::LoopOption_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DrawablesCommandGroupArchive_DrawablesCommandGroupType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDCommandArchives_2eproto);
  return file_level_enum_descriptors_TSDCommandArchives_2eproto[1];
}
bool DrawablesCommandGroupArchive_DrawablesCommandGroupType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::Constructive;
constexpr DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::Destructive;
constexpr DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::InPlace;
constexpr DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::DrawablesCommandGroupType_MIN;
constexpr DrawablesCommandGroupArchive_DrawablesCommandGroupType DrawablesCommandGroupArchive::DrawablesCommandGroupType_MAX;
constexpr int DrawablesCommandGroupArchive::DrawablesCommandGroupType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDCommandArchives_2eproto);
  return file_level_enum_descriptors_TSDCommandArchives_2eproto[2];
}
bool CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::Constructive;
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::Destructive;
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::InPlace;
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::Replace;
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::CommandSelectionBehaviorType_MIN;
constexpr CommandSelectionBehaviorArchive_CommandSelectionBehaviorType CommandSelectionBehaviorArchive::CommandSelectionBehaviorType_MAX;
constexpr int CommandSelectionBehaviorArchive::CommandSelectionBehaviorType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GuideCommandArchive_GuideCommandMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSDCommandArchives_2eproto);
  return file_level_enum_descriptors_TSDCommandArchives_2eproto[3];
}
bool GuideCommandArchive_GuideCommandMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GuideCommandArchive_GuideCommandMode GuideCommandArchive::Add;
constexpr GuideCommandArchive_GuideCommandMode GuideCommandArchive::Replace;
constexpr GuideCommandArchive_GuideCommandMode GuideCommandArchive::Delete;
constexpr GuideCommandArchive_GuideCommandMode GuideCommandArchive::GuideCommandMode_MIN;
constexpr GuideCommandArchive_GuideCommandMode GuideCommandArchive::GuideCommandMode_MAX;
constexpr int GuideCommandArchive::GuideCommandMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ConnectionLineConnectCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConnectionLineConnectCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& connection_line(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_connection_line(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& connect_to(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_connect_to(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& connect_from(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_connect_from(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& old_connect_to(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_old_connect_to(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& old_connect_from(const ConnectionLineConnectCommandArchive* msg);
  static void set_has_old_connect_from(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSK::CommandArchive&
ConnectionLineConnectCommandArchive::_Internal::super(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ConnectionLineConnectCommandArchive::_Internal::connection_line(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.connection_line_;
}
const ::TSP::Reference&
ConnectionLineConnectCommandArchive::_Internal::connect_to(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.connect_to_;
}
const ::TSP::Reference&
ConnectionLineConnectCommandArchive::_Internal::connect_from(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.connect_from_;
}
const ::TSP::Reference&
ConnectionLineConnectCommandArchive::_Internal::old_connect_to(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.old_connect_to_;
}
const ::TSP::Reference&
ConnectionLineConnectCommandArchive::_Internal::old_connect_from(const ConnectionLineConnectCommandArchive* msg) {
  return *msg->_impl_.old_connect_from_;
}
void ConnectionLineConnectCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ConnectionLineConnectCommandArchive::clear_connection_line() {
  if (_impl_.connection_line_ != nullptr) _impl_.connection_line_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ConnectionLineConnectCommandArchive::clear_connect_to() {
  if (_impl_.connect_to_ != nullptr) _impl_.connect_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ConnectionLineConnectCommandArchive::clear_connect_from() {
  if (_impl_.connect_from_ != nullptr) _impl_.connect_from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ConnectionLineConnectCommandArchive::clear_old_connect_to() {
  if (_impl_.old_connect_to_ != nullptr) _impl_.old_connect_to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ConnectionLineConnectCommandArchive::clear_old_connect_from() {
  if (_impl_.old_connect_from_ != nullptr) _impl_.old_connect_from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
ConnectionLineConnectCommandArchive::ConnectionLineConnectCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ConnectionLineConnectCommandArchive)
}
ConnectionLineConnectCommandArchive::ConnectionLineConnectCommandArchive(const ConnectionLineConnectCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConnectionLineConnectCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connection_line_){nullptr}
    , decltype(_impl_.connect_to_){nullptr}
    , decltype(_impl_.connect_from_){nullptr}
    , decltype(_impl_.old_connect_to_){nullptr}
    , decltype(_impl_.old_connect_from_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_connection_line()) {
    _this->_impl_.connection_line_ = new ::TSP::Reference(*from._impl_.connection_line_);
  }
  if (from._internal_has_connect_to()) {
    _this->_impl_.connect_to_ = new ::TSP::Reference(*from._impl_.connect_to_);
  }
  if (from._internal_has_connect_from()) {
    _this->_impl_.connect_from_ = new ::TSP::Reference(*from._impl_.connect_from_);
  }
  if (from._internal_has_old_connect_to()) {
    _this->_impl_.old_connect_to_ = new ::TSP::Reference(*from._impl_.old_connect_to_);
  }
  if (from._internal_has_old_connect_from()) {
    _this->_impl_.old_connect_from_ = new ::TSP::Reference(*from._impl_.old_connect_from_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ConnectionLineConnectCommandArchive)
}

inline void ConnectionLineConnectCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.connection_line_){nullptr}
    , decltype(_impl_.connect_to_){nullptr}
    , decltype(_impl_.connect_from_){nullptr}
    , decltype(_impl_.old_connect_to_){nullptr}
    , decltype(_impl_.old_connect_from_){nullptr}
  };
}

ConnectionLineConnectCommandArchive::~ConnectionLineConnectCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ConnectionLineConnectCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConnectionLineConnectCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.connection_line_;
  if (this != internal_default_instance()) delete _impl_.connect_to_;
  if (this != internal_default_instance()) delete _impl_.connect_from_;
  if (this != internal_default_instance()) delete _impl_.old_connect_to_;
  if (this != internal_default_instance()) delete _impl_.old_connect_from_;
}

void ConnectionLineConnectCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConnectionLineConnectCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ConnectionLineConnectCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.connection_line_ != nullptr);
      _impl_.connection_line_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.connect_to_ != nullptr);
      _impl_.connect_to_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.connect_from_ != nullptr);
      _impl_.connect_from_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.old_connect_to_ != nullptr);
      _impl_.old_connect_to_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.old_connect_from_ != nullptr);
      _impl_.old_connect_from_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConnectionLineConnectCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference connection_line = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_connection_line(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connect_to = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference connect_from = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_connect_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_connect_to = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_connect_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_connect_from = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_connect_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConnectionLineConnectCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ConnectionLineConnectCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference connection_line = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::connection_line(this),
        _Internal::connection_line(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connect_to = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::connect_to(this),
        _Internal::connect_to(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference connect_from = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::connect_from(this),
        _Internal::connect_from(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_connect_to = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::old_connect_to(this),
        _Internal::old_connect_to(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_connect_from = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::old_connect_from(this),
        _Internal::old_connect_from(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ConnectionLineConnectCommandArchive)
  return target;
}

size_t ConnectionLineConnectCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.ConnectionLineConnectCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_connection_line()) {
    // required .TSP.Reference connection_line = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connection_line_);
  }

  return total_size;
}
size_t ConnectionLineConnectCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ConnectionLineConnectCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference connection_line = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.connection_line_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional .TSP.Reference connect_to = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connect_to_);
    }

    // optional .TSP.Reference connect_from = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.connect_from_);
    }

    // optional .TSP.Reference old_connect_to = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_connect_to_);
    }

    // optional .TSP.Reference old_connect_from = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_connect_from_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConnectionLineConnectCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConnectionLineConnectCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConnectionLineConnectCommandArchive::GetClassData() const { return &_class_data_; }


void ConnectionLineConnectCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConnectionLineConnectCommandArchive*>(&to_msg);
  auto& from = static_cast<const ConnectionLineConnectCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ConnectionLineConnectCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_connection_line()->::TSP::Reference::MergeFrom(
          from._internal_connection_line());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_connect_to()->::TSP::Reference::MergeFrom(
          from._internal_connect_to());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_connect_from()->::TSP::Reference::MergeFrom(
          from._internal_connect_from());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_old_connect_to()->::TSP::Reference::MergeFrom(
          from._internal_old_connect_to());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_old_connect_from()->::TSP::Reference::MergeFrom(
          from._internal_old_connect_from());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConnectionLineConnectCommandArchive::CopyFrom(const ConnectionLineConnectCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ConnectionLineConnectCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectionLineConnectCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_connection_line()) {
    if (!_impl_.connection_line_->IsInitialized()) return false;
  }
  if (_internal_has_connect_to()) {
    if (!_impl_.connect_to_->IsInitialized()) return false;
  }
  if (_internal_has_connect_from()) {
    if (!_impl_.connect_from_->IsInitialized()) return false;
  }
  if (_internal_has_old_connect_to()) {
    if (!_impl_.old_connect_to_->IsInitialized()) return false;
  }
  if (_internal_has_old_connect_from()) {
    if (!_impl_.old_connect_from_->IsInitialized()) return false;
  }
  return true;
}

void ConnectionLineConnectCommandArchive::InternalSwap(ConnectionLineConnectCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConnectionLineConnectCommandArchive, _impl_.old_connect_from_)
      + sizeof(ConnectionLineConnectCommandArchive::_impl_.old_connect_from_)
      - PROTOBUF_FIELD_OFFSET(ConnectionLineConnectCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConnectionLineConnectCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[0]);
}

// ===================================================================

class GroupDrawablesCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupDrawablesCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const GroupDrawablesCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& group(const GroupDrawablesCommandArchive* msg);
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
GroupDrawablesCommandArchive::_Internal::super(const GroupDrawablesCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
GroupDrawablesCommandArchive::_Internal::group(const GroupDrawablesCommandArchive* msg) {
  return *msg->_impl_.group_;
}
void GroupDrawablesCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GroupDrawablesCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
void GroupDrawablesCommandArchive::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
GroupDrawablesCommandArchive::GroupDrawablesCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GroupDrawablesCommandArchive)
}
GroupDrawablesCommandArchive::GroupDrawablesCommandArchive(const GroupDrawablesCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupDrawablesCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.group_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_group()) {
    _this->_impl_.group_ = new ::TSP::Reference(*from._impl_.group_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.GroupDrawablesCommandArchive)
}

inline void GroupDrawablesCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.group_){nullptr}
  };
}

GroupDrawablesCommandArchive::~GroupDrawablesCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.GroupDrawablesCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupDrawablesCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.group_;
}

void GroupDrawablesCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupDrawablesCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GroupDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.group_ != nullptr);
      _impl_.group_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupDrawablesCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference drawables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_group(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupDrawablesCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GroupDrawablesCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference drawables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference group = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::group(this),
        _Internal::group(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GroupDrawablesCommandArchive)
  return target;
}

size_t GroupDrawablesCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GroupDrawablesCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference drawables = 2;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference group = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.group_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupDrawablesCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupDrawablesCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupDrawablesCommandArchive::GetClassData() const { return &_class_data_; }


void GroupDrawablesCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupDrawablesCommandArchive*>(&to_msg);
  auto& from = static_cast<const GroupDrawablesCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GroupDrawablesCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_group()->::TSP::Reference::MergeFrom(
          from._internal_group());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupDrawablesCommandArchive::CopyFrom(const GroupDrawablesCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GroupDrawablesCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupDrawablesCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_group()) {
    if (!_impl_.group_->IsInitialized()) return false;
  }
  return true;
}

void GroupDrawablesCommandArchive::InternalSwap(GroupDrawablesCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupDrawablesCommandArchive, _impl_.group_)
      + sizeof(GroupDrawablesCommandArchive::_impl_.group_)
      - PROTOBUF_FIELD_OFFSET(GroupDrawablesCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupDrawablesCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[1]);
}

// ===================================================================

class UngroupGroupCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UngroupGroupCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const UngroupGroupCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& group(const UngroupGroupCommandArchive* msg);
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
UngroupGroupCommandArchive::_Internal::super(const UngroupGroupCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
UngroupGroupCommandArchive::_Internal::group(const UngroupGroupCommandArchive* msg) {
  return *msg->_impl_.group_;
}
void UngroupGroupCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UngroupGroupCommandArchive::clear_drawables() {
  _impl_.drawables_.Clear();
}
void UngroupGroupCommandArchive::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
UngroupGroupCommandArchive::UngroupGroupCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.UngroupGroupCommandArchive)
}
UngroupGroupCommandArchive::UngroupGroupCommandArchive(const UngroupGroupCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UngroupGroupCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){from._impl_.drawables_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.group_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_group()) {
    _this->_impl_.group_ = new ::TSP::Reference(*from._impl_.group_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.UngroupGroupCommandArchive)
}

inline void UngroupGroupCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.drawables_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.group_){nullptr}
  };
}

UngroupGroupCommandArchive::~UngroupGroupCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.UngroupGroupCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UngroupGroupCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.drawables_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.group_;
}

void UngroupGroupCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UngroupGroupCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.UngroupGroupCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.drawables_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.group_ != nullptr);
      _impl_.group_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UngroupGroupCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference drawables = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drawables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference group = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_group(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UngroupGroupCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.UngroupGroupCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference drawables = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_drawables_size()); i < n; i++) {
    const auto& repfield = this->_internal_drawables(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference group = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::group(this),
        _Internal::group(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.UngroupGroupCommandArchive)
  return target;
}

size_t UngroupGroupCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.UngroupGroupCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference drawables = 2;
  total_size += 1UL * this->_internal_drawables_size();
  for (const auto& msg : this->_impl_.drawables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference group = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.group_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UngroupGroupCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UngroupGroupCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UngroupGroupCommandArchive::GetClassData() const { return &_class_data_; }


void UngroupGroupCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UngroupGroupCommandArchive*>(&to_msg);
  auto& from = static_cast<const UngroupGroupCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.UngroupGroupCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.drawables_.MergeFrom(from._impl_.drawables_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_group()->::TSP::Reference::MergeFrom(
          from._internal_group());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UngroupGroupCommandArchive::CopyFrom(const UngroupGroupCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.UngroupGroupCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UngroupGroupCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.drawables_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_group()) {
    if (!_impl_.group_->IsInitialized()) return false;
  }
  return true;
}

void UngroupGroupCommandArchive::InternalSwap(UngroupGroupCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.drawables_.InternalSwap(&other->_impl_.drawables_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UngroupGroupCommandArchive, _impl_.group_)
      + sizeof(UngroupGroupCommandArchive::_impl_.group_)
      - PROTOBUF_FIELD_OFFSET(UngroupGroupCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UngroupGroupCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[2]);
}

// ===================================================================

class ContainerRemoveChildrenCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerRemoveChildrenCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ContainerRemoveChildrenCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& container(const ContainerRemoveChildrenCommandArchive* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::IndexSet& children_indices(const ContainerRemoveChildrenCommandArchive* msg);
  static void set_has_children_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ContainerRemoveChildrenCommandArchive::_Internal::super(const ContainerRemoveChildrenCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ContainerRemoveChildrenCommandArchive::_Internal::container(const ContainerRemoveChildrenCommandArchive* msg) {
  return *msg->_impl_.container_;
}
const ::TSP::IndexSet&
ContainerRemoveChildrenCommandArchive::_Internal::children_indices(const ContainerRemoveChildrenCommandArchive* msg) {
  return *msg->_impl_.children_indices_;
}
void ContainerRemoveChildrenCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ContainerRemoveChildrenCommandArchive::clear_container() {
  if (_impl_.container_ != nullptr) _impl_.container_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainerRemoveChildrenCommandArchive::clear_children() {
  _impl_.children_.Clear();
}
void ContainerRemoveChildrenCommandArchive::clear_children_indices() {
  if (_impl_.children_indices_ != nullptr) _impl_.children_indices_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ContainerRemoveChildrenCommandArchive::ContainerRemoveChildrenCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContainerRemoveChildrenCommandArchive)
}
ContainerRemoveChildrenCommandArchive::ContainerRemoveChildrenCommandArchive(const ContainerRemoveChildrenCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerRemoveChildrenCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.children_indices_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_container()) {
    _this->_impl_.container_ = new ::TSP::Reference(*from._impl_.container_);
  }
  if (from._internal_has_children_indices()) {
    _this->_impl_.children_indices_ = new ::TSP::IndexSet(*from._impl_.children_indices_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ContainerRemoveChildrenCommandArchive)
}

inline void ContainerRemoveChildrenCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.children_indices_){nullptr}
  };
}

ContainerRemoveChildrenCommandArchive::~ContainerRemoveChildrenCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContainerRemoveChildrenCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerRemoveChildrenCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.container_;
  if (this != internal_default_instance()) delete _impl_.children_indices_;
}

void ContainerRemoveChildrenCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerRemoveChildrenCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContainerRemoveChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.container_ != nullptr);
      _impl_.container_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.children_indices_ != nullptr);
      _impl_.children_indices_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerRemoveChildrenCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference container = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.IndexSet children_indices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_children_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerRemoveChildrenCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContainerRemoveChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference container = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.IndexSet children_indices = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::children_indices(this),
        _Internal::children_indices(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContainerRemoveChildrenCommandArchive)
  return target;
}

size_t ContainerRemoveChildrenCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContainerRemoveChildrenCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 3;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference container = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.container_);
    }

    // optional .TSP.IndexSet children_indices = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.children_indices_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerRemoveChildrenCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerRemoveChildrenCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerRemoveChildrenCommandArchive::GetClassData() const { return &_class_data_; }


void ContainerRemoveChildrenCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerRemoveChildrenCommandArchive*>(&to_msg);
  auto& from = static_cast<const ContainerRemoveChildrenCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContainerRemoveChildrenCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_container()->::TSP::Reference::MergeFrom(
          from._internal_container());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_children_indices()->::TSP::IndexSet::MergeFrom(
          from._internal_children_indices());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerRemoveChildrenCommandArchive::CopyFrom(const ContainerRemoveChildrenCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContainerRemoveChildrenCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerRemoveChildrenCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_container()) {
    if (!_impl_.container_->IsInitialized()) return false;
  }
  if (_internal_has_children_indices()) {
    if (!_impl_.children_indices_->IsInitialized()) return false;
  }
  return true;
}

void ContainerRemoveChildrenCommandArchive::InternalSwap(ContainerRemoveChildrenCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerRemoveChildrenCommandArchive, _impl_.children_indices_)
      + sizeof(ContainerRemoveChildrenCommandArchive::_impl_.children_indices_)
      - PROTOBUF_FIELD_OFFSET(ContainerRemoveChildrenCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerRemoveChildrenCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[3]);
}

// ===================================================================

class ContainerInsertChildrenCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerInsertChildrenCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ContainerInsertChildrenCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& container(const ContainerInsertChildrenCommandArchive* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ContainerInsertChildrenCommandArchive::_Internal::super(const ContainerInsertChildrenCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ContainerInsertChildrenCommandArchive::_Internal::container(const ContainerInsertChildrenCommandArchive* msg) {
  return *msg->_impl_.container_;
}
void ContainerInsertChildrenCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ContainerInsertChildrenCommandArchive::clear_container() {
  if (_impl_.container_ != nullptr) _impl_.container_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainerInsertChildrenCommandArchive::clear_children() {
  _impl_.children_.Clear();
}
ContainerInsertChildrenCommandArchive::ContainerInsertChildrenCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContainerInsertChildrenCommandArchive)
}
ContainerInsertChildrenCommandArchive::ContainerInsertChildrenCommandArchive(const ContainerInsertChildrenCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerInsertChildrenCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_container()) {
    _this->_impl_.container_ = new ::TSP::Reference(*from._impl_.container_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TSD.ContainerInsertChildrenCommandArchive)
}

inline void ContainerInsertChildrenCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.index_){uint64_t{0u}}
  };
}

ContainerInsertChildrenCommandArchive::~ContainerInsertChildrenCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContainerInsertChildrenCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerInsertChildrenCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.container_;
}

void ContainerInsertChildrenCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerInsertChildrenCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContainerInsertChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.container_ != nullptr);
      _impl_.container_->Clear();
    }
  }
  _impl_.index_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerInsertChildrenCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference container = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerInsertChildrenCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContainerInsertChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference container = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContainerInsertChildrenCommandArchive)
  return target;
}

size_t ContainerInsertChildrenCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContainerInsertChildrenCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 3;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference container = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.container_);
    }

    // optional uint64 index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerInsertChildrenCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerInsertChildrenCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerInsertChildrenCommandArchive::GetClassData() const { return &_class_data_; }


void ContainerInsertChildrenCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerInsertChildrenCommandArchive*>(&to_msg);
  auto& from = static_cast<const ContainerInsertChildrenCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContainerInsertChildrenCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_container()->::TSP::Reference::MergeFrom(
          from._internal_container());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerInsertChildrenCommandArchive::CopyFrom(const ContainerInsertChildrenCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContainerInsertChildrenCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInsertChildrenCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_container()) {
    if (!_impl_.container_->IsInitialized()) return false;
  }
  return true;
}

void ContainerInsertChildrenCommandArchive::InternalSwap(ContainerInsertChildrenCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerInsertChildrenCommandArchive, _impl_.index_)
      + sizeof(ContainerInsertChildrenCommandArchive::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(ContainerInsertChildrenCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerInsertChildrenCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[4]);
}

// ===================================================================

class ContainerReorderChildrenCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ContainerReorderChildrenCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ContainerReorderChildrenCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& container(const ContainerReorderChildrenCommandArchive* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::IndexSet& children_indices(const ContainerReorderChildrenCommandArchive* msg);
  static void set_has_children_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ContainerReorderChildrenCommandArchive::_Internal::super(const ContainerReorderChildrenCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ContainerReorderChildrenCommandArchive::_Internal::container(const ContainerReorderChildrenCommandArchive* msg) {
  return *msg->_impl_.container_;
}
const ::TSP::IndexSet&
ContainerReorderChildrenCommandArchive::_Internal::children_indices(const ContainerReorderChildrenCommandArchive* msg) {
  return *msg->_impl_.children_indices_;
}
void ContainerReorderChildrenCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ContainerReorderChildrenCommandArchive::clear_container() {
  if (_impl_.container_ != nullptr) _impl_.container_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ContainerReorderChildrenCommandArchive::clear_children() {
  _impl_.children_.Clear();
}
void ContainerReorderChildrenCommandArchive::clear_children_indices() {
  if (_impl_.children_indices_ != nullptr) _impl_.children_indices_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ContainerReorderChildrenCommandArchive::ContainerReorderChildrenCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ContainerReorderChildrenCommandArchive)
}
ContainerReorderChildrenCommandArchive::ContainerReorderChildrenCommandArchive(const ContainerReorderChildrenCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ContainerReorderChildrenCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.children_indices_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_container()) {
    _this->_impl_.container_ = new ::TSP::Reference(*from._impl_.container_);
  }
  if (from._internal_has_children_indices()) {
    _this->_impl_.children_indices_ = new ::TSP::IndexSet(*from._impl_.children_indices_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ContainerReorderChildrenCommandArchive)
}

inline void ContainerReorderChildrenCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.container_){nullptr}
    , decltype(_impl_.children_indices_){nullptr}
  };
}

ContainerReorderChildrenCommandArchive::~ContainerReorderChildrenCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ContainerReorderChildrenCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContainerReorderChildrenCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.container_;
  if (this != internal_default_instance()) delete _impl_.children_indices_;
}

void ContainerReorderChildrenCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ContainerReorderChildrenCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ContainerReorderChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.container_ != nullptr);
      _impl_.container_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.children_indices_ != nullptr);
      _impl_.children_indices_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ContainerReorderChildrenCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference container = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.IndexSet children_indices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_children_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContainerReorderChildrenCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ContainerReorderChildrenCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference container = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference children = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.IndexSet children_indices = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::children_indices(this),
        _Internal::children_indices(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ContainerReorderChildrenCommandArchive)
  return target;
}

size_t ContainerReorderChildrenCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ContainerReorderChildrenCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 3;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference container = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.container_);
    }

    // optional .TSP.IndexSet children_indices = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.children_indices_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ContainerReorderChildrenCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ContainerReorderChildrenCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ContainerReorderChildrenCommandArchive::GetClassData() const { return &_class_data_; }


void ContainerReorderChildrenCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ContainerReorderChildrenCommandArchive*>(&to_msg);
  auto& from = static_cast<const ContainerReorderChildrenCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ContainerReorderChildrenCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_container()->::TSP::Reference::MergeFrom(
          from._internal_container());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_children_indices()->::TSP::IndexSet::MergeFrom(
          from._internal_children_indices());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ContainerReorderChildrenCommandArchive::CopyFrom(const ContainerReorderChildrenCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ContainerReorderChildrenCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerReorderChildrenCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_container()) {
    if (!_impl_.container_->IsInitialized()) return false;
  }
  if (_internal_has_children_indices()) {
    if (!_impl_.children_indices_->IsInitialized()) return false;
  }
  return true;
}

void ContainerReorderChildrenCommandArchive::InternalSwap(ContainerReorderChildrenCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContainerReorderChildrenCommandArchive, _impl_.children_indices_)
      + sizeof(ContainerReorderChildrenCommandArchive::_impl_.children_indices_)
      - PROTOBUF_FIELD_OFFSET(ContainerReorderChildrenCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ContainerReorderChildrenCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[5]);
}

// ===================================================================

class InfoGeometryCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoGeometryCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InfoGeometryCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const InfoGeometryCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::GeometryArchive& newgeometry(const InfoGeometryCommandArchive* msg);
  static void set_has_newgeometry(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::GeometryArchive& oldgeometry(const InfoGeometryCommandArchive* msg);
  static void set_has_oldgeometry(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shouldclearobjectplaceholderflag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_didmatchobjectplaceholdergeometry(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
InfoGeometryCommandArchive::_Internal::super(const InfoGeometryCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InfoGeometryCommandArchive::_Internal::info(const InfoGeometryCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSD::GeometryArchive&
InfoGeometryCommandArchive::_Internal::newgeometry(const InfoGeometryCommandArchive* msg) {
  return *msg->_impl_.newgeometry_;
}
const ::TSD::GeometryArchive&
InfoGeometryCommandArchive::_Internal::oldgeometry(const InfoGeometryCommandArchive* msg) {
  return *msg->_impl_.oldgeometry_;
}
void InfoGeometryCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InfoGeometryCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InfoGeometryCommandArchive::clear_newgeometry() {
  if (_impl_.newgeometry_ != nullptr) _impl_.newgeometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void InfoGeometryCommandArchive::clear_oldgeometry() {
  if (_impl_.oldgeometry_ != nullptr) _impl_.oldgeometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
InfoGeometryCommandArchive::InfoGeometryCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.InfoGeometryCommandArchive)
}
InfoGeometryCommandArchive::InfoGeometryCommandArchive(const InfoGeometryCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InfoGeometryCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newgeometry_){nullptr}
    , decltype(_impl_.oldgeometry_){nullptr}
    , decltype(_impl_.shouldclearobjectplaceholderflag_){}
    , decltype(_impl_.didmatchobjectplaceholdergeometry_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_newgeometry()) {
    _this->_impl_.newgeometry_ = new ::TSD::GeometryArchive(*from._impl_.newgeometry_);
  }
  if (from._internal_has_oldgeometry()) {
    _this->_impl_.oldgeometry_ = new ::TSD::GeometryArchive(*from._impl_.oldgeometry_);
  }
  ::memcpy(&_impl_.shouldclearobjectplaceholderflag_, &from._impl_.shouldclearobjectplaceholderflag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.didmatchobjectplaceholdergeometry_) -
    reinterpret_cast<char*>(&_impl_.shouldclearobjectplaceholderflag_)) + sizeof(_impl_.didmatchobjectplaceholdergeometry_));
  // @@protoc_insertion_point(copy_constructor:TSD.InfoGeometryCommandArchive)
}

inline void InfoGeometryCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newgeometry_){nullptr}
    , decltype(_impl_.oldgeometry_){nullptr}
    , decltype(_impl_.shouldclearobjectplaceholderflag_){false}
    , decltype(_impl_.didmatchobjectplaceholdergeometry_){false}
  };
}

InfoGeometryCommandArchive::~InfoGeometryCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.InfoGeometryCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoGeometryCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.newgeometry_;
  if (this != internal_default_instance()) delete _impl_.oldgeometry_;
}

void InfoGeometryCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InfoGeometryCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.InfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.newgeometry_ != nullptr);
      _impl_.newgeometry_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.oldgeometry_ != nullptr);
      _impl_.oldgeometry_->Clear();
    }
  }
  ::memset(&_impl_.shouldclearobjectplaceholderflag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.didmatchobjectplaceholdergeometry_) -
      reinterpret_cast<char*>(&_impl_.shouldclearobjectplaceholderflag_)) + sizeof(_impl_.didmatchobjectplaceholdergeometry_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InfoGeometryCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive newGeometry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_newgeometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive oldGeometry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldgeometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool shouldClearObjectPlaceholderFlag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_shouldclearobjectplaceholderflag(&has_bits);
          _impl_.shouldclearobjectplaceholderflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool didMatchObjectPlaceholderGeometry = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_didmatchobjectplaceholdergeometry(&has_bits);
          _impl_.didmatchobjectplaceholdergeometry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoGeometryCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.InfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive newGeometry = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::newgeometry(this),
        _Internal::newgeometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive oldGeometry = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::oldgeometry(this),
        _Internal::oldgeometry(this).GetCachedSize(), target, stream);
  }

  // optional bool shouldClearObjectPlaceholderFlag = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_shouldclearobjectplaceholderflag(), target);
  }

  // optional bool didMatchObjectPlaceholderGeometry = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_didmatchobjectplaceholdergeometry(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.InfoGeometryCommandArchive)
  return target;
}

size_t InfoGeometryCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.InfoGeometryCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSD.GeometryArchive newGeometry = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newgeometry_);
    }

    // optional .TSD.GeometryArchive oldGeometry = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldgeometry_);
    }

    // optional bool shouldClearObjectPlaceholderFlag = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool didMatchObjectPlaceholderGeometry = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InfoGeometryCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InfoGeometryCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InfoGeometryCommandArchive::GetClassData() const { return &_class_data_; }


void InfoGeometryCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InfoGeometryCommandArchive*>(&to_msg);
  auto& from = static_cast<const InfoGeometryCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.InfoGeometryCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_newgeometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_newgeometry());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_oldgeometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_oldgeometry());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.shouldclearobjectplaceholderflag_ = from._impl_.shouldclearobjectplaceholderflag_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.didmatchobjectplaceholdergeometry_ = from._impl_.didmatchobjectplaceholdergeometry_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InfoGeometryCommandArchive::CopyFrom(const InfoGeometryCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.InfoGeometryCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoGeometryCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_newgeometry()) {
    if (!_impl_.newgeometry_->IsInitialized()) return false;
  }
  if (_internal_has_oldgeometry()) {
    if (!_impl_.oldgeometry_->IsInitialized()) return false;
  }
  return true;
}

void InfoGeometryCommandArchive::InternalSwap(InfoGeometryCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InfoGeometryCommandArchive, _impl_.didmatchobjectplaceholdergeometry_)
      + sizeof(InfoGeometryCommandArchive::_impl_.didmatchobjectplaceholdergeometry_)
      - PROTOBUF_FIELD_OFFSET(InfoGeometryCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InfoGeometryCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[6]);
}

// ===================================================================

class DrawablePathSourceCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawablePathSourceCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawablePathSourceCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawablePathSourceCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::PathSourceArchive& oldpathsource(const DrawablePathSourceCommandArchive* msg);
  static void set_has_oldpathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::PathSourceArchive& newpathsource(const DrawablePathSourceCommandArchive* msg);
  static void set_has_newpathsource(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DrawablePathSourceCommandArchive::_Internal::super(const DrawablePathSourceCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawablePathSourceCommandArchive::_Internal::info(const DrawablePathSourceCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSD::PathSourceArchive&
DrawablePathSourceCommandArchive::_Internal::oldpathsource(const DrawablePathSourceCommandArchive* msg) {
  return *msg->_impl_.oldpathsource_;
}
const ::TSD::PathSourceArchive&
DrawablePathSourceCommandArchive::_Internal::newpathsource(const DrawablePathSourceCommandArchive* msg) {
  return *msg->_impl_.newpathsource_;
}
void DrawablePathSourceCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawablePathSourceCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawablePathSourceCommandArchive::clear_oldpathsource() {
  if (_impl_.oldpathsource_ != nullptr) _impl_.oldpathsource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrawablePathSourceCommandArchive::clear_newpathsource() {
  if (_impl_.newpathsource_ != nullptr) _impl_.newpathsource_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
DrawablePathSourceCommandArchive::DrawablePathSourceCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawablePathSourceCommandArchive)
}
DrawablePathSourceCommandArchive::DrawablePathSourceCommandArchive(const DrawablePathSourceCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawablePathSourceCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.oldpathsource_){nullptr}
    , decltype(_impl_.newpathsource_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_oldpathsource()) {
    _this->_impl_.oldpathsource_ = new ::TSD::PathSourceArchive(*from._impl_.oldpathsource_);
  }
  if (from._internal_has_newpathsource()) {
    _this->_impl_.newpathsource_ = new ::TSD::PathSourceArchive(*from._impl_.newpathsource_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawablePathSourceCommandArchive)
}

inline void DrawablePathSourceCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.oldpathsource_){nullptr}
    , decltype(_impl_.newpathsource_){nullptr}
  };
}

DrawablePathSourceCommandArchive::~DrawablePathSourceCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawablePathSourceCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawablePathSourceCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.oldpathsource_;
  if (this != internal_default_instance()) delete _impl_.newpathsource_;
}

void DrawablePathSourceCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawablePathSourceCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawablePathSourceCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.oldpathsource_ != nullptr);
      _impl_.oldpathsource_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.newpathsource_ != nullptr);
      _impl_.newpathsource_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawablePathSourceCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive oldpathsource = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldpathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.PathSourceArchive newpathsource = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_newpathsource(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawablePathSourceCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawablePathSourceCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive oldpathsource = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::oldpathsource(this),
        _Internal::oldpathsource(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.PathSourceArchive newpathsource = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::newpathsource(this),
        _Internal::newpathsource(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawablePathSourceCommandArchive)
  return target;
}

size_t DrawablePathSourceCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawablePathSourceCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSD.PathSourceArchive oldpathsource = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldpathsource_);
    }

    // optional .TSD.PathSourceArchive newpathsource = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newpathsource_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawablePathSourceCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawablePathSourceCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawablePathSourceCommandArchive::GetClassData() const { return &_class_data_; }


void DrawablePathSourceCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawablePathSourceCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawablePathSourceCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawablePathSourceCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_oldpathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_oldpathsource());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_newpathsource()->::TSD::PathSourceArchive::MergeFrom(
          from._internal_newpathsource());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawablePathSourceCommandArchive::CopyFrom(const DrawablePathSourceCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawablePathSourceCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawablePathSourceCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_oldpathsource()) {
    if (!_impl_.oldpathsource_->IsInitialized()) return false;
  }
  if (_internal_has_newpathsource()) {
    if (!_impl_.newpathsource_->IsInitialized()) return false;
  }
  return true;
}

void DrawablePathSourceCommandArchive::InternalSwap(DrawablePathSourceCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawablePathSourceCommandArchive, _impl_.newpathsource_)
      + sizeof(DrawablePathSourceCommandArchive::_impl_.newpathsource_)
      - PROTOBUF_FIELD_OFFSET(DrawablePathSourceCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawablePathSourceCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[7]);
}

// ===================================================================

class InstantAlphaCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InstantAlphaCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InstantAlphaCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& image(const InstantAlphaCommandArchive* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Path& oldpath(const InstantAlphaCommandArchive* msg);
  static void set_has_oldpath(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Path& newpath(const InstantAlphaCommandArchive* msg);
  static void set_has_newpath(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
InstantAlphaCommandArchive::_Internal::super(const InstantAlphaCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InstantAlphaCommandArchive::_Internal::image(const InstantAlphaCommandArchive* msg) {
  return *msg->_impl_.image_;
}
const ::TSP::Path&
InstantAlphaCommandArchive::_Internal::oldpath(const InstantAlphaCommandArchive* msg) {
  return *msg->_impl_.oldpath_;
}
const ::TSP::Path&
InstantAlphaCommandArchive::_Internal::newpath(const InstantAlphaCommandArchive* msg) {
  return *msg->_impl_.newpath_;
}
void InstantAlphaCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InstantAlphaCommandArchive::clear_image() {
  if (_impl_.image_ != nullptr) _impl_.image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InstantAlphaCommandArchive::clear_oldpath() {
  if (_impl_.oldpath_ != nullptr) _impl_.oldpath_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void InstantAlphaCommandArchive::clear_newpath() {
  if (_impl_.newpath_ != nullptr) _impl_.newpath_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
InstantAlphaCommandArchive::InstantAlphaCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.InstantAlphaCommandArchive)
}
InstantAlphaCommandArchive::InstantAlphaCommandArchive(const InstantAlphaCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstantAlphaCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.image_){nullptr}
    , decltype(_impl_.oldpath_){nullptr}
    , decltype(_impl_.newpath_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_image()) {
    _this->_impl_.image_ = new ::TSP::Reference(*from._impl_.image_);
  }
  if (from._internal_has_oldpath()) {
    _this->_impl_.oldpath_ = new ::TSP::Path(*from._impl_.oldpath_);
  }
  if (from._internal_has_newpath()) {
    _this->_impl_.newpath_ = new ::TSP::Path(*from._impl_.newpath_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.InstantAlphaCommandArchive)
}

inline void InstantAlphaCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.image_){nullptr}
    , decltype(_impl_.oldpath_){nullptr}
    , decltype(_impl_.newpath_){nullptr}
  };
}

InstantAlphaCommandArchive::~InstantAlphaCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.InstantAlphaCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstantAlphaCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.image_;
  if (this != internal_default_instance()) delete _impl_.oldpath_;
  if (this != internal_default_instance()) delete _impl_.newpath_;
}

void InstantAlphaCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstantAlphaCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.InstantAlphaCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.oldpath_ != nullptr);
      _impl_.oldpath_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.newpath_ != nullptr);
      _impl_.newpath_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstantAlphaCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference image = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path oldpath = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldpath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Path newpath = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_newpath(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstantAlphaCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.InstantAlphaCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference image = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path oldpath = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::oldpath(this),
        _Internal::oldpath(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Path newpath = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::newpath(this),
        _Internal::newpath(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.InstantAlphaCommandArchive)
  return target;
}

size_t InstantAlphaCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.InstantAlphaCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference image = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

    // optional .TSP.Path oldpath = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldpath_);
    }

    // optional .TSP.Path newpath = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newpath_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstantAlphaCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstantAlphaCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstantAlphaCommandArchive::GetClassData() const { return &_class_data_; }


void InstantAlphaCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstantAlphaCommandArchive*>(&to_msg);
  auto& from = static_cast<const InstantAlphaCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.InstantAlphaCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_image()->::TSP::Reference::MergeFrom(
          from._internal_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_oldpath()->::TSP::Path::MergeFrom(
          from._internal_oldpath());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_newpath()->::TSP::Path::MergeFrom(
          from._internal_newpath());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstantAlphaCommandArchive::CopyFrom(const InstantAlphaCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.InstantAlphaCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstantAlphaCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_image()) {
    if (!_impl_.image_->IsInitialized()) return false;
  }
  if (_internal_has_oldpath()) {
    if (!_impl_.oldpath_->IsInitialized()) return false;
  }
  if (_internal_has_newpath()) {
    if (!_impl_.newpath_->IsInitialized()) return false;
  }
  return true;
}

void InstantAlphaCommandArchive::InternalSwap(InstantAlphaCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InstantAlphaCommandArchive, _impl_.newpath_)
      + sizeof(InstantAlphaCommandArchive::_impl_.newpath_)
      - PROTOBUF_FIELD_OFFSET(InstantAlphaCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InstantAlphaCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[8]);
}

// ===================================================================

class DrawableShadowCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableShadowCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableShadowCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawableShadowCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ShadowArchive& oldshadow(const DrawableShadowCommandArchive* msg);
  static void set_has_oldshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::ShadowArchive& newshadow(const DrawableShadowCommandArchive* msg);
  static void set_has_newshadow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableShadowCommandArchive::_Internal::super(const DrawableShadowCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableShadowCommandArchive::_Internal::info(const DrawableShadowCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSD::ShadowArchive&
DrawableShadowCommandArchive::_Internal::oldshadow(const DrawableShadowCommandArchive* msg) {
  return *msg->_impl_.oldshadow_;
}
const ::TSD::ShadowArchive&
DrawableShadowCommandArchive::_Internal::newshadow(const DrawableShadowCommandArchive* msg) {
  return *msg->_impl_.newshadow_;
}
void DrawableShadowCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawableShadowCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawableShadowCommandArchive::clear_oldshadow() {
  if (_impl_.oldshadow_ != nullptr) _impl_.oldshadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrawableShadowCommandArchive::clear_newshadow() {
  if (_impl_.newshadow_ != nullptr) _impl_.newshadow_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
DrawableShadowCommandArchive::DrawableShadowCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableShadowCommandArchive)
}
DrawableShadowCommandArchive::DrawableShadowCommandArchive(const DrawableShadowCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableShadowCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.oldshadow_){nullptr}
    , decltype(_impl_.newshadow_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_oldshadow()) {
    _this->_impl_.oldshadow_ = new ::TSD::ShadowArchive(*from._impl_.oldshadow_);
  }
  if (from._internal_has_newshadow()) {
    _this->_impl_.newshadow_ = new ::TSD::ShadowArchive(*from._impl_.newshadow_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableShadowCommandArchive)
}

inline void DrawableShadowCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.oldshadow_){nullptr}
    , decltype(_impl_.newshadow_){nullptr}
  };
}

DrawableShadowCommandArchive::~DrawableShadowCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableShadowCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableShadowCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.oldshadow_;
  if (this != internal_default_instance()) delete _impl_.newshadow_;
}

void DrawableShadowCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableShadowCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableShadowCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.oldshadow_ != nullptr);
      _impl_.oldshadow_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.newshadow_ != nullptr);
      _impl_.newshadow_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableShadowCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive oldshadow = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive newshadow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_newshadow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableShadowCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableShadowCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShadowArchive oldshadow = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::oldshadow(this),
        _Internal::oldshadow(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShadowArchive newshadow = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::newshadow(this),
        _Internal::newshadow(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableShadowCommandArchive)
  return target;
}

size_t DrawableShadowCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableShadowCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSD.ShadowArchive oldshadow = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldshadow_);
    }

    // optional .TSD.ShadowArchive newshadow = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newshadow_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableShadowCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableShadowCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableShadowCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableShadowCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableShadowCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableShadowCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableShadowCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_oldshadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_oldshadow());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_newshadow()->::TSD::ShadowArchive::MergeFrom(
          from._internal_newshadow());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableShadowCommandArchive::CopyFrom(const DrawableShadowCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableShadowCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableShadowCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_oldshadow()) {
    if (!_impl_.oldshadow_->IsInitialized()) return false;
  }
  if (_internal_has_newshadow()) {
    if (!_impl_.newshadow_->IsInitialized()) return false;
  }
  return true;
}

void DrawableShadowCommandArchive::InternalSwap(DrawableShadowCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableShadowCommandArchive, _impl_.newshadow_)
      + sizeof(DrawableShadowCommandArchive::_impl_.newshadow_)
      - PROTOBUF_FIELD_OFFSET(DrawableShadowCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableShadowCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[9]);
}

// ===================================================================

class DrawableApplyThemeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableApplyThemeCommandArchive>()._impl_._has_bits_);
  static const ::TSS::ApplyThemeChildCommandArchive& super(const DrawableApplyThemeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawableApplyThemeCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& style(const DrawableApplyThemeCommandArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::ApplyThemeChildCommandArchive&
DrawableApplyThemeCommandArchive::_Internal::super(const DrawableApplyThemeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableApplyThemeCommandArchive::_Internal::info(const DrawableApplyThemeCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::Reference&
DrawableApplyThemeCommandArchive::_Internal::style(const DrawableApplyThemeCommandArchive* msg) {
  return *msg->_impl_.style_;
}
void DrawableApplyThemeCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawableApplyThemeCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawableApplyThemeCommandArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
DrawableApplyThemeCommandArchive::DrawableApplyThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableApplyThemeCommandArchive)
}
DrawableApplyThemeCommandArchive::DrawableApplyThemeCommandArchive(const DrawableApplyThemeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableApplyThemeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::ApplyThemeChildCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableApplyThemeCommandArchive)
}

inline void DrawableApplyThemeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.style_){nullptr}
  };
}

DrawableApplyThemeCommandArchive::~DrawableApplyThemeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableApplyThemeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableApplyThemeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.style_;
}

void DrawableApplyThemeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableApplyThemeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableApplyThemeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.ApplyThemeChildCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableApplyThemeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableApplyThemeCommandArchive)
  return target;
}

size_t DrawableApplyThemeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableApplyThemeCommandArchive)
  size_t total_size = 0;

  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableApplyThemeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableApplyThemeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableApplyThemeCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableApplyThemeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableApplyThemeCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableApplyThemeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableApplyThemeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::ApplyThemeChildCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableApplyThemeCommandArchive::CopyFrom(const DrawableApplyThemeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableApplyThemeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableApplyThemeCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  return true;
}

void DrawableApplyThemeCommandArchive::InternalSwap(DrawableApplyThemeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableApplyThemeCommandArchive, _impl_.style_)
      + sizeof(DrawableApplyThemeCommandArchive::_impl_.style_)
      - PROTOBUF_FIELD_OFFSET(DrawableApplyThemeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableApplyThemeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[10]);
}

// ===================================================================

class StyledInfoSetStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyledInfoSetStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const StyledInfoSetStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const StyledInfoSetStyleCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& style(const StyledInfoSetStyleCommandArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
StyledInfoSetStyleCommandArchive::_Internal::super(const StyledInfoSetStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
StyledInfoSetStyleCommandArchive::_Internal::info(const StyledInfoSetStyleCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::Reference&
StyledInfoSetStyleCommandArchive::_Internal::style(const StyledInfoSetStyleCommandArchive* msg) {
  return *msg->_impl_.style_;
}
void StyledInfoSetStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StyledInfoSetStyleCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StyledInfoSetStyleCommandArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
StyledInfoSetStyleCommandArchive::StyledInfoSetStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.StyledInfoSetStyleCommandArchive)
}
StyledInfoSetStyleCommandArchive::StyledInfoSetStyleCommandArchive(const StyledInfoSetStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyledInfoSetStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.StyledInfoSetStyleCommandArchive)
}

inline void StyledInfoSetStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.style_){nullptr}
  };
}

StyledInfoSetStyleCommandArchive::~StyledInfoSetStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.StyledInfoSetStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyledInfoSetStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.style_;
}

void StyledInfoSetStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyledInfoSetStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.StyledInfoSetStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyledInfoSetStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyledInfoSetStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.StyledInfoSetStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.StyledInfoSetStyleCommandArchive)
  return target;
}

size_t StyledInfoSetStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.StyledInfoSetStyleCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyledInfoSetStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyledInfoSetStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyledInfoSetStyleCommandArchive::GetClassData() const { return &_class_data_; }


void StyledInfoSetStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyledInfoSetStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyledInfoSetStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.StyledInfoSetStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyledInfoSetStyleCommandArchive::CopyFrom(const StyledInfoSetStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.StyledInfoSetStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyledInfoSetStyleCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  return true;
}

void StyledInfoSetStyleCommandArchive::InternalSwap(StyledInfoSetStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyledInfoSetStyleCommandArchive, _impl_.style_)
      + sizeof(StyledInfoSetStyleCommandArchive::_impl_.style_)
      - PROTOBUF_FIELD_OFFSET(StyledInfoSetStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyledInfoSetStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[11]);
}

// ===================================================================

class ShapePathSourceFlipCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapePathSourceFlipCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ShapePathSourceFlipCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const ShapePathSourceFlipCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_newhorizontalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_newverticalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_oldhorizontalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_oldverticalflip(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ShapePathSourceFlipCommandArchive::_Internal::super(const ShapePathSourceFlipCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapePathSourceFlipCommandArchive::_Internal::info(const ShapePathSourceFlipCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void ShapePathSourceFlipCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapePathSourceFlipCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapePathSourceFlipCommandArchive::ShapePathSourceFlipCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapePathSourceFlipCommandArchive)
}
ShapePathSourceFlipCommandArchive::ShapePathSourceFlipCommandArchive(const ShapePathSourceFlipCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapePathSourceFlipCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newhorizontalflip_){}
    , decltype(_impl_.newverticalflip_){}
    , decltype(_impl_.oldhorizontalflip_){}
    , decltype(_impl_.oldverticalflip_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  ::memcpy(&_impl_.newhorizontalflip_, &from._impl_.newhorizontalflip_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.oldverticalflip_) -
    reinterpret_cast<char*>(&_impl_.newhorizontalflip_)) + sizeof(_impl_.oldverticalflip_));
  // @@protoc_insertion_point(copy_constructor:TSD.ShapePathSourceFlipCommandArchive)
}

inline void ShapePathSourceFlipCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newhorizontalflip_){false}
    , decltype(_impl_.newverticalflip_){false}
    , decltype(_impl_.oldhorizontalflip_){false}
    , decltype(_impl_.oldverticalflip_){false}
  };
}

ShapePathSourceFlipCommandArchive::~ShapePathSourceFlipCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapePathSourceFlipCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapePathSourceFlipCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void ShapePathSourceFlipCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapePathSourceFlipCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapePathSourceFlipCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  ::memset(&_impl_.newhorizontalflip_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.oldverticalflip_) -
      reinterpret_cast<char*>(&_impl_.newhorizontalflip_)) + sizeof(_impl_.oldverticalflip_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapePathSourceFlipCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool newHorizontalFlip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_newhorizontalflip(&has_bits);
          _impl_.newhorizontalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool newVerticalFlip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_newverticalflip(&has_bits);
          _impl_.newverticalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool oldHorizontalFlip = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_oldhorizontalflip(&has_bits);
          _impl_.oldhorizontalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool oldVerticalFlip = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_oldverticalflip(&has_bits);
          _impl_.oldverticalflip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapePathSourceFlipCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapePathSourceFlipCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional bool newHorizontalFlip = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_newhorizontalflip(), target);
  }

  // optional bool newVerticalFlip = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_newverticalflip(), target);
  }

  // optional bool oldHorizontalFlip = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_oldhorizontalflip(), target);
  }

  // optional bool oldVerticalFlip = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_oldverticalflip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapePathSourceFlipCommandArchive)
  return target;
}

size_t ShapePathSourceFlipCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapePathSourceFlipCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional bool newHorizontalFlip = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool newVerticalFlip = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool oldHorizontalFlip = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool oldVerticalFlip = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapePathSourceFlipCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapePathSourceFlipCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapePathSourceFlipCommandArchive::GetClassData() const { return &_class_data_; }


void ShapePathSourceFlipCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapePathSourceFlipCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapePathSourceFlipCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapePathSourceFlipCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.newhorizontalflip_ = from._impl_.newhorizontalflip_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.newverticalflip_ = from._impl_.newverticalflip_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.oldhorizontalflip_ = from._impl_.oldhorizontalflip_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.oldverticalflip_ = from._impl_.oldverticalflip_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapePathSourceFlipCommandArchive::CopyFrom(const ShapePathSourceFlipCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapePathSourceFlipCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapePathSourceFlipCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void ShapePathSourceFlipCommandArchive::InternalSwap(ShapePathSourceFlipCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapePathSourceFlipCommandArchive, _impl_.oldverticalflip_)
      + sizeof(ShapePathSourceFlipCommandArchive::_impl_.oldverticalflip_)
      - PROTOBUF_FIELD_OFFSET(ShapePathSourceFlipCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapePathSourceFlipCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[12]);
}

// ===================================================================

class ShapeStyleSetValueCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeStyleSetValueCommandArchive>()._impl_._has_bits_);
  static const ::TSD::StyledInfoSetStyleCommandArchive& super(const ShapeStyleSetValueCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::ShapeStylePropertiesArchive& shape_properties(const ShapeStyleSetValueCommandArchive* msg);
  static void set_has_shape_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::StyledInfoSetStyleCommandArchive&
ShapeStyleSetValueCommandArchive::_Internal::super(const ShapeStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::ShapeStylePropertiesArchive&
ShapeStyleSetValueCommandArchive::_Internal::shape_properties(const ShapeStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.shape_properties_;
}
void ShapeStyleSetValueCommandArchive::clear_shape_properties() {
  if (_impl_.shape_properties_ != nullptr) _impl_.shape_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeStyleSetValueCommandArchive)
}
ShapeStyleSetValueCommandArchive::ShapeStyleSetValueCommandArchive(const ShapeStyleSetValueCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeStyleSetValueCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::StyledInfoSetStyleCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_shape_properties()) {
    _this->_impl_.shape_properties_ = new ::TSD::ShapeStylePropertiesArchive(*from._impl_.shape_properties_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeStyleSetValueCommandArchive)
}

inline void ShapeStyleSetValueCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_properties_){nullptr}
  };
}

ShapeStyleSetValueCommandArchive::~ShapeStyleSetValueCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeStyleSetValueCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeStyleSetValueCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.shape_properties_;
}

void ShapeStyleSetValueCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeStyleSetValueCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shape_properties_ != nullptr);
      _impl_.shape_properties_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeStyleSetValueCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShapeStylePropertiesArchive shape_properties = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeStyleSetValueCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::shape_properties(this),
        _Internal::shape_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeStyleSetValueCommandArchive)
  return target;
}

size_t ShapeStyleSetValueCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeStyleSetValueCommandArchive)
  size_t total_size = 0;

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSD.ShapeStylePropertiesArchive shape_properties = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_properties_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeStyleSetValueCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeStyleSetValueCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeStyleSetValueCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeStyleSetValueCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeStyleSetValueCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeStyleSetValueCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeStyleSetValueCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::StyledInfoSetStyleCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shape_properties()->::TSD::ShapeStylePropertiesArchive::MergeFrom(
          from._internal_shape_properties());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeStyleSetValueCommandArchive::CopyFrom(const ShapeStyleSetValueCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeStyleSetValueCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeStyleSetValueCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_shape_properties()) {
    if (!_impl_.shape_properties_->IsInitialized()) return false;
  }
  return true;
}

void ShapeStyleSetValueCommandArchive::InternalSwap(ShapeStyleSetValueCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeStyleSetValueCommandArchive, _impl_.shape_properties_)
      + sizeof(ShapeStyleSetValueCommandArchive::_impl_.shape_properties_)
      - PROTOBUF_FIELD_OFFSET(ShapeStyleSetValueCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeStyleSetValueCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[13]);
}

// ===================================================================

class ShapeApplyPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeApplyPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSD::StyledInfoSetStyleCommandArchive& super(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& stylepreset(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_stylepreset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Color& colorpreset(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_colorpreset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::FillArchive& fillpreset(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_fillpreset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::ShadowArchive& shadowpreset(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_shadowpreset(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::StyledInfoSetStyleCommandArchive&
ShapeApplyPresetCommandArchive::_Internal::super(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapeApplyPresetCommandArchive::_Internal::stylepreset(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.stylepreset_;
}
const ::TSP::Color&
ShapeApplyPresetCommandArchive::_Internal::colorpreset(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.colorpreset_;
}
const ::TSD::FillArchive&
ShapeApplyPresetCommandArchive::_Internal::fillpreset(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.fillpreset_;
}
const ::TSD::ShadowArchive&
ShapeApplyPresetCommandArchive::_Internal::shadowpreset(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.shadowpreset_;
}
void ShapeApplyPresetCommandArchive::clear_stylepreset() {
  if (_impl_.stylepreset_ != nullptr) _impl_.stylepreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ShapeApplyPresetCommandArchive::clear_colorpreset() {
  if (_impl_.colorpreset_ != nullptr) _impl_.colorpreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ShapeApplyPresetCommandArchive::clear_fillpreset() {
  if (_impl_.fillpreset_ != nullptr) _impl_.fillpreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ShapeApplyPresetCommandArchive::clear_shadowpreset() {
  if (_impl_.shadowpreset_ != nullptr) _impl_.shadowpreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeApplyPresetCommandArchive)
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeApplyPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.stylepreset_){nullptr}
    , decltype(_impl_.colorpreset_){nullptr}
    , decltype(_impl_.fillpreset_){nullptr}
    , decltype(_impl_.shadowpreset_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::StyledInfoSetStyleCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_stylepreset()) {
    _this->_impl_.stylepreset_ = new ::TSP::Reference(*from._impl_.stylepreset_);
  }
  if (from._internal_has_colorpreset()) {
    _this->_impl_.colorpreset_ = new ::TSP::Color(*from._impl_.colorpreset_);
  }
  if (from._internal_has_fillpreset()) {
    _this->_impl_.fillpreset_ = new ::TSD::FillArchive(*from._impl_.fillpreset_);
  }
  if (from._internal_has_shadowpreset()) {
    _this->_impl_.shadowpreset_ = new ::TSD::ShadowArchive(*from._impl_.shadowpreset_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeApplyPresetCommandArchive)
}

inline void ShapeApplyPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.stylepreset_){nullptr}
    , decltype(_impl_.colorpreset_){nullptr}
    , decltype(_impl_.fillpreset_){nullptr}
    , decltype(_impl_.shadowpreset_){nullptr}
  };
}

ShapeApplyPresetCommandArchive::~ShapeApplyPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeApplyPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeApplyPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.stylepreset_;
  if (this != internal_default_instance()) delete _impl_.colorpreset_;
  if (this != internal_default_instance()) delete _impl_.fillpreset_;
  if (this != internal_default_instance()) delete _impl_.shadowpreset_;
}

void ShapeApplyPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeApplyPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stylepreset_ != nullptr);
      _impl_.stylepreset_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.colorpreset_ != nullptr);
      _impl_.colorpreset_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.fillpreset_ != nullptr);
      _impl_.fillpreset_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.shadowpreset_ != nullptr);
      _impl_.shadowpreset_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeApplyPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference stylepreset = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_stylepreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color colorpreset = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_colorpreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.FillArchive fillpreset = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_fillpreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadowpreset = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadowpreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeApplyPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference stylepreset = 10;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::stylepreset(this),
        _Internal::stylepreset(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color colorpreset = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::colorpreset(this),
        _Internal::colorpreset(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.FillArchive fillpreset = 12;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::fillpreset(this),
        _Internal::fillpreset(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShadowArchive shadowpreset = 13;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::shadowpreset(this),
        _Internal::shadowpreset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeApplyPresetCommandArchive)
  return target;
}

size_t ShapeApplyPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeApplyPresetCommandArchive)
  size_t total_size = 0;

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSP.Reference stylepreset = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stylepreset_);
    }

    // optional .TSP.Color colorpreset = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.colorpreset_);
    }

    // optional .TSD.FillArchive fillpreset = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.fillpreset_);
    }

    // optional .TSD.ShadowArchive shadowpreset = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadowpreset_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeApplyPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeApplyPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeApplyPresetCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeApplyPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeApplyPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeApplyPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeApplyPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::StyledInfoSetStyleCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stylepreset()->::TSP::Reference::MergeFrom(
          from._internal_stylepreset());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_colorpreset()->::TSP::Color::MergeFrom(
          from._internal_colorpreset());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_fillpreset()->::TSD::FillArchive::MergeFrom(
          from._internal_fillpreset());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_shadowpreset()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadowpreset());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeApplyPresetCommandArchive::CopyFrom(const ShapeApplyPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeApplyPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeApplyPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_stylepreset()) {
    if (!_impl_.stylepreset_->IsInitialized()) return false;
  }
  if (_internal_has_colorpreset()) {
    if (!_impl_.colorpreset_->IsInitialized()) return false;
  }
  if (_internal_has_fillpreset()) {
    if (!_impl_.fillpreset_->IsInitialized()) return false;
  }
  if (_internal_has_shadowpreset()) {
    if (!_impl_.shadowpreset_->IsInitialized()) return false;
  }
  return true;
}

void ShapeApplyPresetCommandArchive::InternalSwap(ShapeApplyPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeApplyPresetCommandArchive, _impl_.shadowpreset_)
      + sizeof(ShapeApplyPresetCommandArchive::_impl_.shadowpreset_)
      - PROTOBUF_FIELD_OFFSET(ShapeApplyPresetCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeApplyPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[14]);
}

// ===================================================================

class ShapeSetLineEndCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeSetLineEndCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ShapeSetLineEndCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& shape(const ShapeSetLineEndCommandArchive* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::LineEndArchive& line_end(const ShapeSetLineEndCommandArchive* msg);
  static void set_has_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_head_line_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ShapeSetLineEndCommandArchive::_Internal::super(const ShapeSetLineEndCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapeSetLineEndCommandArchive::_Internal::shape(const ShapeSetLineEndCommandArchive* msg) {
  return *msg->_impl_.shape_;
}
const ::TSD::LineEndArchive&
ShapeSetLineEndCommandArchive::_Internal::line_end(const ShapeSetLineEndCommandArchive* msg) {
  return *msg->_impl_.line_end_;
}
void ShapeSetLineEndCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapeSetLineEndCommandArchive::clear_shape() {
  if (_impl_.shape_ != nullptr) _impl_.shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ShapeSetLineEndCommandArchive::clear_line_end() {
  if (_impl_.line_end_ != nullptr) _impl_.line_end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ShapeSetLineEndCommandArchive::ShapeSetLineEndCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ShapeSetLineEndCommandArchive)
}
ShapeSetLineEndCommandArchive::ShapeSetLineEndCommandArchive(const ShapeSetLineEndCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeSetLineEndCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.line_end_){nullptr}
    , decltype(_impl_.is_head_line_end_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_shape()) {
    _this->_impl_.shape_ = new ::TSP::Reference(*from._impl_.shape_);
  }
  if (from._internal_has_line_end()) {
    _this->_impl_.line_end_ = new ::TSD::LineEndArchive(*from._impl_.line_end_);
  }
  _this->_impl_.is_head_line_end_ = from._impl_.is_head_line_end_;
  // @@protoc_insertion_point(copy_constructor:TSD.ShapeSetLineEndCommandArchive)
}

inline void ShapeSetLineEndCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.line_end_){nullptr}
    , decltype(_impl_.is_head_line_end_){false}
  };
}

ShapeSetLineEndCommandArchive::~ShapeSetLineEndCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ShapeSetLineEndCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeSetLineEndCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.shape_;
  if (this != internal_default_instance()) delete _impl_.line_end_;
}

void ShapeSetLineEndCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeSetLineEndCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ShapeSetLineEndCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.shape_ != nullptr);
      _impl_.shape_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.line_end_ != nullptr);
      _impl_.line_end_->Clear();
    }
  }
  _impl_.is_head_line_end_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeSetLineEndCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference shape = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.LineEndArchive line_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_line_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_head_line_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_head_line_end(&has_bits);
          _impl_.is_head_line_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeSetLineEndCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ShapeSetLineEndCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference shape = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::shape(this),
        _Internal::shape(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.LineEndArchive line_end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::line_end(this),
        _Internal::line_end(this).GetCachedSize(), target, stream);
  }

  // optional bool is_head_line_end = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_head_line_end(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ShapeSetLineEndCommandArchive)
  return target;
}

size_t ShapeSetLineEndCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ShapeSetLineEndCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference shape = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_);
    }

    // optional .TSD.LineEndArchive line_end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.line_end_);
    }

    // optional bool is_head_line_end = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeSetLineEndCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeSetLineEndCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeSetLineEndCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeSetLineEndCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeSetLineEndCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeSetLineEndCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ShapeSetLineEndCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_shape()->::TSP::Reference::MergeFrom(
          from._internal_shape());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_line_end()->::TSD::LineEndArchive::MergeFrom(
          from._internal_line_end());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_head_line_end_ = from._impl_.is_head_line_end_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeSetLineEndCommandArchive::CopyFrom(const ShapeSetLineEndCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ShapeSetLineEndCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeSetLineEndCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_shape()) {
    if (!_impl_.shape_->IsInitialized()) return false;
  }
  if (_internal_has_line_end()) {
    if (!_impl_.line_end_->IsInitialized()) return false;
  }
  return true;
}

void ShapeSetLineEndCommandArchive::InternalSwap(ShapeSetLineEndCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeSetLineEndCommandArchive, _impl_.is_head_line_end_)
      + sizeof(ShapeSetLineEndCommandArchive::_impl_.is_head_line_end_)
      - PROTOBUF_FIELD_OFFSET(ShapeSetLineEndCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeSetLineEndCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[15]);
}

// ===================================================================

class MovieSetValueCommandArchive_PropertyValue::_Internal {
 public:
  using HasBits = decltype(std::declval<MovieSetValueCommandArchive_PropertyValue>()._impl_._has_bits_);
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endtime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_postertime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::DataReference& posterimagedata(const MovieSetValueCommandArchive_PropertyValue* msg);
  static void set_has_posterimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_autoplay(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_loopoption(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::DataReference& media(const MovieSetValueCommandArchive_PropertyValue* msg);
  static void set_has_media(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::DataReference& importedauxiliarymedia(const MovieSetValueCommandArchive_PropertyValue* msg);
  static void set_has_importedauxiliarymedia(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::DataReference&
MovieSetValueCommandArchive_PropertyValue::_Internal::posterimagedata(const MovieSetValueCommandArchive_PropertyValue* msg) {
  return *msg->_impl_.posterimagedata_;
}
const ::TSP::DataReference&
MovieSetValueCommandArchive_PropertyValue::_Internal::media(const MovieSetValueCommandArchive_PropertyValue* msg) {
  return *msg->_impl_.media_;
}
const ::TSP::DataReference&
MovieSetValueCommandArchive_PropertyValue::_Internal::importedauxiliarymedia(const MovieSetValueCommandArchive_PropertyValue* msg) {
  return *msg->_impl_.importedauxiliarymedia_;
}
void MovieSetValueCommandArchive_PropertyValue::clear_posterimagedata() {
  if (_impl_.posterimagedata_ != nullptr) _impl_.posterimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MovieSetValueCommandArchive_PropertyValue::clear_media() {
  if (_impl_.media_ != nullptr) _impl_.media_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MovieSetValueCommandArchive_PropertyValue::clear_importedauxiliarymedia() {
  if (_impl_.importedauxiliarymedia_ != nullptr) _impl_.importedauxiliarymedia_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MovieSetValueCommandArchive_PropertyValue::MovieSetValueCommandArchive_PropertyValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieSetValueCommandArchive.PropertyValue)
}
MovieSetValueCommandArchive_PropertyValue::MovieSetValueCommandArchive_PropertyValue(const MovieSetValueCommandArchive_PropertyValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieSetValueCommandArchive_PropertyValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.media_){nullptr}
    , decltype(_impl_.importedauxiliarymedia_){nullptr}
    , decltype(_impl_.starttime_){}
    , decltype(_impl_.endtime_){}
    , decltype(_impl_.postertime_){}
    , decltype(_impl_.autoplay_){}
    , decltype(_impl_.loopoption_){}
    , decltype(_impl_.volume_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_posterimagedata()) {
    _this->_impl_.posterimagedata_ = new ::TSP::DataReference(*from._impl_.posterimagedata_);
  }
  if (from._internal_has_media()) {
    _this->_impl_.media_ = new ::TSP::DataReference(*from._impl_.media_);
  }
  if (from._internal_has_importedauxiliarymedia()) {
    _this->_impl_.importedauxiliarymedia_ = new ::TSP::DataReference(*from._impl_.importedauxiliarymedia_);
  }
  ::memcpy(&_impl_.starttime_, &from._impl_.starttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.volume_) -
    reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.volume_));
  // @@protoc_insertion_point(copy_constructor:TSD.MovieSetValueCommandArchive.PropertyValue)
}

inline void MovieSetValueCommandArchive_PropertyValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posterimagedata_){nullptr}
    , decltype(_impl_.media_){nullptr}
    , decltype(_impl_.importedauxiliarymedia_){nullptr}
    , decltype(_impl_.starttime_){0}
    , decltype(_impl_.endtime_){0}
    , decltype(_impl_.postertime_){0}
    , decltype(_impl_.autoplay_){false}
    , decltype(_impl_.loopoption_){0}
    , decltype(_impl_.volume_){0}
  };
}

MovieSetValueCommandArchive_PropertyValue::~MovieSetValueCommandArchive_PropertyValue() {
  // @@protoc_insertion_point(destructor:TSD.MovieSetValueCommandArchive.PropertyValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieSetValueCommandArchive_PropertyValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.posterimagedata_;
  if (this != internal_default_instance()) delete _impl_.media_;
  if (this != internal_default_instance()) delete _impl_.importedauxiliarymedia_;
}

void MovieSetValueCommandArchive_PropertyValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieSetValueCommandArchive_PropertyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieSetValueCommandArchive.PropertyValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.posterimagedata_ != nullptr);
      _impl_.posterimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.media_ != nullptr);
      _impl_.media_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.importedauxiliarymedia_ != nullptr);
      _impl_.importedauxiliarymedia_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.starttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.loopoption_) -
        reinterpret_cast<char*>(&_impl_.starttime_)) + sizeof(_impl_.loopoption_));
  }
  _impl_.volume_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieSetValueCommandArchive_PropertyValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double starttime = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_starttime(&has_bits);
          _impl_.starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double endtime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_endtime(&has_bits);
          _impl_.endtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double postertime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_postertime(&has_bits);
          _impl_.postertime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference posterimagedata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_posterimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoplay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_autoplay(&has_bits);
          _impl_.autoplay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::MovieSetValueCommandArchive_LoopOption_IsValid(val))) {
            _internal_set_loopoption(static_cast<::TSD::MovieSetValueCommandArchive_LoopOption>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float volume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference media = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_media(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference importedauxiliarymedia = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_importedauxiliarymedia(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieSetValueCommandArchive_PropertyValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieSetValueCommandArchive.PropertyValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double starttime = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_starttime(), target);
  }

  // optional double endtime = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_endtime(), target);
  }

  // optional double postertime = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_postertime(), target);
  }

  // optional .TSP.DataReference posterimagedata = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::posterimagedata(this),
        _Internal::posterimagedata(this).GetCachedSize(), target, stream);
  }

  // optional bool autoplay = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_autoplay(), target);
  }

  // optional .TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_loopoption(), target);
  }

  // optional float volume = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_volume(), target);
  }

  // optional .TSP.DataReference media = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::media(this),
        _Internal::media(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference importedauxiliarymedia = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::importedauxiliarymedia(this),
        _Internal::importedauxiliarymedia(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieSetValueCommandArchive.PropertyValue)
  return target;
}

size_t MovieSetValueCommandArchive_PropertyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieSetValueCommandArchive.PropertyValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.DataReference posterimagedata = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.posterimagedata_);
    }

    // optional .TSP.DataReference media = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.media_);
    }

    // optional .TSP.DataReference importedauxiliarymedia = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.importedauxiliarymedia_);
    }

    // optional double starttime = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double endtime = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

    // optional double postertime = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional bool autoplay = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_loopoption());
    }

  }
  // optional float volume = 7;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieSetValueCommandArchive_PropertyValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieSetValueCommandArchive_PropertyValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieSetValueCommandArchive_PropertyValue::GetClassData() const { return &_class_data_; }


void MovieSetValueCommandArchive_PropertyValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieSetValueCommandArchive_PropertyValue*>(&to_msg);
  auto& from = static_cast<const MovieSetValueCommandArchive_PropertyValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieSetValueCommandArchive.PropertyValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_posterimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_posterimagedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_media()->::TSP::DataReference::MergeFrom(
          from._internal_media());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_importedauxiliarymedia()->::TSP::DataReference::MergeFrom(
          from._internal_importedauxiliarymedia());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.starttime_ = from._impl_.starttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.endtime_ = from._impl_.endtime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.postertime_ = from._impl_.postertime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.autoplay_ = from._impl_.autoplay_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.loopoption_ = from._impl_.loopoption_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_volume(from._internal_volume());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieSetValueCommandArchive_PropertyValue::CopyFrom(const MovieSetValueCommandArchive_PropertyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieSetValueCommandArchive.PropertyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieSetValueCommandArchive_PropertyValue::IsInitialized() const {
  if (_internal_has_posterimagedata()) {
    if (!_impl_.posterimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_media()) {
    if (!_impl_.media_->IsInitialized()) return false;
  }
  if (_internal_has_importedauxiliarymedia()) {
    if (!_impl_.importedauxiliarymedia_->IsInitialized()) return false;
  }
  return true;
}

void MovieSetValueCommandArchive_PropertyValue::InternalSwap(MovieSetValueCommandArchive_PropertyValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovieSetValueCommandArchive_PropertyValue, _impl_.volume_)
      + sizeof(MovieSetValueCommandArchive_PropertyValue::_impl_.volume_)
      - PROTOBUF_FIELD_OFFSET(MovieSetValueCommandArchive_PropertyValue, _impl_.posterimagedata_)>(
          reinterpret_cast<char*>(&_impl_.posterimagedata_),
          reinterpret_cast<char*>(&other->_impl_.posterimagedata_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieSetValueCommandArchive_PropertyValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[16]);
}

// ===================================================================

class MovieSetValueCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MovieSetValueCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MovieSetValueCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& movie(const MovieSetValueCommandArchive* msg);
  static void set_has_movie(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_deprecated_property(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_property(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSD::MovieSetValueCommandArchive_PropertyValue& value(const MovieSetValueCommandArchive* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSK::CommandArchive&
MovieSetValueCommandArchive::_Internal::super(const MovieSetValueCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MovieSetValueCommandArchive::_Internal::movie(const MovieSetValueCommandArchive* msg) {
  return *msg->_impl_.movie_;
}
const ::TSD::MovieSetValueCommandArchive_PropertyValue&
MovieSetValueCommandArchive::_Internal::value(const MovieSetValueCommandArchive* msg) {
  return *msg->_impl_.value_;
}
void MovieSetValueCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MovieSetValueCommandArchive::clear_movie() {
  if (_impl_.movie_ != nullptr) _impl_.movie_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MovieSetValueCommandArchive::MovieSetValueCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MovieSetValueCommandArchive)
}
MovieSetValueCommandArchive::MovieSetValueCommandArchive(const MovieSetValueCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MovieSetValueCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.movie_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.property_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.deprecated_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_deprecated_property()) {
    _this->_impl_.deprecated_property_.Set(from._internal_deprecated_property(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_movie()) {
    _this->_impl_.movie_ = new ::TSP::Reference(*from._impl_.movie_);
  }
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::TSD::MovieSetValueCommandArchive_PropertyValue(*from._impl_.value_);
  }
  _this->_impl_.property_ = from._impl_.property_;
  // @@protoc_insertion_point(copy_constructor:TSD.MovieSetValueCommandArchive)
}

inline void MovieSetValueCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.deprecated_property_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.movie_){nullptr}
    , decltype(_impl_.value_){nullptr}
    , decltype(_impl_.property_){0}
  };
  _impl_.deprecated_property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MovieSetValueCommandArchive::~MovieSetValueCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.MovieSetValueCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MovieSetValueCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.deprecated_property_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.movie_;
  if (this != internal_default_instance()) delete _impl_.value_;
}

void MovieSetValueCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MovieSetValueCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MovieSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.deprecated_property_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.movie_ != nullptr);
      _impl_.movie_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.value_ != nullptr);
      _impl_.value_->Clear();
    }
  }
  _impl_.property_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovieSetValueCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference movie = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_movie(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string deprecated_property = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_deprecated_property();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.MovieSetValueCommandArchive.deprecated_property");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 property = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_property(&has_bits);
          _impl_.property_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MovieSetValueCommandArchive.PropertyValue value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MovieSetValueCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MovieSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference movie = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::movie(this),
        _Internal::movie(this).GetCachedSize(), target, stream);
  }

  // optional string deprecated_property = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_deprecated_property().data(), static_cast<int>(this->_internal_deprecated_property().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.MovieSetValueCommandArchive.deprecated_property");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_deprecated_property(), target);
  }

  // optional int32 property = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_property(), target);
  }

  // optional .TSD.MovieSetValueCommandArchive.PropertyValue value = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MovieSetValueCommandArchive)
  return target;
}

size_t MovieSetValueCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MovieSetValueCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string deprecated_property = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_deprecated_property());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .TSP.Reference movie = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.movie_);
    }

    // optional .TSD.MovieSetValueCommandArchive.PropertyValue value = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.value_);
    }

    // optional int32 property = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_property());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MovieSetValueCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MovieSetValueCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MovieSetValueCommandArchive::GetClassData() const { return &_class_data_; }


void MovieSetValueCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MovieSetValueCommandArchive*>(&to_msg);
  auto& from = static_cast<const MovieSetValueCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MovieSetValueCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_deprecated_property(from._internal_deprecated_property());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_movie()->::TSP::Reference::MergeFrom(
          from._internal_movie());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_value()->::TSD::MovieSetValueCommandArchive_PropertyValue::MergeFrom(
          from._internal_value());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.property_ = from._impl_.property_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MovieSetValueCommandArchive::CopyFrom(const MovieSetValueCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MovieSetValueCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieSetValueCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_movie()) {
    if (!_impl_.movie_->IsInitialized()) return false;
  }
  if (_internal_has_value()) {
    if (!_impl_.value_->IsInitialized()) return false;
  }
  return true;
}

void MovieSetValueCommandArchive::InternalSwap(MovieSetValueCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.deprecated_property_, lhs_arena,
      &other->_impl_.deprecated_property_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovieSetValueCommandArchive, _impl_.property_)
      + sizeof(MovieSetValueCommandArchive::_impl_.property_)
      - PROTOBUF_FIELD_OFFSET(MovieSetValueCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovieSetValueCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[17]);
}

// ===================================================================

class MediaStyleSetValueCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaStyleSetValueCommandArchive>()._impl_._has_bits_);
  static const ::TSD::StyledInfoSetStyleCommandArchive& super(const MediaStyleSetValueCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::MediaStylePropertiesArchive& media_properties(const MediaStyleSetValueCommandArchive* msg);
  static void set_has_media_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::StyledInfoSetStyleCommandArchive&
MediaStyleSetValueCommandArchive::_Internal::super(const MediaStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::MediaStylePropertiesArchive&
MediaStyleSetValueCommandArchive::_Internal::media_properties(const MediaStyleSetValueCommandArchive* msg) {
  return *msg->_impl_.media_properties_;
}
void MediaStyleSetValueCommandArchive::clear_media_properties() {
  if (_impl_.media_properties_ != nullptr) _impl_.media_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MediaStyleSetValueCommandArchive::MediaStyleSetValueCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaStyleSetValueCommandArchive)
}
MediaStyleSetValueCommandArchive::MediaStyleSetValueCommandArchive(const MediaStyleSetValueCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaStyleSetValueCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::StyledInfoSetStyleCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_media_properties()) {
    _this->_impl_.media_properties_ = new ::TSD::MediaStylePropertiesArchive(*from._impl_.media_properties_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.MediaStyleSetValueCommandArchive)
}

inline void MediaStyleSetValueCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.media_properties_){nullptr}
  };
}

MediaStyleSetValueCommandArchive::~MediaStyleSetValueCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaStyleSetValueCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaStyleSetValueCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.media_properties_;
}

void MediaStyleSetValueCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaStyleSetValueCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.media_properties_ != nullptr);
      _impl_.media_properties_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaStyleSetValueCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.MediaStylePropertiesArchive media_properties = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_media_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaStyleSetValueCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaStyleSetValueCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.MediaStylePropertiesArchive media_properties = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::media_properties(this),
        _Internal::media_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaStyleSetValueCommandArchive)
  return target;
}

size_t MediaStyleSetValueCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaStyleSetValueCommandArchive)
  size_t total_size = 0;

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSD.MediaStylePropertiesArchive media_properties = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.media_properties_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaStyleSetValueCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaStyleSetValueCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaStyleSetValueCommandArchive::GetClassData() const { return &_class_data_; }


void MediaStyleSetValueCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaStyleSetValueCommandArchive*>(&to_msg);
  auto& from = static_cast<const MediaStyleSetValueCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaStyleSetValueCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::StyledInfoSetStyleCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_media_properties()->::TSD::MediaStylePropertiesArchive::MergeFrom(
          from._internal_media_properties());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaStyleSetValueCommandArchive::CopyFrom(const MediaStyleSetValueCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaStyleSetValueCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaStyleSetValueCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_media_properties()) {
    if (!_impl_.media_properties_->IsInitialized()) return false;
  }
  return true;
}

void MediaStyleSetValueCommandArchive::InternalSwap(MediaStyleSetValueCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaStyleSetValueCommandArchive, _impl_.media_properties_)
      + sizeof(MediaStyleSetValueCommandArchive::_impl_.media_properties_)
      - PROTOBUF_FIELD_OFFSET(MediaStyleSetValueCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaStyleSetValueCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[18]);
}

// ===================================================================

class ImageMediaCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageMediaCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ImageMediaCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const ImageMediaCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::DataReference& newimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_newimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::DataReference& oldimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_oldimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::DataReference& oldoriginalimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_oldoriginalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Size& oldnaturalsize(const ImageMediaCommandArchive* msg);
  static void set_has_oldnaturalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::DataReference& neworiginalimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_neworiginalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSD::ImageAdjustmentsArchive& oldimageadjustments(const ImageMediaCommandArchive* msg);
  static void set_has_oldimageadjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::DataReference& oldadjustedimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_oldadjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::DataReference& oldenhancedimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_oldenhancedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSP::Reference& database_newimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_database_newimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& database_oldimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_database_oldimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& database_oldoriginalimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_database_oldoriginalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& database_neworiginalimagedata(const ImageMediaCommandArchive* msg);
  static void set_has_database_neworiginalimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ImageMediaCommandArchive::_Internal::super(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ImageMediaCommandArchive::_Internal::info(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::newimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.newimagedata_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::oldimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldimagedata_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::oldoriginalimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldoriginalimagedata_;
}
const ::TSP::Size&
ImageMediaCommandArchive::_Internal::oldnaturalsize(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldnaturalsize_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::neworiginalimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.neworiginalimagedata_;
}
const ::TSD::ImageAdjustmentsArchive&
ImageMediaCommandArchive::_Internal::oldimageadjustments(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldimageadjustments_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::oldadjustedimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldadjustedimagedata_;
}
const ::TSP::DataReference&
ImageMediaCommandArchive::_Internal::oldenhancedimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.oldenhancedimagedata_;
}
const ::TSP::Reference&
ImageMediaCommandArchive::_Internal::database_newimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.database_newimagedata_;
}
const ::TSP::Reference&
ImageMediaCommandArchive::_Internal::database_oldimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.database_oldimagedata_;
}
const ::TSP::Reference&
ImageMediaCommandArchive::_Internal::database_oldoriginalimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.database_oldoriginalimagedata_;
}
const ::TSP::Reference&
ImageMediaCommandArchive::_Internal::database_neworiginalimagedata(const ImageMediaCommandArchive* msg) {
  return *msg->_impl_.database_neworiginalimagedata_;
}
void ImageMediaCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ImageMediaCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageMediaCommandArchive::clear_newimagedata() {
  if (_impl_.newimagedata_ != nullptr) _impl_.newimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void ImageMediaCommandArchive::clear_oldimagedata() {
  if (_impl_.oldimagedata_ != nullptr) _impl_.oldimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void ImageMediaCommandArchive::clear_oldoriginalimagedata() {
  if (_impl_.oldoriginalimagedata_ != nullptr) _impl_.oldoriginalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void ImageMediaCommandArchive::clear_oldnaturalsize() {
  if (_impl_.oldnaturalsize_ != nullptr) _impl_.oldnaturalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageMediaCommandArchive::clear_neworiginalimagedata() {
  if (_impl_.neworiginalimagedata_ != nullptr) _impl_.neworiginalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void ImageMediaCommandArchive::clear_oldimageadjustments() {
  if (_impl_.oldimageadjustments_ != nullptr) _impl_.oldimageadjustments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void ImageMediaCommandArchive::clear_oldadjustedimagedata() {
  if (_impl_.oldadjustedimagedata_ != nullptr) _impl_.oldadjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void ImageMediaCommandArchive::clear_oldenhancedimagedata() {
  if (_impl_.oldenhancedimagedata_ != nullptr) _impl_.oldenhancedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void ImageMediaCommandArchive::clear_database_newimagedata() {
  if (_impl_.database_newimagedata_ != nullptr) _impl_.database_newimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageMediaCommandArchive::clear_database_oldimagedata() {
  if (_impl_.database_oldimagedata_ != nullptr) _impl_.database_oldimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ImageMediaCommandArchive::clear_database_oldoriginalimagedata() {
  if (_impl_.database_oldoriginalimagedata_ != nullptr) _impl_.database_oldoriginalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageMediaCommandArchive::clear_database_neworiginalimagedata() {
  if (_impl_.database_neworiginalimagedata_ != nullptr) _impl_.database_neworiginalimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
ImageMediaCommandArchive::ImageMediaCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageMediaCommandArchive)
}
ImageMediaCommandArchive::ImageMediaCommandArchive(const ImageMediaCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageMediaCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.database_newimagedata_){nullptr}
    , decltype(_impl_.database_oldimagedata_){nullptr}
    , decltype(_impl_.database_oldoriginalimagedata_){nullptr}
    , decltype(_impl_.oldnaturalsize_){nullptr}
    , decltype(_impl_.database_neworiginalimagedata_){nullptr}
    , decltype(_impl_.newimagedata_){nullptr}
    , decltype(_impl_.oldimagedata_){nullptr}
    , decltype(_impl_.oldoriginalimagedata_){nullptr}
    , decltype(_impl_.neworiginalimagedata_){nullptr}
    , decltype(_impl_.oldimageadjustments_){nullptr}
    , decltype(_impl_.oldadjustedimagedata_){nullptr}
    , decltype(_impl_.oldenhancedimagedata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_database_newimagedata()) {
    _this->_impl_.database_newimagedata_ = new ::TSP::Reference(*from._impl_.database_newimagedata_);
  }
  if (from._internal_has_database_oldimagedata()) {
    _this->_impl_.database_oldimagedata_ = new ::TSP::Reference(*from._impl_.database_oldimagedata_);
  }
  if (from._internal_has_database_oldoriginalimagedata()) {
    _this->_impl_.database_oldoriginalimagedata_ = new ::TSP::Reference(*from._impl_.database_oldoriginalimagedata_);
  }
  if (from._internal_has_oldnaturalsize()) {
    _this->_impl_.oldnaturalsize_ = new ::TSP::Size(*from._impl_.oldnaturalsize_);
  }
  if (from._internal_has_database_neworiginalimagedata()) {
    _this->_impl_.database_neworiginalimagedata_ = new ::TSP::Reference(*from._impl_.database_neworiginalimagedata_);
  }
  if (from._internal_has_newimagedata()) {
    _this->_impl_.newimagedata_ = new ::TSP::DataReference(*from._impl_.newimagedata_);
  }
  if (from._internal_has_oldimagedata()) {
    _this->_impl_.oldimagedata_ = new ::TSP::DataReference(*from._impl_.oldimagedata_);
  }
  if (from._internal_has_oldoriginalimagedata()) {
    _this->_impl_.oldoriginalimagedata_ = new ::TSP::DataReference(*from._impl_.oldoriginalimagedata_);
  }
  if (from._internal_has_neworiginalimagedata()) {
    _this->_impl_.neworiginalimagedata_ = new ::TSP::DataReference(*from._impl_.neworiginalimagedata_);
  }
  if (from._internal_has_oldimageadjustments()) {
    _this->_impl_.oldimageadjustments_ = new ::TSD::ImageAdjustmentsArchive(*from._impl_.oldimageadjustments_);
  }
  if (from._internal_has_oldadjustedimagedata()) {
    _this->_impl_.oldadjustedimagedata_ = new ::TSP::DataReference(*from._impl_.oldadjustedimagedata_);
  }
  if (from._internal_has_oldenhancedimagedata()) {
    _this->_impl_.oldenhancedimagedata_ = new ::TSP::DataReference(*from._impl_.oldenhancedimagedata_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ImageMediaCommandArchive)
}

inline void ImageMediaCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.database_newimagedata_){nullptr}
    , decltype(_impl_.database_oldimagedata_){nullptr}
    , decltype(_impl_.database_oldoriginalimagedata_){nullptr}
    , decltype(_impl_.oldnaturalsize_){nullptr}
    , decltype(_impl_.database_neworiginalimagedata_){nullptr}
    , decltype(_impl_.newimagedata_){nullptr}
    , decltype(_impl_.oldimagedata_){nullptr}
    , decltype(_impl_.oldoriginalimagedata_){nullptr}
    , decltype(_impl_.neworiginalimagedata_){nullptr}
    , decltype(_impl_.oldimageadjustments_){nullptr}
    , decltype(_impl_.oldadjustedimagedata_){nullptr}
    , decltype(_impl_.oldenhancedimagedata_){nullptr}
  };
}

ImageMediaCommandArchive::~ImageMediaCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageMediaCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageMediaCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.database_newimagedata_;
  if (this != internal_default_instance()) delete _impl_.database_oldimagedata_;
  if (this != internal_default_instance()) delete _impl_.database_oldoriginalimagedata_;
  if (this != internal_default_instance()) delete _impl_.oldnaturalsize_;
  if (this != internal_default_instance()) delete _impl_.database_neworiginalimagedata_;
  if (this != internal_default_instance()) delete _impl_.newimagedata_;
  if (this != internal_default_instance()) delete _impl_.oldimagedata_;
  if (this != internal_default_instance()) delete _impl_.oldoriginalimagedata_;
  if (this != internal_default_instance()) delete _impl_.neworiginalimagedata_;
  if (this != internal_default_instance()) delete _impl_.oldimageadjustments_;
  if (this != internal_default_instance()) delete _impl_.oldadjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.oldenhancedimagedata_;
}

void ImageMediaCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageMediaCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageMediaCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.database_newimagedata_ != nullptr);
      _impl_.database_newimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.database_oldimagedata_ != nullptr);
      _impl_.database_oldimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.database_oldoriginalimagedata_ != nullptr);
      _impl_.database_oldoriginalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.oldnaturalsize_ != nullptr);
      _impl_.oldnaturalsize_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.database_neworiginalimagedata_ != nullptr);
      _impl_.database_neworiginalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.newimagedata_ != nullptr);
      _impl_.newimagedata_->Clear();
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.oldimagedata_ != nullptr);
      _impl_.oldimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.oldoriginalimagedata_ != nullptr);
      _impl_.oldoriginalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.neworiginalimagedata_ != nullptr);
      _impl_.neworiginalimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.oldimageadjustments_ != nullptr);
      _impl_.oldimageadjustments_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.oldadjustedimagedata_ != nullptr);
      _impl_.oldadjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.oldenhancedimagedata_ != nullptr);
      _impl_.oldenhancedimagedata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageMediaCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_newImageData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_newimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_oldImageData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_oldimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_oldOriginalImageData = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_oldoriginalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size oldNaturalSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldnaturalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference database_newOriginalImageData = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_database_neworiginalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference newImageData = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_newimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference oldImageData = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference oldOriginalImageData = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldoriginalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference newOriginalImageData = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_neworiginalimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageAdjustmentsArchive oldImageAdjustments = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldimageadjustments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference oldAdjustedImageData = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldadjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference oldEnhancedImageData = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldenhancedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageMediaCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageMediaCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_newImageData = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::database_newimagedata(this),
        _Internal::database_newimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_oldImageData = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::database_oldimagedata(this),
        _Internal::database_oldimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_oldOriginalImageData = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::database_oldoriginalimagedata(this),
        _Internal::database_oldoriginalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size oldNaturalSize = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::oldnaturalsize(this),
        _Internal::oldnaturalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference database_newOriginalImageData = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::database_neworiginalimagedata(this),
        _Internal::database_neworiginalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference newImageData = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::newimagedata(this),
        _Internal::newimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference oldImageData = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::oldimagedata(this),
        _Internal::oldimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference oldOriginalImageData = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::oldoriginalimagedata(this),
        _Internal::oldoriginalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference newOriginalImageData = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::neworiginalimagedata(this),
        _Internal::neworiginalimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageAdjustmentsArchive oldImageAdjustments = 12;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::oldimageadjustments(this),
        _Internal::oldimageadjustments(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference oldAdjustedImageData = 13;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::oldadjustedimagedata(this),
        _Internal::oldadjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference oldEnhancedImageData = 14;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::oldenhancedimagedata(this),
        _Internal::oldenhancedimagedata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageMediaCommandArchive)
  return target;
}

size_t ImageMediaCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageMediaCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Reference database_newImageData = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_newimagedata_);
    }

    // optional .TSP.Reference database_oldImageData = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_oldimagedata_);
    }

    // optional .TSP.Reference database_oldOriginalImageData = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_oldoriginalimagedata_);
    }

    // optional .TSP.Size oldNaturalSize = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldnaturalsize_);
    }

    // optional .TSP.Reference database_newOriginalImageData = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.database_neworiginalimagedata_);
    }

    // optional .TSP.DataReference newImageData = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newimagedata_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .TSP.DataReference oldImageData = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldimagedata_);
    }

    // optional .TSP.DataReference oldOriginalImageData = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldoriginalimagedata_);
    }

    // optional .TSP.DataReference newOriginalImageData = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.neworiginalimagedata_);
    }

    // optional .TSD.ImageAdjustmentsArchive oldImageAdjustments = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldimageadjustments_);
    }

    // optional .TSP.DataReference oldAdjustedImageData = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldadjustedimagedata_);
    }

    // optional .TSP.DataReference oldEnhancedImageData = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldenhancedimagedata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageMediaCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageMediaCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageMediaCommandArchive::GetClassData() const { return &_class_data_; }


void ImageMediaCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageMediaCommandArchive*>(&to_msg);
  auto& from = static_cast<const ImageMediaCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageMediaCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_database_newimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_newimagedata());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_database_oldimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_oldimagedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_database_oldoriginalimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_oldoriginalimagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_oldnaturalsize()->::TSP::Size::MergeFrom(
          from._internal_oldnaturalsize());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_database_neworiginalimagedata()->::TSP::Reference::MergeFrom(
          from._internal_database_neworiginalimagedata());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_newimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_newimagedata());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_oldimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_oldimagedata());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_oldoriginalimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_oldoriginalimagedata());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_neworiginalimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_neworiginalimagedata());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_oldimageadjustments()->::TSD::ImageAdjustmentsArchive::MergeFrom(
          from._internal_oldimageadjustments());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_oldadjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_oldadjustedimagedata());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_oldenhancedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_oldenhancedimagedata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageMediaCommandArchive::CopyFrom(const ImageMediaCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageMediaCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageMediaCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_database_newimagedata()) {
    if (!_impl_.database_newimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_oldimagedata()) {
    if (!_impl_.database_oldimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_database_oldoriginalimagedata()) {
    if (!_impl_.database_oldoriginalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_oldnaturalsize()) {
    if (!_impl_.oldnaturalsize_->IsInitialized()) return false;
  }
  if (_internal_has_database_neworiginalimagedata()) {
    if (!_impl_.database_neworiginalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_newimagedata()) {
    if (!_impl_.newimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_oldimagedata()) {
    if (!_impl_.oldimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_oldoriginalimagedata()) {
    if (!_impl_.oldoriginalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_neworiginalimagedata()) {
    if (!_impl_.neworiginalimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_oldadjustedimagedata()) {
    if (!_impl_.oldadjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_oldenhancedimagedata()) {
    if (!_impl_.oldenhancedimagedata_->IsInitialized()) return false;
  }
  return true;
}

void ImageMediaCommandArchive::InternalSwap(ImageMediaCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageMediaCommandArchive, _impl_.oldenhancedimagedata_)
      + sizeof(ImageMediaCommandArchive::_impl_.oldenhancedimagedata_)
      - PROTOBUF_FIELD_OFFSET(ImageMediaCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageMediaCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[19]);
}

// ===================================================================

class MediaOriginalSizeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaOriginalSizeCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MediaOriginalSizeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const MediaOriginalSizeCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& neworiginalsize(const MediaOriginalSizeCommandArchive* msg);
  static void set_has_neworiginalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Size& oldoriginalsize(const MediaOriginalSizeCommandArchive* msg);
  static void set_has_oldoriginalsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MediaOriginalSizeCommandArchive::_Internal::super(const MediaOriginalSizeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MediaOriginalSizeCommandArchive::_Internal::info(const MediaOriginalSizeCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::Size&
MediaOriginalSizeCommandArchive::_Internal::neworiginalsize(const MediaOriginalSizeCommandArchive* msg) {
  return *msg->_impl_.neworiginalsize_;
}
const ::TSP::Size&
MediaOriginalSizeCommandArchive::_Internal::oldoriginalsize(const MediaOriginalSizeCommandArchive* msg) {
  return *msg->_impl_.oldoriginalsize_;
}
void MediaOriginalSizeCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MediaOriginalSizeCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MediaOriginalSizeCommandArchive::clear_neworiginalsize() {
  if (_impl_.neworiginalsize_ != nullptr) _impl_.neworiginalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void MediaOriginalSizeCommandArchive::clear_oldoriginalsize() {
  if (_impl_.oldoriginalsize_ != nullptr) _impl_.oldoriginalsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
MediaOriginalSizeCommandArchive::MediaOriginalSizeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaOriginalSizeCommandArchive)
}
MediaOriginalSizeCommandArchive::MediaOriginalSizeCommandArchive(const MediaOriginalSizeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaOriginalSizeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.neworiginalsize_){nullptr}
    , decltype(_impl_.oldoriginalsize_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_neworiginalsize()) {
    _this->_impl_.neworiginalsize_ = new ::TSP::Size(*from._impl_.neworiginalsize_);
  }
  if (from._internal_has_oldoriginalsize()) {
    _this->_impl_.oldoriginalsize_ = new ::TSP::Size(*from._impl_.oldoriginalsize_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.MediaOriginalSizeCommandArchive)
}

inline void MediaOriginalSizeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.neworiginalsize_){nullptr}
    , decltype(_impl_.oldoriginalsize_){nullptr}
  };
}

MediaOriginalSizeCommandArchive::~MediaOriginalSizeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaOriginalSizeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaOriginalSizeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.neworiginalsize_;
  if (this != internal_default_instance()) delete _impl_.oldoriginalsize_;
}

void MediaOriginalSizeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaOriginalSizeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaOriginalSizeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.neworiginalsize_ != nullptr);
      _impl_.neworiginalsize_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.oldoriginalsize_ != nullptr);
      _impl_.oldoriginalsize_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaOriginalSizeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size newOriginalSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_neworiginalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size oldOriginalSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldoriginalsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaOriginalSizeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaOriginalSizeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size newOriginalSize = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::neworiginalsize(this),
        _Internal::neworiginalsize(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Size oldOriginalSize = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::oldoriginalsize(this),
        _Internal::oldoriginalsize(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaOriginalSizeCommandArchive)
  return target;
}

size_t MediaOriginalSizeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaOriginalSizeCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Size newOriginalSize = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.neworiginalsize_);
    }

    // optional .TSP.Size oldOriginalSize = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldoriginalsize_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaOriginalSizeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaOriginalSizeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaOriginalSizeCommandArchive::GetClassData() const { return &_class_data_; }


void MediaOriginalSizeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaOriginalSizeCommandArchive*>(&to_msg);
  auto& from = static_cast<const MediaOriginalSizeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaOriginalSizeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_neworiginalsize()->::TSP::Size::MergeFrom(
          from._internal_neworiginalsize());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_oldoriginalsize()->::TSP::Size::MergeFrom(
          from._internal_oldoriginalsize());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaOriginalSizeCommandArchive::CopyFrom(const MediaOriginalSizeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaOriginalSizeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaOriginalSizeCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_neworiginalsize()) {
    if (!_impl_.neworiginalsize_->IsInitialized()) return false;
  }
  if (_internal_has_oldoriginalsize()) {
    if (!_impl_.oldoriginalsize_->IsInitialized()) return false;
  }
  return true;
}

void MediaOriginalSizeCommandArchive::InternalSwap(MediaOriginalSizeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaOriginalSizeCommandArchive, _impl_.oldoriginalsize_)
      + sizeof(MediaOriginalSizeCommandArchive::_impl_.oldoriginalsize_)
      - PROTOBUF_FIELD_OFFSET(MediaOriginalSizeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaOriginalSizeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[20]);
}

// ===================================================================

class ImageMaskCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageMaskCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ImageMaskCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const ImageMaskCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& newmaskinfo(const ImageMaskCommandArchive* msg);
  static void set_has_newmaskinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& oldmaskinfo(const ImageMaskCommandArchive* msg);
  static void set_has_oldmaskinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ImageMaskCommandArchive::_Internal::super(const ImageMaskCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ImageMaskCommandArchive::_Internal::info(const ImageMaskCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::Reference&
ImageMaskCommandArchive::_Internal::newmaskinfo(const ImageMaskCommandArchive* msg) {
  return *msg->_impl_.newmaskinfo_;
}
const ::TSP::Reference&
ImageMaskCommandArchive::_Internal::oldmaskinfo(const ImageMaskCommandArchive* msg) {
  return *msg->_impl_.oldmaskinfo_;
}
void ImageMaskCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ImageMaskCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageMaskCommandArchive::clear_newmaskinfo() {
  if (_impl_.newmaskinfo_ != nullptr) _impl_.newmaskinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageMaskCommandArchive::clear_oldmaskinfo() {
  if (_impl_.oldmaskinfo_ != nullptr) _impl_.oldmaskinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ImageMaskCommandArchive::ImageMaskCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageMaskCommandArchive)
}
ImageMaskCommandArchive::ImageMaskCommandArchive(const ImageMaskCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageMaskCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newmaskinfo_){nullptr}
    , decltype(_impl_.oldmaskinfo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_newmaskinfo()) {
    _this->_impl_.newmaskinfo_ = new ::TSP::Reference(*from._impl_.newmaskinfo_);
  }
  if (from._internal_has_oldmaskinfo()) {
    _this->_impl_.oldmaskinfo_ = new ::TSP::Reference(*from._impl_.oldmaskinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ImageMaskCommandArchive)
}

inline void ImageMaskCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.newmaskinfo_){nullptr}
    , decltype(_impl_.oldmaskinfo_){nullptr}
  };
}

ImageMaskCommandArchive::~ImageMaskCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageMaskCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageMaskCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.newmaskinfo_;
  if (this != internal_default_instance()) delete _impl_.oldmaskinfo_;
}

void ImageMaskCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageMaskCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageMaskCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.newmaskinfo_ != nullptr);
      _impl_.newmaskinfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.oldmaskinfo_ != nullptr);
      _impl_.oldmaskinfo_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageMaskCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference newMaskInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_newmaskinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference oldMaskInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldmaskinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageMaskCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageMaskCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference newMaskInfo = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::newmaskinfo(this),
        _Internal::newmaskinfo(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference oldMaskInfo = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::oldmaskinfo(this),
        _Internal::oldmaskinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageMaskCommandArchive)
  return target;
}

size_t ImageMaskCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageMaskCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Reference newMaskInfo = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newmaskinfo_);
    }

    // optional .TSP.Reference oldMaskInfo = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldmaskinfo_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageMaskCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageMaskCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageMaskCommandArchive::GetClassData() const { return &_class_data_; }


void ImageMaskCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageMaskCommandArchive*>(&to_msg);
  auto& from = static_cast<const ImageMaskCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageMaskCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_newmaskinfo()->::TSP::Reference::MergeFrom(
          from._internal_newmaskinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_oldmaskinfo()->::TSP::Reference::MergeFrom(
          from._internal_oldmaskinfo());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageMaskCommandArchive::CopyFrom(const ImageMaskCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageMaskCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageMaskCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_newmaskinfo()) {
    if (!_impl_.newmaskinfo_->IsInitialized()) return false;
  }
  if (_internal_has_oldmaskinfo()) {
    if (!_impl_.oldmaskinfo_->IsInitialized()) return false;
  }
  return true;
}

void ImageMaskCommandArchive::InternalSwap(ImageMaskCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageMaskCommandArchive, _impl_.oldmaskinfo_)
      + sizeof(ImageMaskCommandArchive::_impl_.oldmaskinfo_)
      - PROTOBUF_FIELD_OFFSET(ImageMaskCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageMaskCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[21]);
}

// ===================================================================

class MediaApplyPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaApplyPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSD::StyledInfoSetStyleCommandArchive& super(const MediaApplyPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& stylepreset(const MediaApplyPresetCommandArchive* msg);
  static void set_has_stylepreset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ShadowArchive& shadowpreset(const MediaApplyPresetCommandArchive* msg);
  static void set_has_shadowpreset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::StyledInfoSetStyleCommandArchive&
MediaApplyPresetCommandArchive::_Internal::super(const MediaApplyPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MediaApplyPresetCommandArchive::_Internal::stylepreset(const MediaApplyPresetCommandArchive* msg) {
  return *msg->_impl_.stylepreset_;
}
const ::TSD::ShadowArchive&
MediaApplyPresetCommandArchive::_Internal::shadowpreset(const MediaApplyPresetCommandArchive* msg) {
  return *msg->_impl_.shadowpreset_;
}
void MediaApplyPresetCommandArchive::clear_stylepreset() {
  if (_impl_.stylepreset_ != nullptr) _impl_.stylepreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MediaApplyPresetCommandArchive::clear_shadowpreset() {
  if (_impl_.shadowpreset_ != nullptr) _impl_.shadowpreset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MediaApplyPresetCommandArchive::MediaApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaApplyPresetCommandArchive)
}
MediaApplyPresetCommandArchive::MediaApplyPresetCommandArchive(const MediaApplyPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaApplyPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.stylepreset_){nullptr}
    , decltype(_impl_.shadowpreset_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::StyledInfoSetStyleCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_stylepreset()) {
    _this->_impl_.stylepreset_ = new ::TSP::Reference(*from._impl_.stylepreset_);
  }
  if (from._internal_has_shadowpreset()) {
    _this->_impl_.shadowpreset_ = new ::TSD::ShadowArchive(*from._impl_.shadowpreset_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.MediaApplyPresetCommandArchive)
}

inline void MediaApplyPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.stylepreset_){nullptr}
    , decltype(_impl_.shadowpreset_){nullptr}
  };
}

MediaApplyPresetCommandArchive::~MediaApplyPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaApplyPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaApplyPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.stylepreset_;
  if (this != internal_default_instance()) delete _impl_.shadowpreset_;
}

void MediaApplyPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaApplyPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.stylepreset_ != nullptr);
      _impl_.stylepreset_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.shadowpreset_ != nullptr);
      _impl_.shadowpreset_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaApplyPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference stylepreset = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_stylepreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ShadowArchive shadowpreset = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_shadowpreset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaApplyPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference stylepreset = 10;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::stylepreset(this),
        _Internal::stylepreset(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ShadowArchive shadowpreset = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::shadowpreset(this),
        _Internal::shadowpreset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaApplyPresetCommandArchive)
  return target;
}

size_t MediaApplyPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaApplyPresetCommandArchive)
  size_t total_size = 0;

  // required .TSD.StyledInfoSetStyleCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference stylepreset = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stylepreset_);
    }

    // optional .TSD.ShadowArchive shadowpreset = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shadowpreset_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaApplyPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaApplyPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaApplyPresetCommandArchive::GetClassData() const { return &_class_data_; }


void MediaApplyPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaApplyPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const MediaApplyPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaApplyPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::StyledInfoSetStyleCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_stylepreset()->::TSP::Reference::MergeFrom(
          from._internal_stylepreset());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_shadowpreset()->::TSD::ShadowArchive::MergeFrom(
          from._internal_shadowpreset());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaApplyPresetCommandArchive::CopyFrom(const MediaApplyPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaApplyPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaApplyPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_stylepreset()) {
    if (!_impl_.stylepreset_->IsInitialized()) return false;
  }
  if (_internal_has_shadowpreset()) {
    if (!_impl_.shadowpreset_->IsInitialized()) return false;
  }
  return true;
}

void MediaApplyPresetCommandArchive::InternalSwap(MediaApplyPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaApplyPresetCommandArchive, _impl_.shadowpreset_)
      + sizeof(MediaApplyPresetCommandArchive::_impl_.shadowpreset_)
      - PROTOBUF_FIELD_OFFSET(MediaApplyPresetCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaApplyPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[22]);
}

// ===================================================================

class ImageAdjustmentsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageAdjustmentsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::ImageAdjustmentsArchive& old_image_adjustments(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_old_image_adjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::ImageAdjustmentsArchive& new_image_adjustments(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_new_image_adjustments(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::DataReference& adjustedimagedata(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_adjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::DataReference& replacedadjustedimagedata(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_replacedadjustedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::DataReference& enhancedimagedata(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_enhancedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::DataReference& replacedenhancedimagedata(const ImageAdjustmentsCommandArchive* msg);
  static void set_has_replacedenhancedimagedata(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ImageAdjustmentsCommandArchive::_Internal::super(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::ImageAdjustmentsArchive&
ImageAdjustmentsCommandArchive::_Internal::old_image_adjustments(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.old_image_adjustments_;
}
const ::TSD::ImageAdjustmentsArchive&
ImageAdjustmentsCommandArchive::_Internal::new_image_adjustments(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.new_image_adjustments_;
}
const ::TSP::DataReference&
ImageAdjustmentsCommandArchive::_Internal::adjustedimagedata(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.adjustedimagedata_;
}
const ::TSP::DataReference&
ImageAdjustmentsCommandArchive::_Internal::replacedadjustedimagedata(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.replacedadjustedimagedata_;
}
const ::TSP::DataReference&
ImageAdjustmentsCommandArchive::_Internal::enhancedimagedata(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.enhancedimagedata_;
}
const ::TSP::DataReference&
ImageAdjustmentsCommandArchive::_Internal::replacedenhancedimagedata(const ImageAdjustmentsCommandArchive* msg) {
  return *msg->_impl_.replacedenhancedimagedata_;
}
void ImageAdjustmentsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ImageAdjustmentsCommandArchive::clear_old_image_adjustments() {
  if (_impl_.old_image_adjustments_ != nullptr) _impl_.old_image_adjustments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ImageAdjustmentsCommandArchive::clear_new_image_adjustments() {
  if (_impl_.new_image_adjustments_ != nullptr) _impl_.new_image_adjustments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ImageAdjustmentsCommandArchive::clear_adjustedimagedata() {
  if (_impl_.adjustedimagedata_ != nullptr) _impl_.adjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ImageAdjustmentsCommandArchive::clear_replacedadjustedimagedata() {
  if (_impl_.replacedadjustedimagedata_ != nullptr) _impl_.replacedadjustedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void ImageAdjustmentsCommandArchive::clear_enhancedimagedata() {
  if (_impl_.enhancedimagedata_ != nullptr) _impl_.enhancedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void ImageAdjustmentsCommandArchive::clear_replacedenhancedimagedata() {
  if (_impl_.replacedenhancedimagedata_ != nullptr) _impl_.replacedenhancedimagedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
ImageAdjustmentsCommandArchive::ImageAdjustmentsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageAdjustmentsCommandArchive)
}
ImageAdjustmentsCommandArchive::ImageAdjustmentsCommandArchive(const ImageAdjustmentsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageAdjustmentsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_image_adjustments_){nullptr}
    , decltype(_impl_.new_image_adjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.replacedadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.replacedenhancedimagedata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_image_adjustments()) {
    _this->_impl_.old_image_adjustments_ = new ::TSD::ImageAdjustmentsArchive(*from._impl_.old_image_adjustments_);
  }
  if (from._internal_has_new_image_adjustments()) {
    _this->_impl_.new_image_adjustments_ = new ::TSD::ImageAdjustmentsArchive(*from._impl_.new_image_adjustments_);
  }
  if (from._internal_has_adjustedimagedata()) {
    _this->_impl_.adjustedimagedata_ = new ::TSP::DataReference(*from._impl_.adjustedimagedata_);
  }
  if (from._internal_has_replacedadjustedimagedata()) {
    _this->_impl_.replacedadjustedimagedata_ = new ::TSP::DataReference(*from._impl_.replacedadjustedimagedata_);
  }
  if (from._internal_has_enhancedimagedata()) {
    _this->_impl_.enhancedimagedata_ = new ::TSP::DataReference(*from._impl_.enhancedimagedata_);
  }
  if (from._internal_has_replacedenhancedimagedata()) {
    _this->_impl_.replacedenhancedimagedata_ = new ::TSP::DataReference(*from._impl_.replacedenhancedimagedata_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ImageAdjustmentsCommandArchive)
}

inline void ImageAdjustmentsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_image_adjustments_){nullptr}
    , decltype(_impl_.new_image_adjustments_){nullptr}
    , decltype(_impl_.adjustedimagedata_){nullptr}
    , decltype(_impl_.replacedadjustedimagedata_){nullptr}
    , decltype(_impl_.enhancedimagedata_){nullptr}
    , decltype(_impl_.replacedenhancedimagedata_){nullptr}
  };
}

ImageAdjustmentsCommandArchive::~ImageAdjustmentsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageAdjustmentsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageAdjustmentsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_image_adjustments_;
  if (this != internal_default_instance()) delete _impl_.new_image_adjustments_;
  if (this != internal_default_instance()) delete _impl_.adjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.replacedadjustedimagedata_;
  if (this != internal_default_instance()) delete _impl_.enhancedimagedata_;
  if (this != internal_default_instance()) delete _impl_.replacedenhancedimagedata_;
}

void ImageAdjustmentsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageAdjustmentsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageAdjustmentsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_image_adjustments_ != nullptr);
      _impl_.old_image_adjustments_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_image_adjustments_ != nullptr);
      _impl_.new_image_adjustments_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.adjustedimagedata_ != nullptr);
      _impl_.adjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.replacedadjustedimagedata_ != nullptr);
      _impl_.replacedadjustedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.enhancedimagedata_ != nullptr);
      _impl_.enhancedimagedata_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.replacedenhancedimagedata_ != nullptr);
      _impl_.replacedenhancedimagedata_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageAdjustmentsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageAdjustmentsArchive old_image_adjustments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_image_adjustments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ImageAdjustmentsArchive new_image_adjustments = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_image_adjustments(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference adjustedImageData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_adjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference replacedAdjustedImageData = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_replacedadjustedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference enhancedImageData = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_enhancedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.DataReference replacedEnhancedImageData = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_replacedenhancedimagedata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageAdjustmentsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageAdjustmentsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageAdjustmentsArchive old_image_adjustments = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_image_adjustments(this),
        _Internal::old_image_adjustments(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ImageAdjustmentsArchive new_image_adjustments = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_image_adjustments(this),
        _Internal::new_image_adjustments(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference adjustedImageData = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::adjustedimagedata(this),
        _Internal::adjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference replacedAdjustedImageData = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::replacedadjustedimagedata(this),
        _Internal::replacedadjustedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference enhancedImageData = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::enhancedimagedata(this),
        _Internal::enhancedimagedata(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.DataReference replacedEnhancedImageData = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::replacedenhancedimagedata(this),
        _Internal::replacedenhancedimagedata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageAdjustmentsCommandArchive)
  return target;
}

size_t ImageAdjustmentsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageAdjustmentsCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional .TSD.ImageAdjustmentsArchive old_image_adjustments = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_image_adjustments_);
    }

    // optional .TSD.ImageAdjustmentsArchive new_image_adjustments = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_image_adjustments_);
    }

    // optional .TSP.DataReference adjustedImageData = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.adjustedimagedata_);
    }

    // optional .TSP.DataReference replacedAdjustedImageData = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.replacedadjustedimagedata_);
    }

    // optional .TSP.DataReference enhancedImageData = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.enhancedimagedata_);
    }

    // optional .TSP.DataReference replacedEnhancedImageData = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.replacedenhancedimagedata_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageAdjustmentsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageAdjustmentsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageAdjustmentsCommandArchive::GetClassData() const { return &_class_data_; }


void ImageAdjustmentsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageAdjustmentsCommandArchive*>(&to_msg);
  auto& from = static_cast<const ImageAdjustmentsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageAdjustmentsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_image_adjustments()->::TSD::ImageAdjustmentsArchive::MergeFrom(
          from._internal_old_image_adjustments());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_image_adjustments()->::TSD::ImageAdjustmentsArchive::MergeFrom(
          from._internal_new_image_adjustments());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_adjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_adjustedimagedata());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_replacedadjustedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_replacedadjustedimagedata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_enhancedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_enhancedimagedata());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_replacedenhancedimagedata()->::TSP::DataReference::MergeFrom(
          from._internal_replacedenhancedimagedata());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageAdjustmentsCommandArchive::CopyFrom(const ImageAdjustmentsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageAdjustmentsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageAdjustmentsCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_adjustedimagedata()) {
    if (!_impl_.adjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_replacedadjustedimagedata()) {
    if (!_impl_.replacedadjustedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_enhancedimagedata()) {
    if (!_impl_.enhancedimagedata_->IsInitialized()) return false;
  }
  if (_internal_has_replacedenhancedimagedata()) {
    if (!_impl_.replacedenhancedimagedata_->IsInitialized()) return false;
  }
  return true;
}

void ImageAdjustmentsCommandArchive::InternalSwap(ImageAdjustmentsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ImageAdjustmentsCommandArchive, _impl_.replacedenhancedimagedata_)
      + sizeof(ImageAdjustmentsCommandArchive::_impl_.replacedenhancedimagedata_)
      - PROTOBUF_FIELD_OFFSET(ImageAdjustmentsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageAdjustmentsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[23]);
}

// ===================================================================

class MediaFlagsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MediaFlagsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MediaFlagsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const MediaFlagsCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
MediaFlagsCommandArchive::_Internal::super(const MediaFlagsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MediaFlagsCommandArchive::_Internal::info(const MediaFlagsCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void MediaFlagsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MediaFlagsCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MediaFlagsCommandArchive::MediaFlagsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.MediaFlagsCommandArchive)
}
MediaFlagsCommandArchive::MediaFlagsCommandArchive(const MediaFlagsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MediaFlagsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  _this->_impl_.flags_ = from._impl_.flags_;
  // @@protoc_insertion_point(copy_constructor:TSD.MediaFlagsCommandArchive)
}

inline void MediaFlagsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.flags_){0u}
  };
}

MediaFlagsCommandArchive::~MediaFlagsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.MediaFlagsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MediaFlagsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void MediaFlagsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MediaFlagsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.MediaFlagsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_.flags_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MediaFlagsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MediaFlagsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.MediaFlagsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.MediaFlagsCommandArchive)
  return target;
}

size_t MediaFlagsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.MediaFlagsCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MediaFlagsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MediaFlagsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MediaFlagsCommandArchive::GetClassData() const { return &_class_data_; }


void MediaFlagsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MediaFlagsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MediaFlagsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.MediaFlagsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MediaFlagsCommandArchive::CopyFrom(const MediaFlagsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.MediaFlagsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MediaFlagsCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void MediaFlagsCommandArchive::InternalSwap(MediaFlagsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MediaFlagsCommandArchive, _impl_.flags_)
      + sizeof(MediaFlagsCommandArchive::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(MediaFlagsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MediaFlagsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[24]);
}

// ===================================================================

class DrawablesCommandGroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawablesCommandGroupArchive>()._impl_._has_bits_);
  static const ::TSK::CommandGroupArchive& super(const DrawablesCommandGroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::CanvasSelectionArchive& obsolete_selection(const DrawablesCommandGroupArchive* msg);
  static void set_has_obsolete_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& modelforselection(const DrawablesCommandGroupArchive* msg);
  static void set_has_modelforselection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fordrag(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& archivedselection(const DrawablesCommandGroupArchive* msg);
  static void set_has_archivedselection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandGroupArchive&
DrawablesCommandGroupArchive::_Internal::super(const DrawablesCommandGroupArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSD::CanvasSelectionArchive&
DrawablesCommandGroupArchive::_Internal::obsolete_selection(const DrawablesCommandGroupArchive* msg) {
  return *msg->_impl_.obsolete_selection_;
}
const ::TSP::Reference&
DrawablesCommandGroupArchive::_Internal::modelforselection(const DrawablesCommandGroupArchive* msg) {
  return *msg->_impl_.modelforselection_;
}
const ::TSP::Reference&
DrawablesCommandGroupArchive::_Internal::archivedselection(const DrawablesCommandGroupArchive* msg) {
  return *msg->_impl_.archivedselection_;
}
void DrawablesCommandGroupArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawablesCommandGroupArchive::clear_obsolete_selection() {
  if (_impl_.obsolete_selection_ != nullptr) _impl_.obsolete_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawablesCommandGroupArchive::clear_modelforselection() {
  if (_impl_.modelforselection_ != nullptr) _impl_.modelforselection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrawablesCommandGroupArchive::clear_archivedselection() {
  if (_impl_.archivedselection_ != nullptr) _impl_.archivedselection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
DrawablesCommandGroupArchive::DrawablesCommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawablesCommandGroupArchive)
}
DrawablesCommandGroupArchive::DrawablesCommandGroupArchive(const DrawablesCommandGroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawablesCommandGroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_selection_){nullptr}
    , decltype(_impl_.modelforselection_){nullptr}
    , decltype(_impl_.archivedselection_){nullptr}
    , decltype(_impl_.fordrag_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandGroupArchive(*from._impl_.super_);
  }
  if (from._internal_has_obsolete_selection()) {
    _this->_impl_.obsolete_selection_ = new ::TSD::CanvasSelectionArchive(*from._impl_.obsolete_selection_);
  }
  if (from._internal_has_modelforselection()) {
    _this->_impl_.modelforselection_ = new ::TSP::Reference(*from._impl_.modelforselection_);
  }
  if (from._internal_has_archivedselection()) {
    _this->_impl_.archivedselection_ = new ::TSP::Reference(*from._impl_.archivedselection_);
  }
  ::memcpy(&_impl_.fordrag_, &from._impl_.fordrag_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.fordrag_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:TSD.DrawablesCommandGroupArchive)
}

inline void DrawablesCommandGroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.obsolete_selection_){nullptr}
    , decltype(_impl_.modelforselection_){nullptr}
    , decltype(_impl_.archivedselection_){nullptr}
    , decltype(_impl_.fordrag_){false}
    , decltype(_impl_.type_){1}
  };
}

DrawablesCommandGroupArchive::~DrawablesCommandGroupArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawablesCommandGroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawablesCommandGroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.obsolete_selection_;
  if (this != internal_default_instance()) delete _impl_.modelforselection_;
  if (this != internal_default_instance()) delete _impl_.archivedselection_;
}

void DrawablesCommandGroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawablesCommandGroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawablesCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.obsolete_selection_ != nullptr);
      _impl_.obsolete_selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.modelforselection_ != nullptr);
      _impl_.modelforselection_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.archivedselection_ != nullptr);
      _impl_.archivedselection_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    _impl_.fordrag_ = false;
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawablesCommandGroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandGroupArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CanvasSelectionArchive obsolete_selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_obsolete_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference modelforselection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_modelforselection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::DrawablesCommandGroupArchive_DrawablesCommandGroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool forDrag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_fordrag(&has_bits);
          _impl_.fordrag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference archivedselection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_archivedselection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawablesCommandGroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawablesCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandGroupArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CanvasSelectionArchive obsolete_selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::obsolete_selection(this),
        _Internal::obsolete_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference modelforselection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::modelforselection(this),
        _Internal::modelforselection(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional bool forDrag = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_fordrag(), target);
  }

  // optional .TSP.Reference archivedselection = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::archivedselection(this),
        _Internal::archivedselection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawablesCommandGroupArchive)
  return target;
}

size_t DrawablesCommandGroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawablesCommandGroupArchive)
  size_t total_size = 0;

  // required .TSK.CommandGroupArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional .TSD.CanvasSelectionArchive obsolete_selection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.obsolete_selection_);
    }

    // optional .TSP.Reference modelforselection = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.modelforselection_);
    }

    // optional .TSP.Reference archivedselection = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.archivedselection_);
    }

    // optional bool forDrag = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional .TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawablesCommandGroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawablesCommandGroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawablesCommandGroupArchive::GetClassData() const { return &_class_data_; }


void DrawablesCommandGroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawablesCommandGroupArchive*>(&to_msg);
  auto& from = static_cast<const DrawablesCommandGroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawablesCommandGroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandGroupArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_obsolete_selection()->::TSD::CanvasSelectionArchive::MergeFrom(
          from._internal_obsolete_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_modelforselection()->::TSP::Reference::MergeFrom(
          from._internal_modelforselection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_archivedselection()->::TSP::Reference::MergeFrom(
          from._internal_archivedselection());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.fordrag_ = from._impl_.fordrag_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawablesCommandGroupArchive::CopyFrom(const DrawablesCommandGroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawablesCommandGroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawablesCommandGroupArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_obsolete_selection()) {
    if (!_impl_.obsolete_selection_->IsInitialized()) return false;
  }
  if (_internal_has_modelforselection()) {
    if (!_impl_.modelforselection_->IsInitialized()) return false;
  }
  if (_internal_has_archivedselection()) {
    if (!_impl_.archivedselection_->IsInitialized()) return false;
  }
  return true;
}

void DrawablesCommandGroupArchive::InternalSwap(DrawablesCommandGroupArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawablesCommandGroupArchive, _impl_.fordrag_)
      + sizeof(DrawablesCommandGroupArchive::_impl_.fordrag_)
      - PROTOBUF_FIELD_OFFSET(DrawablesCommandGroupArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawablesCommandGroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[25]);
}

// ===================================================================

class ExteriorTextWrapCommandArchive_InfoAndWrap::_Internal {
 public:
  using HasBits = decltype(std::declval<ExteriorTextWrapCommandArchive_InfoAndWrap>()._impl_._has_bits_);
  static const ::TSP::Reference& info(const ExteriorTextWrapCommandArchive_InfoAndWrap* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::ExteriorTextWrapArchive& exterior_text_wrap(const ExteriorTextWrapCommandArchive_InfoAndWrap* msg);
  static void set_has_exterior_text_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
ExteriorTextWrapCommandArchive_InfoAndWrap::_Internal::info(const ExteriorTextWrapCommandArchive_InfoAndWrap* msg) {
  return *msg->_impl_.info_;
}
const ::TSD::ExteriorTextWrapArchive&
ExteriorTextWrapCommandArchive_InfoAndWrap::_Internal::exterior_text_wrap(const ExteriorTextWrapCommandArchive_InfoAndWrap* msg) {
  return *msg->_impl_.exterior_text_wrap_;
}
void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ExteriorTextWrapCommandArchive_InfoAndWrap::clear_exterior_text_wrap() {
  if (_impl_.exterior_text_wrap_ != nullptr) _impl_.exterior_text_wrap_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ExteriorTextWrapCommandArchive_InfoAndWrap::ExteriorTextWrapCommandArchive_InfoAndWrap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
}
ExteriorTextWrapCommandArchive_InfoAndWrap::ExteriorTextWrapCommandArchive_InfoAndWrap(const ExteriorTextWrapCommandArchive_InfoAndWrap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExteriorTextWrapCommandArchive_InfoAndWrap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_exterior_text_wrap()) {
    _this->_impl_.exterior_text_wrap_ = new ::TSD::ExteriorTextWrapArchive(*from._impl_.exterior_text_wrap_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
}

inline void ExteriorTextWrapCommandArchive_InfoAndWrap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.exterior_text_wrap_){nullptr}
  };
}

ExteriorTextWrapCommandArchive_InfoAndWrap::~ExteriorTextWrapCommandArchive_InfoAndWrap() {
  // @@protoc_insertion_point(destructor:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExteriorTextWrapCommandArchive_InfoAndWrap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.exterior_text_wrap_;
}

void ExteriorTextWrapCommandArchive_InfoAndWrap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExteriorTextWrapCommandArchive_InfoAndWrap::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.exterior_text_wrap_ != nullptr);
      _impl_.exterior_text_wrap_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExteriorTextWrapCommandArchive_InfoAndWrap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_exterior_text_wrap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExteriorTextWrapCommandArchive_InfoAndWrap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::exterior_text_wrap(this),
        _Internal::exterior_text_wrap(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  return target;
}

size_t ExteriorTextWrapCommandArchive_InfoAndWrap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSD.ExteriorTextWrapArchive exterior_text_wrap = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.exterior_text_wrap_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExteriorTextWrapCommandArchive_InfoAndWrap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExteriorTextWrapCommandArchive_InfoAndWrap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExteriorTextWrapCommandArchive_InfoAndWrap::GetClassData() const { return &_class_data_; }


void ExteriorTextWrapCommandArchive_InfoAndWrap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExteriorTextWrapCommandArchive_InfoAndWrap*>(&to_msg);
  auto& from = static_cast<const ExteriorTextWrapCommandArchive_InfoAndWrap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_exterior_text_wrap()->::TSD::ExteriorTextWrapArchive::MergeFrom(
          from._internal_exterior_text_wrap());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExteriorTextWrapCommandArchive_InfoAndWrap::CopyFrom(const ExteriorTextWrapCommandArchive_InfoAndWrap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ExteriorTextWrapCommandArchive.InfoAndWrap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExteriorTextWrapCommandArchive_InfoAndWrap::IsInitialized() const {
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void ExteriorTextWrapCommandArchive_InfoAndWrap::InternalSwap(ExteriorTextWrapCommandArchive_InfoAndWrap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExteriorTextWrapCommandArchive_InfoAndWrap, _impl_.exterior_text_wrap_)
      + sizeof(ExteriorTextWrapCommandArchive_InfoAndWrap::_impl_.exterior_text_wrap_)
      - PROTOBUF_FIELD_OFFSET(ExteriorTextWrapCommandArchive_InfoAndWrap, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExteriorTextWrapCommandArchive_InfoAndWrap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[26]);
}

// ===================================================================

class ExteriorTextWrapCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ExteriorTextWrapCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ExteriorTextWrapCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ExteriorTextWrapCommandArchive::_Internal::super(const ExteriorTextWrapCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ExteriorTextWrapCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ExteriorTextWrapCommandArchive::ExteriorTextWrapCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ExteriorTextWrapCommandArchive)
}
ExteriorTextWrapCommandArchive::ExteriorTextWrapCommandArchive(const ExteriorTextWrapCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExteriorTextWrapCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_and_wrap_){from._impl_.info_and_wrap_}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ExteriorTextWrapCommandArchive)
}

inline void ExteriorTextWrapCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.info_and_wrap_){arena}
    , decltype(_impl_.super_){nullptr}
  };
}

ExteriorTextWrapCommandArchive::~ExteriorTextWrapCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ExteriorTextWrapCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExteriorTextWrapCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.info_and_wrap_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ExteriorTextWrapCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExteriorTextWrapCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ExteriorTextWrapCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.info_and_wrap_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExteriorTextWrapCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSD.ExteriorTextWrapCommandArchive.InfoAndWrap info_and_wrap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_info_and_wrap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExteriorTextWrapCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ExteriorTextWrapCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSD.ExteriorTextWrapCommandArchive.InfoAndWrap info_and_wrap = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_info_and_wrap_size()); i < n; i++) {
    const auto& repfield = this->_internal_info_and_wrap(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ExteriorTextWrapCommandArchive)
  return target;
}

size_t ExteriorTextWrapCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ExteriorTextWrapCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSD.ExteriorTextWrapCommandArchive.InfoAndWrap info_and_wrap = 2;
  total_size += 1UL * this->_internal_info_and_wrap_size();
  for (const auto& msg : this->_impl_.info_and_wrap_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExteriorTextWrapCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExteriorTextWrapCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExteriorTextWrapCommandArchive::GetClassData() const { return &_class_data_; }


void ExteriorTextWrapCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExteriorTextWrapCommandArchive*>(&to_msg);
  auto& from = static_cast<const ExteriorTextWrapCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ExteriorTextWrapCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.info_and_wrap_.MergeFrom(from._impl_.info_and_wrap_);
  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExteriorTextWrapCommandArchive::CopyFrom(const ExteriorTextWrapCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ExteriorTextWrapCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExteriorTextWrapCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.info_and_wrap_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ExteriorTextWrapCommandArchive::InternalSwap(ExteriorTextWrapCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.info_and_wrap_.InternalSwap(&other->_impl_.info_and_wrap_);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExteriorTextWrapCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[27]);
}

// ===================================================================

class DrawableHyperlinkCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableHyperlinkCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableHyperlinkCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& info(const DrawableHyperlinkCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_oldhyperlink_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newhyperlink_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableHyperlinkCommandArchive::_Internal::super(const DrawableHyperlinkCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableHyperlinkCommandArchive::_Internal::info(const DrawableHyperlinkCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void DrawableHyperlinkCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrawableHyperlinkCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
DrawableHyperlinkCommandArchive::DrawableHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableHyperlinkCommandArchive)
}
DrawableHyperlinkCommandArchive::DrawableHyperlinkCommandArchive(const DrawableHyperlinkCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableHyperlinkCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oldhyperlink_url_){}
    , decltype(_impl_.newhyperlink_url_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.oldhyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldhyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oldhyperlink_url()) {
    _this->_impl_.oldhyperlink_url_.Set(from._internal_oldhyperlink_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.newhyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newhyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newhyperlink_url()) {
    _this->_impl_.newhyperlink_url_.Set(from._internal_newhyperlink_url(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableHyperlinkCommandArchive)
}

inline void DrawableHyperlinkCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.oldhyperlink_url_){}
    , decltype(_impl_.newhyperlink_url_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
  _impl_.oldhyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldhyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.newhyperlink_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newhyperlink_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DrawableHyperlinkCommandArchive::~DrawableHyperlinkCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableHyperlinkCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableHyperlinkCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.oldhyperlink_url_.Destroy();
  _impl_.newhyperlink_url_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void DrawableHyperlinkCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableHyperlinkCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.oldhyperlink_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.newhyperlink_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableHyperlinkCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string oldhyperlink_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_oldhyperlink_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableHyperlinkCommandArchive.oldhyperlink_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string newhyperlink_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_newhyperlink_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableHyperlinkCommandArchive.newhyperlink_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableHyperlinkCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional string oldhyperlink_url = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_oldhyperlink_url().data(), static_cast<int>(this->_internal_oldhyperlink_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableHyperlinkCommandArchive.oldhyperlink_url");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_oldhyperlink_url(), target);
  }

  // optional string newhyperlink_url = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newhyperlink_url().data(), static_cast<int>(this->_internal_newhyperlink_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableHyperlinkCommandArchive.newhyperlink_url");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_newhyperlink_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableHyperlinkCommandArchive)
  return target;
}

size_t DrawableHyperlinkCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableHyperlinkCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string oldhyperlink_url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_oldhyperlink_url());
    }

    // optional string newhyperlink_url = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_newhyperlink_url());
    }

  }
  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableHyperlinkCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableHyperlinkCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableHyperlinkCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableHyperlinkCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableHyperlinkCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableHyperlinkCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableHyperlinkCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_oldhyperlink_url(from._internal_oldhyperlink_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_newhyperlink_url(from._internal_newhyperlink_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableHyperlinkCommandArchive::CopyFrom(const DrawableHyperlinkCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableHyperlinkCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableHyperlinkCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void DrawableHyperlinkCommandArchive::InternalSwap(DrawableHyperlinkCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.oldhyperlink_url_, lhs_arena,
      &other->_impl_.oldhyperlink_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newhyperlink_url_, lhs_arena,
      &other->_impl_.newhyperlink_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableHyperlinkCommandArchive, _impl_.info_)
      + sizeof(DrawableHyperlinkCommandArchive::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(DrawableHyperlinkCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableHyperlinkCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[28]);
}

// ===================================================================

class CommandSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSelectionBehaviorArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& model_for_selection(const CommandSelectionBehaviorArchive* msg);
  static void set_has_model_for_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& archived_selection(const CommandSelectionBehaviorArchive* msg);
  static void set_has_archived_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& archived_new_selection(const CommandSelectionBehaviorArchive* msg);
  static void set_has_archived_new_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSP::Reference&
CommandSelectionBehaviorArchive::_Internal::model_for_selection(const CommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.model_for_selection_;
}
const ::TSP::Reference&
CommandSelectionBehaviorArchive::_Internal::archived_selection(const CommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.archived_selection_;
}
const ::TSP::Reference&
CommandSelectionBehaviorArchive::_Internal::archived_new_selection(const CommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.archived_new_selection_;
}
void CommandSelectionBehaviorArchive::clear_model_for_selection() {
  if (_impl_.model_for_selection_ != nullptr) _impl_.model_for_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSelectionBehaviorArchive::clear_archived_selection() {
  if (_impl_.archived_selection_ != nullptr) _impl_.archived_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSelectionBehaviorArchive::clear_archived_new_selection() {
  if (_impl_.archived_new_selection_ != nullptr) _impl_.archived_new_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSelectionBehaviorArchive::CommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CommandSelectionBehaviorArchive)
}
CommandSelectionBehaviorArchive::CommandSelectionBehaviorArchive(const CommandSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.model_for_selection_){nullptr}
    , decltype(_impl_.archived_selection_){nullptr}
    , decltype(_impl_.archived_new_selection_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_model_for_selection()) {
    _this->_impl_.model_for_selection_ = new ::TSP::Reference(*from._impl_.model_for_selection_);
  }
  if (from._internal_has_archived_selection()) {
    _this->_impl_.archived_selection_ = new ::TSP::Reference(*from._impl_.archived_selection_);
  }
  if (from._internal_has_archived_new_selection()) {
    _this->_impl_.archived_new_selection_ = new ::TSP::Reference(*from._impl_.archived_new_selection_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:TSD.CommandSelectionBehaviorArchive)
}

inline void CommandSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.model_for_selection_){nullptr}
    , decltype(_impl_.archived_selection_){nullptr}
    , decltype(_impl_.archived_new_selection_){nullptr}
    , decltype(_impl_.type_){1}
  };
}

CommandSelectionBehaviorArchive::~CommandSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TSD.CommandSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.model_for_selection_;
  if (this != internal_default_instance()) delete _impl_.archived_selection_;
  if (this != internal_default_instance()) delete _impl_.archived_new_selection_;
}

void CommandSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.model_for_selection_ != nullptr);
      _impl_.model_for_selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.archived_selection_ != nullptr);
      _impl_.archived_selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.archived_new_selection_ != nullptr);
      _impl_.archived_new_selection_->Clear();
    }
    _impl_.type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference model_for_selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_for_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.CommandSelectionBehaviorArchive.CommandSelectionBehaviorType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType_IsValid(val))) {
            _internal_set_type(static_cast<::TSD::CommandSelectionBehaviorArchive_CommandSelectionBehaviorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference archived_selection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_archived_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference archived_new_selection = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_archived_new_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference model_for_selection = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::model_for_selection(this),
        _Internal::model_for_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.CommandSelectionBehaviorArchive.CommandSelectionBehaviorType type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional .TSP.Reference archived_selection = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::archived_selection(this),
        _Internal::archived_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference archived_new_selection = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::archived_new_selection(this),
        _Internal::archived_new_selection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CommandSelectionBehaviorArchive)
  return target;
}

size_t CommandSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CommandSelectionBehaviorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSP.Reference model_for_selection = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.model_for_selection_);
    }

    // optional .TSP.Reference archived_selection = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.archived_selection_);
    }

    // optional .TSP.Reference archived_new_selection = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.archived_new_selection_);
    }

    // optional .TSD.CommandSelectionBehaviorArchive.CommandSelectionBehaviorType type = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void CommandSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const CommandSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CommandSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_model_for_selection()->::TSP::Reference::MergeFrom(
          from._internal_model_for_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_archived_selection()->::TSP::Reference::MergeFrom(
          from._internal_archived_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_archived_new_selection()->::TSP::Reference::MergeFrom(
          from._internal_archived_new_selection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSelectionBehaviorArchive::CopyFrom(const CommandSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CommandSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSelectionBehaviorArchive::IsInitialized() const {
  if (_internal_has_model_for_selection()) {
    if (!_impl_.model_for_selection_->IsInitialized()) return false;
  }
  if (_internal_has_archived_selection()) {
    if (!_impl_.archived_selection_->IsInitialized()) return false;
  }
  if (_internal_has_archived_new_selection()) {
    if (!_impl_.archived_new_selection_->IsInitialized()) return false;
  }
  return true;
}

void CommandSelectionBehaviorArchive::InternalSwap(CommandSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSelectionBehaviorArchive, _impl_.archived_new_selection_)
      + sizeof(CommandSelectionBehaviorArchive::_impl_.archived_new_selection_)
      - PROTOBUF_FIELD_OFFSET(CommandSelectionBehaviorArchive, _impl_.model_for_selection_)>(
          reinterpret_cast<char*>(&_impl_.model_for_selection_),
          reinterpret_cast<char*>(&other->_impl_.model_for_selection_));
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[29]);
}

// ===================================================================

class ImageReplaceCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageReplaceCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ImageReplaceCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ImageReplaceCommandArchive::_Internal::super(const ImageReplaceCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ImageReplaceCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ImageReplaceCommandArchive::ImageReplaceCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.ImageReplaceCommandArchive)
}
ImageReplaceCommandArchive::ImageReplaceCommandArchive(const ImageReplaceCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImageReplaceCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.ImageReplaceCommandArchive)
}

inline void ImageReplaceCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ImageReplaceCommandArchive::~ImageReplaceCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.ImageReplaceCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageReplaceCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ImageReplaceCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImageReplaceCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.ImageReplaceCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImageReplaceCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageReplaceCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.ImageReplaceCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.ImageReplaceCommandArchive)
  return target;
}

size_t ImageReplaceCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.ImageReplaceCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImageReplaceCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImageReplaceCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImageReplaceCommandArchive::GetClassData() const { return &_class_data_; }


void ImageReplaceCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImageReplaceCommandArchive*>(&to_msg);
  auto& from = static_cast<const ImageReplaceCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.ImageReplaceCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImageReplaceCommandArchive::CopyFrom(const ImageReplaceCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.ImageReplaceCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageReplaceCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ImageReplaceCommandArchive::InternalSwap(ImageReplaceCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ImageReplaceCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[30]);
}

// ===================================================================

class DrawableLockCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableLockCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableLockCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawableLockCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lock(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableLockCommandArchive::_Internal::super(const DrawableLockCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableLockCommandArchive::_Internal::info(const DrawableLockCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void DrawableLockCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawableLockCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
DrawableLockCommandArchive::DrawableLockCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableLockCommandArchive)
}
DrawableLockCommandArchive::DrawableLockCommandArchive(const DrawableLockCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableLockCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.lock_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  _this->_impl_.lock_ = from._impl_.lock_;
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableLockCommandArchive)
}

inline void DrawableLockCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.lock_){false}
  };
}

DrawableLockCommandArchive::~DrawableLockCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableLockCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableLockCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void DrawableLockCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableLockCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableLockCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_.lock_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableLockCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool lock = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_lock(&has_bits);
          _impl_.lock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableLockCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableLockCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional bool lock = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_lock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableLockCommandArchive)
  return target;
}

size_t DrawableLockCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableLockCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional bool lock = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableLockCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableLockCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableLockCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableLockCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableLockCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableLockCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableLockCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.lock_ = from._impl_.lock_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableLockCommandArchive::CopyFrom(const DrawableLockCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableLockCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableLockCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void DrawableLockCommandArchive::InternalSwap(DrawableLockCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableLockCommandArchive, _impl_.lock_)
      + sizeof(DrawableLockCommandArchive::_impl_.lock_)
      - PROTOBUF_FIELD_OFFSET(DrawableLockCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableLockCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[31]);
}

// ===================================================================

class DrawableInfoCommentCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableInfoCommentCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableInfoCommentCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawableInfoCommentCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& old_comment(const DrawableInfoCommentCommandArchive* msg);
  static void set_has_old_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& new_comment(const DrawableInfoCommentCommandArchive* msg);
  static void set_has_new_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableInfoCommentCommandArchive::_Internal::super(const DrawableInfoCommentCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableInfoCommentCommandArchive::_Internal::info(const DrawableInfoCommentCommandArchive* msg) {
  return *msg->_impl_.info_;
}
const ::TSP::Reference&
DrawableInfoCommentCommandArchive::_Internal::old_comment(const DrawableInfoCommentCommandArchive* msg) {
  return *msg->_impl_.old_comment_;
}
const ::TSP::Reference&
DrawableInfoCommentCommandArchive::_Internal::new_comment(const DrawableInfoCommentCommandArchive* msg) {
  return *msg->_impl_.new_comment_;
}
void DrawableInfoCommentCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawableInfoCommentCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawableInfoCommentCommandArchive::clear_old_comment() {
  if (_impl_.old_comment_ != nullptr) _impl_.old_comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DrawableInfoCommentCommandArchive::clear_new_comment() {
  if (_impl_.new_comment_ != nullptr) _impl_.new_comment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
DrawableInfoCommentCommandArchive::DrawableInfoCommentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableInfoCommentCommandArchive)
}
DrawableInfoCommentCommandArchive::DrawableInfoCommentCommandArchive(const DrawableInfoCommentCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableInfoCommentCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.old_comment_){nullptr}
    , decltype(_impl_.new_comment_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  if (from._internal_has_old_comment()) {
    _this->_impl_.old_comment_ = new ::TSP::Reference(*from._impl_.old_comment_);
  }
  if (from._internal_has_new_comment()) {
    _this->_impl_.new_comment_ = new ::TSP::Reference(*from._impl_.new_comment_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableInfoCommentCommandArchive)
}

inline void DrawableInfoCommentCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.old_comment_){nullptr}
    , decltype(_impl_.new_comment_){nullptr}
  };
}

DrawableInfoCommentCommandArchive::~DrawableInfoCommentCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableInfoCommentCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableInfoCommentCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
  if (this != internal_default_instance()) delete _impl_.old_comment_;
  if (this != internal_default_instance()) delete _impl_.new_comment_;
}

void DrawableInfoCommentCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableInfoCommentCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableInfoCommentCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.old_comment_ != nullptr);
      _impl_.old_comment_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.new_comment_ != nullptr);
      _impl_.new_comment_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableInfoCommentCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_comment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_comment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_comment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableInfoCommentCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableInfoCommentCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_comment = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::old_comment(this),
        _Internal::old_comment(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_comment = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::new_comment(this),
        _Internal::new_comment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableInfoCommentCommandArchive)
  return target;
}

size_t DrawableInfoCommentCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableInfoCommentCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional .TSP.Reference old_comment = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_comment_);
    }

    // optional .TSP.Reference new_comment = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_comment_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableInfoCommentCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableInfoCommentCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableInfoCommentCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableInfoCommentCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableInfoCommentCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableInfoCommentCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableInfoCommentCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_old_comment()->::TSP::Reference::MergeFrom(
          from._internal_old_comment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_new_comment()->::TSP::Reference::MergeFrom(
          from._internal_new_comment());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableInfoCommentCommandArchive::CopyFrom(const DrawableInfoCommentCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableInfoCommentCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableInfoCommentCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  if (_internal_has_old_comment()) {
    if (!_impl_.old_comment_->IsInitialized()) return false;
  }
  if (_internal_has_new_comment()) {
    if (!_impl_.new_comment_->IsInitialized()) return false;
  }
  return true;
}

void DrawableInfoCommentCommandArchive::InternalSwap(DrawableInfoCommentCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableInfoCommentCommandArchive, _impl_.new_comment_)
      + sizeof(DrawableInfoCommentCommandArchive::_impl_.new_comment_)
      - PROTOBUF_FIELD_OFFSET(DrawableInfoCommentCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableInfoCommentCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[32]);
}

// ===================================================================

class CommentStorageApplyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommentStorageApplyCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const CommentStorageApplyCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& comment_storage(const CommentStorageApplyCommandArchive* msg);
  static void set_has_comment_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_comment_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_comment_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TSK::CommandArchive&
CommentStorageApplyCommandArchive::_Internal::super(const CommentStorageApplyCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommentStorageApplyCommandArchive::_Internal::comment_storage(const CommentStorageApplyCommandArchive* msg) {
  return *msg->_impl_.comment_storage_;
}
void CommentStorageApplyCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommentStorageApplyCommandArchive::clear_comment_storage() {
  if (_impl_.comment_storage_ != nullptr) _impl_.comment_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommentStorageApplyCommandArchive::CommentStorageApplyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.CommentStorageApplyCommandArchive)
}
CommentStorageApplyCommandArchive::CommentStorageApplyCommandArchive(const CommentStorageApplyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommentStorageApplyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_string_){}
    , decltype(_impl_.old_comment_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comment_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment_string()) {
    _this->_impl_.comment_string_.Set(from._internal_comment_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_comment_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_comment_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_old_comment_string()) {
    _this->_impl_.old_comment_string_.Set(from._internal_old_comment_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_comment_storage()) {
    _this->_impl_.comment_storage_ = new ::TSP::Reference(*from._impl_.comment_storage_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.CommentStorageApplyCommandArchive)
}

inline void CommentStorageApplyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.comment_string_){}
    , decltype(_impl_.old_comment_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}
  };
  _impl_.comment_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_comment_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_comment_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommentStorageApplyCommandArchive::~CommentStorageApplyCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.CommentStorageApplyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommentStorageApplyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.comment_string_.Destroy();
  _impl_.old_comment_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.comment_storage_;
}

void CommentStorageApplyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommentStorageApplyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.CommentStorageApplyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.comment_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.old_comment_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.comment_storage_ != nullptr);
      _impl_.comment_storage_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommentStorageApplyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference comment_storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string comment_string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_comment_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.CommentStorageApplyCommandArchive.comment_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string old_comment_string = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_old_comment_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.CommentStorageApplyCommandArchive.old_comment_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommentStorageApplyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.CommentStorageApplyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference comment_storage = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::comment_storage(this),
        _Internal::comment_storage(this).GetCachedSize(), target, stream);
  }

  // required string comment_string = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_comment_string().data(), static_cast<int>(this->_internal_comment_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.CommentStorageApplyCommandArchive.comment_string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_comment_string(), target);
  }

  // required string old_comment_string = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_old_comment_string().data(), static_cast<int>(this->_internal_old_comment_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.CommentStorageApplyCommandArchive.old_comment_string");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_old_comment_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.CommentStorageApplyCommandArchive)
  return target;
}

size_t CommentStorageApplyCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.CommentStorageApplyCommandArchive)
  size_t total_size = 0;

  if (_internal_has_comment_string()) {
    // required string comment_string = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment_string());
  }

  if (_internal_has_old_comment_string()) {
    // required string old_comment_string = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_comment_string());
  }

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_comment_storage()) {
    // required .TSP.Reference comment_storage = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.comment_storage_);
  }

  return total_size;
}
size_t CommentStorageApplyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.CommentStorageApplyCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string comment_string = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_comment_string());

    // required string old_comment_string = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_comment_string());

    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference comment_storage = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.comment_storage_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommentStorageApplyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommentStorageApplyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommentStorageApplyCommandArchive::GetClassData() const { return &_class_data_; }


void CommentStorageApplyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommentStorageApplyCommandArchive*>(&to_msg);
  auto& from = static_cast<const CommentStorageApplyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.CommentStorageApplyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comment_string(from._internal_comment_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_old_comment_string(from._internal_old_comment_string());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_comment_storage()->::TSP::Reference::MergeFrom(
          from._internal_comment_storage());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommentStorageApplyCommandArchive::CopyFrom(const CommentStorageApplyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.CommentStorageApplyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommentStorageApplyCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_comment_storage()) {
    if (!_impl_.comment_storage_->IsInitialized()) return false;
  }
  return true;
}

void CommentStorageApplyCommandArchive::InternalSwap(CommentStorageApplyCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_string_, lhs_arena,
      &other->_impl_.comment_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_comment_string_, lhs_arena,
      &other->_impl_.old_comment_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommentStorageApplyCommandArchive, _impl_.comment_storage_)
      + sizeof(CommentStorageApplyCommandArchive::_impl_.comment_storage_)
      - PROTOBUF_FIELD_OFFSET(CommentStorageApplyCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommentStorageApplyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[33]);
}

// ===================================================================

class GuideCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<GuideCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const GuideCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const GuideCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSD::UserDefinedGuideArchive& old_guide(const GuideCommandArchive* msg);
  static void set_has_old_guide(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::UserDefinedGuideArchive& new_guide(const GuideCommandArchive* msg);
  static void set_has_new_guide(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
GuideCommandArchive::_Internal::super(const GuideCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
GuideCommandArchive::_Internal::storage(const GuideCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSD::UserDefinedGuideArchive&
GuideCommandArchive::_Internal::old_guide(const GuideCommandArchive* msg) {
  return *msg->_impl_.old_guide_;
}
const ::TSD::UserDefinedGuideArchive&
GuideCommandArchive::_Internal::new_guide(const GuideCommandArchive* msg) {
  return *msg->_impl_.new_guide_;
}
void GuideCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void GuideCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void GuideCommandArchive::clear_old_guide() {
  if (_impl_.old_guide_ != nullptr) _impl_.old_guide_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void GuideCommandArchive::clear_new_guide() {
  if (_impl_.new_guide_ != nullptr) _impl_.new_guide_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
GuideCommandArchive::GuideCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.GuideCommandArchive)
}
GuideCommandArchive::GuideCommandArchive(const GuideCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GuideCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.old_guide_){nullptr}
    , decltype(_impl_.new_guide_){nullptr}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_old_guide()) {
    _this->_impl_.old_guide_ = new ::TSD::UserDefinedGuideArchive(*from._impl_.old_guide_);
  }
  if (from._internal_has_new_guide()) {
    _this->_impl_.new_guide_ = new ::TSD::UserDefinedGuideArchive(*from._impl_.new_guide_);
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:TSD.GuideCommandArchive)
}

inline void GuideCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.old_guide_){nullptr}
    , decltype(_impl_.new_guide_){nullptr}
    , decltype(_impl_.mode_){1}
  };
}

GuideCommandArchive::~GuideCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.GuideCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GuideCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.old_guide_;
  if (this != internal_default_instance()) delete _impl_.new_guide_;
}

void GuideCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GuideCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.GuideCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.old_guide_ != nullptr);
      _impl_.old_guide_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.new_guide_ != nullptr);
      _impl_.new_guide_->Clear();
    }
    _impl_.mode_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GuideCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.UserDefinedGuideArchive old_guide = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_guide(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.UserDefinedGuideArchive new_guide = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_guide(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GuideCommandArchive.GuideCommandMode mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSD::GuideCommandArchive_GuideCommandMode_IsValid(val))) {
            _internal_set_mode(static_cast<::TSD::GuideCommandArchive_GuideCommandMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GuideCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.GuideCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.UserDefinedGuideArchive old_guide = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::old_guide(this),
        _Internal::old_guide(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.UserDefinedGuideArchive new_guide = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::new_guide(this),
        _Internal::new_guide(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GuideCommandArchive.GuideCommandMode mode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.GuideCommandArchive)
  return target;
}

size_t GuideCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.GuideCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSD.UserDefinedGuideArchive old_guide = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_guide_);
    }

    // optional .TSD.UserDefinedGuideArchive new_guide = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_guide_);
    }

    // optional .TSD.GuideCommandArchive.GuideCommandMode mode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GuideCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GuideCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GuideCommandArchive::GetClassData() const { return &_class_data_; }


void GuideCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GuideCommandArchive*>(&to_msg);
  auto& from = static_cast<const GuideCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.GuideCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_old_guide()->::TSD::UserDefinedGuideArchive::MergeFrom(
          from._internal_old_guide());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_new_guide()->::TSD::UserDefinedGuideArchive::MergeFrom(
          from._internal_new_guide());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GuideCommandArchive::CopyFrom(const GuideCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.GuideCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GuideCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  return true;
}

void GuideCommandArchive::InternalSwap(GuideCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GuideCommandArchive, _impl_.new_guide_)
      + sizeof(GuideCommandArchive::_impl_.new_guide_)
      - PROTOBUF_FIELD_OFFSET(GuideCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GuideCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[34]);
}

// ===================================================================

class DrawableAspectRatioLockedCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableAspectRatioLockedCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableAspectRatioLockedCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& info(const DrawableAspectRatioLockedCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_aspect_ratio_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableAspectRatioLockedCommandArchive::_Internal::super(const DrawableAspectRatioLockedCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableAspectRatioLockedCommandArchive::_Internal::info(const DrawableAspectRatioLockedCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void DrawableAspectRatioLockedCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DrawableAspectRatioLockedCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
DrawableAspectRatioLockedCommandArchive::DrawableAspectRatioLockedCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableAspectRatioLockedCommandArchive)
}
DrawableAspectRatioLockedCommandArchive::DrawableAspectRatioLockedCommandArchive(const DrawableAspectRatioLockedCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableAspectRatioLockedCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.aspect_ratio_locked_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  _this->_impl_.aspect_ratio_locked_ = from._impl_.aspect_ratio_locked_;
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableAspectRatioLockedCommandArchive)
}

inline void DrawableAspectRatioLockedCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
    , decltype(_impl_.aspect_ratio_locked_){false}
  };
}

DrawableAspectRatioLockedCommandArchive::~DrawableAspectRatioLockedCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableAspectRatioLockedCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableAspectRatioLockedCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void DrawableAspectRatioLockedCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableAspectRatioLockedCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableAspectRatioLockedCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_.aspect_ratio_locked_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableAspectRatioLockedCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool aspect_ratio_locked = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_aspect_ratio_locked(&has_bits);
          _impl_.aspect_ratio_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableAspectRatioLockedCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableAspectRatioLockedCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional bool aspect_ratio_locked = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_aspect_ratio_locked(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableAspectRatioLockedCommandArchive)
  return target;
}

size_t DrawableAspectRatioLockedCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableAspectRatioLockedCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.info_);
    }

    // optional bool aspect_ratio_locked = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableAspectRatioLockedCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableAspectRatioLockedCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableAspectRatioLockedCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableAspectRatioLockedCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableAspectRatioLockedCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableAspectRatioLockedCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableAspectRatioLockedCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.aspect_ratio_locked_ = from._impl_.aspect_ratio_locked_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableAspectRatioLockedCommandArchive::CopyFrom(const DrawableAspectRatioLockedCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableAspectRatioLockedCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableAspectRatioLockedCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void DrawableAspectRatioLockedCommandArchive::InternalSwap(DrawableAspectRatioLockedCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableAspectRatioLockedCommandArchive, _impl_.aspect_ratio_locked_)
      + sizeof(DrawableAspectRatioLockedCommandArchive::_impl_.aspect_ratio_locked_)
      - PROTOBUF_FIELD_OFFSET(DrawableAspectRatioLockedCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableAspectRatioLockedCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[35]);
}

// ===================================================================

class DrawableAccessibilityDescriptionCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DrawableAccessibilityDescriptionCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const DrawableAccessibilityDescriptionCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& info(const DrawableAccessibilityDescriptionCommandArchive* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_accessibility_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSK::CommandArchive&
DrawableAccessibilityDescriptionCommandArchive::_Internal::super(const DrawableAccessibilityDescriptionCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
DrawableAccessibilityDescriptionCommandArchive::_Internal::info(const DrawableAccessibilityDescriptionCommandArchive* msg) {
  return *msg->_impl_.info_;
}
void DrawableAccessibilityDescriptionCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DrawableAccessibilityDescriptionCommandArchive::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
DrawableAccessibilityDescriptionCommandArchive::DrawableAccessibilityDescriptionCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.DrawableAccessibilityDescriptionCommandArchive)
}
DrawableAccessibilityDescriptionCommandArchive::DrawableAccessibilityDescriptionCommandArchive(const DrawableAccessibilityDescriptionCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawableAccessibilityDescriptionCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accessibility_description()) {
    _this->_impl_.accessibility_description_.Set(from._internal_accessibility_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::TSP::Reference(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.DrawableAccessibilityDescriptionCommandArchive)
}

inline void DrawableAccessibilityDescriptionCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.accessibility_description_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.info_){nullptr}
  };
  _impl_.accessibility_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.accessibility_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DrawableAccessibilityDescriptionCommandArchive::~DrawableAccessibilityDescriptionCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.DrawableAccessibilityDescriptionCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableAccessibilityDescriptionCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.accessibility_description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.info_;
}

void DrawableAccessibilityDescriptionCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawableAccessibilityDescriptionCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.DrawableAccessibilityDescriptionCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.accessibility_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.info_ != nullptr);
      _impl_.info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawableAccessibilityDescriptionCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string accessibility_description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_accessibility_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSD.DrawableAccessibilityDescriptionCommandArchive.accessibility_description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableAccessibilityDescriptionCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.DrawableAccessibilityDescriptionCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional string accessibility_description = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_accessibility_description().data(), static_cast<int>(this->_internal_accessibility_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSD.DrawableAccessibilityDescriptionCommandArchive.accessibility_description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_accessibility_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.DrawableAccessibilityDescriptionCommandArchive)
  return target;
}

size_t DrawableAccessibilityDescriptionCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.DrawableAccessibilityDescriptionCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string accessibility_description = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_accessibility_description());
  }

  // optional .TSP.Reference info = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawableAccessibilityDescriptionCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawableAccessibilityDescriptionCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawableAccessibilityDescriptionCommandArchive::GetClassData() const { return &_class_data_; }


void DrawableAccessibilityDescriptionCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawableAccessibilityDescriptionCommandArchive*>(&to_msg);
  auto& from = static_cast<const DrawableAccessibilityDescriptionCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.DrawableAccessibilityDescriptionCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_accessibility_description(from._internal_accessibility_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_info()->::TSP::Reference::MergeFrom(
          from._internal_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawableAccessibilityDescriptionCommandArchive::CopyFrom(const DrawableAccessibilityDescriptionCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.DrawableAccessibilityDescriptionCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableAccessibilityDescriptionCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_info()) {
    if (!_impl_.info_->IsInitialized()) return false;
  }
  return true;
}

void DrawableAccessibilityDescriptionCommandArchive::InternalSwap(DrawableAccessibilityDescriptionCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.accessibility_description_, lhs_arena,
      &other->_impl_.accessibility_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DrawableAccessibilityDescriptionCommandArchive, _impl_.info_)
      + sizeof(DrawableAccessibilityDescriptionCommandArchive::_impl_.info_)
      - PROTOBUF_FIELD_OFFSET(DrawableAccessibilityDescriptionCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawableAccessibilityDescriptionCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[36]);
}

// ===================================================================

class PasteStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PasteStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const PasteStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& dest_info(const PasteStyleCommandArchive* msg);
  static void set_has_dest_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& shape_style(const PasteStyleCommandArchive* msg);
  static void set_has_shape_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSK::CommandArchive&
PasteStyleCommandArchive::_Internal::super(const PasteStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
PasteStyleCommandArchive::_Internal::dest_info(const PasteStyleCommandArchive* msg) {
  return *msg->_impl_.dest_info_;
}
const ::TSP::Reference&
PasteStyleCommandArchive::_Internal::shape_style(const PasteStyleCommandArchive* msg) {
  return *msg->_impl_.shape_style_;
}
void PasteStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PasteStyleCommandArchive::clear_dest_info() {
  if (_impl_.dest_info_ != nullptr) _impl_.dest_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PasteStyleCommandArchive::clear_shape_style() {
  if (_impl_.shape_style_ != nullptr) _impl_.shape_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PasteStyleCommandArchive::PasteStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSD.PasteStyleCommandArchive)
}
PasteStyleCommandArchive::PasteStyleCommandArchive(const PasteStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PasteStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.dest_info_){nullptr}
    , decltype(_impl_.shape_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_dest_info()) {
    _this->_impl_.dest_info_ = new ::TSP::Reference(*from._impl_.dest_info_);
  }
  if (from._internal_has_shape_style()) {
    _this->_impl_.shape_style_ = new ::TSP::Reference(*from._impl_.shape_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSD.PasteStyleCommandArchive)
}

inline void PasteStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.dest_info_){nullptr}
    , decltype(_impl_.shape_style_){nullptr}
  };
}

PasteStyleCommandArchive::~PasteStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSD.PasteStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PasteStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.dest_info_;
  if (this != internal_default_instance()) delete _impl_.shape_style_;
}

void PasteStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PasteStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSD.PasteStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dest_info_ != nullptr);
      _impl_.dest_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.shape_style_ != nullptr);
      _impl_.shape_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PasteStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference dest_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dest_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference shape_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PasteStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSD.PasteStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference dest_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dest_info(this),
        _Internal::dest_info(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference shape_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::shape_style(this),
        _Internal::shape_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSD.PasteStyleCommandArchive)
  return target;
}

size_t PasteStyleCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSD.PasteStyleCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_dest_info()) {
    // required .TSP.Reference dest_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dest_info_);
  }

  return total_size;
}
size_t PasteStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSD.PasteStyleCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference dest_info = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dest_info_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference shape_style = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.shape_style_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PasteStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PasteStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PasteStyleCommandArchive::GetClassData() const { return &_class_data_; }


void PasteStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PasteStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const PasteStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSD.PasteStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dest_info()->::TSP::Reference::MergeFrom(
          from._internal_dest_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_shape_style()->::TSP::Reference::MergeFrom(
          from._internal_shape_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PasteStyleCommandArchive::CopyFrom(const PasteStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSD.PasteStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PasteStyleCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_dest_info()) {
    if (!_impl_.dest_info_->IsInitialized()) return false;
  }
  if (_internal_has_shape_style()) {
    if (!_impl_.shape_style_->IsInitialized()) return false;
  }
  return true;
}

void PasteStyleCommandArchive::InternalSwap(PasteStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PasteStyleCommandArchive, _impl_.shape_style_)
      + sizeof(PasteStyleCommandArchive::_impl_.shape_style_)
      - PROTOBUF_FIELD_OFFSET(PasteStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PasteStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSDCommandArchives_2eproto_getter, &descriptor_table_TSDCommandArchives_2eproto_once,
      file_level_metadata_TSDCommandArchives_2eproto[37]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSD
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSD::ConnectionLineConnectCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ConnectionLineConnectCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ConnectionLineConnectCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GroupDrawablesCommandArchive*
Arena::CreateMaybeMessage< ::TSD::GroupDrawablesCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GroupDrawablesCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::UngroupGroupCommandArchive*
Arena::CreateMaybeMessage< ::TSD::UngroupGroupCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::UngroupGroupCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContainerRemoveChildrenCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ContainerRemoveChildrenCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContainerRemoveChildrenCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContainerInsertChildrenCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ContainerInsertChildrenCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContainerInsertChildrenCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ContainerReorderChildrenCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ContainerReorderChildrenCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ContainerReorderChildrenCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::InfoGeometryCommandArchive*
Arena::CreateMaybeMessage< ::TSD::InfoGeometryCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::InfoGeometryCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawablePathSourceCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawablePathSourceCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawablePathSourceCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::InstantAlphaCommandArchive*
Arena::CreateMaybeMessage< ::TSD::InstantAlphaCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::InstantAlphaCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableShadowCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableShadowCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableShadowCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableApplyThemeCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableApplyThemeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableApplyThemeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::StyledInfoSetStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSD::StyledInfoSetStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::StyledInfoSetStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapePathSourceFlipCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ShapePathSourceFlipCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapePathSourceFlipCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeStyleSetValueCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeStyleSetValueCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeStyleSetValueCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeApplyPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeApplyPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeApplyPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ShapeSetLineEndCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ShapeSetLineEndCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ShapeSetLineEndCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieSetValueCommandArchive_PropertyValue*
Arena::CreateMaybeMessage< ::TSD::MovieSetValueCommandArchive_PropertyValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieSetValueCommandArchive_PropertyValue >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MovieSetValueCommandArchive*
Arena::CreateMaybeMessage< ::TSD::MovieSetValueCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MovieSetValueCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaStyleSetValueCommandArchive*
Arena::CreateMaybeMessage< ::TSD::MediaStyleSetValueCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaStyleSetValueCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageMediaCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ImageMediaCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageMediaCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaOriginalSizeCommandArchive*
Arena::CreateMaybeMessage< ::TSD::MediaOriginalSizeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaOriginalSizeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageMaskCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ImageMaskCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageMaskCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaApplyPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSD::MediaApplyPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaApplyPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageAdjustmentsCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ImageAdjustmentsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageAdjustmentsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::MediaFlagsCommandArchive*
Arena::CreateMaybeMessage< ::TSD::MediaFlagsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::MediaFlagsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawablesCommandGroupArchive*
Arena::CreateMaybeMessage< ::TSD::DrawablesCommandGroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawablesCommandGroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap*
Arena::CreateMaybeMessage< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ExteriorTextWrapCommandArchive_InfoAndWrap >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ExteriorTextWrapCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ExteriorTextWrapCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ExteriorTextWrapCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableHyperlinkCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableHyperlinkCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableHyperlinkCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CommandSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TSD::CommandSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CommandSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::ImageReplaceCommandArchive*
Arena::CreateMaybeMessage< ::TSD::ImageReplaceCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::ImageReplaceCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableLockCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableLockCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableLockCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableInfoCommentCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableInfoCommentCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableInfoCommentCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::CommentStorageApplyCommandArchive*
Arena::CreateMaybeMessage< ::TSD::CommentStorageApplyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::CommentStorageApplyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::GuideCommandArchive*
Arena::CreateMaybeMessage< ::TSD::GuideCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::GuideCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableAspectRatioLockedCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableAspectRatioLockedCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableAspectRatioLockedCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::DrawableAccessibilityDescriptionCommandArchive*
Arena::CreateMaybeMessage< ::TSD::DrawableAccessibilityDescriptionCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::DrawableAccessibilityDescriptionCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSD::PasteStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSD::PasteStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSD::PasteStyleCommandArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
