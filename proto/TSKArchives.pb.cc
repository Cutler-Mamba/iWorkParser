// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSKArchives.proto

#include "TSKArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSK {
PROTOBUF_CONSTEXPR TreeNode::TreeNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.object_)*/nullptr} {}
struct TreeNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TreeNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TreeNodeDefaultTypeInternal() {}
  union {
    TreeNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
PROTOBUF_CONSTEXPR CommandHistory::CommandHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_.marked_redo_commands_)*/{}
  , /*decltype(_impl_.pending_preflight_command_)*/nullptr
  , /*decltype(_impl_.undo_count_)*/0u
  , /*decltype(_impl_.fixed_radar_13365177_)*/false} {}
struct CommandHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandHistoryDefaultTypeInternal() {}
  union {
    CommandHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandHistoryDefaultTypeInternal _CommandHistory_default_instance_;
PROTOBUF_CONSTEXPR DocumentArchive::DocumentArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.locale_identifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.annotation_author_storage_)*/nullptr} {}
struct DocumentArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentArchiveDefaultTypeInternal() {}
  union {
    DocumentArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentArchiveDefaultTypeInternal _DocumentArchive_default_instance_;
PROTOBUF_CONSTEXPR DocumentSupportArchive::DocumentSupportArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.undo_action_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.redo_action_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_history_)*/nullptr
  , /*decltype(_impl_.command_selection_behavior_history_)*/nullptr
  , /*decltype(_impl_.web_state_)*/nullptr
  , /*decltype(_impl_.undo_count_)*/0u
  , /*decltype(_impl_.redo_count_)*/0u} {}
struct DocumentSupportArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocumentSupportArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocumentSupportArchiveDefaultTypeInternal() {}
  union {
    DocumentSupportArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocumentSupportArchiveDefaultTypeInternal _DocumentSupportArchive_default_instance_;
PROTOBUF_CONSTEXPR ViewStateArchive::ViewStateArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.view_state_root_)*/nullptr} {}
struct ViewStateArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViewStateArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViewStateArchiveDefaultTypeInternal() {}
  union {
    ViewStateArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewStateArchiveDefaultTypeInternal _ViewStateArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandArchive::CommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.undoredostate_)*/nullptr
  , /*decltype(_impl_.undocollection_)*/nullptr} {}
struct CommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandArchiveDefaultTypeInternal() {}
  union {
    CommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandArchiveDefaultTypeInternal _CommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandGroupArchive::CommandGroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.process_results_)*/nullptr} {}
struct CommandGroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandGroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandGroupArchiveDefaultTypeInternal() {}
  union {
    CommandGroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandGroupArchiveDefaultTypeInternal _CommandGroupArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandContainerArchive::CommandContainerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CommandContainerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandContainerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandContainerArchiveDefaultTypeInternal() {}
  union {
    CommandContainerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandContainerArchiveDefaultTypeInternal _CommandContainerArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAllChildCommandArchive::ReplaceAllChildCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ReplaceAllChildCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAllChildCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAllChildCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAllChildCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAllChildCommandArchiveDefaultTypeInternal _ReplaceAllChildCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAllCommandArchive::ReplaceAllCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commands_)*/{}
  , /*decltype(_impl_.find_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.replace_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.options_)*/0u} {}
struct ReplaceAllCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAllCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAllCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAllCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAllCommandArchiveDefaultTypeInternal _ReplaceAllCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShuffleMappingArchive_Entry::ShuffleMappingArchive_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.from_)*/0u
  , /*decltype(_impl_.to_)*/0u} {}
struct ShuffleMappingArchive_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShuffleMappingArchive_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShuffleMappingArchive_EntryDefaultTypeInternal() {}
  union {
    ShuffleMappingArchive_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShuffleMappingArchive_EntryDefaultTypeInternal _ShuffleMappingArchive_Entry_default_instance_;
PROTOBUF_CONSTEXPR ShuffleMappingArchive::ShuffleMappingArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.start_index_)*/0u
  , /*decltype(_impl_.end_index_)*/0u
  , /*decltype(_impl_.is_move_operation_)*/false
  , /*decltype(_impl_.first_moved_index_)*/0u
  , /*decltype(_impl_.destination_index_for_move_)*/0u
  , /*decltype(_impl_.number_of_indices_moved_)*/0u
  , /*decltype(_impl_.is_vertical_)*/true} {}
struct ShuffleMappingArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShuffleMappingArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShuffleMappingArchiveDefaultTypeInternal() {}
  union {
    ShuffleMappingArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShuffleMappingArchiveDefaultTypeInternal _ShuffleMappingArchive_default_instance_;
PROTOBUF_CONSTEXPR ProgressiveCommandGroupArchive::ProgressiveCommandGroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ProgressiveCommandGroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProgressiveCommandGroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProgressiveCommandGroupArchiveDefaultTypeInternal() {}
  union {
    ProgressiveCommandGroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProgressiveCommandGroupArchiveDefaultTypeInternal _ProgressiveCommandGroupArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchive_Entry::CommandSelectionBehaviorHistoryArchive_Entry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_)*/nullptr
  , /*decltype(_impl_.command_selection_behavior_)*/nullptr} {}
struct CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal() {}
  union {
    CommandSelectionBehaviorHistoryArchive_Entry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal _CommandSelectionBehaviorHistoryArchive_Entry_default_instance_;
PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchive::CommandSelectionBehaviorHistoryArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal() {}
  union {
    CommandSelectionBehaviorHistoryArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal _CommandSelectionBehaviorHistoryArchive_default_instance_;
PROTOBUF_CONSTEXPR UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.undo_redo_state_)*/nullptr} {}
struct UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    UndoRedoStateCommandSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal _UndoRedoStateCommandSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR FormatStructArchive::FormatStructArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.interstitial_strings_)*/{}
  , /*decltype(_impl_.currency_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.date_time_format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.custom_format_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.inters_str_insertion_indexes_)*/nullptr
  , /*decltype(_impl_.format_type_)*/0u
  , /*decltype(_impl_.decimal_places_)*/0u
  , /*decltype(_impl_.negative_style_)*/0u
  , /*decltype(_impl_.duration_style_)*/0u
  , /*decltype(_impl_.base_)*/0u
  , /*decltype(_impl_.show_thousands_separator_)*/false
  , /*decltype(_impl_.use_accounting_style_)*/false
  , /*decltype(_impl_.base_use_minus_sign_)*/false
  , /*decltype(_impl_.suppress_date_format_)*/false
  , /*decltype(_impl_.base_places_)*/0u
  , /*decltype(_impl_.fraction_accuracy_)*/0u
  , /*decltype(_impl_.duration_unit_largest_)*/0u
  , /*decltype(_impl_.duration_unit_smallest_)*/0u
  , /*decltype(_impl_.scale_factor_)*/0
  , /*decltype(_impl_.custom_id_)*/0u
  , /*decltype(_impl_.control_format_type_)*/0u
  , /*decltype(_impl_.control_minimum_)*/0
  , /*decltype(_impl_.control_maximum_)*/0
  , /*decltype(_impl_.control_increment_)*/0
  , /*decltype(_impl_.slider_orientation_)*/0u
  , /*decltype(_impl_.slider_position_)*/0u
  , /*decltype(_impl_.suppress_time_format_)*/false
  , /*decltype(_impl_.requires_fraction_replacement_)*/false
  , /*decltype(_impl_.is_complex_)*/false
  , /*decltype(_impl_.contains_integer_token_)*/false
  , /*decltype(_impl_.decimal_width_)*/0u
  , /*decltype(_impl_.min_integer_width_)*/0u
  , /*decltype(_impl_.num_nonspace_integer_digits_)*/0u
  , /*decltype(_impl_.num_nonspace_decimal_digits_)*/0u
  , /*decltype(_impl_.index_from_right_last_integer_)*/0u
  , /*decltype(_impl_.num_hash_decimal_digits_)*/0u
  , /*decltype(_impl_.total_num_decimal_digits_)*/0u
  , /*decltype(_impl_.multiple_choice_list_initial_value_)*/0u
  , /*decltype(_impl_.multiple_choice_list_id_)*/0u
  , /*decltype(_impl_.use_automatic_duration_units_)*/false} {}
struct FormatStructArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormatStructArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormatStructArchiveDefaultTypeInternal() {}
  union {
    FormatStructArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormatStructArchiveDefaultTypeInternal _FormatStructArchive_default_instance_;
PROTOBUF_CONSTEXPR CustomFormatArchive_Condition::CustomFormatArchive_Condition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.condition_format_)*/nullptr
  , /*decltype(_impl_.condition_type_)*/0u
  , /*decltype(_impl_.condition_value_)*/0
  , /*decltype(_impl_.condition_value_dbl_)*/0} {}
struct CustomFormatArchive_ConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomFormatArchive_ConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomFormatArchive_ConditionDefaultTypeInternal() {}
  union {
    CustomFormatArchive_Condition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomFormatArchive_ConditionDefaultTypeInternal _CustomFormatArchive_Condition_default_instance_;
PROTOBUF_CONSTEXPR CustomFormatArchive::CustomFormatArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.conditions_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.default_format_)*/nullptr
  , /*decltype(_impl_.format_type_)*/0u} {}
struct CustomFormatArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CustomFormatArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CustomFormatArchiveDefaultTypeInternal() {}
  union {
    CustomFormatArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomFormatArchiveDefaultTypeInternal _CustomFormatArchive_default_instance_;
PROTOBUF_CONSTEXPR AnnotationAuthorArchive::AnnotationAuthorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.color_)*/nullptr} {}
struct AnnotationAuthorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnnotationAuthorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnnotationAuthorArchiveDefaultTypeInternal() {}
  union {
    AnnotationAuthorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnnotationAuthorArchiveDefaultTypeInternal _AnnotationAuthorArchive_default_instance_;
PROTOBUF_CONSTEXPR DeprecatedChangeAuthorArchive::DeprecatedChangeAuthorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.change_color_)*/nullptr} {}
struct DeprecatedChangeAuthorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeprecatedChangeAuthorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeprecatedChangeAuthorArchiveDefaultTypeInternal() {}
  union {
    DeprecatedChangeAuthorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeprecatedChangeAuthorArchiveDefaultTypeInternal _DeprecatedChangeAuthorArchive_default_instance_;
PROTOBUF_CONSTEXPR AnnotationAuthorStorageArchive::AnnotationAuthorStorageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.annotation_author_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AnnotationAuthorStorageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnnotationAuthorStorageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnnotationAuthorStorageArchiveDefaultTypeInternal() {}
  union {
    AnnotationAuthorStorageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnnotationAuthorStorageArchiveDefaultTypeInternal _AnnotationAuthorStorageArchive_default_instance_;
PROTOBUF_CONSTEXPR AddAnnotationAuthorCommandArchive::AddAnnotationAuthorCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.document_root_)*/nullptr
  , /*decltype(_impl_.annotation_author_)*/nullptr} {}
struct AddAnnotationAuthorCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AddAnnotationAuthorCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AddAnnotationAuthorCommandArchiveDefaultTypeInternal() {}
  union {
    AddAnnotationAuthorCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddAnnotationAuthorCommandArchiveDefaultTypeInternal _AddAnnotationAuthorCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR SetAnnotationAuthorColorCommandArchive::SetAnnotationAuthorColorCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.annotation_author_)*/nullptr
  , /*decltype(_impl_.color_)*/nullptr} {}
struct SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal() {}
  union {
    SetAnnotationAuthorColorCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal _SetAnnotationAuthorColorCommandArchive_default_instance_;
}  // namespace TSK
static ::_pb::Metadata file_level_metadata_TSKArchives_2eproto[24];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_TSKArchives_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSKArchives_2eproto = nullptr;

const uint32_t TableStruct_TSKArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSK::TreeNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::TreeNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::TreeNode, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TSK::TreeNode, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TSK::TreeNode, _impl_.object_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_.undo_count_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_.commands_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_.marked_redo_commands_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_.pending_preflight_command_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandHistory, _impl_.fixed_radar_13365177_),
  1,
  ~0u,
  ~0u,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentArchive, _impl_.locale_identifier_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentArchive, _impl_.annotation_author_storage_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.command_history_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.command_selection_behavior_history_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.undo_count_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.redo_count_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.undo_action_string_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.redo_action_string_),
  PROTOBUF_FIELD_OFFSET(::TSK::DocumentSupportArchive, _impl_.web_state_),
  2,
  3,
  5,
  6,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::TSK::ViewStateArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ViewStateArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ViewStateArchive, _impl_.view_state_root_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSK::CommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandArchive, _impl_.undoredostate_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandArchive, _impl_.undocollection_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSK::CommandGroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandGroupArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandGroupArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandGroupArchive, _impl_.commands_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandGroupArchive, _impl_.process_results_),
  0,
  ~0u,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandContainerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandContainerArchive, _impl_.commands_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllChildCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllChildCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllChildCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_.commands_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_.find_string_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_.replace_string_),
  PROTOBUF_FIELD_OFFSET(::TSK::ReplaceAllCommandArchive, _impl_.options_),
  2,
  ~0u,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive_Entry, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive_Entry, _impl_.to_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.start_index_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.end_index_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.entries_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.is_vertical_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.is_move_operation_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.first_moved_index_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.destination_index_for_move_),
  PROTOBUF_FIELD_OFFSET(::TSK::ShuffleMappingArchive, _impl_.number_of_indices_moved_),
  0,
  1,
  ~0u,
  6,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSK::ProgressiveCommandGroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::ProgressiveCommandGroupArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::ProgressiveCommandGroupArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive_Entry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive_Entry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive_Entry, _impl_.command_),
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive_Entry, _impl_.command_selection_behavior_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CommandSelectionBehaviorHistoryArchive, _impl_.entries_),
  PROTOBUF_FIELD_OFFSET(::TSK::UndoRedoStateCommandSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::UndoRedoStateCommandSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.undo_redo_state_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_._extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.format_type_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.decimal_places_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.currency_code_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.negative_style_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.show_thousands_separator_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.use_accounting_style_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.duration_style_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.base_places_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.base_use_minus_sign_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.fraction_accuracy_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.suppress_date_format_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.suppress_time_format_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.date_time_format_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.duration_unit_largest_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.duration_unit_smallest_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.custom_id_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.custom_format_string_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.scale_factor_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.requires_fraction_replacement_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.control_minimum_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.control_maximum_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.control_increment_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.control_format_type_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.slider_orientation_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.slider_position_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.decimal_width_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.min_integer_width_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.num_nonspace_integer_digits_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.num_nonspace_decimal_digits_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.index_from_right_last_integer_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.interstitial_strings_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.inters_str_insertion_indexes_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.num_hash_decimal_digits_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.total_num_decimal_digits_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.is_complex_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.contains_integer_token_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.multiple_choice_list_initial_value_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.multiple_choice_list_id_),
  PROTOBUF_FIELD_OFFSET(::TSK::FormatStructArchive, _impl_.use_automatic_duration_units_),
  4,
  5,
  0,
  6,
  9,
  10,
  7,
  8,
  13,
  11,
  14,
  12,
  25,
  1,
  15,
  16,
  18,
  2,
  17,
  26,
  20,
  21,
  22,
  19,
  23,
  24,
  29,
  30,
  31,
  32,
  33,
  ~0u,
  3,
  34,
  35,
  27,
  28,
  36,
  37,
  38,
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _impl_.condition_type_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _impl_.condition_value_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _impl_.condition_format_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive_Condition, _impl_.condition_value_dbl_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _impl_.format_type_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _impl_.default_format_),
  PROTOBUF_FIELD_OFFSET(::TSK::CustomFormatArchive, _impl_.conditions_),
  0,
  2,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorArchive, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorArchive, _impl_.color_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSK::DeprecatedChangeAuthorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::DeprecatedChangeAuthorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::DeprecatedChangeAuthorArchive, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::TSK::DeprecatedChangeAuthorArchive, _impl_.change_color_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorStorageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::AnnotationAuthorStorageArchive, _impl_.annotation_author_),
  PROTOBUF_FIELD_OFFSET(::TSK::AddAnnotationAuthorCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::AddAnnotationAuthorCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::AddAnnotationAuthorCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSK::AddAnnotationAuthorCommandArchive, _impl_.document_root_),
  PROTOBUF_FIELD_OFFSET(::TSK::AddAnnotationAuthorCommandArchive, _impl_.annotation_author_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSK::SetAnnotationAuthorColorCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSK::SetAnnotationAuthorColorCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSK::SetAnnotationAuthorColorCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSK::SetAnnotationAuthorColorCommandArchive, _impl_.annotation_author_),
  PROTOBUF_FIELD_OFFSET(::TSK::SetAnnotationAuthorColorCommandArchive, _impl_.color_),
  0,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::TSK::TreeNode)},
  { 12, 23, -1, sizeof(::TSK::CommandHistory)},
  { 28, 36, -1, sizeof(::TSK::DocumentArchive)},
  { 38, 51, -1, sizeof(::TSK::DocumentSupportArchive)},
  { 58, 65, -1, sizeof(::TSK::ViewStateArchive)},
  { 66, 74, -1, sizeof(::TSK::CommandArchive)},
  { 76, 85, -1, sizeof(::TSK::CommandGroupArchive)},
  { 88, -1, -1, sizeof(::TSK::CommandContainerArchive)},
  { 95, 102, -1, sizeof(::TSK::ReplaceAllChildCommandArchive)},
  { 103, 114, -1, sizeof(::TSK::ReplaceAllCommandArchive)},
  { 119, 127, -1, sizeof(::TSK::ShuffleMappingArchive_Entry)},
  { 129, 143, -1, sizeof(::TSK::ShuffleMappingArchive)},
  { 151, 158, -1, sizeof(::TSK::ProgressiveCommandGroupArchive)},
  { 159, 167, -1, sizeof(::TSK::CommandSelectionBehaviorHistoryArchive_Entry)},
  { 169, -1, -1, sizeof(::TSK::CommandSelectionBehaviorHistoryArchive)},
  { 176, 183, -1, sizeof(::TSK::UndoRedoStateCommandSelectionBehaviorArchive)},
  { 184, 230, -1, sizeof(::TSK::FormatStructArchive)},
  { 270, 280, -1, sizeof(::TSK::CustomFormatArchive_Condition)},
  { 284, 294, -1, sizeof(::TSK::CustomFormatArchive)},
  { 298, 306, -1, sizeof(::TSK::AnnotationAuthorArchive)},
  { 308, 316, -1, sizeof(::TSK::DeprecatedChangeAuthorArchive)},
  { 318, -1, -1, sizeof(::TSK::AnnotationAuthorStorageArchive)},
  { 325, 334, -1, sizeof(::TSK::AddAnnotationAuthorCommandArchive)},
  { 337, 346, -1, sizeof(::TSK::SetAnnotationAuthorColorCommandArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSK::_TreeNode_default_instance_._instance,
  &::TSK::_CommandHistory_default_instance_._instance,
  &::TSK::_DocumentArchive_default_instance_._instance,
  &::TSK::_DocumentSupportArchive_default_instance_._instance,
  &::TSK::_ViewStateArchive_default_instance_._instance,
  &::TSK::_CommandArchive_default_instance_._instance,
  &::TSK::_CommandGroupArchive_default_instance_._instance,
  &::TSK::_CommandContainerArchive_default_instance_._instance,
  &::TSK::_ReplaceAllChildCommandArchive_default_instance_._instance,
  &::TSK::_ReplaceAllCommandArchive_default_instance_._instance,
  &::TSK::_ShuffleMappingArchive_Entry_default_instance_._instance,
  &::TSK::_ShuffleMappingArchive_default_instance_._instance,
  &::TSK::_ProgressiveCommandGroupArchive_default_instance_._instance,
  &::TSK::_CommandSelectionBehaviorHistoryArchive_Entry_default_instance_._instance,
  &::TSK::_CommandSelectionBehaviorHistoryArchive_default_instance_._instance,
  &::TSK::_UndoRedoStateCommandSelectionBehaviorArchive_default_instance_._instance,
  &::TSK::_FormatStructArchive_default_instance_._instance,
  &::TSK::_CustomFormatArchive_Condition_default_instance_._instance,
  &::TSK::_CustomFormatArchive_default_instance_._instance,
  &::TSK::_AnnotationAuthorArchive_default_instance_._instance,
  &::TSK::_DeprecatedChangeAuthorArchive_default_instance_._instance,
  &::TSK::_AnnotationAuthorStorageArchive_default_instance_._instance,
  &::TSK::_AddAnnotationAuthorCommandArchive_default_instance_._instance,
  &::TSK::_SetAnnotationAuthorColorCommandArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSKArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021TSKArchives.proto\022\003TSK\032\021TSPMessages.pr"
  "oto\"Z\n\010TreeNode\022\014\n\004name\030\001 \001(\t\022 \n\010childre"
  "n\030\002 \003(\0132\016.TSP.Reference\022\036\n\006object\030\003 \001(\0132"
  "\016.TSP.Reference\"\305\001\n\016CommandHistory\022\022\n\nun"
  "do_count\030\001 \002(\r\022 \n\010commands\030\002 \003(\0132\016.TSP.R"
  "eference\022,\n\024marked_redo_commands\030\003 \003(\0132\016"
  ".TSP.Reference\0221\n\031pending_preflight_comm"
  "and\030\004 \001(\0132\016.TSP.Reference\022\034\n\024fixed_radar"
  "_13365177\030\n \001(\010\"_\n\017DocumentArchive\022\031\n\021lo"
  "cale_identifier\030\004 \001(\t\0221\n\031annotation_auth"
  "or_storage\030\007 \001(\0132\016.TSP.Reference\"\200\002\n\026Doc"
  "umentSupportArchive\022\'\n\017command_history\030\001"
  " \001(\0132\016.TSP.Reference\022:\n\"command_selectio"
  "n_behavior_history\030\002 \001(\0132\016.TSP.Reference"
  "\022\022\n\nundo_count\030\004 \001(\r\022\022\n\nredo_count\030\005 \001(\r"
  "\022\032\n\022undo_action_string\030\006 \001(\t\022\032\n\022redo_act"
  "ion_string\030\007 \001(\t\022!\n\tweb_state\030\010 \001(\0132\016.TS"
  "P.Reference\";\n\020ViewStateArchive\022\'\n\017view_"
  "state_root\030\001 \002(\0132\016.TSP.Reference\"_\n\016Comm"
  "andArchive\022%\n\rundoRedoState\030\001 \001(\0132\016.TSP."
  "Reference\022&\n\016undoCollection\030\002 \001(\0132\016.TSP."
  "Reference\"\203\001\n\023CommandGroupArchive\022\"\n\005sup"
  "er\030\001 \002(\0132\023.TSK.CommandArchive\022 \n\010command"
  "s\030\002 \003(\0132\016.TSP.Reference\022&\n\017process_resul"
  "ts\030\003 \001(\0132\r.TSP.IndexSet\";\n\027CommandContai"
  "nerArchive\022 \n\010commands\030\001 \003(\0132\016.TSP.Refer"
  "ence\"C\n\035ReplaceAllChildCommandArchive\022\"\n"
  "\005super\030\001 \002(\0132\023.TSK.CommandArchive\"\236\001\n\030Re"
  "placeAllCommandArchive\022\"\n\005super\030\001 \002(\0132\023."
  "TSK.CommandArchive\022 \n\010commands\030\002 \003(\0132\016.T"
  "SP.Reference\022\023\n\013find_string\030\003 \002(\t\022\026\n\016rep"
  "lace_string\030\004 \002(\t\022\017\n\007options\030\005 \002(\r\"\273\002\n\025S"
  "huffleMappingArchive\022\023\n\013start_index\030\001 \002("
  "\r\022\021\n\tend_index\030\002 \002(\r\0221\n\007entries\030\003 \003(\0132 ."
  "TSK.ShuffleMappingArchive.Entry\022\031\n\013is_ve"
  "rtical\030\004 \001(\010:\004true\022 \n\021is_move_operation\030"
  "\005 \001(\010:\005false\022\034\n\021first_moved_index\030\006 \001(\r:"
  "\0010\022%\n\032destination_index_for_move\030\007 \001(\r:\001"
  "0\022\"\n\027number_of_indices_moved\030\010 \001(\r:\0010\032!\n"
  "\005Entry\022\014\n\004from\030\001 \002(\r\022\n\n\002to\030\002 \002(\r\"I\n\036Prog"
  "ressiveCommandGroupArchive\022\'\n\005super\030\001 \002("
  "\0132\030.TSK.CommandGroupArchive\"\312\001\n&CommandS"
  "electionBehaviorHistoryArchive\022B\n\007entrie"
  "s\030\001 \003(\01321.TSK.CommandSelectionBehaviorHi"
  "storyArchive.Entry\032\\\n\005Entry\022\037\n\007command\030\001"
  " \002(\0132\016.TSP.Reference\0222\n\032command_selectio"
  "n_behavior\030\002 \002(\0132\016.TSP.Reference\"W\n,Undo"
  "RedoStateCommandSelectionBehaviorArchive"
  "\022\'\n\017undo_redo_state\030\002 \001(\0132\016.TSP.Referenc"
  "e\"\257\t\n\023FormatStructArchive\022\023\n\013format_type"
  "\030\001 \002(\r\022\026\n\016decimal_places\030\002 \001(\r\022\025\n\rcurren"
  "cy_code\030\003 \001(\t\022\026\n\016negative_style\030\004 \001(\r\022 \n"
  "\030show_thousands_separator\030\005 \001(\010\022\034\n\024use_a"
  "ccounting_style\030\006 \001(\010\022\026\n\016duration_style\030"
  "\007 \001(\r\022\014\n\004base\030\010 \001(\r\022\023\n\013base_places\030\t \001(\r"
  "\022\033\n\023base_use_minus_sign\030\n \001(\010\022\031\n\021fractio"
  "n_accuracy\030\013 \001(\r\022\034\n\024suppress_date_format"
  "\030\014 \001(\010\022\034\n\024suppress_time_format\030\r \001(\010\022\030\n\020"
  "date_time_format\030\016 \001(\t\022\035\n\025duration_unit_"
  "largest\030\017 \001(\r\022\036\n\026duration_unit_smallest\030"
  "\020 \001(\r\022\021\n\tcustom_id\030\021 \001(\r\022\034\n\024custom_forma"
  "t_string\030\022 \001(\t\022\024\n\014scale_factor\030\023 \001(\001\022%\n\035"
  "requires_fraction_replacement\030\024 \001(\010\022\027\n\017c"
  "ontrol_minimum\030\025 \001(\001\022\027\n\017control_maximum\030"
  "\026 \001(\001\022\031\n\021control_increment\030\027 \001(\001\022\033\n\023cont"
  "rol_format_type\030\030 \001(\r\022\032\n\022slider_orientat"
  "ion\030\031 \001(\r\022\027\n\017slider_position\030\032 \001(\r\022\025\n\rde"
  "cimal_width\030\033 \001(\r\022\031\n\021min_integer_width\030\034"
  " \001(\r\022#\n\033num_nonspace_integer_digits\030\035 \001("
  "\r\022#\n\033num_nonspace_decimal_digits\030\036 \001(\r\022%"
  "\n\035index_from_right_last_integer\030\037 \001(\r\022\034\n"
  "\024interstitial_strings\030  \003(\t\0223\n\034inters_st"
  "r_insertion_indexes\030! \001(\0132\r.TSP.IndexSet"
  "\022\037\n\027num_hash_decimal_digits\030\" \001(\r\022 \n\030tot"
  "al_num_decimal_digits\030# \001(\r\022\022\n\nis_comple"
  "x\030$ \001(\010\022\036\n\026contains_integer_token\030% \001(\010\022"
  "*\n\"multiple_choice_list_initial_value\030& "
  "\001(\r\022\037\n\027multiple_choice_list_id\030\' \001(\r\022$\n\034"
  "use_automatic_duration_units\030( \001(\010*\007\010\220N\020"
  "\240\234\001\"\262\002\n\023CustomFormatArchive\022\014\n\004name\030\001 \002("
  "\t\022\023\n\013format_type\030\002 \002(\r\0220\n\016default_format"
  "\030\003 \002(\0132\030.TSK.FormatStructArchive\0226\n\ncond"
  "itions\030\004 \003(\0132\".TSK.CustomFormatArchive.C"
  "ondition\032\215\001\n\tCondition\022\026\n\016condition_type"
  "\030\001 \002(\r\022\027\n\017condition_value\030\002 \001(\002\0222\n\020condi"
  "tion_format\030\003 \002(\0132\030.TSK.FormatStructArch"
  "ive\022\033\n\023condition_value_dbl\030\004 \001(\001\"B\n\027Anno"
  "tationAuthorArchive\022\014\n\004name\030\001 \001(\t\022\031\n\005col"
  "or\030\002 \001(\0132\n.TSP.Color\"O\n\035DeprecatedChange"
  "AuthorArchive\022\014\n\004name\030\001 \001(\t\022 \n\014change_co"
  "lor\030\002 \001(\0132\n.TSP.Color\"K\n\036AnnotationAutho"
  "rStorageArchive\022)\n\021annotation_author\030\001 \003"
  "(\0132\016.TSP.Reference\"\231\001\n!AddAnnotationAuth"
  "orCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.Co"
  "mmandArchive\022%\n\rdocument_root\030\002 \001(\0132\016.TS"
  "P.Reference\022)\n\021annotation_author\030\003 \001(\0132\016"
  ".TSP.Reference\"\222\001\n&SetAnnotationAuthorCo"
  "lorCommandArchive\022\"\n\005super\030\001 \002(\0132\023.TSK.C"
  "ommandArchive\022)\n\021annotation_author\030\002 \001(\013"
  "2\016.TSP.Reference\022\031\n\005color\030\003 \001(\0132\n.TSP.Co"
  "lor"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSKArchives_2eproto_deps[1] = {
  &::descriptor_table_TSPMessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSKArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSKArchives_2eproto = {
    false, false, 4003, descriptor_table_protodef_TSKArchives_2eproto,
    "TSKArchives.proto",
    &descriptor_table_TSKArchives_2eproto_once, descriptor_table_TSKArchives_2eproto_deps, 1, 24,
    schemas, file_default_instances, TableStruct_TSKArchives_2eproto::offsets,
    file_level_metadata_TSKArchives_2eproto, file_level_enum_descriptors_TSKArchives_2eproto,
    file_level_service_descriptors_TSKArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSKArchives_2eproto_getter() {
  return &descriptor_table_TSKArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSKArchives_2eproto(&descriptor_table_TSKArchives_2eproto);
namespace TSK {

// ===================================================================

class TreeNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TreeNode>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& object(const TreeNode* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
TreeNode::_Internal::object(const TreeNode* msg) {
  return *msg->_impl_.object_;
}
void TreeNode::clear_children() {
  _impl_.children_.Clear();
}
void TreeNode::clear_object() {
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TreeNode::TreeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.TreeNode)
}
TreeNode::TreeNode(const TreeNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TreeNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.object_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_object()) {
    _this->_impl_.object_ = new ::TSP::Reference(*from._impl_.object_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.TreeNode)
}

inline void TreeNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.object_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TreeNode::~TreeNode() {
  // @@protoc_insertion_point(destructor:TSK.TreeNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TreeNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.object_;
}

void TreeNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TreeNode::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.TreeNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.object_ != nullptr);
      _impl_.object_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TreeNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.TreeNode.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference children = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference object = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TreeNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.TreeNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.TreeNode.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .TSP.Reference children = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference object = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.TreeNode)
  return target;
}

size_t TreeNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.TreeNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 2;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .TSP.Reference object = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TreeNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TreeNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TreeNode::GetClassData() const { return &_class_data_; }


void TreeNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TreeNode*>(&to_msg);
  auto& from = static_cast<const TreeNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.TreeNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_object()->::TSP::Reference::MergeFrom(
          from._internal_object());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TreeNode::CopyFrom(const TreeNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.TreeNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TreeNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  if (_internal_has_object()) {
    if (!_impl_.object_->IsInitialized()) return false;
  }
  return true;
}

void TreeNode::InternalSwap(TreeNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.object_, other->_impl_.object_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TreeNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[0]);
}

// ===================================================================

class CommandHistory::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandHistory>()._impl_._has_bits_);
  static void set_has_undo_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& pending_preflight_command(const CommandHistory* msg);
  static void set_has_pending_preflight_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fixed_radar_13365177(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSP::Reference&
CommandHistory::_Internal::pending_preflight_command(const CommandHistory* msg) {
  return *msg->_impl_.pending_preflight_command_;
}
void CommandHistory::clear_commands() {
  _impl_.commands_.Clear();
}
void CommandHistory::clear_marked_redo_commands() {
  _impl_.marked_redo_commands_.Clear();
}
void CommandHistory::clear_pending_preflight_command() {
  if (_impl_.pending_preflight_command_ != nullptr) _impl_.pending_preflight_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CommandHistory::CommandHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandHistory)
}
CommandHistory::CommandHistory(const CommandHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){from._impl_.commands_}
    , decltype(_impl_.marked_redo_commands_){from._impl_.marked_redo_commands_}
    , decltype(_impl_.pending_preflight_command_){nullptr}
    , decltype(_impl_.undo_count_){}
    , decltype(_impl_.fixed_radar_13365177_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pending_preflight_command()) {
    _this->_impl_.pending_preflight_command_ = new ::TSP::Reference(*from._impl_.pending_preflight_command_);
  }
  ::memcpy(&_impl_.undo_count_, &from._impl_.undo_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fixed_radar_13365177_) -
    reinterpret_cast<char*>(&_impl_.undo_count_)) + sizeof(_impl_.fixed_radar_13365177_));
  // @@protoc_insertion_point(copy_constructor:TSK.CommandHistory)
}

inline void CommandHistory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){arena}
    , decltype(_impl_.marked_redo_commands_){arena}
    , decltype(_impl_.pending_preflight_command_){nullptr}
    , decltype(_impl_.undo_count_){0u}
    , decltype(_impl_.fixed_radar_13365177_){false}
  };
}

CommandHistory::~CommandHistory() {
  // @@protoc_insertion_point(destructor:TSK.CommandHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
  _impl_.marked_redo_commands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.pending_preflight_command_;
}

void CommandHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  _impl_.marked_redo_commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pending_preflight_command_ != nullptr);
    _impl_.pending_preflight_command_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.undo_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fixed_radar_13365177_) -
        reinterpret_cast<char*>(&_impl_.undo_count_)) + sizeof(_impl_.fixed_radar_13365177_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 undo_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_undo_count(&has_bits);
          _impl_.undo_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference marked_redo_commands = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_marked_redo_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference pending_preflight_command = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_pending_preflight_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool fixed_radar_13365177 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_fixed_radar_13365177(&has_bits);
          _impl_.fixed_radar_13365177_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 undo_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_undo_count(), target);
  }

  // repeated .TSP.Reference commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference marked_redo_commands = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_marked_redo_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_marked_redo_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference pending_preflight_command = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::pending_preflight_command(this),
        _Internal::pending_preflight_command(this).GetCachedSize(), target, stream);
  }

  // optional bool fixed_radar_13365177 = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_fixed_radar_13365177(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandHistory)
  return target;
}

size_t CommandHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandHistory)
  size_t total_size = 0;

  // required uint32 undo_count = 1;
  if (_internal_has_undo_count()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_count());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference commands = 2;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSP.Reference marked_redo_commands = 3;
  total_size += 1UL * this->_internal_marked_redo_commands_size();
  for (const auto& msg : this->_impl_.marked_redo_commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference pending_preflight_command = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pending_preflight_command_);
  }

  // optional bool fixed_radar_13365177 = 10;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandHistory::GetClassData() const { return &_class_data_; }


void CommandHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandHistory*>(&to_msg);
  auto& from = static_cast<const CommandHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandHistory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  _this->_impl_.marked_redo_commands_.MergeFrom(from._impl_.marked_redo_commands_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pending_preflight_command()->::TSP::Reference::MergeFrom(
          from._internal_pending_preflight_command());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.undo_count_ = from._impl_.undo_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.fixed_radar_13365177_ = from._impl_.fixed_radar_13365177_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandHistory::CopyFrom(const CommandHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandHistory::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.commands_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.marked_redo_commands_))
    return false;
  if (_internal_has_pending_preflight_command()) {
    if (!_impl_.pending_preflight_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandHistory::InternalSwap(CommandHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
  _impl_.marked_redo_commands_.InternalSwap(&other->_impl_.marked_redo_commands_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandHistory, _impl_.fixed_radar_13365177_)
      + sizeof(CommandHistory::_impl_.fixed_radar_13365177_)
      - PROTOBUF_FIELD_OFFSET(CommandHistory, _impl_.pending_preflight_command_)>(
          reinterpret_cast<char*>(&_impl_.pending_preflight_command_),
          reinterpret_cast<char*>(&other->_impl_.pending_preflight_command_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[1]);
}

// ===================================================================

class DocumentArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentArchive>()._impl_._has_bits_);
  static void set_has_locale_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& annotation_author_storage(const DocumentArchive* msg);
  static void set_has_annotation_author_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
DocumentArchive::_Internal::annotation_author_storage(const DocumentArchive* msg) {
  return *msg->_impl_.annotation_author_storage_;
}
void DocumentArchive::clear_annotation_author_storage() {
  if (_impl_.annotation_author_storage_ != nullptr) _impl_.annotation_author_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
DocumentArchive::DocumentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.DocumentArchive)
}
DocumentArchive::DocumentArchive(const DocumentArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DocumentArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locale_identifier_){}
    , decltype(_impl_.annotation_author_storage_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.locale_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale_identifier()) {
    _this->_impl_.locale_identifier_.Set(from._internal_locale_identifier(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_annotation_author_storage()) {
    _this->_impl_.annotation_author_storage_ = new ::TSP::Reference(*from._impl_.annotation_author_storage_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.DocumentArchive)
}

inline void DocumentArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.locale_identifier_){}
    , decltype(_impl_.annotation_author_storage_){nullptr}
  };
  _impl_.locale_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DocumentArchive::~DocumentArchive() {
  // @@protoc_insertion_point(destructor:TSK.DocumentArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DocumentArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.locale_identifier_.Destroy();
  if (this != internal_default_instance()) delete _impl_.annotation_author_storage_;
}

void DocumentArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DocumentArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.DocumentArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.locale_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.annotation_author_storage_ != nullptr);
      _impl_.annotation_author_storage_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DocumentArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string locale_identifier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_locale_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.DocumentArchive.locale_identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference annotation_author_storage = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotation_author_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DocumentArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.DocumentArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string locale_identifier = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_locale_identifier().data(), static_cast<int>(this->_internal_locale_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.DocumentArchive.locale_identifier");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_locale_identifier(), target);
  }

  // optional .TSP.Reference annotation_author_storage = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::annotation_author_storage(this),
        _Internal::annotation_author_storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.DocumentArchive)
  return target;
}

size_t DocumentArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.DocumentArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string locale_identifier = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale_identifier());
    }

    // optional .TSP.Reference annotation_author_storage = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.annotation_author_storage_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DocumentArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DocumentArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DocumentArchive::GetClassData() const { return &_class_data_; }


void DocumentArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DocumentArchive*>(&to_msg);
  auto& from = static_cast<const DocumentArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.DocumentArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_locale_identifier(from._internal_locale_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_annotation_author_storage()->::TSP::Reference::MergeFrom(
          from._internal_annotation_author_storage());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DocumentArchive::CopyFrom(const DocumentArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.DocumentArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentArchive::IsInitialized() const {
  if (_internal_has_annotation_author_storage()) {
    if (!_impl_.annotation_author_storage_->IsInitialized()) return false;
  }
  return true;
}

void DocumentArchive::InternalSwap(DocumentArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.locale_identifier_, lhs_arena,
      &other->_impl_.locale_identifier_, rhs_arena
  );
  swap(_impl_.annotation_author_storage_, other->_impl_.annotation_author_storage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DocumentArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[2]);
}

// ===================================================================

class DocumentSupportArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DocumentSupportArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& command_history(const DocumentSupportArchive* msg);
  static void set_has_command_history(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& command_selection_behavior_history(const DocumentSupportArchive* msg);
  static void set_has_command_selection_behavior_history(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_undo_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_redo_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_undo_action_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_redo_action_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& web_state(const DocumentSupportArchive* msg);
  static void set_has_web_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Reference&
DocumentSupportArchive::_Internal::command_history(const DocumentSupportArchive* msg) {
  return *msg->_impl_.command_history_;
}
const ::TSP::Reference&
DocumentSupportArchive::_Internal::command_selection_behavior_history(const DocumentSupportArchive* msg) {
  return *msg->_impl_.command_selection_behavior_history_;
}
const ::TSP::Reference&
DocumentSupportArchive::_Internal::web_state(const DocumentSupportArchive* msg) {
  return *msg->_impl_.web_state_;
}
void DocumentSupportArchive::clear_command_history() {
  if (_impl_.command_history_ != nullptr) _impl_.command_history_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DocumentSupportArchive::clear_command_selection_behavior_history() {
  if (_impl_.command_selection_behavior_history_ != nullptr) _impl_.command_selection_behavior_history_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DocumentSupportArchive::clear_web_state() {
  if (_impl_.web_state_ != nullptr) _impl_.web_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
DocumentSupportArchive::DocumentSupportArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.DocumentSupportArchive)
}
DocumentSupportArchive::DocumentSupportArchive(const DocumentSupportArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DocumentSupportArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_action_string_){}
    , decltype(_impl_.redo_action_string_){}
    , decltype(_impl_.command_history_){nullptr}
    , decltype(_impl_.command_selection_behavior_history_){nullptr}
    , decltype(_impl_.web_state_){nullptr}
    , decltype(_impl_.undo_count_){}
    , decltype(_impl_.redo_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.undo_action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.undo_action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_undo_action_string()) {
    _this->_impl_.undo_action_string_.Set(from._internal_undo_action_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.redo_action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.redo_action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_redo_action_string()) {
    _this->_impl_.redo_action_string_.Set(from._internal_redo_action_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_command_history()) {
    _this->_impl_.command_history_ = new ::TSP::Reference(*from._impl_.command_history_);
  }
  if (from._internal_has_command_selection_behavior_history()) {
    _this->_impl_.command_selection_behavior_history_ = new ::TSP::Reference(*from._impl_.command_selection_behavior_history_);
  }
  if (from._internal_has_web_state()) {
    _this->_impl_.web_state_ = new ::TSP::Reference(*from._impl_.web_state_);
  }
  ::memcpy(&_impl_.undo_count_, &from._impl_.undo_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.redo_count_) -
    reinterpret_cast<char*>(&_impl_.undo_count_)) + sizeof(_impl_.redo_count_));
  // @@protoc_insertion_point(copy_constructor:TSK.DocumentSupportArchive)
}

inline void DocumentSupportArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_action_string_){}
    , decltype(_impl_.redo_action_string_){}
    , decltype(_impl_.command_history_){nullptr}
    , decltype(_impl_.command_selection_behavior_history_){nullptr}
    , decltype(_impl_.web_state_){nullptr}
    , decltype(_impl_.undo_count_){0u}
    , decltype(_impl_.redo_count_){0u}
  };
  _impl_.undo_action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.undo_action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.redo_action_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.redo_action_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DocumentSupportArchive::~DocumentSupportArchive() {
  // @@protoc_insertion_point(destructor:TSK.DocumentSupportArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DocumentSupportArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.undo_action_string_.Destroy();
  _impl_.redo_action_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.command_history_;
  if (this != internal_default_instance()) delete _impl_.command_selection_behavior_history_;
  if (this != internal_default_instance()) delete _impl_.web_state_;
}

void DocumentSupportArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DocumentSupportArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.DocumentSupportArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.undo_action_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.redo_action_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.command_history_ != nullptr);
      _impl_.command_history_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.command_selection_behavior_history_ != nullptr);
      _impl_.command_selection_behavior_history_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.web_state_ != nullptr);
      _impl_.web_state_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.undo_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.redo_count_) -
        reinterpret_cast<char*>(&_impl_.undo_count_)) + sizeof(_impl_.redo_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DocumentSupportArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference command_history = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_history(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference command_selection_behavior_history = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_selection_behavior_history(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undo_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_undo_count(&has_bits);
          _impl_.undo_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_redo_count(&has_bits);
          _impl_.redo_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string undo_action_string = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_undo_action_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.DocumentSupportArchive.undo_action_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string redo_action_string = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_redo_action_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.DocumentSupportArchive.redo_action_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference web_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_web_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DocumentSupportArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.DocumentSupportArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference command_history = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::command_history(this),
        _Internal::command_history(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference command_selection_behavior_history = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::command_selection_behavior_history(this),
        _Internal::command_selection_behavior_history(this).GetCachedSize(), target, stream);
  }

  // optional uint32 undo_count = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_undo_count(), target);
  }

  // optional uint32 redo_count = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_redo_count(), target);
  }

  // optional string undo_action_string = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_undo_action_string().data(), static_cast<int>(this->_internal_undo_action_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.DocumentSupportArchive.undo_action_string");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_undo_action_string(), target);
  }

  // optional string redo_action_string = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_redo_action_string().data(), static_cast<int>(this->_internal_redo_action_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.DocumentSupportArchive.redo_action_string");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_redo_action_string(), target);
  }

  // optional .TSP.Reference web_state = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::web_state(this),
        _Internal::web_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.DocumentSupportArchive)
  return target;
}

size_t DocumentSupportArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.DocumentSupportArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string undo_action_string = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_undo_action_string());
    }

    // optional string redo_action_string = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_redo_action_string());
    }

    // optional .TSP.Reference command_history = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_history_);
    }

    // optional .TSP.Reference command_selection_behavior_history = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_selection_behavior_history_);
    }

    // optional .TSP.Reference web_state = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.web_state_);
    }

    // optional uint32 undo_count = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undo_count());
    }

    // optional uint32 redo_count = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DocumentSupportArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DocumentSupportArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DocumentSupportArchive::GetClassData() const { return &_class_data_; }


void DocumentSupportArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DocumentSupportArchive*>(&to_msg);
  auto& from = static_cast<const DocumentSupportArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.DocumentSupportArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_undo_action_string(from._internal_undo_action_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_redo_action_string(from._internal_redo_action_string());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_command_history()->::TSP::Reference::MergeFrom(
          from._internal_command_history());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_command_selection_behavior_history()->::TSP::Reference::MergeFrom(
          from._internal_command_selection_behavior_history());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_web_state()->::TSP::Reference::MergeFrom(
          from._internal_web_state());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.undo_count_ = from._impl_.undo_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.redo_count_ = from._impl_.redo_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DocumentSupportArchive::CopyFrom(const DocumentSupportArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.DocumentSupportArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DocumentSupportArchive::IsInitialized() const {
  if (_internal_has_command_history()) {
    if (!_impl_.command_history_->IsInitialized()) return false;
  }
  if (_internal_has_command_selection_behavior_history()) {
    if (!_impl_.command_selection_behavior_history_->IsInitialized()) return false;
  }
  if (_internal_has_web_state()) {
    if (!_impl_.web_state_->IsInitialized()) return false;
  }
  return true;
}

void DocumentSupportArchive::InternalSwap(DocumentSupportArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.undo_action_string_, lhs_arena,
      &other->_impl_.undo_action_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.redo_action_string_, lhs_arena,
      &other->_impl_.redo_action_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DocumentSupportArchive, _impl_.redo_count_)
      + sizeof(DocumentSupportArchive::_impl_.redo_count_)
      - PROTOBUF_FIELD_OFFSET(DocumentSupportArchive, _impl_.command_history_)>(
          reinterpret_cast<char*>(&_impl_.command_history_),
          reinterpret_cast<char*>(&other->_impl_.command_history_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DocumentSupportArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[3]);
}

// ===================================================================

class ViewStateArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ViewStateArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& view_state_root(const ViewStateArchive* msg);
  static void set_has_view_state_root(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSP::Reference&
ViewStateArchive::_Internal::view_state_root(const ViewStateArchive* msg) {
  return *msg->_impl_.view_state_root_;
}
void ViewStateArchive::clear_view_state_root() {
  if (_impl_.view_state_root_ != nullptr) _impl_.view_state_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ViewStateArchive::ViewStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ViewStateArchive)
}
ViewStateArchive::ViewStateArchive(const ViewStateArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ViewStateArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_state_root_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_view_state_root()) {
    _this->_impl_.view_state_root_ = new ::TSP::Reference(*from._impl_.view_state_root_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.ViewStateArchive)
}

inline void ViewStateArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.view_state_root_){nullptr}
  };
}

ViewStateArchive::~ViewStateArchive() {
  // @@protoc_insertion_point(destructor:TSK.ViewStateArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViewStateArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.view_state_root_;
}

void ViewStateArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ViewStateArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ViewStateArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.view_state_root_ != nullptr);
    _impl_.view_state_root_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ViewStateArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference view_state_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_state_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViewStateArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ViewStateArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference view_state_root = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::view_state_root(this),
        _Internal::view_state_root(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ViewStateArchive)
  return target;
}

size_t ViewStateArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ViewStateArchive)
  size_t total_size = 0;

  // required .TSP.Reference view_state_root = 1;
  if (_internal_has_view_state_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.view_state_root_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ViewStateArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ViewStateArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ViewStateArchive::GetClassData() const { return &_class_data_; }


void ViewStateArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ViewStateArchive*>(&to_msg);
  auto& from = static_cast<const ViewStateArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ViewStateArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_view_state_root()) {
    _this->_internal_mutable_view_state_root()->::TSP::Reference::MergeFrom(
        from._internal_view_state_root());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ViewStateArchive::CopyFrom(const ViewStateArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ViewStateArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViewStateArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_view_state_root()) {
    if (!_impl_.view_state_root_->IsInitialized()) return false;
  }
  return true;
}

void ViewStateArchive::InternalSwap(ViewStateArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.view_state_root_, other->_impl_.view_state_root_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ViewStateArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[4]);
}

// ===================================================================

class CommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& undoredostate(const CommandArchive* msg);
  static void set_has_undoredostate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& undocollection(const CommandArchive* msg);
  static void set_has_undocollection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Reference&
CommandArchive::_Internal::undoredostate(const CommandArchive* msg) {
  return *msg->_impl_.undoredostate_;
}
const ::TSP::Reference&
CommandArchive::_Internal::undocollection(const CommandArchive* msg) {
  return *msg->_impl_.undocollection_;
}
void CommandArchive::clear_undoredostate() {
  if (_impl_.undoredostate_ != nullptr) _impl_.undoredostate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandArchive::clear_undocollection() {
  if (_impl_.undocollection_ != nullptr) _impl_.undocollection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandArchive::CommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandArchive)
}
CommandArchive::CommandArchive(const CommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undoredostate_){nullptr}
    , decltype(_impl_.undocollection_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_undoredostate()) {
    _this->_impl_.undoredostate_ = new ::TSP::Reference(*from._impl_.undoredostate_);
  }
  if (from._internal_has_undocollection()) {
    _this->_impl_.undocollection_ = new ::TSP::Reference(*from._impl_.undocollection_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.CommandArchive)
}

inline void CommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undoredostate_){nullptr}
    , decltype(_impl_.undocollection_){nullptr}
  };
}

CommandArchive::~CommandArchive() {
  // @@protoc_insertion_point(destructor:TSK.CommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.undoredostate_;
  if (this != internal_default_instance()) delete _impl_.undocollection_;
}

void CommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.undoredostate_ != nullptr);
      _impl_.undoredostate_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undocollection_ != nullptr);
      _impl_.undocollection_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference undoRedoState = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_undoredostate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undoCollection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undocollection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference undoRedoState = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::undoredostate(this),
        _Internal::undoredostate(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undoCollection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undocollection(this),
        _Internal::undocollection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandArchive)
  return target;
}

size_t CommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference undoRedoState = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undoredostate_);
    }

    // optional .TSP.Reference undoCollection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undocollection_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandArchive::GetClassData() const { return &_class_data_; }


void CommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandArchive*>(&to_msg);
  auto& from = static_cast<const CommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_undoredostate()->::TSP::Reference::MergeFrom(
          from._internal_undoredostate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undocollection()->::TSP::Reference::MergeFrom(
          from._internal_undocollection());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandArchive::CopyFrom(const CommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandArchive::IsInitialized() const {
  if (_internal_has_undoredostate()) {
    if (!_impl_.undoredostate_->IsInitialized()) return false;
  }
  if (_internal_has_undocollection()) {
    if (!_impl_.undocollection_->IsInitialized()) return false;
  }
  return true;
}

void CommandArchive::InternalSwap(CommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandArchive, _impl_.undocollection_)
      + sizeof(CommandArchive::_impl_.undocollection_)
      - PROTOBUF_FIELD_OFFSET(CommandArchive, _impl_.undoredostate_)>(
          reinterpret_cast<char*>(&_impl_.undoredostate_),
          reinterpret_cast<char*>(&other->_impl_.undoredostate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[5]);
}

// ===================================================================

class CommandGroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandGroupArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const CommandGroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::IndexSet& process_results(const CommandGroupArchive* msg);
  static void set_has_process_results(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
CommandGroupArchive::_Internal::super(const CommandGroupArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::IndexSet&
CommandGroupArchive::_Internal::process_results(const CommandGroupArchive* msg) {
  return *msg->_impl_.process_results_;
}
void CommandGroupArchive::clear_commands() {
  _impl_.commands_.Clear();
}
void CommandGroupArchive::clear_process_results() {
  if (_impl_.process_results_ != nullptr) _impl_.process_results_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandGroupArchive::CommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandGroupArchive)
}
CommandGroupArchive::CommandGroupArchive(const CommandGroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandGroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){from._impl_.commands_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.process_results_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_process_results()) {
    _this->_impl_.process_results_ = new ::TSP::IndexSet(*from._impl_.process_results_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.CommandGroupArchive)
}

inline void CommandGroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.process_results_){nullptr}
  };
}

CommandGroupArchive::~CommandGroupArchive() {
  // @@protoc_insertion_point(destructor:TSK.CommandGroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandGroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.process_results_;
}

void CommandGroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandGroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandGroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.process_results_ != nullptr);
      _impl_.process_results_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandGroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.IndexSet process_results = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_process_results(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandGroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandGroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TSP.IndexSet process_results = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::process_results(this),
        _Internal::process_results(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandGroupArchive)
  return target;
}

size_t CommandGroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandGroupArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference commands = 2;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.IndexSet process_results = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.process_results_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandGroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandGroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandGroupArchive::GetClassData() const { return &_class_data_; }


void CommandGroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandGroupArchive*>(&to_msg);
  auto& from = static_cast<const CommandGroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandGroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_process_results()->::TSP::IndexSet::MergeFrom(
          from._internal_process_results());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandGroupArchive::CopyFrom(const CommandGroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandGroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandGroupArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.commands_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_process_results()) {
    if (!_impl_.process_results_->IsInitialized()) return false;
  }
  return true;
}

void CommandGroupArchive::InternalSwap(CommandGroupArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandGroupArchive, _impl_.process_results_)
      + sizeof(CommandGroupArchive::_impl_.process_results_)
      - PROTOBUF_FIELD_OFFSET(CommandGroupArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandGroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[6]);
}

// ===================================================================

class CommandContainerArchive::_Internal {
 public:
};

void CommandContainerArchive::clear_commands() {
  _impl_.commands_.Clear();
}
CommandContainerArchive::CommandContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandContainerArchive)
}
CommandContainerArchive::CommandContainerArchive(const CommandContainerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandContainerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){from._impl_.commands_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSK.CommandContainerArchive)
}

inline void CommandContainerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.commands_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CommandContainerArchive::~CommandContainerArchive() {
  // @@protoc_insertion_point(destructor:TSK.CommandContainerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandContainerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
}

void CommandContainerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandContainerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandContainerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandContainerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference commands = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandContainerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandContainerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference commands = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandContainerArchive)
  return target;
}

size_t CommandContainerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandContainerArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference commands = 1;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandContainerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandContainerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandContainerArchive::GetClassData() const { return &_class_data_; }


void CommandContainerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandContainerArchive*>(&to_msg);
  auto& from = static_cast<const CommandContainerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandContainerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandContainerArchive::CopyFrom(const CommandContainerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandContainerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandContainerArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.commands_))
    return false;
  return true;
}

void CommandContainerArchive::InternalSwap(CommandContainerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandContainerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[7]);
}

// ===================================================================

class ReplaceAllChildCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAllChildCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ReplaceAllChildCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
ReplaceAllChildCommandArchive::_Internal::super(const ReplaceAllChildCommandArchive* msg) {
  return *msg->_impl_.super_;
}
ReplaceAllChildCommandArchive::ReplaceAllChildCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ReplaceAllChildCommandArchive)
}
ReplaceAllChildCommandArchive::ReplaceAllChildCommandArchive(const ReplaceAllChildCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAllChildCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.ReplaceAllChildCommandArchive)
}

inline void ReplaceAllChildCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ReplaceAllChildCommandArchive::~ReplaceAllChildCommandArchive() {
  // @@protoc_insertion_point(destructor:TSK.ReplaceAllChildCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAllChildCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ReplaceAllChildCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAllChildCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ReplaceAllChildCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAllChildCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAllChildCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ReplaceAllChildCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ReplaceAllChildCommandArchive)
  return target;
}

size_t ReplaceAllChildCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ReplaceAllChildCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAllChildCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAllChildCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAllChildCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAllChildCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAllChildCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAllChildCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ReplaceAllChildCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAllChildCommandArchive::CopyFrom(const ReplaceAllChildCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ReplaceAllChildCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAllChildCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAllChildCommandArchive::InternalSwap(ReplaceAllChildCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAllChildCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[8]);
}

// ===================================================================

class ReplaceAllCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAllCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ReplaceAllCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_find_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_replace_string(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_options(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TSK::CommandArchive&
ReplaceAllCommandArchive::_Internal::super(const ReplaceAllCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ReplaceAllCommandArchive::clear_commands() {
  _impl_.commands_.Clear();
}
ReplaceAllCommandArchive::ReplaceAllCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ReplaceAllCommandArchive)
}
ReplaceAllCommandArchive::ReplaceAllCommandArchive(const ReplaceAllCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAllCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){from._impl_.commands_}
    , decltype(_impl_.find_string_){}
    , decltype(_impl_.replace_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.options_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.find_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.find_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_find_string()) {
    _this->_impl_.find_string_.Set(from._internal_find_string(), 
      _this->GetArenaForAllocation());
  }
  _impl_.replace_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.replace_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_replace_string()) {
    _this->_impl_.replace_string_.Set(from._internal_replace_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.options_ = from._impl_.options_;
  // @@protoc_insertion_point(copy_constructor:TSK.ReplaceAllCommandArchive)
}

inline void ReplaceAllCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_){arena}
    , decltype(_impl_.find_string_){}
    , decltype(_impl_.replace_string_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.options_){0u}
  };
  _impl_.find_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.find_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.replace_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.replace_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplaceAllCommandArchive::~ReplaceAllCommandArchive() {
  // @@protoc_insertion_point(destructor:TSK.ReplaceAllCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAllCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commands_.~RepeatedPtrField();
  _impl_.find_string_.Destroy();
  _impl_.replace_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ReplaceAllCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAllCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ReplaceAllCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.find_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.replace_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.options_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAllCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference commands = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required string find_string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_find_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.ReplaceAllCommandArchive.find_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string replace_string = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_replace_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.ReplaceAllCommandArchive.replace_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 options = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_options(&has_bits);
          _impl_.options_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAllCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ReplaceAllCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference commands = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required string find_string = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_find_string().data(), static_cast<int>(this->_internal_find_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.ReplaceAllCommandArchive.find_string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_find_string(), target);
  }

  // required string replace_string = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_replace_string().data(), static_cast<int>(this->_internal_replace_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.ReplaceAllCommandArchive.replace_string");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_replace_string(), target);
  }

  // required uint32 options = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_options(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ReplaceAllCommandArchive)
  return target;
}

size_t ReplaceAllCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.ReplaceAllCommandArchive)
  size_t total_size = 0;

  if (_internal_has_find_string()) {
    // required string find_string = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_find_string());
  }

  if (_internal_has_replace_string()) {
    // required string replace_string = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_replace_string());
  }

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_options()) {
    // required uint32 options = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_options());
  }

  return total_size;
}
size_t ReplaceAllCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ReplaceAllCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string find_string = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_find_string());

    // required string replace_string = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_replace_string());

    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 options = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_options());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference commands = 2;
  total_size += 1UL * this->_internal_commands_size();
  for (const auto& msg : this->_impl_.commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAllCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAllCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAllCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAllCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAllCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAllCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ReplaceAllCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.commands_.MergeFrom(from._impl_.commands_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_find_string(from._internal_find_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_replace_string(from._internal_replace_string());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.options_ = from._impl_.options_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAllCommandArchive::CopyFrom(const ReplaceAllCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ReplaceAllCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAllCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.commands_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAllCommandArchive::InternalSwap(ReplaceAllCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.commands_.InternalSwap(&other->_impl_.commands_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.find_string_, lhs_arena,
      &other->_impl_.find_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.replace_string_, lhs_arena,
      &other->_impl_.replace_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplaceAllCommandArchive, _impl_.options_)
      + sizeof(ReplaceAllCommandArchive::_impl_.options_)
      - PROTOBUF_FIELD_OFFSET(ReplaceAllCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAllCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[9]);
}

// ===================================================================

class ShuffleMappingArchive_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<ShuffleMappingArchive_Entry>()._impl_._has_bits_);
  static void set_has_from(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_to(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ShuffleMappingArchive_Entry::ShuffleMappingArchive_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ShuffleMappingArchive.Entry)
}
ShuffleMappingArchive_Entry::ShuffleMappingArchive_Entry(const ShuffleMappingArchive_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShuffleMappingArchive_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_){}
    , decltype(_impl_.to_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.from_, &from._impl_.from_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.to_) -
    reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.to_));
  // @@protoc_insertion_point(copy_constructor:TSK.ShuffleMappingArchive.Entry)
}

inline void ShuffleMappingArchive_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.from_){0u}
    , decltype(_impl_.to_){0u}
  };
}

ShuffleMappingArchive_Entry::~ShuffleMappingArchive_Entry() {
  // @@protoc_insertion_point(destructor:TSK.ShuffleMappingArchive.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShuffleMappingArchive_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShuffleMappingArchive_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShuffleMappingArchive_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ShuffleMappingArchive.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.from_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.to_) -
        reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.to_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShuffleMappingArchive_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_from(&has_bits);
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_to(&has_bits);
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShuffleMappingArchive_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ShuffleMappingArchive.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 from = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_from(), target);
  }

  // required uint32 to = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_to(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ShuffleMappingArchive.Entry)
  return target;
}

size_t ShuffleMappingArchive_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.ShuffleMappingArchive.Entry)
  size_t total_size = 0;

  if (_internal_has_from()) {
    // required uint32 from = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from());
  }

  if (_internal_has_to()) {
    // required uint32 to = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_to());
  }

  return total_size;
}
size_t ShuffleMappingArchive_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ShuffleMappingArchive.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 from = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from());

    // required uint32 to = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_to());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShuffleMappingArchive_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShuffleMappingArchive_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShuffleMappingArchive_Entry::GetClassData() const { return &_class_data_; }


void ShuffleMappingArchive_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShuffleMappingArchive_Entry*>(&to_msg);
  auto& from = static_cast<const ShuffleMappingArchive_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ShuffleMappingArchive.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.from_ = from._impl_.from_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.to_ = from._impl_.to_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShuffleMappingArchive_Entry::CopyFrom(const ShuffleMappingArchive_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ShuffleMappingArchive.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShuffleMappingArchive_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ShuffleMappingArchive_Entry::InternalSwap(ShuffleMappingArchive_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShuffleMappingArchive_Entry, _impl_.to_)
      + sizeof(ShuffleMappingArchive_Entry::_impl_.to_)
      - PROTOBUF_FIELD_OFFSET(ShuffleMappingArchive_Entry, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShuffleMappingArchive_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[10]);
}

// ===================================================================

class ShuffleMappingArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShuffleMappingArchive>()._impl_._has_bits_);
  static void set_has_start_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_vertical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_move_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_first_moved_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_destination_index_for_move(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_number_of_indices_moved(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ShuffleMappingArchive::ShuffleMappingArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ShuffleMappingArchive)
}
ShuffleMappingArchive::ShuffleMappingArchive(const ShuffleMappingArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShuffleMappingArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.start_index_){}
    , decltype(_impl_.end_index_){}
    , decltype(_impl_.is_move_operation_){}
    , decltype(_impl_.first_moved_index_){}
    , decltype(_impl_.destination_index_for_move_){}
    , decltype(_impl_.number_of_indices_moved_){}
    , decltype(_impl_.is_vertical_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.start_index_, &from._impl_.start_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_vertical_) -
    reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.is_vertical_));
  // @@protoc_insertion_point(copy_constructor:TSK.ShuffleMappingArchive)
}

inline void ShuffleMappingArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.start_index_){0u}
    , decltype(_impl_.end_index_){0u}
    , decltype(_impl_.is_move_operation_){false}
    , decltype(_impl_.first_moved_index_){0u}
    , decltype(_impl_.destination_index_for_move_){0u}
    , decltype(_impl_.number_of_indices_moved_){0u}
    , decltype(_impl_.is_vertical_){true}
  };
}

ShuffleMappingArchive::~ShuffleMappingArchive() {
  // @@protoc_insertion_point(destructor:TSK.ShuffleMappingArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShuffleMappingArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void ShuffleMappingArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShuffleMappingArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ShuffleMappingArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.start_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_indices_moved_) -
        reinterpret_cast<char*>(&_impl_.start_index_)) + sizeof(_impl_.number_of_indices_moved_));
    _impl_.is_vertical_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShuffleMappingArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 start_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_index(&has_bits);
          _impl_.start_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 end_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_end_index(&has_bits);
          _impl_.end_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vertical = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_vertical(&has_bits);
          _impl_.is_vertical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_move_operation = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_move_operation(&has_bits);
          _impl_.is_move_operation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 first_moved_index = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_first_moved_index(&has_bits);
          _impl_.first_moved_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 destination_index_for_move = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_destination_index_for_move(&has_bits);
          _impl_.destination_index_for_move_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_indices_moved = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_number_of_indices_moved(&has_bits);
          _impl_.number_of_indices_moved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShuffleMappingArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ShuffleMappingArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 start_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_start_index(), target);
  }

  // required uint32 end_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_index(), target);
  }

  // repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool is_vertical = 4 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_vertical(), target);
  }

  // optional bool is_move_operation = 5 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_move_operation(), target);
  }

  // optional uint32 first_moved_index = 6 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_first_moved_index(), target);
  }

  // optional uint32 destination_index_for_move = 7 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_destination_index_for_move(), target);
  }

  // optional uint32 number_of_indices_moved = 8 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_number_of_indices_moved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ShuffleMappingArchive)
  return target;
}

size_t ShuffleMappingArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.ShuffleMappingArchive)
  size_t total_size = 0;

  if (_internal_has_start_index()) {
    // required uint32 start_index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_index());
  }

  if (_internal_has_end_index()) {
    // required uint32 end_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_index());
  }

  return total_size;
}
size_t ShuffleMappingArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ShuffleMappingArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 start_index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_index());

    // required uint32 end_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_end_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007cu) {
    // optional bool is_move_operation = 5 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 first_moved_index = 6 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_first_moved_index());
    }

    // optional uint32 destination_index_for_move = 7 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_destination_index_for_move());
    }

    // optional uint32 number_of_indices_moved = 8 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_indices_moved());
    }

    // optional bool is_vertical = 4 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShuffleMappingArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShuffleMappingArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShuffleMappingArchive::GetClassData() const { return &_class_data_; }


void ShuffleMappingArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShuffleMappingArchive*>(&to_msg);
  auto& from = static_cast<const ShuffleMappingArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ShuffleMappingArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_index_ = from._impl_.start_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_index_ = from._impl_.end_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_move_operation_ = from._impl_.is_move_operation_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.first_moved_index_ = from._impl_.first_moved_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.destination_index_for_move_ = from._impl_.destination_index_for_move_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.number_of_indices_moved_ = from._impl_.number_of_indices_moved_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.is_vertical_ = from._impl_.is_vertical_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShuffleMappingArchive::CopyFrom(const ShuffleMappingArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ShuffleMappingArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShuffleMappingArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void ShuffleMappingArchive::InternalSwap(ShuffleMappingArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShuffleMappingArchive, _impl_.number_of_indices_moved_)
      + sizeof(ShuffleMappingArchive::_impl_.number_of_indices_moved_)
      - PROTOBUF_FIELD_OFFSET(ShuffleMappingArchive, _impl_.start_index_)>(
          reinterpret_cast<char*>(&_impl_.start_index_),
          reinterpret_cast<char*>(&other->_impl_.start_index_));
  swap(_impl_.is_vertical_, other->_impl_.is_vertical_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShuffleMappingArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[11]);
}

// ===================================================================

class ProgressiveCommandGroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ProgressiveCommandGroupArchive>()._impl_._has_bits_);
  static const ::TSK::CommandGroupArchive& super(const ProgressiveCommandGroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandGroupArchive&
ProgressiveCommandGroupArchive::_Internal::super(const ProgressiveCommandGroupArchive* msg) {
  return *msg->_impl_.super_;
}
ProgressiveCommandGroupArchive::ProgressiveCommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.ProgressiveCommandGroupArchive)
}
ProgressiveCommandGroupArchive::ProgressiveCommandGroupArchive(const ProgressiveCommandGroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProgressiveCommandGroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandGroupArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.ProgressiveCommandGroupArchive)
}

inline void ProgressiveCommandGroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ProgressiveCommandGroupArchive::~ProgressiveCommandGroupArchive() {
  // @@protoc_insertion_point(destructor:TSK.ProgressiveCommandGroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProgressiveCommandGroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ProgressiveCommandGroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProgressiveCommandGroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.ProgressiveCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProgressiveCommandGroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandGroupArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProgressiveCommandGroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.ProgressiveCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandGroupArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.ProgressiveCommandGroupArchive)
  return target;
}

size_t ProgressiveCommandGroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.ProgressiveCommandGroupArchive)
  size_t total_size = 0;

  // required .TSK.CommandGroupArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProgressiveCommandGroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProgressiveCommandGroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProgressiveCommandGroupArchive::GetClassData() const { return &_class_data_; }


void ProgressiveCommandGroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProgressiveCommandGroupArchive*>(&to_msg);
  auto& from = static_cast<const ProgressiveCommandGroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.ProgressiveCommandGroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSK::CommandGroupArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProgressiveCommandGroupArchive::CopyFrom(const ProgressiveCommandGroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.ProgressiveCommandGroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProgressiveCommandGroupArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ProgressiveCommandGroupArchive::InternalSwap(ProgressiveCommandGroupArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ProgressiveCommandGroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[12]);
}

// ===================================================================

class CommandSelectionBehaviorHistoryArchive_Entry::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSelectionBehaviorHistoryArchive_Entry>()._impl_._has_bits_);
  static const ::TSP::Reference& command(const CommandSelectionBehaviorHistoryArchive_Entry* msg);
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& command_selection_behavior(const CommandSelectionBehaviorHistoryArchive_Entry* msg);
  static void set_has_command_selection_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::Reference&
CommandSelectionBehaviorHistoryArchive_Entry::_Internal::command(const CommandSelectionBehaviorHistoryArchive_Entry* msg) {
  return *msg->_impl_.command_;
}
const ::TSP::Reference&
CommandSelectionBehaviorHistoryArchive_Entry::_Internal::command_selection_behavior(const CommandSelectionBehaviorHistoryArchive_Entry* msg) {
  return *msg->_impl_.command_selection_behavior_;
}
void CommandSelectionBehaviorHistoryArchive_Entry::clear_command() {
  if (_impl_.command_ != nullptr) _impl_.command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSelectionBehaviorHistoryArchive_Entry::clear_command_selection_behavior() {
  if (_impl_.command_selection_behavior_ != nullptr) _impl_.command_selection_behavior_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandSelectionBehaviorHistoryArchive_Entry::CommandSelectionBehaviorHistoryArchive_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
}
CommandSelectionBehaviorHistoryArchive_Entry::CommandSelectionBehaviorHistoryArchive_Entry(const CommandSelectionBehaviorHistoryArchive_Entry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSelectionBehaviorHistoryArchive_Entry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){nullptr}
    , decltype(_impl_.command_selection_behavior_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_command()) {
    _this->_impl_.command_ = new ::TSP::Reference(*from._impl_.command_);
  }
  if (from._internal_has_command_selection_behavior()) {
    _this->_impl_.command_selection_behavior_ = new ::TSP::Reference(*from._impl_.command_selection_behavior_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
}

inline void CommandSelectionBehaviorHistoryArchive_Entry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_){nullptr}
    , decltype(_impl_.command_selection_behavior_){nullptr}
  };
}

CommandSelectionBehaviorHistoryArchive_Entry::~CommandSelectionBehaviorHistoryArchive_Entry() {
  // @@protoc_insertion_point(destructor:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSelectionBehaviorHistoryArchive_Entry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.command_;
  if (this != internal_default_instance()) delete _impl_.command_selection_behavior_;
}

void CommandSelectionBehaviorHistoryArchive_Entry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSelectionBehaviorHistoryArchive_Entry::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.command_ != nullptr);
      _impl_.command_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.command_selection_behavior_ != nullptr);
      _impl_.command_selection_behavior_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSelectionBehaviorHistoryArchive_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference command = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference command_selection_behavior = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_selection_behavior(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSelectionBehaviorHistoryArchive_Entry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference command = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::command(this),
        _Internal::command(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference command_selection_behavior = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::command_selection_behavior(this),
        _Internal::command_selection_behavior(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  return target;
}

size_t CommandSelectionBehaviorHistoryArchive_Entry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  size_t total_size = 0;

  if (_internal_has_command()) {
    // required .TSP.Reference command = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.command_);
  }

  if (_internal_has_command_selection_behavior()) {
    // required .TSP.Reference command_selection_behavior = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.command_selection_behavior_);
  }

  return total_size;
}
size_t CommandSelectionBehaviorHistoryArchive_Entry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.Reference command = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.command_);

    // required .TSP.Reference command_selection_behavior = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.command_selection_behavior_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSelectionBehaviorHistoryArchive_Entry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSelectionBehaviorHistoryArchive_Entry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSelectionBehaviorHistoryArchive_Entry::GetClassData() const { return &_class_data_; }


void CommandSelectionBehaviorHistoryArchive_Entry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSelectionBehaviorHistoryArchive_Entry*>(&to_msg);
  auto& from = static_cast<const CommandSelectionBehaviorHistoryArchive_Entry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_command()->::TSP::Reference::MergeFrom(
          from._internal_command());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_command_selection_behavior()->::TSP::Reference::MergeFrom(
          from._internal_command_selection_behavior());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSelectionBehaviorHistoryArchive_Entry::CopyFrom(const CommandSelectionBehaviorHistoryArchive_Entry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSelectionBehaviorHistoryArchive_Entry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_command()) {
    if (!_impl_.command_->IsInitialized()) return false;
  }
  if (_internal_has_command_selection_behavior()) {
    if (!_impl_.command_selection_behavior_->IsInitialized()) return false;
  }
  return true;
}

void CommandSelectionBehaviorHistoryArchive_Entry::InternalSwap(CommandSelectionBehaviorHistoryArchive_Entry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSelectionBehaviorHistoryArchive_Entry, _impl_.command_selection_behavior_)
      + sizeof(CommandSelectionBehaviorHistoryArchive_Entry::_impl_.command_selection_behavior_)
      - PROTOBUF_FIELD_OFFSET(CommandSelectionBehaviorHistoryArchive_Entry, _impl_.command_)>(
          reinterpret_cast<char*>(&_impl_.command_),
          reinterpret_cast<char*>(&other->_impl_.command_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSelectionBehaviorHistoryArchive_Entry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[13]);
}

// ===================================================================

class CommandSelectionBehaviorHistoryArchive::_Internal {
 public:
};

CommandSelectionBehaviorHistoryArchive::CommandSelectionBehaviorHistoryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CommandSelectionBehaviorHistoryArchive)
}
CommandSelectionBehaviorHistoryArchive::CommandSelectionBehaviorHistoryArchive(const CommandSelectionBehaviorHistoryArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSelectionBehaviorHistoryArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSK.CommandSelectionBehaviorHistoryArchive)
}

inline void CommandSelectionBehaviorHistoryArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CommandSelectionBehaviorHistoryArchive::~CommandSelectionBehaviorHistoryArchive() {
  // @@protoc_insertion_point(destructor:TSK.CommandSelectionBehaviorHistoryArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSelectionBehaviorHistoryArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void CommandSelectionBehaviorHistoryArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSelectionBehaviorHistoryArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CommandSelectionBehaviorHistoryArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSelectionBehaviorHistoryArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSelectionBehaviorHistoryArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CommandSelectionBehaviorHistoryArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CommandSelectionBehaviorHistoryArchive)
  return target;
}

size_t CommandSelectionBehaviorHistoryArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CommandSelectionBehaviorHistoryArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSelectionBehaviorHistoryArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSelectionBehaviorHistoryArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSelectionBehaviorHistoryArchive::GetClassData() const { return &_class_data_; }


void CommandSelectionBehaviorHistoryArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSelectionBehaviorHistoryArchive*>(&to_msg);
  auto& from = static_cast<const CommandSelectionBehaviorHistoryArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CommandSelectionBehaviorHistoryArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSelectionBehaviorHistoryArchive::CopyFrom(const CommandSelectionBehaviorHistoryArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CommandSelectionBehaviorHistoryArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSelectionBehaviorHistoryArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void CommandSelectionBehaviorHistoryArchive::InternalSwap(CommandSelectionBehaviorHistoryArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSelectionBehaviorHistoryArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[14]);
}

// ===================================================================

class UndoRedoStateCommandSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UndoRedoStateCommandSelectionBehaviorArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_undo_redo_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.undo_redo_state_;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_undo_redo_state() {
  if (_impl_.undo_redo_state_ != nullptr) _impl_.undo_redo_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
}
UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(const UndoRedoStateCommandSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UndoRedoStateCommandSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_redo_state_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_undo_redo_state()) {
    _this->_impl_.undo_redo_state_ = new ::TSP::Reference(*from._impl_.undo_redo_state_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
}

inline void UndoRedoStateCommandSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_redo_state_){nullptr}
  };
}

UndoRedoStateCommandSelectionBehaviorArchive::~UndoRedoStateCommandSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UndoRedoStateCommandSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.undo_redo_state_;
}

void UndoRedoStateCommandSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UndoRedoStateCommandSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.undo_redo_state_ != nullptr);
    _impl_.undo_redo_state_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UndoRedoStateCommandSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference undo_redo_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_redo_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UndoRedoStateCommandSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference undo_redo_state = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_redo_state(this),
        _Internal::undo_redo_state(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  return target;
}

size_t UndoRedoStateCommandSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference undo_redo_state = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_redo_state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UndoRedoStateCommandSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UndoRedoStateCommandSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UndoRedoStateCommandSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void UndoRedoStateCommandSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UndoRedoStateCommandSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const UndoRedoStateCommandSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_undo_redo_state()) {
    _this->_internal_mutable_undo_redo_state()->::TSP::Reference::MergeFrom(
        from._internal_undo_redo_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UndoRedoStateCommandSelectionBehaviorArchive::CopyFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UndoRedoStateCommandSelectionBehaviorArchive::IsInitialized() const {
  if (_internal_has_undo_redo_state()) {
    if (!_impl_.undo_redo_state_->IsInitialized()) return false;
  }
  return true;
}

void UndoRedoStateCommandSelectionBehaviorArchive::InternalSwap(UndoRedoStateCommandSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.undo_redo_state_, other->_impl_.undo_redo_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UndoRedoStateCommandSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[15]);
}

// ===================================================================

class FormatStructArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormatStructArchive>()._impl_._has_bits_);
  static void set_has_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_decimal_places(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_currency_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_negative_style(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_show_thousands_separator(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_use_accounting_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_duration_style(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_base_places(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_base_use_minus_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fraction_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_suppress_date_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_suppress_time_format(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_date_time_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duration_unit_largest(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_duration_unit_smallest(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_custom_id(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_custom_format_string(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_scale_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_requires_fraction_replacement(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_control_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_control_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_control_increment(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_control_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_slider_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_slider_position(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_decimal_width(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_min_integer_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_num_nonspace_integer_digits(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_num_nonspace_decimal_digits(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_index_from_right_last_integer(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static const ::TSP::IndexSet& inters_str_insertion_indexes(const FormatStructArchive* msg);
  static void set_has_inters_str_insertion_indexes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_hash_decimal_digits(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_total_num_decimal_digits(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_is_complex(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_contains_integer_token(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_multiple_choice_list_initial_value(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_multiple_choice_list_id(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_use_automatic_duration_units(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

const ::TSP::IndexSet&
FormatStructArchive::_Internal::inters_str_insertion_indexes(const FormatStructArchive* msg) {
  return *msg->_impl_.inters_str_insertion_indexes_;
}
void FormatStructArchive::clear_inters_str_insertion_indexes() {
  if (_impl_.inters_str_insertion_indexes_ != nullptr) _impl_.inters_str_insertion_indexes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
FormatStructArchive::FormatStructArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.FormatStructArchive)
}
FormatStructArchive::FormatStructArchive(const FormatStructArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormatStructArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interstitial_strings_){from._impl_.interstitial_strings_}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.date_time_format_){}
    , decltype(_impl_.custom_format_string_){}
    , decltype(_impl_.inters_str_insertion_indexes_){nullptr}
    , decltype(_impl_.format_type_){}
    , decltype(_impl_.decimal_places_){}
    , decltype(_impl_.negative_style_){}
    , decltype(_impl_.duration_style_){}
    , decltype(_impl_.base_){}
    , decltype(_impl_.show_thousands_separator_){}
    , decltype(_impl_.use_accounting_style_){}
    , decltype(_impl_.base_use_minus_sign_){}
    , decltype(_impl_.suppress_date_format_){}
    , decltype(_impl_.base_places_){}
    , decltype(_impl_.fraction_accuracy_){}
    , decltype(_impl_.duration_unit_largest_){}
    , decltype(_impl_.duration_unit_smallest_){}
    , decltype(_impl_.scale_factor_){}
    , decltype(_impl_.custom_id_){}
    , decltype(_impl_.control_format_type_){}
    , decltype(_impl_.control_minimum_){}
    , decltype(_impl_.control_maximum_){}
    , decltype(_impl_.control_increment_){}
    , decltype(_impl_.slider_orientation_){}
    , decltype(_impl_.slider_position_){}
    , decltype(_impl_.suppress_time_format_){}
    , decltype(_impl_.requires_fraction_replacement_){}
    , decltype(_impl_.is_complex_){}
    , decltype(_impl_.contains_integer_token_){}
    , decltype(_impl_.decimal_width_){}
    , decltype(_impl_.min_integer_width_){}
    , decltype(_impl_.num_nonspace_integer_digits_){}
    , decltype(_impl_.num_nonspace_decimal_digits_){}
    , decltype(_impl_.index_from_right_last_integer_){}
    , decltype(_impl_.num_hash_decimal_digits_){}
    , decltype(_impl_.total_num_decimal_digits_){}
    , decltype(_impl_.multiple_choice_list_initial_value_){}
    , decltype(_impl_.multiple_choice_list_id_){}
    , decltype(_impl_.use_automatic_duration_units_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currency_code()) {
    _this->_impl_.currency_code_.Set(from._internal_currency_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.date_time_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_time_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_date_time_format()) {
    _this->_impl_.date_time_format_.Set(from._internal_date_time_format(), 
      _this->GetArenaForAllocation());
  }
  _impl_.custom_format_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_format_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_format_string()) {
    _this->_impl_.custom_format_string_.Set(from._internal_custom_format_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_inters_str_insertion_indexes()) {
    _this->_impl_.inters_str_insertion_indexes_ = new ::TSP::IndexSet(*from._impl_.inters_str_insertion_indexes_);
  }
  ::memcpy(&_impl_.format_type_, &from._impl_.format_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_automatic_duration_units_) -
    reinterpret_cast<char*>(&_impl_.format_type_)) + sizeof(_impl_.use_automatic_duration_units_));
  // @@protoc_insertion_point(copy_constructor:TSK.FormatStructArchive)
}

inline void FormatStructArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.interstitial_strings_){arena}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.date_time_format_){}
    , decltype(_impl_.custom_format_string_){}
    , decltype(_impl_.inters_str_insertion_indexes_){nullptr}
    , decltype(_impl_.format_type_){0u}
    , decltype(_impl_.decimal_places_){0u}
    , decltype(_impl_.negative_style_){0u}
    , decltype(_impl_.duration_style_){0u}
    , decltype(_impl_.base_){0u}
    , decltype(_impl_.show_thousands_separator_){false}
    , decltype(_impl_.use_accounting_style_){false}
    , decltype(_impl_.base_use_minus_sign_){false}
    , decltype(_impl_.suppress_date_format_){false}
    , decltype(_impl_.base_places_){0u}
    , decltype(_impl_.fraction_accuracy_){0u}
    , decltype(_impl_.duration_unit_largest_){0u}
    , decltype(_impl_.duration_unit_smallest_){0u}
    , decltype(_impl_.scale_factor_){0}
    , decltype(_impl_.custom_id_){0u}
    , decltype(_impl_.control_format_type_){0u}
    , decltype(_impl_.control_minimum_){0}
    , decltype(_impl_.control_maximum_){0}
    , decltype(_impl_.control_increment_){0}
    , decltype(_impl_.slider_orientation_){0u}
    , decltype(_impl_.slider_position_){0u}
    , decltype(_impl_.suppress_time_format_){false}
    , decltype(_impl_.requires_fraction_replacement_){false}
    , decltype(_impl_.is_complex_){false}
    , decltype(_impl_.contains_integer_token_){false}
    , decltype(_impl_.decimal_width_){0u}
    , decltype(_impl_.min_integer_width_){0u}
    , decltype(_impl_.num_nonspace_integer_digits_){0u}
    , decltype(_impl_.num_nonspace_decimal_digits_){0u}
    , decltype(_impl_.index_from_right_last_integer_){0u}
    , decltype(_impl_.num_hash_decimal_digits_){0u}
    , decltype(_impl_.total_num_decimal_digits_){0u}
    , decltype(_impl_.multiple_choice_list_initial_value_){0u}
    , decltype(_impl_.multiple_choice_list_id_){0u}
    , decltype(_impl_.use_automatic_duration_units_){false}
  };
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.date_time_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_time_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.custom_format_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_format_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FormatStructArchive::~FormatStructArchive() {
  // @@protoc_insertion_point(destructor:TSK.FormatStructArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormatStructArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.interstitial_strings_.~RepeatedPtrField();
  _impl_.currency_code_.Destroy();
  _impl_.date_time_format_.Destroy();
  _impl_.custom_format_string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.inters_str_insertion_indexes_;
}

void FormatStructArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormatStructArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.FormatStructArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _impl_.interstitial_strings_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currency_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.date_time_format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.custom_format_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.inters_str_insertion_indexes_ != nullptr);
      _impl_.inters_str_insertion_indexes_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.format_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.duration_style_) -
        reinterpret_cast<char*>(&_impl_.format_type_)) + sizeof(_impl_.duration_style_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.base_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.duration_unit_largest_) -
        reinterpret_cast<char*>(&_impl_.base_)) + sizeof(_impl_.duration_unit_largest_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.duration_unit_smallest_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.slider_orientation_) -
        reinterpret_cast<char*>(&_impl_.duration_unit_smallest_)) + sizeof(_impl_.slider_orientation_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.slider_position_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_nonspace_integer_digits_) -
        reinterpret_cast<char*>(&_impl_.slider_position_)) + sizeof(_impl_.num_nonspace_integer_digits_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.num_nonspace_decimal_digits_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.use_automatic_duration_units_) -
        reinterpret_cast<char*>(&_impl_.num_nonspace_decimal_digits_)) + sizeof(_impl_.use_automatic_duration_units_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormatStructArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 format_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_format_type(&_impl_._has_bits_);
          _impl_.format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 decimal_places = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_decimal_places(&_impl_._has_bits_);
          _impl_.decimal_places_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currency_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_currency_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.FormatStructArchive.currency_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 negative_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_negative_style(&_impl_._has_bits_);
          _impl_.negative_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_thousands_separator = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_show_thousands_separator(&_impl_._has_bits_);
          _impl_.show_thousands_separator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_accounting_style = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_use_accounting_style(&_impl_._has_bits_);
          _impl_.use_accounting_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration_style = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_duration_style(&_impl_._has_bits_);
          _impl_.duration_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_base(&_impl_._has_bits_);
          _impl_.base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 base_places = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_base_places(&_impl_._has_bits_);
          _impl_.base_places_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool base_use_minus_sign = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_base_use_minus_sign(&_impl_._has_bits_);
          _impl_.base_use_minus_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fraction_accuracy = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_fraction_accuracy(&_impl_._has_bits_);
          _impl_.fraction_accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool suppress_date_format = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_suppress_date_format(&_impl_._has_bits_);
          _impl_.suppress_date_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool suppress_time_format = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_suppress_time_format(&_impl_._has_bits_);
          _impl_.suppress_time_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string date_time_format = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_date_time_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.FormatStructArchive.date_time_format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration_unit_largest = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_duration_unit_largest(&_impl_._has_bits_);
          _impl_.duration_unit_largest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 duration_unit_smallest = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_duration_unit_smallest(&_impl_._has_bits_);
          _impl_.duration_unit_smallest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 custom_id = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_custom_id(&_impl_._has_bits_);
          _impl_.custom_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string custom_format_string = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_custom_format_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.FormatStructArchive.custom_format_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional double scale_factor = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _Internal::set_has_scale_factor(&_impl_._has_bits_);
          _impl_.scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool requires_fraction_replacement = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_requires_fraction_replacement(&_impl_._has_bits_);
          _impl_.requires_fraction_replacement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double control_minimum = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _Internal::set_has_control_minimum(&_impl_._has_bits_);
          _impl_.control_minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double control_maximum = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _Internal::set_has_control_maximum(&_impl_._has_bits_);
          _impl_.control_maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double control_increment = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _Internal::set_has_control_increment(&_impl_._has_bits_);
          _impl_.control_increment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 control_format_type = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_control_format_type(&_impl_._has_bits_);
          _impl_.control_format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slider_orientation = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_slider_orientation(&_impl_._has_bits_);
          _impl_.slider_orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slider_position = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_slider_position(&_impl_._has_bits_);
          _impl_.slider_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 decimal_width = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_decimal_width(&_impl_._has_bits_);
          _impl_.decimal_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 min_integer_width = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_min_integer_width(&_impl_._has_bits_);
          _impl_.min_integer_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_nonspace_integer_digits = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_num_nonspace_integer_digits(&_impl_._has_bits_);
          _impl_.num_nonspace_integer_digits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_nonspace_decimal_digits = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_num_nonspace_decimal_digits(&_impl_._has_bits_);
          _impl_.num_nonspace_decimal_digits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index_from_right_last_integer = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_index_from_right_last_integer(&_impl_._has_bits_);
          _impl_.index_from_right_last_integer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string interstitial_strings = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_interstitial_strings();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "TSK.FormatStructArchive.interstitial_strings");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<258>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.IndexSet inters_str_insertion_indexes = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_inters_str_insertion_indexes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_hash_decimal_digits = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_hash_decimal_digits(&_impl_._has_bits_);
          _impl_.num_hash_decimal_digits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total_num_decimal_digits = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total_num_decimal_digits(&_impl_._has_bits_);
          _impl_.total_num_decimal_digits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_complex = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_complex(&_impl_._has_bits_);
          _impl_.is_complex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contains_integer_token = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_contains_integer_token(&_impl_._has_bits_);
          _impl_.contains_integer_token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 multiple_choice_list_initial_value = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_multiple_choice_list_initial_value(&_impl_._has_bits_);
          _impl_.multiple_choice_list_initial_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 multiple_choice_list_id = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_multiple_choice_list_id(&_impl_._has_bits_);
          _impl_.multiple_choice_list_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_automatic_duration_units = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_use_automatic_duration_units(&_impl_._has_bits_);
          _impl_.use_automatic_duration_units_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((80000u <= tag && tag < 160000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormatStructArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.FormatStructArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 format_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_format_type(), target);
  }

  // optional uint32 decimal_places = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_decimal_places(), target);
  }

  // optional string currency_code = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_currency_code().data(), static_cast<int>(this->_internal_currency_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.FormatStructArchive.currency_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_currency_code(), target);
  }

  // optional uint32 negative_style = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_negative_style(), target);
  }

  // optional bool show_thousands_separator = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_show_thousands_separator(), target);
  }

  // optional bool use_accounting_style = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_use_accounting_style(), target);
  }

  // optional uint32 duration_style = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_duration_style(), target);
  }

  // optional uint32 base = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_base(), target);
  }

  // optional uint32 base_places = 9;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_base_places(), target);
  }

  // optional bool base_use_minus_sign = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_base_use_minus_sign(), target);
  }

  // optional uint32 fraction_accuracy = 11;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_fraction_accuracy(), target);
  }

  // optional bool suppress_date_format = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_suppress_date_format(), target);
  }

  // optional bool suppress_time_format = 13;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_suppress_time_format(), target);
  }

  // optional string date_time_format = 14;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_date_time_format().data(), static_cast<int>(this->_internal_date_time_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.FormatStructArchive.date_time_format");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_date_time_format(), target);
  }

  // optional uint32 duration_unit_largest = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_duration_unit_largest(), target);
  }

  // optional uint32 duration_unit_smallest = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_duration_unit_smallest(), target);
  }

  // optional uint32 custom_id = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_custom_id(), target);
  }

  // optional string custom_format_string = 18;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_custom_format_string().data(), static_cast<int>(this->_internal_custom_format_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.FormatStructArchive.custom_format_string");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_custom_format_string(), target);
  }

  // optional double scale_factor = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(19, this->_internal_scale_factor(), target);
  }

  // optional bool requires_fraction_replacement = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_requires_fraction_replacement(), target);
  }

  // optional double control_minimum = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(21, this->_internal_control_minimum(), target);
  }

  // optional double control_maximum = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_control_maximum(), target);
  }

  // optional double control_increment = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(23, this->_internal_control_increment(), target);
  }

  // optional uint32 control_format_type = 24;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_control_format_type(), target);
  }

  // optional uint32 slider_orientation = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_slider_orientation(), target);
  }

  // optional uint32 slider_position = 26;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_slider_position(), target);
  }

  // optional uint32 decimal_width = 27;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_decimal_width(), target);
  }

  // optional uint32 min_integer_width = 28;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_min_integer_width(), target);
  }

  // optional uint32 num_nonspace_integer_digits = 29;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_num_nonspace_integer_digits(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 num_nonspace_decimal_digits = 30;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(30, this->_internal_num_nonspace_decimal_digits(), target);
  }

  // optional uint32 index_from_right_last_integer = 31;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_index_from_right_last_integer(), target);
  }

  // repeated string interstitial_strings = 32;
  for (int i = 0, n = this->_internal_interstitial_strings_size(); i < n; i++) {
    const auto& s = this->_internal_interstitial_strings(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.FormatStructArchive.interstitial_strings");
    target = stream->WriteString(32, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.IndexSet inters_str_insertion_indexes = 33;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::inters_str_insertion_indexes(this),
        _Internal::inters_str_insertion_indexes(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 num_hash_decimal_digits = 34;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(34, this->_internal_num_hash_decimal_digits(), target);
  }

  // optional uint32 total_num_decimal_digits = 35;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_total_num_decimal_digits(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_complex = 36;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(36, this->_internal_is_complex(), target);
  }

  // optional bool contains_integer_token = 37;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_contains_integer_token(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 multiple_choice_list_initial_value = 38;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(38, this->_internal_multiple_choice_list_initial_value(), target);
  }

  // optional uint32 multiple_choice_list_id = 39;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_multiple_choice_list_id(), target);
  }

  // optional bool use_automatic_duration_units = 40;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(40, this->_internal_use_automatic_duration_units(), target);
  }

  // Extension range [10000, 20000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 10000, 20000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.FormatStructArchive)
  return target;
}

size_t FormatStructArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.FormatStructArchive)
  size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required uint32 format_type = 1;
  if (_internal_has_format_type()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string interstitial_strings = 32;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.interstitial_strings_.size());
  for (int i = 0, n = _impl_.interstitial_strings_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.interstitial_strings_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string currency_code = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currency_code());
    }

    // optional string date_time_format = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date_time_format());
    }

    // optional string custom_format_string = 18;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_format_string());
    }

    // optional .TSP.IndexSet inters_str_insertion_indexes = 33;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.inters_str_insertion_indexes_);
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional uint32 decimal_places = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_decimal_places());
    }

    // optional uint32 negative_style = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_negative_style());
    }

    // optional uint32 duration_style = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration_style());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 base = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base());
    }

    // optional bool show_thousands_separator = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool use_accounting_style = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool base_use_minus_sign = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool suppress_date_format = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional uint32 base_places = 9;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_places());
    }

    // optional uint32 fraction_accuracy = 11;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fraction_accuracy());
    }

    // optional uint32 duration_unit_largest = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_duration_unit_largest());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional uint32 duration_unit_smallest = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_duration_unit_smallest());
    }

    // optional double scale_factor = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional uint32 custom_id = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_custom_id());
    }

    // optional uint32 control_format_type = 24;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_control_format_type());
    }

    // optional double control_minimum = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 8;
    }

    // optional double control_maximum = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional double control_increment = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional uint32 slider_orientation = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_slider_orientation());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 slider_position = 26;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_slider_position());
    }

    // optional bool suppress_time_format = 13;
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 + 1;
    }

    // optional bool requires_fraction_replacement = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_complex = 36;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool contains_integer_token = 37;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional uint32 decimal_width = 27;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_decimal_width());
    }

    // optional uint32 min_integer_width = 28;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_min_integer_width());
    }

    // optional uint32 num_nonspace_integer_digits = 29;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_num_nonspace_integer_digits());
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    // optional uint32 num_nonspace_decimal_digits = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_num_nonspace_decimal_digits());
    }

    // optional uint32 index_from_right_last_integer = 31;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_index_from_right_last_integer());
    }

    // optional uint32 num_hash_decimal_digits = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_num_hash_decimal_digits());
    }

    // optional uint32 total_num_decimal_digits = 35;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_total_num_decimal_digits());
    }

    // optional uint32 multiple_choice_list_initial_value = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_multiple_choice_list_initial_value());
    }

    // optional uint32 multiple_choice_list_id = 39;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_multiple_choice_list_id());
    }

    // optional bool use_automatic_duration_units = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormatStructArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormatStructArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormatStructArchive::GetClassData() const { return &_class_data_; }


void FormatStructArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormatStructArchive*>(&to_msg);
  auto& from = static_cast<const FormatStructArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.FormatStructArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.interstitial_strings_.MergeFrom(from._impl_.interstitial_strings_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currency_code(from._internal_currency_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_date_time_format(from._internal_date_time_format());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_custom_format_string(from._internal_custom_format_string());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_inters_str_insertion_indexes()->::TSP::IndexSet::MergeFrom(
          from._internal_inters_str_insertion_indexes());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.format_type_ = from._impl_.format_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.decimal_places_ = from._impl_.decimal_places_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.negative_style_ = from._impl_.negative_style_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.duration_style_ = from._impl_.duration_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.base_ = from._impl_.base_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.show_thousands_separator_ = from._impl_.show_thousands_separator_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.use_accounting_style_ = from._impl_.use_accounting_style_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.base_use_minus_sign_ = from._impl_.base_use_minus_sign_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.suppress_date_format_ = from._impl_.suppress_date_format_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.base_places_ = from._impl_.base_places_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.fraction_accuracy_ = from._impl_.fraction_accuracy_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.duration_unit_largest_ = from._impl_.duration_unit_largest_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.duration_unit_smallest_ = from._impl_.duration_unit_smallest_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.scale_factor_ = from._impl_.scale_factor_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.custom_id_ = from._impl_.custom_id_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.control_format_type_ = from._impl_.control_format_type_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.control_minimum_ = from._impl_.control_minimum_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.control_maximum_ = from._impl_.control_maximum_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.control_increment_ = from._impl_.control_increment_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.slider_orientation_ = from._impl_.slider_orientation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.slider_position_ = from._impl_.slider_position_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.suppress_time_format_ = from._impl_.suppress_time_format_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.requires_fraction_replacement_ = from._impl_.requires_fraction_replacement_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.is_complex_ = from._impl_.is_complex_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.contains_integer_token_ = from._impl_.contains_integer_token_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.decimal_width_ = from._impl_.decimal_width_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.min_integer_width_ = from._impl_.min_integer_width_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.num_nonspace_integer_digits_ = from._impl_.num_nonspace_integer_digits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.num_nonspace_decimal_digits_ = from._impl_.num_nonspace_decimal_digits_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_from_right_last_integer_ = from._impl_.index_from_right_last_integer_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_hash_decimal_digits_ = from._impl_.num_hash_decimal_digits_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.total_num_decimal_digits_ = from._impl_.total_num_decimal_digits_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.multiple_choice_list_initial_value_ = from._impl_.multiple_choice_list_initial_value_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.multiple_choice_list_id_ = from._impl_.multiple_choice_list_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.use_automatic_duration_units_ = from._impl_.use_automatic_duration_units_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormatStructArchive::CopyFrom(const FormatStructArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.FormatStructArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormatStructArchive::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized()) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_inters_str_insertion_indexes()) {
    if (!_impl_.inters_str_insertion_indexes_->IsInitialized()) return false;
  }
  return true;
}

void FormatStructArchive::InternalSwap(FormatStructArchive* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  _impl_.interstitial_strings_.InternalSwap(&other->_impl_.interstitial_strings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currency_code_, lhs_arena,
      &other->_impl_.currency_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.date_time_format_, lhs_arena,
      &other->_impl_.date_time_format_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.custom_format_string_, lhs_arena,
      &other->_impl_.custom_format_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FormatStructArchive, _impl_.use_automatic_duration_units_)
      + sizeof(FormatStructArchive::_impl_.use_automatic_duration_units_)
      - PROTOBUF_FIELD_OFFSET(FormatStructArchive, _impl_.inters_str_insertion_indexes_)>(
          reinterpret_cast<char*>(&_impl_.inters_str_insertion_indexes_),
          reinterpret_cast<char*>(&other->_impl_.inters_str_insertion_indexes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FormatStructArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[16]);
}

// ===================================================================

class CustomFormatArchive_Condition::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomFormatArchive_Condition>()._impl_._has_bits_);
  static void set_has_condition_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_condition_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSK::FormatStructArchive& condition_format(const CustomFormatArchive_Condition* msg);
  static void set_has_condition_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_condition_value_dbl(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSK::FormatStructArchive&
CustomFormatArchive_Condition::_Internal::condition_format(const CustomFormatArchive_Condition* msg) {
  return *msg->_impl_.condition_format_;
}
CustomFormatArchive_Condition::CustomFormatArchive_Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CustomFormatArchive.Condition)
}
CustomFormatArchive_Condition::CustomFormatArchive_Condition(const CustomFormatArchive_Condition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CustomFormatArchive_Condition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.condition_format_){nullptr}
    , decltype(_impl_.condition_type_){}
    , decltype(_impl_.condition_value_){}
    , decltype(_impl_.condition_value_dbl_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_condition_format()) {
    _this->_impl_.condition_format_ = new ::TSK::FormatStructArchive(*from._impl_.condition_format_);
  }
  ::memcpy(&_impl_.condition_type_, &from._impl_.condition_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.condition_value_dbl_) -
    reinterpret_cast<char*>(&_impl_.condition_type_)) + sizeof(_impl_.condition_value_dbl_));
  // @@protoc_insertion_point(copy_constructor:TSK.CustomFormatArchive.Condition)
}

inline void CustomFormatArchive_Condition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.condition_format_){nullptr}
    , decltype(_impl_.condition_type_){0u}
    , decltype(_impl_.condition_value_){0}
    , decltype(_impl_.condition_value_dbl_){0}
  };
}

CustomFormatArchive_Condition::~CustomFormatArchive_Condition() {
  // @@protoc_insertion_point(destructor:TSK.CustomFormatArchive.Condition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CustomFormatArchive_Condition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.condition_format_;
}

void CustomFormatArchive_Condition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CustomFormatArchive_Condition::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CustomFormatArchive.Condition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.condition_format_ != nullptr);
    _impl_.condition_format_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.condition_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.condition_value_dbl_) -
        reinterpret_cast<char*>(&_impl_.condition_type_)) + sizeof(_impl_.condition_value_dbl_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomFormatArchive_Condition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 condition_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_condition_type(&has_bits);
          _impl_.condition_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float condition_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_condition_value(&has_bits);
          _impl_.condition_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.FormatStructArchive condition_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_condition_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double condition_value_dbl = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_condition_value_dbl(&has_bits);
          _impl_.condition_value_dbl_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomFormatArchive_Condition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CustomFormatArchive.Condition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 condition_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_condition_type(), target);
  }

  // optional float condition_value = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_condition_value(), target);
  }

  // required .TSK.FormatStructArchive condition_format = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::condition_format(this),
        _Internal::condition_format(this).GetCachedSize(), target, stream);
  }

  // optional double condition_value_dbl = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_condition_value_dbl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CustomFormatArchive.Condition)
  return target;
}

size_t CustomFormatArchive_Condition::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.CustomFormatArchive.Condition)
  size_t total_size = 0;

  if (_internal_has_condition_format()) {
    // required .TSK.FormatStructArchive condition_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.condition_format_);
  }

  if (_internal_has_condition_type()) {
    // required uint32 condition_type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_condition_type());
  }

  return total_size;
}
size_t CustomFormatArchive_Condition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CustomFormatArchive.Condition)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSK.FormatStructArchive condition_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.condition_format_);

    // required uint32 condition_type = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_condition_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional float condition_value = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional double condition_value_dbl = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomFormatArchive_Condition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CustomFormatArchive_Condition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomFormatArchive_Condition::GetClassData() const { return &_class_data_; }


void CustomFormatArchive_Condition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CustomFormatArchive_Condition*>(&to_msg);
  auto& from = static_cast<const CustomFormatArchive_Condition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CustomFormatArchive.Condition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_condition_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_condition_format());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.condition_type_ = from._impl_.condition_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.condition_value_ = from._impl_.condition_value_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.condition_value_dbl_ = from._impl_.condition_value_dbl_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CustomFormatArchive_Condition::CopyFrom(const CustomFormatArchive_Condition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CustomFormatArchive.Condition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomFormatArchive_Condition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_condition_format()) {
    if (!_impl_.condition_format_->IsInitialized()) return false;
  }
  return true;
}

void CustomFormatArchive_Condition::InternalSwap(CustomFormatArchive_Condition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CustomFormatArchive_Condition, _impl_.condition_value_dbl_)
      + sizeof(CustomFormatArchive_Condition::_impl_.condition_value_dbl_)
      - PROTOBUF_FIELD_OFFSET(CustomFormatArchive_Condition, _impl_.condition_format_)>(
          reinterpret_cast<char*>(&_impl_.condition_format_),
          reinterpret_cast<char*>(&other->_impl_.condition_format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomFormatArchive_Condition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[17]);
}

// ===================================================================

class CustomFormatArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CustomFormatArchive>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSK::FormatStructArchive& default_format(const CustomFormatArchive* msg);
  static void set_has_default_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TSK::FormatStructArchive&
CustomFormatArchive::_Internal::default_format(const CustomFormatArchive* msg) {
  return *msg->_impl_.default_format_;
}
CustomFormatArchive::CustomFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.CustomFormatArchive)
}
CustomFormatArchive::CustomFormatArchive(const CustomFormatArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CustomFormatArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){from._impl_.conditions_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.default_format_){nullptr}
    , decltype(_impl_.format_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_default_format()) {
    _this->_impl_.default_format_ = new ::TSK::FormatStructArchive(*from._impl_.default_format_);
  }
  _this->_impl_.format_type_ = from._impl_.format_type_;
  // @@protoc_insertion_point(copy_constructor:TSK.CustomFormatArchive)
}

inline void CustomFormatArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.conditions_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.default_format_){nullptr}
    , decltype(_impl_.format_type_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomFormatArchive::~CustomFormatArchive() {
  // @@protoc_insertion_point(destructor:TSK.CustomFormatArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CustomFormatArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.conditions_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.default_format_;
}

void CustomFormatArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CustomFormatArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.CustomFormatArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.conditions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.default_format_ != nullptr);
      _impl_.default_format_->Clear();
    }
  }
  _impl_.format_type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CustomFormatArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.CustomFormatArchive.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 format_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_format_type(&has_bits);
          _impl_.format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.FormatStructArchive default_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSK.CustomFormatArchive.Condition conditions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CustomFormatArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.CustomFormatArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.CustomFormatArchive.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 format_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_format_type(), target);
  }

  // required .TSK.FormatStructArchive default_format = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::default_format(this),
        _Internal::default_format(this).GetCachedSize(), target, stream);
  }

  // repeated .TSK.CustomFormatArchive.Condition conditions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.CustomFormatArchive)
  return target;
}

size_t CustomFormatArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TSK.CustomFormatArchive)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_default_format()) {
    // required .TSK.FormatStructArchive default_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_format_);
  }

  if (_internal_has_format_type()) {
    // required uint32 format_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());
  }

  return total_size;
}
size_t CustomFormatArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.CustomFormatArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required .TSK.FormatStructArchive default_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_format_);

    // required uint32 format_type = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSK.CustomFormatArchive.Condition conditions = 4;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->_impl_.conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CustomFormatArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CustomFormatArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CustomFormatArchive::GetClassData() const { return &_class_data_; }


void CustomFormatArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CustomFormatArchive*>(&to_msg);
  auto& from = static_cast<const CustomFormatArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.CustomFormatArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_default_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_default_format());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_type_ = from._impl_.format_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CustomFormatArchive::CopyFrom(const CustomFormatArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.CustomFormatArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CustomFormatArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.conditions_))
    return false;
  if (_internal_has_default_format()) {
    if (!_impl_.default_format_->IsInitialized()) return false;
  }
  return true;
}

void CustomFormatArchive::InternalSwap(CustomFormatArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CustomFormatArchive, _impl_.format_type_)
      + sizeof(CustomFormatArchive::_impl_.format_type_)
      - PROTOBUF_FIELD_OFFSET(CustomFormatArchive, _impl_.default_format_)>(
          reinterpret_cast<char*>(&_impl_.default_format_),
          reinterpret_cast<char*>(&other->_impl_.default_format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CustomFormatArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[18]);
}

// ===================================================================

class AnnotationAuthorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AnnotationAuthorArchive>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Color& color(const AnnotationAuthorArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Color&
AnnotationAuthorArchive::_Internal::color(const AnnotationAuthorArchive* msg) {
  return *msg->_impl_.color_;
}
void AnnotationAuthorArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
AnnotationAuthorArchive::AnnotationAuthorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.AnnotationAuthorArchive)
}
AnnotationAuthorArchive::AnnotationAuthorArchive(const AnnotationAuthorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnnotationAuthorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.AnnotationAuthorArchive)
}

inline void AnnotationAuthorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.color_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AnnotationAuthorArchive::~AnnotationAuthorArchive() {
  // @@protoc_insertion_point(destructor:TSK.AnnotationAuthorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnnotationAuthorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.color_;
}

void AnnotationAuthorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnnotationAuthorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.AnnotationAuthorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnnotationAuthorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.AnnotationAuthorArchive.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnnotationAuthorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.AnnotationAuthorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.AnnotationAuthorArchive.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .TSP.Color color = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.AnnotationAuthorArchive)
  return target;
}

size_t AnnotationAuthorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.AnnotationAuthorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .TSP.Color color = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnnotationAuthorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnnotationAuthorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnnotationAuthorArchive::GetClassData() const { return &_class_data_; }


void AnnotationAuthorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnnotationAuthorArchive*>(&to_msg);
  auto& from = static_cast<const AnnotationAuthorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.AnnotationAuthorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnnotationAuthorArchive::CopyFrom(const AnnotationAuthorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.AnnotationAuthorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnotationAuthorArchive::IsInitialized() const {
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void AnnotationAuthorArchive::InternalSwap(AnnotationAuthorArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.color_, other->_impl_.color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnnotationAuthorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[19]);
}

// ===================================================================

class DeprecatedChangeAuthorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DeprecatedChangeAuthorArchive>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Color& change_color(const DeprecatedChangeAuthorArchive* msg);
  static void set_has_change_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSP::Color&
DeprecatedChangeAuthorArchive::_Internal::change_color(const DeprecatedChangeAuthorArchive* msg) {
  return *msg->_impl_.change_color_;
}
void DeprecatedChangeAuthorArchive::clear_change_color() {
  if (_impl_.change_color_ != nullptr) _impl_.change_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
DeprecatedChangeAuthorArchive::DeprecatedChangeAuthorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.DeprecatedChangeAuthorArchive)
}
DeprecatedChangeAuthorArchive::DeprecatedChangeAuthorArchive(const DeprecatedChangeAuthorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeprecatedChangeAuthorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.change_color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_change_color()) {
    _this->_impl_.change_color_ = new ::TSP::Color(*from._impl_.change_color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.DeprecatedChangeAuthorArchive)
}

inline void DeprecatedChangeAuthorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.change_color_){nullptr}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeprecatedChangeAuthorArchive::~DeprecatedChangeAuthorArchive() {
  // @@protoc_insertion_point(destructor:TSK.DeprecatedChangeAuthorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeprecatedChangeAuthorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.change_color_;
}

void DeprecatedChangeAuthorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeprecatedChangeAuthorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.DeprecatedChangeAuthorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.change_color_ != nullptr);
      _impl_.change_color_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeprecatedChangeAuthorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSK.DeprecatedChangeAuthorArchive.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color change_color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeprecatedChangeAuthorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.DeprecatedChangeAuthorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSK.DeprecatedChangeAuthorArchive.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional .TSP.Color change_color = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::change_color(this),
        _Internal::change_color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.DeprecatedChangeAuthorArchive)
  return target;
}

size_t DeprecatedChangeAuthorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.DeprecatedChangeAuthorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .TSP.Color change_color = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.change_color_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeprecatedChangeAuthorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeprecatedChangeAuthorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeprecatedChangeAuthorArchive::GetClassData() const { return &_class_data_; }


void DeprecatedChangeAuthorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeprecatedChangeAuthorArchive*>(&to_msg);
  auto& from = static_cast<const DeprecatedChangeAuthorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.DeprecatedChangeAuthorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_change_color()->::TSP::Color::MergeFrom(
          from._internal_change_color());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeprecatedChangeAuthorArchive::CopyFrom(const DeprecatedChangeAuthorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.DeprecatedChangeAuthorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeprecatedChangeAuthorArchive::IsInitialized() const {
  if (_internal_has_change_color()) {
    if (!_impl_.change_color_->IsInitialized()) return false;
  }
  return true;
}

void DeprecatedChangeAuthorArchive::InternalSwap(DeprecatedChangeAuthorArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.change_color_, other->_impl_.change_color_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeprecatedChangeAuthorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[20]);
}

// ===================================================================

class AnnotationAuthorStorageArchive::_Internal {
 public:
};

void AnnotationAuthorStorageArchive::clear_annotation_author() {
  _impl_.annotation_author_.Clear();
}
AnnotationAuthorStorageArchive::AnnotationAuthorStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.AnnotationAuthorStorageArchive)
}
AnnotationAuthorStorageArchive::AnnotationAuthorStorageArchive(const AnnotationAuthorStorageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnnotationAuthorStorageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.annotation_author_){from._impl_.annotation_author_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TSK.AnnotationAuthorStorageArchive)
}

inline void AnnotationAuthorStorageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.annotation_author_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AnnotationAuthorStorageArchive::~AnnotationAuthorStorageArchive() {
  // @@protoc_insertion_point(destructor:TSK.AnnotationAuthorStorageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnnotationAuthorStorageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.annotation_author_.~RepeatedPtrField();
}

void AnnotationAuthorStorageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnnotationAuthorStorageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.AnnotationAuthorStorageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.annotation_author_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnnotationAuthorStorageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference annotation_author = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_annotation_author(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnnotationAuthorStorageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.AnnotationAuthorStorageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference annotation_author = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_annotation_author_size()); i < n; i++) {
    const auto& repfield = this->_internal_annotation_author(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.AnnotationAuthorStorageArchive)
  return target;
}

size_t AnnotationAuthorStorageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.AnnotationAuthorStorageArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference annotation_author = 1;
  total_size += 1UL * this->_internal_annotation_author_size();
  for (const auto& msg : this->_impl_.annotation_author_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnnotationAuthorStorageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnnotationAuthorStorageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnnotationAuthorStorageArchive::GetClassData() const { return &_class_data_; }


void AnnotationAuthorStorageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnnotationAuthorStorageArchive*>(&to_msg);
  auto& from = static_cast<const AnnotationAuthorStorageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.AnnotationAuthorStorageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.annotation_author_.MergeFrom(from._impl_.annotation_author_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnnotationAuthorStorageArchive::CopyFrom(const AnnotationAuthorStorageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.AnnotationAuthorStorageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnnotationAuthorStorageArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.annotation_author_))
    return false;
  return true;
}

void AnnotationAuthorStorageArchive::InternalSwap(AnnotationAuthorStorageArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.annotation_author_.InternalSwap(&other->_impl_.annotation_author_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AnnotationAuthorStorageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[21]);
}

// ===================================================================

class AddAnnotationAuthorCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AddAnnotationAuthorCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const AddAnnotationAuthorCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& document_root(const AddAnnotationAuthorCommandArchive* msg);
  static void set_has_document_root(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& annotation_author(const AddAnnotationAuthorCommandArchive* msg);
  static void set_has_annotation_author(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
AddAnnotationAuthorCommandArchive::_Internal::super(const AddAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
AddAnnotationAuthorCommandArchive::_Internal::document_root(const AddAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.document_root_;
}
const ::TSP::Reference&
AddAnnotationAuthorCommandArchive::_Internal::annotation_author(const AddAnnotationAuthorCommandArchive* msg) {
  return *msg->_impl_.annotation_author_;
}
void AddAnnotationAuthorCommandArchive::clear_document_root() {
  if (_impl_.document_root_ != nullptr) _impl_.document_root_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AddAnnotationAuthorCommandArchive::clear_annotation_author() {
  if (_impl_.annotation_author_ != nullptr) _impl_.annotation_author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
AddAnnotationAuthorCommandArchive::AddAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.AddAnnotationAuthorCommandArchive)
}
AddAnnotationAuthorCommandArchive::AddAnnotationAuthorCommandArchive(const AddAnnotationAuthorCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AddAnnotationAuthorCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.document_root_){nullptr}
    , decltype(_impl_.annotation_author_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_document_root()) {
    _this->_impl_.document_root_ = new ::TSP::Reference(*from._impl_.document_root_);
  }
  if (from._internal_has_annotation_author()) {
    _this->_impl_.annotation_author_ = new ::TSP::Reference(*from._impl_.annotation_author_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.AddAnnotationAuthorCommandArchive)
}

inline void AddAnnotationAuthorCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.document_root_){nullptr}
    , decltype(_impl_.annotation_author_){nullptr}
  };
}

AddAnnotationAuthorCommandArchive::~AddAnnotationAuthorCommandArchive() {
  // @@protoc_insertion_point(destructor:TSK.AddAnnotationAuthorCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AddAnnotationAuthorCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.document_root_;
  if (this != internal_default_instance()) delete _impl_.annotation_author_;
}

void AddAnnotationAuthorCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AddAnnotationAuthorCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.AddAnnotationAuthorCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.document_root_ != nullptr);
      _impl_.document_root_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.annotation_author_ != nullptr);
      _impl_.annotation_author_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddAnnotationAuthorCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference document_root = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_document_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference annotation_author = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotation_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AddAnnotationAuthorCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.AddAnnotationAuthorCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference document_root = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::document_root(this),
        _Internal::document_root(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference annotation_author = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::annotation_author(this),
        _Internal::annotation_author(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.AddAnnotationAuthorCommandArchive)
  return target;
}

size_t AddAnnotationAuthorCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.AddAnnotationAuthorCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference document_root = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.document_root_);
    }

    // optional .TSP.Reference annotation_author = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.annotation_author_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddAnnotationAuthorCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AddAnnotationAuthorCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddAnnotationAuthorCommandArchive::GetClassData() const { return &_class_data_; }


void AddAnnotationAuthorCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AddAnnotationAuthorCommandArchive*>(&to_msg);
  auto& from = static_cast<const AddAnnotationAuthorCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.AddAnnotationAuthorCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_document_root()->::TSP::Reference::MergeFrom(
          from._internal_document_root());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_annotation_author()->::TSP::Reference::MergeFrom(
          from._internal_annotation_author());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddAnnotationAuthorCommandArchive::CopyFrom(const AddAnnotationAuthorCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.AddAnnotationAuthorCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddAnnotationAuthorCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_document_root()) {
    if (!_impl_.document_root_->IsInitialized()) return false;
  }
  if (_internal_has_annotation_author()) {
    if (!_impl_.annotation_author_->IsInitialized()) return false;
  }
  return true;
}

void AddAnnotationAuthorCommandArchive::InternalSwap(AddAnnotationAuthorCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AddAnnotationAuthorCommandArchive, _impl_.annotation_author_)
      + sizeof(AddAnnotationAuthorCommandArchive::_impl_.annotation_author_)
      - PROTOBUF_FIELD_OFFSET(AddAnnotationAuthorCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AddAnnotationAuthorCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[22]);
}

// ===================================================================

class SetAnnotationAuthorColorCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SetAnnotationAuthorColorCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const SetAnnotationAuthorColorCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& annotation_author(const SetAnnotationAuthorColorCommandArchive* msg);
  static void set_has_annotation_author(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Color& color(const SetAnnotationAuthorColorCommandArchive* msg);
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSK::CommandArchive&
SetAnnotationAuthorColorCommandArchive::_Internal::super(const SetAnnotationAuthorColorCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
SetAnnotationAuthorColorCommandArchive::_Internal::annotation_author(const SetAnnotationAuthorColorCommandArchive* msg) {
  return *msg->_impl_.annotation_author_;
}
const ::TSP::Color&
SetAnnotationAuthorColorCommandArchive::_Internal::color(const SetAnnotationAuthorColorCommandArchive* msg) {
  return *msg->_impl_.color_;
}
void SetAnnotationAuthorColorCommandArchive::clear_annotation_author() {
  if (_impl_.annotation_author_ != nullptr) _impl_.annotation_author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SetAnnotationAuthorColorCommandArchive::clear_color() {
  if (_impl_.color_ != nullptr) _impl_.color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SetAnnotationAuthorColorCommandArchive::SetAnnotationAuthorColorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSK.SetAnnotationAuthorColorCommandArchive)
}
SetAnnotationAuthorColorCommandArchive::SetAnnotationAuthorColorCommandArchive(const SetAnnotationAuthorColorCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetAnnotationAuthorColorCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.annotation_author_){nullptr}
    , decltype(_impl_.color_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_annotation_author()) {
    _this->_impl_.annotation_author_ = new ::TSP::Reference(*from._impl_.annotation_author_);
  }
  if (from._internal_has_color()) {
    _this->_impl_.color_ = new ::TSP::Color(*from._impl_.color_);
  }
  // @@protoc_insertion_point(copy_constructor:TSK.SetAnnotationAuthorColorCommandArchive)
}

inline void SetAnnotationAuthorColorCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.annotation_author_){nullptr}
    , decltype(_impl_.color_){nullptr}
  };
}

SetAnnotationAuthorColorCommandArchive::~SetAnnotationAuthorColorCommandArchive() {
  // @@protoc_insertion_point(destructor:TSK.SetAnnotationAuthorColorCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetAnnotationAuthorColorCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.annotation_author_;
  if (this != internal_default_instance()) delete _impl_.color_;
}

void SetAnnotationAuthorColorCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetAnnotationAuthorColorCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSK.SetAnnotationAuthorColorCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.annotation_author_ != nullptr);
      _impl_.annotation_author_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.color_ != nullptr);
      _impl_.color_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetAnnotationAuthorColorCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference annotation_author = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotation_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Color color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetAnnotationAuthorColorCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSK.SetAnnotationAuthorColorCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference annotation_author = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::annotation_author(this),
        _Internal::annotation_author(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Color color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::color(this),
        _Internal::color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSK.SetAnnotationAuthorColorCommandArchive)
  return target;
}

size_t SetAnnotationAuthorColorCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSK.SetAnnotationAuthorColorCommandArchive)
  size_t total_size = 0;

  // required .TSK.CommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TSP.Reference annotation_author = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.annotation_author_);
    }

    // optional .TSP.Color color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.color_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetAnnotationAuthorColorCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetAnnotationAuthorColorCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetAnnotationAuthorColorCommandArchive::GetClassData() const { return &_class_data_; }


void SetAnnotationAuthorColorCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetAnnotationAuthorColorCommandArchive*>(&to_msg);
  auto& from = static_cast<const SetAnnotationAuthorColorCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSK.SetAnnotationAuthorColorCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_annotation_author()->::TSP::Reference::MergeFrom(
          from._internal_annotation_author());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_color()->::TSP::Color::MergeFrom(
          from._internal_color());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetAnnotationAuthorColorCommandArchive::CopyFrom(const SetAnnotationAuthorColorCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSK.SetAnnotationAuthorColorCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetAnnotationAuthorColorCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_annotation_author()) {
    if (!_impl_.annotation_author_->IsInitialized()) return false;
  }
  if (_internal_has_color()) {
    if (!_impl_.color_->IsInitialized()) return false;
  }
  return true;
}

void SetAnnotationAuthorColorCommandArchive::InternalSwap(SetAnnotationAuthorColorCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetAnnotationAuthorColorCommandArchive, _impl_.color_)
      + sizeof(SetAnnotationAuthorColorCommandArchive::_impl_.color_)
      - PROTOBUF_FIELD_OFFSET(SetAnnotationAuthorColorCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetAnnotationAuthorColorCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSKArchives_2eproto_getter, &descriptor_table_TSKArchives_2eproto_once,
      file_level_metadata_TSKArchives_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSK
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSK::TreeNode*
Arena::CreateMaybeMessage< ::TSK::TreeNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::TreeNode >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandHistory*
Arena::CreateMaybeMessage< ::TSK::CommandHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::DocumentArchive*
Arena::CreateMaybeMessage< ::TSK::DocumentArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::DocumentArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::DocumentSupportArchive*
Arena::CreateMaybeMessage< ::TSK::DocumentSupportArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::DocumentSupportArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ViewStateArchive*
Arena::CreateMaybeMessage< ::TSK::ViewStateArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ViewStateArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandArchive*
Arena::CreateMaybeMessage< ::TSK::CommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandGroupArchive*
Arena::CreateMaybeMessage< ::TSK::CommandGroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandGroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandContainerArchive*
Arena::CreateMaybeMessage< ::TSK::CommandContainerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandContainerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ReplaceAllChildCommandArchive*
Arena::CreateMaybeMessage< ::TSK::ReplaceAllChildCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ReplaceAllChildCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ReplaceAllCommandArchive*
Arena::CreateMaybeMessage< ::TSK::ReplaceAllCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ReplaceAllCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ShuffleMappingArchive_Entry*
Arena::CreateMaybeMessage< ::TSK::ShuffleMappingArchive_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ShuffleMappingArchive_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ShuffleMappingArchive*
Arena::CreateMaybeMessage< ::TSK::ShuffleMappingArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ShuffleMappingArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::ProgressiveCommandGroupArchive*
Arena::CreateMaybeMessage< ::TSK::ProgressiveCommandGroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::ProgressiveCommandGroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandSelectionBehaviorHistoryArchive_Entry*
Arena::CreateMaybeMessage< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CommandSelectionBehaviorHistoryArchive*
Arena::CreateMaybeMessage< ::TSK::CommandSelectionBehaviorHistoryArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CommandSelectionBehaviorHistoryArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::UndoRedoStateCommandSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TSK::UndoRedoStateCommandSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::UndoRedoStateCommandSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::FormatStructArchive*
Arena::CreateMaybeMessage< ::TSK::FormatStructArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::FormatStructArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CustomFormatArchive_Condition*
Arena::CreateMaybeMessage< ::TSK::CustomFormatArchive_Condition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CustomFormatArchive_Condition >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::CustomFormatArchive*
Arena::CreateMaybeMessage< ::TSK::CustomFormatArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::CustomFormatArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::AnnotationAuthorArchive*
Arena::CreateMaybeMessage< ::TSK::AnnotationAuthorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::AnnotationAuthorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::DeprecatedChangeAuthorArchive*
Arena::CreateMaybeMessage< ::TSK::DeprecatedChangeAuthorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::DeprecatedChangeAuthorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::AnnotationAuthorStorageArchive*
Arena::CreateMaybeMessage< ::TSK::AnnotationAuthorStorageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::AnnotationAuthorStorageArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::AddAnnotationAuthorCommandArchive*
Arena::CreateMaybeMessage< ::TSK::AddAnnotationAuthorCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::AddAnnotationAuthorCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSK::SetAnnotationAuthorColorCommandArchive*
Arena::CreateMaybeMessage< ::TSK::SetAnnotationAuthorColorCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSK::SetAnnotationAuthorColorCommandArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
