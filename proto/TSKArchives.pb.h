// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSKArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSKArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSKArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSKArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSKArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSKArchives_2eproto;
namespace TSK {
class AddAnnotationAuthorCommandArchive;
struct AddAnnotationAuthorCommandArchiveDefaultTypeInternal;
extern AddAnnotationAuthorCommandArchiveDefaultTypeInternal _AddAnnotationAuthorCommandArchive_default_instance_;
class AnnotationAuthorArchive;
struct AnnotationAuthorArchiveDefaultTypeInternal;
extern AnnotationAuthorArchiveDefaultTypeInternal _AnnotationAuthorArchive_default_instance_;
class AnnotationAuthorStorageArchive;
struct AnnotationAuthorStorageArchiveDefaultTypeInternal;
extern AnnotationAuthorStorageArchiveDefaultTypeInternal _AnnotationAuthorStorageArchive_default_instance_;
class CommandArchive;
struct CommandArchiveDefaultTypeInternal;
extern CommandArchiveDefaultTypeInternal _CommandArchive_default_instance_;
class CommandContainerArchive;
struct CommandContainerArchiveDefaultTypeInternal;
extern CommandContainerArchiveDefaultTypeInternal _CommandContainerArchive_default_instance_;
class CommandGroupArchive;
struct CommandGroupArchiveDefaultTypeInternal;
extern CommandGroupArchiveDefaultTypeInternal _CommandGroupArchive_default_instance_;
class CommandHistory;
struct CommandHistoryDefaultTypeInternal;
extern CommandHistoryDefaultTypeInternal _CommandHistory_default_instance_;
class CommandSelectionBehaviorHistoryArchive;
struct CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal;
extern CommandSelectionBehaviorHistoryArchiveDefaultTypeInternal _CommandSelectionBehaviorHistoryArchive_default_instance_;
class CommandSelectionBehaviorHistoryArchive_Entry;
struct CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal;
extern CommandSelectionBehaviorHistoryArchive_EntryDefaultTypeInternal _CommandSelectionBehaviorHistoryArchive_Entry_default_instance_;
class CustomFormatArchive;
struct CustomFormatArchiveDefaultTypeInternal;
extern CustomFormatArchiveDefaultTypeInternal _CustomFormatArchive_default_instance_;
class CustomFormatArchive_Condition;
struct CustomFormatArchive_ConditionDefaultTypeInternal;
extern CustomFormatArchive_ConditionDefaultTypeInternal _CustomFormatArchive_Condition_default_instance_;
class DeprecatedChangeAuthorArchive;
struct DeprecatedChangeAuthorArchiveDefaultTypeInternal;
extern DeprecatedChangeAuthorArchiveDefaultTypeInternal _DeprecatedChangeAuthorArchive_default_instance_;
class DocumentArchive;
struct DocumentArchiveDefaultTypeInternal;
extern DocumentArchiveDefaultTypeInternal _DocumentArchive_default_instance_;
class DocumentSupportArchive;
struct DocumentSupportArchiveDefaultTypeInternal;
extern DocumentSupportArchiveDefaultTypeInternal _DocumentSupportArchive_default_instance_;
class FormatStructArchive;
struct FormatStructArchiveDefaultTypeInternal;
extern FormatStructArchiveDefaultTypeInternal _FormatStructArchive_default_instance_;
class ProgressiveCommandGroupArchive;
struct ProgressiveCommandGroupArchiveDefaultTypeInternal;
extern ProgressiveCommandGroupArchiveDefaultTypeInternal _ProgressiveCommandGroupArchive_default_instance_;
class ReplaceAllChildCommandArchive;
struct ReplaceAllChildCommandArchiveDefaultTypeInternal;
extern ReplaceAllChildCommandArchiveDefaultTypeInternal _ReplaceAllChildCommandArchive_default_instance_;
class ReplaceAllCommandArchive;
struct ReplaceAllCommandArchiveDefaultTypeInternal;
extern ReplaceAllCommandArchiveDefaultTypeInternal _ReplaceAllCommandArchive_default_instance_;
class SetAnnotationAuthorColorCommandArchive;
struct SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal;
extern SetAnnotationAuthorColorCommandArchiveDefaultTypeInternal _SetAnnotationAuthorColorCommandArchive_default_instance_;
class ShuffleMappingArchive;
struct ShuffleMappingArchiveDefaultTypeInternal;
extern ShuffleMappingArchiveDefaultTypeInternal _ShuffleMappingArchive_default_instance_;
class ShuffleMappingArchive_Entry;
struct ShuffleMappingArchive_EntryDefaultTypeInternal;
extern ShuffleMappingArchive_EntryDefaultTypeInternal _ShuffleMappingArchive_Entry_default_instance_;
class TreeNode;
struct TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
class UndoRedoStateCommandSelectionBehaviorArchive;
struct UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal;
extern UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal _UndoRedoStateCommandSelectionBehaviorArchive_default_instance_;
class ViewStateArchive;
struct ViewStateArchiveDefaultTypeInternal;
extern ViewStateArchiveDefaultTypeInternal _ViewStateArchive_default_instance_;
}  // namespace TSK
PROTOBUF_NAMESPACE_OPEN
template<> ::TSK::AddAnnotationAuthorCommandArchive* Arena::CreateMaybeMessage<::TSK::AddAnnotationAuthorCommandArchive>(Arena*);
template<> ::TSK::AnnotationAuthorArchive* Arena::CreateMaybeMessage<::TSK::AnnotationAuthorArchive>(Arena*);
template<> ::TSK::AnnotationAuthorStorageArchive* Arena::CreateMaybeMessage<::TSK::AnnotationAuthorStorageArchive>(Arena*);
template<> ::TSK::CommandArchive* Arena::CreateMaybeMessage<::TSK::CommandArchive>(Arena*);
template<> ::TSK::CommandContainerArchive* Arena::CreateMaybeMessage<::TSK::CommandContainerArchive>(Arena*);
template<> ::TSK::CommandGroupArchive* Arena::CreateMaybeMessage<::TSK::CommandGroupArchive>(Arena*);
template<> ::TSK::CommandHistory* Arena::CreateMaybeMessage<::TSK::CommandHistory>(Arena*);
template<> ::TSK::CommandSelectionBehaviorHistoryArchive* Arena::CreateMaybeMessage<::TSK::CommandSelectionBehaviorHistoryArchive>(Arena*);
template<> ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* Arena::CreateMaybeMessage<::TSK::CommandSelectionBehaviorHistoryArchive_Entry>(Arena*);
template<> ::TSK::CustomFormatArchive* Arena::CreateMaybeMessage<::TSK::CustomFormatArchive>(Arena*);
template<> ::TSK::CustomFormatArchive_Condition* Arena::CreateMaybeMessage<::TSK::CustomFormatArchive_Condition>(Arena*);
template<> ::TSK::DeprecatedChangeAuthorArchive* Arena::CreateMaybeMessage<::TSK::DeprecatedChangeAuthorArchive>(Arena*);
template<> ::TSK::DocumentArchive* Arena::CreateMaybeMessage<::TSK::DocumentArchive>(Arena*);
template<> ::TSK::DocumentSupportArchive* Arena::CreateMaybeMessage<::TSK::DocumentSupportArchive>(Arena*);
template<> ::TSK::FormatStructArchive* Arena::CreateMaybeMessage<::TSK::FormatStructArchive>(Arena*);
template<> ::TSK::ProgressiveCommandGroupArchive* Arena::CreateMaybeMessage<::TSK::ProgressiveCommandGroupArchive>(Arena*);
template<> ::TSK::ReplaceAllChildCommandArchive* Arena::CreateMaybeMessage<::TSK::ReplaceAllChildCommandArchive>(Arena*);
template<> ::TSK::ReplaceAllCommandArchive* Arena::CreateMaybeMessage<::TSK::ReplaceAllCommandArchive>(Arena*);
template<> ::TSK::SetAnnotationAuthorColorCommandArchive* Arena::CreateMaybeMessage<::TSK::SetAnnotationAuthorColorCommandArchive>(Arena*);
template<> ::TSK::ShuffleMappingArchive* Arena::CreateMaybeMessage<::TSK::ShuffleMappingArchive>(Arena*);
template<> ::TSK::ShuffleMappingArchive_Entry* Arena::CreateMaybeMessage<::TSK::ShuffleMappingArchive_Entry>(Arena*);
template<> ::TSK::TreeNode* Arena::CreateMaybeMessage<::TSK::TreeNode>(Arena*);
template<> ::TSK::UndoRedoStateCommandSelectionBehaviorArchive* Arena::CreateMaybeMessage<::TSK::UndoRedoStateCommandSelectionBehaviorArchive>(Arena*);
template<> ::TSK::ViewStateArchive* Arena::CreateMaybeMessage<::TSK::ViewStateArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSK {

// ===================================================================

class TreeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.TreeNode) */ {
 public:
  inline TreeNode() : TreeNode(nullptr) {}
  ~TreeNode() override;
  explicit PROTOBUF_CONSTEXPR TreeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreeNode(const TreeNode& from);
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TreeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TreeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TreeNode& from) {
    TreeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.TreeNode";
  }
  protected:
  explicit TreeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kNameFieldNumber = 1,
    kObjectFieldNumber = 3,
  };
  // repeated .TSP.Reference children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .TSP.Reference object = 3;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::TSP::Reference& object() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_object();
  ::TSP::Reference* mutable_object();
  void set_allocated_object(::TSP::Reference* object);
  private:
  const ::TSP::Reference& _internal_object() const;
  ::TSP::Reference* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::TSP::Reference* object);
  ::TSP::Reference* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:TSK.TreeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TSP::Reference* object_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandHistory) */ {
 public:
  inline CommandHistory() : CommandHistory(nullptr) {}
  ~CommandHistory() override;
  explicit PROTOBUF_CONSTEXPR CommandHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandHistory(const CommandHistory& from);
  CommandHistory(CommandHistory&& from) noexcept
    : CommandHistory() {
    *this = ::std::move(from);
  }

  inline CommandHistory& operator=(const CommandHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandHistory& operator=(CommandHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandHistory* internal_default_instance() {
    return reinterpret_cast<const CommandHistory*>(
               &_CommandHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommandHistory& a, CommandHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandHistory& from) {
    CommandHistory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandHistory";
  }
  protected:
  explicit CommandHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 2,
    kMarkedRedoCommandsFieldNumber = 3,
    kPendingPreflightCommandFieldNumber = 4,
    kUndoCountFieldNumber = 1,
    kFixedRadar13365177FieldNumber = 10,
  };
  // repeated .TSP.Reference commands = 2;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::TSP::Reference* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();
  private:
  const ::TSP::Reference& _internal_commands(int index) const;
  ::TSP::Reference* _internal_add_commands();
  public:
  const ::TSP::Reference& commands(int index) const;
  ::TSP::Reference* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      commands() const;

  // repeated .TSP.Reference marked_redo_commands = 3;
  int marked_redo_commands_size() const;
  private:
  int _internal_marked_redo_commands_size() const;
  public:
  void clear_marked_redo_commands();
  ::TSP::Reference* mutable_marked_redo_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_marked_redo_commands();
  private:
  const ::TSP::Reference& _internal_marked_redo_commands(int index) const;
  ::TSP::Reference* _internal_add_marked_redo_commands();
  public:
  const ::TSP::Reference& marked_redo_commands(int index) const;
  ::TSP::Reference* add_marked_redo_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      marked_redo_commands() const;

  // optional .TSP.Reference pending_preflight_command = 4;
  bool has_pending_preflight_command() const;
  private:
  bool _internal_has_pending_preflight_command() const;
  public:
  void clear_pending_preflight_command();
  const ::TSP::Reference& pending_preflight_command() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_pending_preflight_command();
  ::TSP::Reference* mutable_pending_preflight_command();
  void set_allocated_pending_preflight_command(::TSP::Reference* pending_preflight_command);
  private:
  const ::TSP::Reference& _internal_pending_preflight_command() const;
  ::TSP::Reference* _internal_mutable_pending_preflight_command();
  public:
  void unsafe_arena_set_allocated_pending_preflight_command(
      ::TSP::Reference* pending_preflight_command);
  ::TSP::Reference* unsafe_arena_release_pending_preflight_command();

  // required uint32 undo_count = 1;
  bool has_undo_count() const;
  private:
  bool _internal_has_undo_count() const;
  public:
  void clear_undo_count();
  uint32_t undo_count() const;
  void set_undo_count(uint32_t value);
  private:
  uint32_t _internal_undo_count() const;
  void _internal_set_undo_count(uint32_t value);
  public:

  // optional bool fixed_radar_13365177 = 10;
  bool has_fixed_radar_13365177() const;
  private:
  bool _internal_has_fixed_radar_13365177() const;
  public:
  void clear_fixed_radar_13365177();
  bool fixed_radar_13365177() const;
  void set_fixed_radar_13365177(bool value);
  private:
  bool _internal_fixed_radar_13365177() const;
  void _internal_set_fixed_radar_13365177(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.CommandHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > commands_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > marked_redo_commands_;
    ::TSP::Reference* pending_preflight_command_;
    uint32_t undo_count_;
    bool fixed_radar_13365177_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class DocumentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.DocumentArchive) */ {
 public:
  inline DocumentArchive() : DocumentArchive(nullptr) {}
  ~DocumentArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentArchive(const DocumentArchive& from);
  DocumentArchive(DocumentArchive&& from) noexcept
    : DocumentArchive() {
    *this = ::std::move(from);
  }

  inline DocumentArchive& operator=(const DocumentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentArchive& operator=(DocumentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentArchive*>(
               &_DocumentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DocumentArchive& a, DocumentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentArchive& from) {
    DocumentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.DocumentArchive";
  }
  protected:
  explicit DocumentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleIdentifierFieldNumber = 4,
    kAnnotationAuthorStorageFieldNumber = 7,
  };
  // optional string locale_identifier = 4;
  bool has_locale_identifier() const;
  private:
  bool _internal_has_locale_identifier() const;
  public:
  void clear_locale_identifier();
  const std::string& locale_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale_identifier();
  PROTOBUF_NODISCARD std::string* release_locale_identifier();
  void set_allocated_locale_identifier(std::string* locale_identifier);
  private:
  const std::string& _internal_locale_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale_identifier(const std::string& value);
  std::string* _internal_mutable_locale_identifier();
  public:

  // optional .TSP.Reference annotation_author_storage = 7;
  bool has_annotation_author_storage() const;
  private:
  bool _internal_has_annotation_author_storage() const;
  public:
  void clear_annotation_author_storage();
  const ::TSP::Reference& annotation_author_storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_annotation_author_storage();
  ::TSP::Reference* mutable_annotation_author_storage();
  void set_allocated_annotation_author_storage(::TSP::Reference* annotation_author_storage);
  private:
  const ::TSP::Reference& _internal_annotation_author_storage() const;
  ::TSP::Reference* _internal_mutable_annotation_author_storage();
  public:
  void unsafe_arena_set_allocated_annotation_author_storage(
      ::TSP::Reference* annotation_author_storage);
  ::TSP::Reference* unsafe_arena_release_annotation_author_storage();

  // @@protoc_insertion_point(class_scope:TSK.DocumentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_identifier_;
    ::TSP::Reference* annotation_author_storage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class DocumentSupportArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.DocumentSupportArchive) */ {
 public:
  inline DocumentSupportArchive() : DocumentSupportArchive(nullptr) {}
  ~DocumentSupportArchive() override;
  explicit PROTOBUF_CONSTEXPR DocumentSupportArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentSupportArchive(const DocumentSupportArchive& from);
  DocumentSupportArchive(DocumentSupportArchive&& from) noexcept
    : DocumentSupportArchive() {
    *this = ::std::move(from);
  }

  inline DocumentSupportArchive& operator=(const DocumentSupportArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentSupportArchive& operator=(DocumentSupportArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentSupportArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentSupportArchive* internal_default_instance() {
    return reinterpret_cast<const DocumentSupportArchive*>(
               &_DocumentSupportArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DocumentSupportArchive& a, DocumentSupportArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentSupportArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentSupportArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentSupportArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentSupportArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentSupportArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentSupportArchive& from) {
    DocumentSupportArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentSupportArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.DocumentSupportArchive";
  }
  protected:
  explicit DocumentSupportArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUndoActionStringFieldNumber = 6,
    kRedoActionStringFieldNumber = 7,
    kCommandHistoryFieldNumber = 1,
    kCommandSelectionBehaviorHistoryFieldNumber = 2,
    kWebStateFieldNumber = 8,
    kUndoCountFieldNumber = 4,
    kRedoCountFieldNumber = 5,
  };
  // optional string undo_action_string = 6;
  bool has_undo_action_string() const;
  private:
  bool _internal_has_undo_action_string() const;
  public:
  void clear_undo_action_string();
  const std::string& undo_action_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_undo_action_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_undo_action_string();
  PROTOBUF_NODISCARD std::string* release_undo_action_string();
  void set_allocated_undo_action_string(std::string* undo_action_string);
  private:
  const std::string& _internal_undo_action_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_undo_action_string(const std::string& value);
  std::string* _internal_mutable_undo_action_string();
  public:

  // optional string redo_action_string = 7;
  bool has_redo_action_string() const;
  private:
  bool _internal_has_redo_action_string() const;
  public:
  void clear_redo_action_string();
  const std::string& redo_action_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redo_action_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redo_action_string();
  PROTOBUF_NODISCARD std::string* release_redo_action_string();
  void set_allocated_redo_action_string(std::string* redo_action_string);
  private:
  const std::string& _internal_redo_action_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redo_action_string(const std::string& value);
  std::string* _internal_mutable_redo_action_string();
  public:

  // optional .TSP.Reference command_history = 1;
  bool has_command_history() const;
  private:
  bool _internal_has_command_history() const;
  public:
  void clear_command_history();
  const ::TSP::Reference& command_history() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_command_history();
  ::TSP::Reference* mutable_command_history();
  void set_allocated_command_history(::TSP::Reference* command_history);
  private:
  const ::TSP::Reference& _internal_command_history() const;
  ::TSP::Reference* _internal_mutable_command_history();
  public:
  void unsafe_arena_set_allocated_command_history(
      ::TSP::Reference* command_history);
  ::TSP::Reference* unsafe_arena_release_command_history();

  // optional .TSP.Reference command_selection_behavior_history = 2;
  bool has_command_selection_behavior_history() const;
  private:
  bool _internal_has_command_selection_behavior_history() const;
  public:
  void clear_command_selection_behavior_history();
  const ::TSP::Reference& command_selection_behavior_history() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_command_selection_behavior_history();
  ::TSP::Reference* mutable_command_selection_behavior_history();
  void set_allocated_command_selection_behavior_history(::TSP::Reference* command_selection_behavior_history);
  private:
  const ::TSP::Reference& _internal_command_selection_behavior_history() const;
  ::TSP::Reference* _internal_mutable_command_selection_behavior_history();
  public:
  void unsafe_arena_set_allocated_command_selection_behavior_history(
      ::TSP::Reference* command_selection_behavior_history);
  ::TSP::Reference* unsafe_arena_release_command_selection_behavior_history();

  // optional .TSP.Reference web_state = 8;
  bool has_web_state() const;
  private:
  bool _internal_has_web_state() const;
  public:
  void clear_web_state();
  const ::TSP::Reference& web_state() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_web_state();
  ::TSP::Reference* mutable_web_state();
  void set_allocated_web_state(::TSP::Reference* web_state);
  private:
  const ::TSP::Reference& _internal_web_state() const;
  ::TSP::Reference* _internal_mutable_web_state();
  public:
  void unsafe_arena_set_allocated_web_state(
      ::TSP::Reference* web_state);
  ::TSP::Reference* unsafe_arena_release_web_state();

  // optional uint32 undo_count = 4;
  bool has_undo_count() const;
  private:
  bool _internal_has_undo_count() const;
  public:
  void clear_undo_count();
  uint32_t undo_count() const;
  void set_undo_count(uint32_t value);
  private:
  uint32_t _internal_undo_count() const;
  void _internal_set_undo_count(uint32_t value);
  public:

  // optional uint32 redo_count = 5;
  bool has_redo_count() const;
  private:
  bool _internal_has_redo_count() const;
  public:
  void clear_redo_count();
  uint32_t redo_count() const;
  void set_redo_count(uint32_t value);
  private:
  uint32_t _internal_redo_count() const;
  void _internal_set_redo_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.DocumentSupportArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr undo_action_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redo_action_string_;
    ::TSP::Reference* command_history_;
    ::TSP::Reference* command_selection_behavior_history_;
    ::TSP::Reference* web_state_;
    uint32_t undo_count_;
    uint32_t redo_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ViewStateArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ViewStateArchive) */ {
 public:
  inline ViewStateArchive() : ViewStateArchive(nullptr) {}
  ~ViewStateArchive() override;
  explicit PROTOBUF_CONSTEXPR ViewStateArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewStateArchive(const ViewStateArchive& from);
  ViewStateArchive(ViewStateArchive&& from) noexcept
    : ViewStateArchive() {
    *this = ::std::move(from);
  }

  inline ViewStateArchive& operator=(const ViewStateArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewStateArchive& operator=(ViewStateArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViewStateArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewStateArchive* internal_default_instance() {
    return reinterpret_cast<const ViewStateArchive*>(
               &_ViewStateArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ViewStateArchive& a, ViewStateArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ViewStateArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewStateArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewStateArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewStateArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViewStateArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ViewStateArchive& from) {
    ViewStateArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewStateArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ViewStateArchive";
  }
  protected:
  explicit ViewStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewStateRootFieldNumber = 1,
  };
  // required .TSP.Reference view_state_root = 1;
  bool has_view_state_root() const;
  private:
  bool _internal_has_view_state_root() const;
  public:
  void clear_view_state_root();
  const ::TSP::Reference& view_state_root() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_view_state_root();
  ::TSP::Reference* mutable_view_state_root();
  void set_allocated_view_state_root(::TSP::Reference* view_state_root);
  private:
  const ::TSP::Reference& _internal_view_state_root() const;
  ::TSP::Reference* _internal_mutable_view_state_root();
  public:
  void unsafe_arena_set_allocated_view_state_root(
      ::TSP::Reference* view_state_root);
  ::TSP::Reference* unsafe_arena_release_view_state_root();

  // @@protoc_insertion_point(class_scope:TSK.ViewStateArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* view_state_root_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandArchive) */ {
 public:
  inline CommandArchive() : CommandArchive(nullptr) {}
  ~CommandArchive() override;
  explicit PROTOBUF_CONSTEXPR CommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandArchive(const CommandArchive& from);
  CommandArchive(CommandArchive&& from) noexcept
    : CommandArchive() {
    *this = ::std::move(from);
  }

  inline CommandArchive& operator=(const CommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandArchive& operator=(CommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandArchive* internal_default_instance() {
    return reinterpret_cast<const CommandArchive*>(
               &_CommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CommandArchive& a, CommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandArchive& from) {
    CommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandArchive";
  }
  protected:
  explicit CommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUndoRedoStateFieldNumber = 1,
    kUndoCollectionFieldNumber = 2,
  };
  // optional .TSP.Reference undoRedoState = 1;
  bool has_undoredostate() const;
  private:
  bool _internal_has_undoredostate() const;
  public:
  void clear_undoredostate();
  const ::TSP::Reference& undoredostate() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_undoredostate();
  ::TSP::Reference* mutable_undoredostate();
  void set_allocated_undoredostate(::TSP::Reference* undoredostate);
  private:
  const ::TSP::Reference& _internal_undoredostate() const;
  ::TSP::Reference* _internal_mutable_undoredostate();
  public:
  void unsafe_arena_set_allocated_undoredostate(
      ::TSP::Reference* undoredostate);
  ::TSP::Reference* unsafe_arena_release_undoredostate();

  // optional .TSP.Reference undoCollection = 2;
  bool has_undocollection() const;
  private:
  bool _internal_has_undocollection() const;
  public:
  void clear_undocollection();
  const ::TSP::Reference& undocollection() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_undocollection();
  ::TSP::Reference* mutable_undocollection();
  void set_allocated_undocollection(::TSP::Reference* undocollection);
  private:
  const ::TSP::Reference& _internal_undocollection() const;
  ::TSP::Reference* _internal_mutable_undocollection();
  public:
  void unsafe_arena_set_allocated_undocollection(
      ::TSP::Reference* undocollection);
  ::TSP::Reference* unsafe_arena_release_undocollection();

  // @@protoc_insertion_point(class_scope:TSK.CommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* undoredostate_;
    ::TSP::Reference* undocollection_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandGroupArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandGroupArchive) */ {
 public:
  inline CommandGroupArchive() : CommandGroupArchive(nullptr) {}
  ~CommandGroupArchive() override;
  explicit PROTOBUF_CONSTEXPR CommandGroupArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandGroupArchive(const CommandGroupArchive& from);
  CommandGroupArchive(CommandGroupArchive&& from) noexcept
    : CommandGroupArchive() {
    *this = ::std::move(from);
  }

  inline CommandGroupArchive& operator=(const CommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandGroupArchive& operator=(CommandGroupArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandGroupArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandGroupArchive* internal_default_instance() {
    return reinterpret_cast<const CommandGroupArchive*>(
               &_CommandGroupArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CommandGroupArchive& a, CommandGroupArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandGroupArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandGroupArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandGroupArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandGroupArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandGroupArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandGroupArchive& from) {
    CommandGroupArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandGroupArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandGroupArchive";
  }
  protected:
  explicit CommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 2,
    kSuperFieldNumber = 1,
    kProcessResultsFieldNumber = 3,
  };
  // repeated .TSP.Reference commands = 2;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::TSP::Reference* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();
  private:
  const ::TSP::Reference& _internal_commands(int index) const;
  ::TSP::Reference* _internal_add_commands();
  public:
  const ::TSP::Reference& commands(int index) const;
  ::TSP::Reference* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      commands() const;

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.IndexSet process_results = 3;
  bool has_process_results() const;
  private:
  bool _internal_has_process_results() const;
  public:
  void clear_process_results();
  const ::TSP::IndexSet& process_results() const;
  PROTOBUF_NODISCARD ::TSP::IndexSet* release_process_results();
  ::TSP::IndexSet* mutable_process_results();
  void set_allocated_process_results(::TSP::IndexSet* process_results);
  private:
  const ::TSP::IndexSet& _internal_process_results() const;
  ::TSP::IndexSet* _internal_mutable_process_results();
  public:
  void unsafe_arena_set_allocated_process_results(
      ::TSP::IndexSet* process_results);
  ::TSP::IndexSet* unsafe_arena_release_process_results();

  // @@protoc_insertion_point(class_scope:TSK.CommandGroupArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > commands_;
    ::TSK::CommandArchive* super_;
    ::TSP::IndexSet* process_results_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandContainerArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandContainerArchive) */ {
 public:
  inline CommandContainerArchive() : CommandContainerArchive(nullptr) {}
  ~CommandContainerArchive() override;
  explicit PROTOBUF_CONSTEXPR CommandContainerArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandContainerArchive(const CommandContainerArchive& from);
  CommandContainerArchive(CommandContainerArchive&& from) noexcept
    : CommandContainerArchive() {
    *this = ::std::move(from);
  }

  inline CommandContainerArchive& operator=(const CommandContainerArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandContainerArchive& operator=(CommandContainerArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandContainerArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandContainerArchive* internal_default_instance() {
    return reinterpret_cast<const CommandContainerArchive*>(
               &_CommandContainerArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CommandContainerArchive& a, CommandContainerArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandContainerArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandContainerArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandContainerArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandContainerArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandContainerArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandContainerArchive& from) {
    CommandContainerArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandContainerArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandContainerArchive";
  }
  protected:
  explicit CommandContainerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 1,
  };
  // repeated .TSP.Reference commands = 1;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::TSP::Reference* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();
  private:
  const ::TSP::Reference& _internal_commands(int index) const;
  ::TSP::Reference* _internal_add_commands();
  public:
  const ::TSP::Reference& commands(int index) const;
  ::TSP::Reference* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      commands() const;

  // @@protoc_insertion_point(class_scope:TSK.CommandContainerArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > commands_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceAllChildCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ReplaceAllChildCommandArchive) */ {
 public:
  inline ReplaceAllChildCommandArchive() : ReplaceAllChildCommandArchive(nullptr) {}
  ~ReplaceAllChildCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ReplaceAllChildCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceAllChildCommandArchive(const ReplaceAllChildCommandArchive& from);
  ReplaceAllChildCommandArchive(ReplaceAllChildCommandArchive&& from) noexcept
    : ReplaceAllChildCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceAllChildCommandArchive& operator=(const ReplaceAllChildCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceAllChildCommandArchive& operator=(ReplaceAllChildCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceAllChildCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceAllChildCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceAllChildCommandArchive*>(
               &_ReplaceAllChildCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReplaceAllChildCommandArchive& a, ReplaceAllChildCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceAllChildCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceAllChildCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaceAllChildCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaceAllChildCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaceAllChildCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaceAllChildCommandArchive& from) {
    ReplaceAllChildCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceAllChildCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ReplaceAllChildCommandArchive";
  }
  protected:
  explicit ReplaceAllChildCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSK.ReplaceAllChildCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ReplaceAllCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ReplaceAllCommandArchive) */ {
 public:
  inline ReplaceAllCommandArchive() : ReplaceAllCommandArchive(nullptr) {}
  ~ReplaceAllCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR ReplaceAllCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplaceAllCommandArchive(const ReplaceAllCommandArchive& from);
  ReplaceAllCommandArchive(ReplaceAllCommandArchive&& from) noexcept
    : ReplaceAllCommandArchive() {
    *this = ::std::move(from);
  }

  inline ReplaceAllCommandArchive& operator=(const ReplaceAllCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplaceAllCommandArchive& operator=(ReplaceAllCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplaceAllCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplaceAllCommandArchive* internal_default_instance() {
    return reinterpret_cast<const ReplaceAllCommandArchive*>(
               &_ReplaceAllCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReplaceAllCommandArchive& a, ReplaceAllCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplaceAllCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplaceAllCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplaceAllCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplaceAllCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplaceAllCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplaceAllCommandArchive& from) {
    ReplaceAllCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceAllCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ReplaceAllCommandArchive";
  }
  protected:
  explicit ReplaceAllCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 2,
    kFindStringFieldNumber = 3,
    kReplaceStringFieldNumber = 4,
    kSuperFieldNumber = 1,
    kOptionsFieldNumber = 5,
  };
  // repeated .TSP.Reference commands = 2;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::TSP::Reference* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_commands();
  private:
  const ::TSP::Reference& _internal_commands(int index) const;
  ::TSP::Reference* _internal_add_commands();
  public:
  const ::TSP::Reference& commands(int index) const;
  ::TSP::Reference* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      commands() const;

  // required string find_string = 3;
  bool has_find_string() const;
  private:
  bool _internal_has_find_string() const;
  public:
  void clear_find_string();
  const std::string& find_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_find_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_find_string();
  PROTOBUF_NODISCARD std::string* release_find_string();
  void set_allocated_find_string(std::string* find_string);
  private:
  const std::string& _internal_find_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_find_string(const std::string& value);
  std::string* _internal_mutable_find_string();
  public:

  // required string replace_string = 4;
  bool has_replace_string() const;
  private:
  bool _internal_has_replace_string() const;
  public:
  void clear_replace_string();
  const std::string& replace_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replace_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replace_string();
  PROTOBUF_NODISCARD std::string* release_replace_string();
  void set_allocated_replace_string(std::string* replace_string);
  private:
  const std::string& _internal_replace_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replace_string(const std::string& value);
  std::string* _internal_mutable_replace_string();
  public:

  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // required uint32 options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  uint32_t options() const;
  void set_options(uint32_t value);
  private:
  uint32_t _internal_options() const;
  void _internal_set_options(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.ReplaceAllCommandArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > commands_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr find_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replace_string_;
    ::TSK::CommandArchive* super_;
    uint32_t options_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ShuffleMappingArchive_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ShuffleMappingArchive.Entry) */ {
 public:
  inline ShuffleMappingArchive_Entry() : ShuffleMappingArchive_Entry(nullptr) {}
  ~ShuffleMappingArchive_Entry() override;
  explicit PROTOBUF_CONSTEXPR ShuffleMappingArchive_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShuffleMappingArchive_Entry(const ShuffleMappingArchive_Entry& from);
  ShuffleMappingArchive_Entry(ShuffleMappingArchive_Entry&& from) noexcept
    : ShuffleMappingArchive_Entry() {
    *this = ::std::move(from);
  }

  inline ShuffleMappingArchive_Entry& operator=(const ShuffleMappingArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShuffleMappingArchive_Entry& operator=(ShuffleMappingArchive_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShuffleMappingArchive_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShuffleMappingArchive_Entry* internal_default_instance() {
    return reinterpret_cast<const ShuffleMappingArchive_Entry*>(
               &_ShuffleMappingArchive_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ShuffleMappingArchive_Entry& a, ShuffleMappingArchive_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ShuffleMappingArchive_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShuffleMappingArchive_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShuffleMappingArchive_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShuffleMappingArchive_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShuffleMappingArchive_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShuffleMappingArchive_Entry& from) {
    ShuffleMappingArchive_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShuffleMappingArchive_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ShuffleMappingArchive.Entry";
  }
  protected:
  explicit ShuffleMappingArchive_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // required uint32 from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  uint32_t from() const;
  void set_from(uint32_t value);
  private:
  uint32_t _internal_from() const;
  void _internal_set_from(uint32_t value);
  public:

  // required uint32 to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  uint32_t to() const;
  void set_to(uint32_t value);
  private:
  uint32_t _internal_to() const;
  void _internal_set_to(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.ShuffleMappingArchive.Entry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t from_;
    uint32_t to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ShuffleMappingArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ShuffleMappingArchive) */ {
 public:
  inline ShuffleMappingArchive() : ShuffleMappingArchive(nullptr) {}
  ~ShuffleMappingArchive() override;
  explicit PROTOBUF_CONSTEXPR ShuffleMappingArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShuffleMappingArchive(const ShuffleMappingArchive& from);
  ShuffleMappingArchive(ShuffleMappingArchive&& from) noexcept
    : ShuffleMappingArchive() {
    *this = ::std::move(from);
  }

  inline ShuffleMappingArchive& operator=(const ShuffleMappingArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShuffleMappingArchive& operator=(ShuffleMappingArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShuffleMappingArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShuffleMappingArchive* internal_default_instance() {
    return reinterpret_cast<const ShuffleMappingArchive*>(
               &_ShuffleMappingArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShuffleMappingArchive& a, ShuffleMappingArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ShuffleMappingArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShuffleMappingArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShuffleMappingArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShuffleMappingArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShuffleMappingArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShuffleMappingArchive& from) {
    ShuffleMappingArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShuffleMappingArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ShuffleMappingArchive";
  }
  protected:
  explicit ShuffleMappingArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ShuffleMappingArchive_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kStartIndexFieldNumber = 1,
    kEndIndexFieldNumber = 2,
    kIsMoveOperationFieldNumber = 5,
    kFirstMovedIndexFieldNumber = 6,
    kDestinationIndexForMoveFieldNumber = 7,
    kNumberOfIndicesMovedFieldNumber = 8,
    kIsVerticalFieldNumber = 4,
  };
  // repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::TSK::ShuffleMappingArchive_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >*
      mutable_entries();
  private:
  const ::TSK::ShuffleMappingArchive_Entry& _internal_entries(int index) const;
  ::TSK::ShuffleMappingArchive_Entry* _internal_add_entries();
  public:
  const ::TSK::ShuffleMappingArchive_Entry& entries(int index) const;
  ::TSK::ShuffleMappingArchive_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >&
      entries() const;

  // required uint32 start_index = 1;
  bool has_start_index() const;
  private:
  bool _internal_has_start_index() const;
  public:
  void clear_start_index();
  uint32_t start_index() const;
  void set_start_index(uint32_t value);
  private:
  uint32_t _internal_start_index() const;
  void _internal_set_start_index(uint32_t value);
  public:

  // required uint32 end_index = 2;
  bool has_end_index() const;
  private:
  bool _internal_has_end_index() const;
  public:
  void clear_end_index();
  uint32_t end_index() const;
  void set_end_index(uint32_t value);
  private:
  uint32_t _internal_end_index() const;
  void _internal_set_end_index(uint32_t value);
  public:

  // optional bool is_move_operation = 5 [default = false];
  bool has_is_move_operation() const;
  private:
  bool _internal_has_is_move_operation() const;
  public:
  void clear_is_move_operation();
  bool is_move_operation() const;
  void set_is_move_operation(bool value);
  private:
  bool _internal_is_move_operation() const;
  void _internal_set_is_move_operation(bool value);
  public:

  // optional uint32 first_moved_index = 6 [default = 0];
  bool has_first_moved_index() const;
  private:
  bool _internal_has_first_moved_index() const;
  public:
  void clear_first_moved_index();
  uint32_t first_moved_index() const;
  void set_first_moved_index(uint32_t value);
  private:
  uint32_t _internal_first_moved_index() const;
  void _internal_set_first_moved_index(uint32_t value);
  public:

  // optional uint32 destination_index_for_move = 7 [default = 0];
  bool has_destination_index_for_move() const;
  private:
  bool _internal_has_destination_index_for_move() const;
  public:
  void clear_destination_index_for_move();
  uint32_t destination_index_for_move() const;
  void set_destination_index_for_move(uint32_t value);
  private:
  uint32_t _internal_destination_index_for_move() const;
  void _internal_set_destination_index_for_move(uint32_t value);
  public:

  // optional uint32 number_of_indices_moved = 8 [default = 0];
  bool has_number_of_indices_moved() const;
  private:
  bool _internal_has_number_of_indices_moved() const;
  public:
  void clear_number_of_indices_moved();
  uint32_t number_of_indices_moved() const;
  void set_number_of_indices_moved(uint32_t value);
  private:
  uint32_t _internal_number_of_indices_moved() const;
  void _internal_set_number_of_indices_moved(uint32_t value);
  public:

  // optional bool is_vertical = 4 [default = true];
  bool has_is_vertical() const;
  private:
  bool _internal_has_is_vertical() const;
  public:
  void clear_is_vertical();
  bool is_vertical() const;
  void set_is_vertical(bool value);
  private:
  bool _internal_is_vertical() const;
  void _internal_set_is_vertical(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.ShuffleMappingArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry > entries_;
    uint32_t start_index_;
    uint32_t end_index_;
    bool is_move_operation_;
    uint32_t first_moved_index_;
    uint32_t destination_index_for_move_;
    uint32_t number_of_indices_moved_;
    bool is_vertical_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class ProgressiveCommandGroupArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.ProgressiveCommandGroupArchive) */ {
 public:
  inline ProgressiveCommandGroupArchive() : ProgressiveCommandGroupArchive(nullptr) {}
  ~ProgressiveCommandGroupArchive() override;
  explicit PROTOBUF_CONSTEXPR ProgressiveCommandGroupArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProgressiveCommandGroupArchive(const ProgressiveCommandGroupArchive& from);
  ProgressiveCommandGroupArchive(ProgressiveCommandGroupArchive&& from) noexcept
    : ProgressiveCommandGroupArchive() {
    *this = ::std::move(from);
  }

  inline ProgressiveCommandGroupArchive& operator=(const ProgressiveCommandGroupArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProgressiveCommandGroupArchive& operator=(ProgressiveCommandGroupArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProgressiveCommandGroupArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProgressiveCommandGroupArchive* internal_default_instance() {
    return reinterpret_cast<const ProgressiveCommandGroupArchive*>(
               &_ProgressiveCommandGroupArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ProgressiveCommandGroupArchive& a, ProgressiveCommandGroupArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ProgressiveCommandGroupArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProgressiveCommandGroupArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProgressiveCommandGroupArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProgressiveCommandGroupArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProgressiveCommandGroupArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProgressiveCommandGroupArchive& from) {
    ProgressiveCommandGroupArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProgressiveCommandGroupArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.ProgressiveCommandGroupArchive";
  }
  protected:
  explicit ProgressiveCommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSK.CommandGroupArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandGroupArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandGroupArchive* release_super();
  ::TSK::CommandGroupArchive* mutable_super();
  void set_allocated_super(::TSK::CommandGroupArchive* super);
  private:
  const ::TSK::CommandGroupArchive& _internal_super() const;
  ::TSK::CommandGroupArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandGroupArchive* super);
  ::TSK::CommandGroupArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TSK.ProgressiveCommandGroupArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandGroupArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandSelectionBehaviorHistoryArchive_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandSelectionBehaviorHistoryArchive.Entry) */ {
 public:
  inline CommandSelectionBehaviorHistoryArchive_Entry() : CommandSelectionBehaviorHistoryArchive_Entry(nullptr) {}
  ~CommandSelectionBehaviorHistoryArchive_Entry() override;
  explicit PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchive_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSelectionBehaviorHistoryArchive_Entry(const CommandSelectionBehaviorHistoryArchive_Entry& from);
  CommandSelectionBehaviorHistoryArchive_Entry(CommandSelectionBehaviorHistoryArchive_Entry&& from) noexcept
    : CommandSelectionBehaviorHistoryArchive_Entry() {
    *this = ::std::move(from);
  }

  inline CommandSelectionBehaviorHistoryArchive_Entry& operator=(const CommandSelectionBehaviorHistoryArchive_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSelectionBehaviorHistoryArchive_Entry& operator=(CommandSelectionBehaviorHistoryArchive_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandSelectionBehaviorHistoryArchive_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSelectionBehaviorHistoryArchive_Entry* internal_default_instance() {
    return reinterpret_cast<const CommandSelectionBehaviorHistoryArchive_Entry*>(
               &_CommandSelectionBehaviorHistoryArchive_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CommandSelectionBehaviorHistoryArchive_Entry& a, CommandSelectionBehaviorHistoryArchive_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSelectionBehaviorHistoryArchive_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSelectionBehaviorHistoryArchive_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSelectionBehaviorHistoryArchive_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSelectionBehaviorHistoryArchive_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandSelectionBehaviorHistoryArchive_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandSelectionBehaviorHistoryArchive_Entry& from) {
    CommandSelectionBehaviorHistoryArchive_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandSelectionBehaviorHistoryArchive_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandSelectionBehaviorHistoryArchive.Entry";
  }
  protected:
  explicit CommandSelectionBehaviorHistoryArchive_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kCommandSelectionBehaviorFieldNumber = 2,
  };
  // required .TSP.Reference command = 1;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::TSP::Reference& command() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_command();
  ::TSP::Reference* mutable_command();
  void set_allocated_command(::TSP::Reference* command);
  private:
  const ::TSP::Reference& _internal_command() const;
  ::TSP::Reference* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::TSP::Reference* command);
  ::TSP::Reference* unsafe_arena_release_command();

  // required .TSP.Reference command_selection_behavior = 2;
  bool has_command_selection_behavior() const;
  private:
  bool _internal_has_command_selection_behavior() const;
  public:
  void clear_command_selection_behavior();
  const ::TSP::Reference& command_selection_behavior() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_command_selection_behavior();
  ::TSP::Reference* mutable_command_selection_behavior();
  void set_allocated_command_selection_behavior(::TSP::Reference* command_selection_behavior);
  private:
  const ::TSP::Reference& _internal_command_selection_behavior() const;
  ::TSP::Reference* _internal_mutable_command_selection_behavior();
  public:
  void unsafe_arena_set_allocated_command_selection_behavior(
      ::TSP::Reference* command_selection_behavior);
  ::TSP::Reference* unsafe_arena_release_command_selection_behavior();

  // @@protoc_insertion_point(class_scope:TSK.CommandSelectionBehaviorHistoryArchive.Entry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* command_;
    ::TSP::Reference* command_selection_behavior_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CommandSelectionBehaviorHistoryArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CommandSelectionBehaviorHistoryArchive) */ {
 public:
  inline CommandSelectionBehaviorHistoryArchive() : CommandSelectionBehaviorHistoryArchive(nullptr) {}
  ~CommandSelectionBehaviorHistoryArchive() override;
  explicit PROTOBUF_CONSTEXPR CommandSelectionBehaviorHistoryArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommandSelectionBehaviorHistoryArchive(const CommandSelectionBehaviorHistoryArchive& from);
  CommandSelectionBehaviorHistoryArchive(CommandSelectionBehaviorHistoryArchive&& from) noexcept
    : CommandSelectionBehaviorHistoryArchive() {
    *this = ::std::move(from);
  }

  inline CommandSelectionBehaviorHistoryArchive& operator=(const CommandSelectionBehaviorHistoryArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSelectionBehaviorHistoryArchive& operator=(CommandSelectionBehaviorHistoryArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommandSelectionBehaviorHistoryArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommandSelectionBehaviorHistoryArchive* internal_default_instance() {
    return reinterpret_cast<const CommandSelectionBehaviorHistoryArchive*>(
               &_CommandSelectionBehaviorHistoryArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CommandSelectionBehaviorHistoryArchive& a, CommandSelectionBehaviorHistoryArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSelectionBehaviorHistoryArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSelectionBehaviorHistoryArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommandSelectionBehaviorHistoryArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommandSelectionBehaviorHistoryArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommandSelectionBehaviorHistoryArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommandSelectionBehaviorHistoryArchive& from) {
    CommandSelectionBehaviorHistoryArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandSelectionBehaviorHistoryArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CommandSelectionBehaviorHistoryArchive";
  }
  protected:
  explicit CommandSelectionBehaviorHistoryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CommandSelectionBehaviorHistoryArchive_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >*
      mutable_entries();
  private:
  const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& _internal_entries(int index) const;
  ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* _internal_add_entries();
  public:
  const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& entries(int index) const;
  ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:TSK.CommandSelectionBehaviorHistoryArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class UndoRedoStateCommandSelectionBehaviorArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.UndoRedoStateCommandSelectionBehaviorArchive) */ {
 public:
  inline UndoRedoStateCommandSelectionBehaviorArchive() : UndoRedoStateCommandSelectionBehaviorArchive(nullptr) {}
  ~UndoRedoStateCommandSelectionBehaviorArchive() override;
  explicit PROTOBUF_CONSTEXPR UndoRedoStateCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndoRedoStateCommandSelectionBehaviorArchive(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  UndoRedoStateCommandSelectionBehaviorArchive(UndoRedoStateCommandSelectionBehaviorArchive&& from) noexcept
    : UndoRedoStateCommandSelectionBehaviorArchive() {
    *this = ::std::move(from);
  }

  inline UndoRedoStateCommandSelectionBehaviorArchive& operator=(const UndoRedoStateCommandSelectionBehaviorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndoRedoStateCommandSelectionBehaviorArchive& operator=(UndoRedoStateCommandSelectionBehaviorArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndoRedoStateCommandSelectionBehaviorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndoRedoStateCommandSelectionBehaviorArchive* internal_default_instance() {
    return reinterpret_cast<const UndoRedoStateCommandSelectionBehaviorArchive*>(
               &_UndoRedoStateCommandSelectionBehaviorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UndoRedoStateCommandSelectionBehaviorArchive& a, UndoRedoStateCommandSelectionBehaviorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(UndoRedoStateCommandSelectionBehaviorArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndoRedoStateCommandSelectionBehaviorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndoRedoStateCommandSelectionBehaviorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndoRedoStateCommandSelectionBehaviorArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndoRedoStateCommandSelectionBehaviorArchive& from) {
    UndoRedoStateCommandSelectionBehaviorArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndoRedoStateCommandSelectionBehaviorArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.UndoRedoStateCommandSelectionBehaviorArchive";
  }
  protected:
  explicit UndoRedoStateCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUndoRedoStateFieldNumber = 2,
  };
  // optional .TSP.Reference undo_redo_state = 2;
  bool has_undo_redo_state() const;
  private:
  bool _internal_has_undo_redo_state() const;
  public:
  void clear_undo_redo_state();
  const ::TSP::Reference& undo_redo_state() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_undo_redo_state();
  ::TSP::Reference* mutable_undo_redo_state();
  void set_allocated_undo_redo_state(::TSP::Reference* undo_redo_state);
  private:
  const ::TSP::Reference& _internal_undo_redo_state() const;
  ::TSP::Reference* _internal_mutable_undo_redo_state();
  public:
  void unsafe_arena_set_allocated_undo_redo_state(
      ::TSP::Reference* undo_redo_state);
  ::TSP::Reference* unsafe_arena_release_undo_redo_state();

  // @@protoc_insertion_point(class_scope:TSK.UndoRedoStateCommandSelectionBehaviorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* undo_redo_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class FormatStructArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.FormatStructArchive) */ {
 public:
  inline FormatStructArchive() : FormatStructArchive(nullptr) {}
  ~FormatStructArchive() override;
  explicit PROTOBUF_CONSTEXPR FormatStructArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatStructArchive(const FormatStructArchive& from);
  FormatStructArchive(FormatStructArchive&& from) noexcept
    : FormatStructArchive() {
    *this = ::std::move(from);
  }

  inline FormatStructArchive& operator=(const FormatStructArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatStructArchive& operator=(FormatStructArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatStructArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatStructArchive* internal_default_instance() {
    return reinterpret_cast<const FormatStructArchive*>(
               &_FormatStructArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FormatStructArchive& a, FormatStructArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatStructArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatStructArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatStructArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatStructArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormatStructArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormatStructArchive& from) {
    FormatStructArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatStructArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.FormatStructArchive";
  }
  protected:
  explicit FormatStructArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterstitialStringsFieldNumber = 32,
    kCurrencyCodeFieldNumber = 3,
    kDateTimeFormatFieldNumber = 14,
    kCustomFormatStringFieldNumber = 18,
    kIntersStrInsertionIndexesFieldNumber = 33,
    kFormatTypeFieldNumber = 1,
    kDecimalPlacesFieldNumber = 2,
    kNegativeStyleFieldNumber = 4,
    kDurationStyleFieldNumber = 7,
    kBaseFieldNumber = 8,
    kShowThousandsSeparatorFieldNumber = 5,
    kUseAccountingStyleFieldNumber = 6,
    kBaseUseMinusSignFieldNumber = 10,
    kSuppressDateFormatFieldNumber = 12,
    kBasePlacesFieldNumber = 9,
    kFractionAccuracyFieldNumber = 11,
    kDurationUnitLargestFieldNumber = 15,
    kDurationUnitSmallestFieldNumber = 16,
    kScaleFactorFieldNumber = 19,
    kCustomIdFieldNumber = 17,
    kControlFormatTypeFieldNumber = 24,
    kControlMinimumFieldNumber = 21,
    kControlMaximumFieldNumber = 22,
    kControlIncrementFieldNumber = 23,
    kSliderOrientationFieldNumber = 25,
    kSliderPositionFieldNumber = 26,
    kSuppressTimeFormatFieldNumber = 13,
    kRequiresFractionReplacementFieldNumber = 20,
    kIsComplexFieldNumber = 36,
    kContainsIntegerTokenFieldNumber = 37,
    kDecimalWidthFieldNumber = 27,
    kMinIntegerWidthFieldNumber = 28,
    kNumNonspaceIntegerDigitsFieldNumber = 29,
    kNumNonspaceDecimalDigitsFieldNumber = 30,
    kIndexFromRightLastIntegerFieldNumber = 31,
    kNumHashDecimalDigitsFieldNumber = 34,
    kTotalNumDecimalDigitsFieldNumber = 35,
    kMultipleChoiceListInitialValueFieldNumber = 38,
    kMultipleChoiceListIdFieldNumber = 39,
    kUseAutomaticDurationUnitsFieldNumber = 40,
  };
  // repeated string interstitial_strings = 32;
  int interstitial_strings_size() const;
  private:
  int _internal_interstitial_strings_size() const;
  public:
  void clear_interstitial_strings();
  const std::string& interstitial_strings(int index) const;
  std::string* mutable_interstitial_strings(int index);
  void set_interstitial_strings(int index, const std::string& value);
  void set_interstitial_strings(int index, std::string&& value);
  void set_interstitial_strings(int index, const char* value);
  void set_interstitial_strings(int index, const char* value, size_t size);
  std::string* add_interstitial_strings();
  void add_interstitial_strings(const std::string& value);
  void add_interstitial_strings(std::string&& value);
  void add_interstitial_strings(const char* value);
  void add_interstitial_strings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& interstitial_strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_interstitial_strings();
  private:
  const std::string& _internal_interstitial_strings(int index) const;
  std::string* _internal_add_interstitial_strings();
  public:

  // optional string currency_code = 3;
  bool has_currency_code() const;
  private:
  bool _internal_has_currency_code() const;
  public:
  void clear_currency_code();
  const std::string& currency_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currency_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currency_code();
  PROTOBUF_NODISCARD std::string* release_currency_code();
  void set_allocated_currency_code(std::string* currency_code);
  private:
  const std::string& _internal_currency_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(const std::string& value);
  std::string* _internal_mutable_currency_code();
  public:

  // optional string date_time_format = 14;
  bool has_date_time_format() const;
  private:
  bool _internal_has_date_time_format() const;
  public:
  void clear_date_time_format();
  const std::string& date_time_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_time_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_time_format();
  PROTOBUF_NODISCARD std::string* release_date_time_format();
  void set_allocated_date_time_format(std::string* date_time_format);
  private:
  const std::string& _internal_date_time_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time_format(const std::string& value);
  std::string* _internal_mutable_date_time_format();
  public:

  // optional string custom_format_string = 18;
  bool has_custom_format_string() const;
  private:
  bool _internal_has_custom_format_string() const;
  public:
  void clear_custom_format_string();
  const std::string& custom_format_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_format_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_format_string();
  PROTOBUF_NODISCARD std::string* release_custom_format_string();
  void set_allocated_custom_format_string(std::string* custom_format_string);
  private:
  const std::string& _internal_custom_format_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_format_string(const std::string& value);
  std::string* _internal_mutable_custom_format_string();
  public:

  // optional .TSP.IndexSet inters_str_insertion_indexes = 33;
  bool has_inters_str_insertion_indexes() const;
  private:
  bool _internal_has_inters_str_insertion_indexes() const;
  public:
  void clear_inters_str_insertion_indexes();
  const ::TSP::IndexSet& inters_str_insertion_indexes() const;
  PROTOBUF_NODISCARD ::TSP::IndexSet* release_inters_str_insertion_indexes();
  ::TSP::IndexSet* mutable_inters_str_insertion_indexes();
  void set_allocated_inters_str_insertion_indexes(::TSP::IndexSet* inters_str_insertion_indexes);
  private:
  const ::TSP::IndexSet& _internal_inters_str_insertion_indexes() const;
  ::TSP::IndexSet* _internal_mutable_inters_str_insertion_indexes();
  public:
  void unsafe_arena_set_allocated_inters_str_insertion_indexes(
      ::TSP::IndexSet* inters_str_insertion_indexes);
  ::TSP::IndexSet* unsafe_arena_release_inters_str_insertion_indexes();

  // required uint32 format_type = 1;
  bool has_format_type() const;
  private:
  bool _internal_has_format_type() const;
  public:
  void clear_format_type();
  uint32_t format_type() const;
  void set_format_type(uint32_t value);
  private:
  uint32_t _internal_format_type() const;
  void _internal_set_format_type(uint32_t value);
  public:

  // optional uint32 decimal_places = 2;
  bool has_decimal_places() const;
  private:
  bool _internal_has_decimal_places() const;
  public:
  void clear_decimal_places();
  uint32_t decimal_places() const;
  void set_decimal_places(uint32_t value);
  private:
  uint32_t _internal_decimal_places() const;
  void _internal_set_decimal_places(uint32_t value);
  public:

  // optional uint32 negative_style = 4;
  bool has_negative_style() const;
  private:
  bool _internal_has_negative_style() const;
  public:
  void clear_negative_style();
  uint32_t negative_style() const;
  void set_negative_style(uint32_t value);
  private:
  uint32_t _internal_negative_style() const;
  void _internal_set_negative_style(uint32_t value);
  public:

  // optional uint32 duration_style = 7;
  bool has_duration_style() const;
  private:
  bool _internal_has_duration_style() const;
  public:
  void clear_duration_style();
  uint32_t duration_style() const;
  void set_duration_style(uint32_t value);
  private:
  uint32_t _internal_duration_style() const;
  void _internal_set_duration_style(uint32_t value);
  public:

  // optional uint32 base = 8;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  uint32_t base() const;
  void set_base(uint32_t value);
  private:
  uint32_t _internal_base() const;
  void _internal_set_base(uint32_t value);
  public:

  // optional bool show_thousands_separator = 5;
  bool has_show_thousands_separator() const;
  private:
  bool _internal_has_show_thousands_separator() const;
  public:
  void clear_show_thousands_separator();
  bool show_thousands_separator() const;
  void set_show_thousands_separator(bool value);
  private:
  bool _internal_show_thousands_separator() const;
  void _internal_set_show_thousands_separator(bool value);
  public:

  // optional bool use_accounting_style = 6;
  bool has_use_accounting_style() const;
  private:
  bool _internal_has_use_accounting_style() const;
  public:
  void clear_use_accounting_style();
  bool use_accounting_style() const;
  void set_use_accounting_style(bool value);
  private:
  bool _internal_use_accounting_style() const;
  void _internal_set_use_accounting_style(bool value);
  public:

  // optional bool base_use_minus_sign = 10;
  bool has_base_use_minus_sign() const;
  private:
  bool _internal_has_base_use_minus_sign() const;
  public:
  void clear_base_use_minus_sign();
  bool base_use_minus_sign() const;
  void set_base_use_minus_sign(bool value);
  private:
  bool _internal_base_use_minus_sign() const;
  void _internal_set_base_use_minus_sign(bool value);
  public:

  // optional bool suppress_date_format = 12;
  bool has_suppress_date_format() const;
  private:
  bool _internal_has_suppress_date_format() const;
  public:
  void clear_suppress_date_format();
  bool suppress_date_format() const;
  void set_suppress_date_format(bool value);
  private:
  bool _internal_suppress_date_format() const;
  void _internal_set_suppress_date_format(bool value);
  public:

  // optional uint32 base_places = 9;
  bool has_base_places() const;
  private:
  bool _internal_has_base_places() const;
  public:
  void clear_base_places();
  uint32_t base_places() const;
  void set_base_places(uint32_t value);
  private:
  uint32_t _internal_base_places() const;
  void _internal_set_base_places(uint32_t value);
  public:

  // optional uint32 fraction_accuracy = 11;
  bool has_fraction_accuracy() const;
  private:
  bool _internal_has_fraction_accuracy() const;
  public:
  void clear_fraction_accuracy();
  uint32_t fraction_accuracy() const;
  void set_fraction_accuracy(uint32_t value);
  private:
  uint32_t _internal_fraction_accuracy() const;
  void _internal_set_fraction_accuracy(uint32_t value);
  public:

  // optional uint32 duration_unit_largest = 15;
  bool has_duration_unit_largest() const;
  private:
  bool _internal_has_duration_unit_largest() const;
  public:
  void clear_duration_unit_largest();
  uint32_t duration_unit_largest() const;
  void set_duration_unit_largest(uint32_t value);
  private:
  uint32_t _internal_duration_unit_largest() const;
  void _internal_set_duration_unit_largest(uint32_t value);
  public:

  // optional uint32 duration_unit_smallest = 16;
  bool has_duration_unit_smallest() const;
  private:
  bool _internal_has_duration_unit_smallest() const;
  public:
  void clear_duration_unit_smallest();
  uint32_t duration_unit_smallest() const;
  void set_duration_unit_smallest(uint32_t value);
  private:
  uint32_t _internal_duration_unit_smallest() const;
  void _internal_set_duration_unit_smallest(uint32_t value);
  public:

  // optional double scale_factor = 19;
  bool has_scale_factor() const;
  private:
  bool _internal_has_scale_factor() const;
  public:
  void clear_scale_factor();
  double scale_factor() const;
  void set_scale_factor(double value);
  private:
  double _internal_scale_factor() const;
  void _internal_set_scale_factor(double value);
  public:

  // optional uint32 custom_id = 17;
  bool has_custom_id() const;
  private:
  bool _internal_has_custom_id() const;
  public:
  void clear_custom_id();
  uint32_t custom_id() const;
  void set_custom_id(uint32_t value);
  private:
  uint32_t _internal_custom_id() const;
  void _internal_set_custom_id(uint32_t value);
  public:

  // optional uint32 control_format_type = 24;
  bool has_control_format_type() const;
  private:
  bool _internal_has_control_format_type() const;
  public:
  void clear_control_format_type();
  uint32_t control_format_type() const;
  void set_control_format_type(uint32_t value);
  private:
  uint32_t _internal_control_format_type() const;
  void _internal_set_control_format_type(uint32_t value);
  public:

  // optional double control_minimum = 21;
  bool has_control_minimum() const;
  private:
  bool _internal_has_control_minimum() const;
  public:
  void clear_control_minimum();
  double control_minimum() const;
  void set_control_minimum(double value);
  private:
  double _internal_control_minimum() const;
  void _internal_set_control_minimum(double value);
  public:

  // optional double control_maximum = 22;
  bool has_control_maximum() const;
  private:
  bool _internal_has_control_maximum() const;
  public:
  void clear_control_maximum();
  double control_maximum() const;
  void set_control_maximum(double value);
  private:
  double _internal_control_maximum() const;
  void _internal_set_control_maximum(double value);
  public:

  // optional double control_increment = 23;
  bool has_control_increment() const;
  private:
  bool _internal_has_control_increment() const;
  public:
  void clear_control_increment();
  double control_increment() const;
  void set_control_increment(double value);
  private:
  double _internal_control_increment() const;
  void _internal_set_control_increment(double value);
  public:

  // optional uint32 slider_orientation = 25;
  bool has_slider_orientation() const;
  private:
  bool _internal_has_slider_orientation() const;
  public:
  void clear_slider_orientation();
  uint32_t slider_orientation() const;
  void set_slider_orientation(uint32_t value);
  private:
  uint32_t _internal_slider_orientation() const;
  void _internal_set_slider_orientation(uint32_t value);
  public:

  // optional uint32 slider_position = 26;
  bool has_slider_position() const;
  private:
  bool _internal_has_slider_position() const;
  public:
  void clear_slider_position();
  uint32_t slider_position() const;
  void set_slider_position(uint32_t value);
  private:
  uint32_t _internal_slider_position() const;
  void _internal_set_slider_position(uint32_t value);
  public:

  // optional bool suppress_time_format = 13;
  bool has_suppress_time_format() const;
  private:
  bool _internal_has_suppress_time_format() const;
  public:
  void clear_suppress_time_format();
  bool suppress_time_format() const;
  void set_suppress_time_format(bool value);
  private:
  bool _internal_suppress_time_format() const;
  void _internal_set_suppress_time_format(bool value);
  public:

  // optional bool requires_fraction_replacement = 20;
  bool has_requires_fraction_replacement() const;
  private:
  bool _internal_has_requires_fraction_replacement() const;
  public:
  void clear_requires_fraction_replacement();
  bool requires_fraction_replacement() const;
  void set_requires_fraction_replacement(bool value);
  private:
  bool _internal_requires_fraction_replacement() const;
  void _internal_set_requires_fraction_replacement(bool value);
  public:

  // optional bool is_complex = 36;
  bool has_is_complex() const;
  private:
  bool _internal_has_is_complex() const;
  public:
  void clear_is_complex();
  bool is_complex() const;
  void set_is_complex(bool value);
  private:
  bool _internal_is_complex() const;
  void _internal_set_is_complex(bool value);
  public:

  // optional bool contains_integer_token = 37;
  bool has_contains_integer_token() const;
  private:
  bool _internal_has_contains_integer_token() const;
  public:
  void clear_contains_integer_token();
  bool contains_integer_token() const;
  void set_contains_integer_token(bool value);
  private:
  bool _internal_contains_integer_token() const;
  void _internal_set_contains_integer_token(bool value);
  public:

  // optional uint32 decimal_width = 27;
  bool has_decimal_width() const;
  private:
  bool _internal_has_decimal_width() const;
  public:
  void clear_decimal_width();
  uint32_t decimal_width() const;
  void set_decimal_width(uint32_t value);
  private:
  uint32_t _internal_decimal_width() const;
  void _internal_set_decimal_width(uint32_t value);
  public:

  // optional uint32 min_integer_width = 28;
  bool has_min_integer_width() const;
  private:
  bool _internal_has_min_integer_width() const;
  public:
  void clear_min_integer_width();
  uint32_t min_integer_width() const;
  void set_min_integer_width(uint32_t value);
  private:
  uint32_t _internal_min_integer_width() const;
  void _internal_set_min_integer_width(uint32_t value);
  public:

  // optional uint32 num_nonspace_integer_digits = 29;
  bool has_num_nonspace_integer_digits() const;
  private:
  bool _internal_has_num_nonspace_integer_digits() const;
  public:
  void clear_num_nonspace_integer_digits();
  uint32_t num_nonspace_integer_digits() const;
  void set_num_nonspace_integer_digits(uint32_t value);
  private:
  uint32_t _internal_num_nonspace_integer_digits() const;
  void _internal_set_num_nonspace_integer_digits(uint32_t value);
  public:

  // optional uint32 num_nonspace_decimal_digits = 30;
  bool has_num_nonspace_decimal_digits() const;
  private:
  bool _internal_has_num_nonspace_decimal_digits() const;
  public:
  void clear_num_nonspace_decimal_digits();
  uint32_t num_nonspace_decimal_digits() const;
  void set_num_nonspace_decimal_digits(uint32_t value);
  private:
  uint32_t _internal_num_nonspace_decimal_digits() const;
  void _internal_set_num_nonspace_decimal_digits(uint32_t value);
  public:

  // optional uint32 index_from_right_last_integer = 31;
  bool has_index_from_right_last_integer() const;
  private:
  bool _internal_has_index_from_right_last_integer() const;
  public:
  void clear_index_from_right_last_integer();
  uint32_t index_from_right_last_integer() const;
  void set_index_from_right_last_integer(uint32_t value);
  private:
  uint32_t _internal_index_from_right_last_integer() const;
  void _internal_set_index_from_right_last_integer(uint32_t value);
  public:

  // optional uint32 num_hash_decimal_digits = 34;
  bool has_num_hash_decimal_digits() const;
  private:
  bool _internal_has_num_hash_decimal_digits() const;
  public:
  void clear_num_hash_decimal_digits();
  uint32_t num_hash_decimal_digits() const;
  void set_num_hash_decimal_digits(uint32_t value);
  private:
  uint32_t _internal_num_hash_decimal_digits() const;
  void _internal_set_num_hash_decimal_digits(uint32_t value);
  public:

  // optional uint32 total_num_decimal_digits = 35;
  bool has_total_num_decimal_digits() const;
  private:
  bool _internal_has_total_num_decimal_digits() const;
  public:
  void clear_total_num_decimal_digits();
  uint32_t total_num_decimal_digits() const;
  void set_total_num_decimal_digits(uint32_t value);
  private:
  uint32_t _internal_total_num_decimal_digits() const;
  void _internal_set_total_num_decimal_digits(uint32_t value);
  public:

  // optional uint32 multiple_choice_list_initial_value = 38;
  bool has_multiple_choice_list_initial_value() const;
  private:
  bool _internal_has_multiple_choice_list_initial_value() const;
  public:
  void clear_multiple_choice_list_initial_value();
  uint32_t multiple_choice_list_initial_value() const;
  void set_multiple_choice_list_initial_value(uint32_t value);
  private:
  uint32_t _internal_multiple_choice_list_initial_value() const;
  void _internal_set_multiple_choice_list_initial_value(uint32_t value);
  public:

  // optional uint32 multiple_choice_list_id = 39;
  bool has_multiple_choice_list_id() const;
  private:
  bool _internal_has_multiple_choice_list_id() const;
  public:
  void clear_multiple_choice_list_id();
  uint32_t multiple_choice_list_id() const;
  void set_multiple_choice_list_id(uint32_t value);
  private:
  uint32_t _internal_multiple_choice_list_id() const;
  void _internal_set_multiple_choice_list_id(uint32_t value);
  public:

  // optional bool use_automatic_duration_units = 40;
  bool has_use_automatic_duration_units() const;
  private:
  bool _internal_has_use_automatic_duration_units() const;
  public:
  void clear_use_automatic_duration_units();
  bool use_automatic_duration_units() const;
  void set_use_automatic_duration_units(bool value);
  private:
  bool _internal_use_automatic_duration_units() const;
  void _internal_set_use_automatic_duration_units(bool value);
  public:


  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline bool HasExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline int ExtensionSize(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_,
                                  id.default_value());
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Mutable(id.number(), _field_type,
                                      &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);

  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
              FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::Release(id.number(), _field_type,
                                      &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) const {

    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index) {

    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);

    return to_add;
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);

  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) const {

    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits,
            ::PROTOBUF_NAMESPACE_ID::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier<
          FormatStructArchive, _proto_TypeTraits, _field_type, _is_packed>& id) {

    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }

  // @@protoc_insertion_point(class_scope:TSK.FormatStructArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> interstitial_strings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_time_format_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_format_string_;
    ::TSP::IndexSet* inters_str_insertion_indexes_;
    uint32_t format_type_;
    uint32_t decimal_places_;
    uint32_t negative_style_;
    uint32_t duration_style_;
    uint32_t base_;
    bool show_thousands_separator_;
    bool use_accounting_style_;
    bool base_use_minus_sign_;
    bool suppress_date_format_;
    uint32_t base_places_;
    uint32_t fraction_accuracy_;
    uint32_t duration_unit_largest_;
    uint32_t duration_unit_smallest_;
    double scale_factor_;
    uint32_t custom_id_;
    uint32_t control_format_type_;
    double control_minimum_;
    double control_maximum_;
    double control_increment_;
    uint32_t slider_orientation_;
    uint32_t slider_position_;
    bool suppress_time_format_;
    bool requires_fraction_replacement_;
    bool is_complex_;
    bool contains_integer_token_;
    uint32_t decimal_width_;
    uint32_t min_integer_width_;
    uint32_t num_nonspace_integer_digits_;
    uint32_t num_nonspace_decimal_digits_;
    uint32_t index_from_right_last_integer_;
    uint32_t num_hash_decimal_digits_;
    uint32_t total_num_decimal_digits_;
    uint32_t multiple_choice_list_initial_value_;
    uint32_t multiple_choice_list_id_;
    bool use_automatic_duration_units_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CustomFormatArchive_Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CustomFormatArchive.Condition) */ {
 public:
  inline CustomFormatArchive_Condition() : CustomFormatArchive_Condition(nullptr) {}
  ~CustomFormatArchive_Condition() override;
  explicit PROTOBUF_CONSTEXPR CustomFormatArchive_Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomFormatArchive_Condition(const CustomFormatArchive_Condition& from);
  CustomFormatArchive_Condition(CustomFormatArchive_Condition&& from) noexcept
    : CustomFormatArchive_Condition() {
    *this = ::std::move(from);
  }

  inline CustomFormatArchive_Condition& operator=(const CustomFormatArchive_Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomFormatArchive_Condition& operator=(CustomFormatArchive_Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomFormatArchive_Condition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomFormatArchive_Condition* internal_default_instance() {
    return reinterpret_cast<const CustomFormatArchive_Condition*>(
               &_CustomFormatArchive_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CustomFormatArchive_Condition& a, CustomFormatArchive_Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomFormatArchive_Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomFormatArchive_Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomFormatArchive_Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomFormatArchive_Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomFormatArchive_Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomFormatArchive_Condition& from) {
    CustomFormatArchive_Condition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomFormatArchive_Condition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CustomFormatArchive.Condition";
  }
  protected:
  explicit CustomFormatArchive_Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFormatFieldNumber = 3,
    kConditionTypeFieldNumber = 1,
    kConditionValueFieldNumber = 2,
    kConditionValueDblFieldNumber = 4,
  };
  // required .TSK.FormatStructArchive condition_format = 3;
  bool has_condition_format() const;
  private:
  bool _internal_has_condition_format() const;
  public:
  void clear_condition_format();
  const ::TSK::FormatStructArchive& condition_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_condition_format();
  ::TSK::FormatStructArchive* mutable_condition_format();
  void set_allocated_condition_format(::TSK::FormatStructArchive* condition_format);
  private:
  const ::TSK::FormatStructArchive& _internal_condition_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_condition_format();
  public:
  void unsafe_arena_set_allocated_condition_format(
      ::TSK::FormatStructArchive* condition_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_condition_format();

  // required uint32 condition_type = 1;
  bool has_condition_type() const;
  private:
  bool _internal_has_condition_type() const;
  public:
  void clear_condition_type();
  uint32_t condition_type() const;
  void set_condition_type(uint32_t value);
  private:
  uint32_t _internal_condition_type() const;
  void _internal_set_condition_type(uint32_t value);
  public:

  // optional float condition_value = 2;
  bool has_condition_value() const;
  private:
  bool _internal_has_condition_value() const;
  public:
  void clear_condition_value();
  float condition_value() const;
  void set_condition_value(float value);
  private:
  float _internal_condition_value() const;
  void _internal_set_condition_value(float value);
  public:

  // optional double condition_value_dbl = 4;
  bool has_condition_value_dbl() const;
  private:
  bool _internal_has_condition_value_dbl() const;
  public:
  void clear_condition_value_dbl();
  double condition_value_dbl() const;
  void set_condition_value_dbl(double value);
  private:
  double _internal_condition_value_dbl() const;
  void _internal_set_condition_value_dbl(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.CustomFormatArchive.Condition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::FormatStructArchive* condition_format_;
    uint32_t condition_type_;
    float condition_value_;
    double condition_value_dbl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class CustomFormatArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.CustomFormatArchive) */ {
 public:
  inline CustomFormatArchive() : CustomFormatArchive(nullptr) {}
  ~CustomFormatArchive() override;
  explicit PROTOBUF_CONSTEXPR CustomFormatArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomFormatArchive(const CustomFormatArchive& from);
  CustomFormatArchive(CustomFormatArchive&& from) noexcept
    : CustomFormatArchive() {
    *this = ::std::move(from);
  }

  inline CustomFormatArchive& operator=(const CustomFormatArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomFormatArchive& operator=(CustomFormatArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomFormatArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomFormatArchive* internal_default_instance() {
    return reinterpret_cast<const CustomFormatArchive*>(
               &_CustomFormatArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CustomFormatArchive& a, CustomFormatArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomFormatArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomFormatArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomFormatArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomFormatArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomFormatArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomFormatArchive& from) {
    CustomFormatArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomFormatArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.CustomFormatArchive";
  }
  protected:
  explicit CustomFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CustomFormatArchive_Condition Condition;

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kDefaultFormatFieldNumber = 3,
    kFormatTypeFieldNumber = 2,
  };
  // repeated .TSK.CustomFormatArchive.Condition conditions = 4;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::TSK::CustomFormatArchive_Condition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >*
      mutable_conditions();
  private:
  const ::TSK::CustomFormatArchive_Condition& _internal_conditions(int index) const;
  ::TSK::CustomFormatArchive_Condition* _internal_add_conditions();
  public:
  const ::TSK::CustomFormatArchive_Condition& conditions(int index) const;
  ::TSK::CustomFormatArchive_Condition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >&
      conditions() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .TSK.FormatStructArchive default_format = 3;
  bool has_default_format() const;
  private:
  bool _internal_has_default_format() const;
  public:
  void clear_default_format();
  const ::TSK::FormatStructArchive& default_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_default_format();
  ::TSK::FormatStructArchive* mutable_default_format();
  void set_allocated_default_format(::TSK::FormatStructArchive* default_format);
  private:
  const ::TSK::FormatStructArchive& _internal_default_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_default_format();
  public:
  void unsafe_arena_set_allocated_default_format(
      ::TSK::FormatStructArchive* default_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_default_format();

  // required uint32 format_type = 2;
  bool has_format_type() const;
  private:
  bool _internal_has_format_type() const;
  public:
  void clear_format_type();
  uint32_t format_type() const;
  void set_format_type(uint32_t value);
  private:
  uint32_t _internal_format_type() const;
  void _internal_set_format_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSK.CustomFormatArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition > conditions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TSK::FormatStructArchive* default_format_;
    uint32_t format_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class AnnotationAuthorArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.AnnotationAuthorArchive) */ {
 public:
  inline AnnotationAuthorArchive() : AnnotationAuthorArchive(nullptr) {}
  ~AnnotationAuthorArchive() override;
  explicit PROTOBUF_CONSTEXPR AnnotationAuthorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotationAuthorArchive(const AnnotationAuthorArchive& from);
  AnnotationAuthorArchive(AnnotationAuthorArchive&& from) noexcept
    : AnnotationAuthorArchive() {
    *this = ::std::move(from);
  }

  inline AnnotationAuthorArchive& operator=(const AnnotationAuthorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotationAuthorArchive& operator=(AnnotationAuthorArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotationAuthorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotationAuthorArchive* internal_default_instance() {
    return reinterpret_cast<const AnnotationAuthorArchive*>(
               &_AnnotationAuthorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AnnotationAuthorArchive& a, AnnotationAuthorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotationAuthorArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotationAuthorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotationAuthorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotationAuthorArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotationAuthorArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotationAuthorArchive& from) {
    AnnotationAuthorArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotationAuthorArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.AnnotationAuthorArchive";
  }
  protected:
  explicit AnnotationAuthorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kColorFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .TSP.Color color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:TSK.AnnotationAuthorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TSP::Color* color_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class DeprecatedChangeAuthorArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.DeprecatedChangeAuthorArchive) */ {
 public:
  inline DeprecatedChangeAuthorArchive() : DeprecatedChangeAuthorArchive(nullptr) {}
  ~DeprecatedChangeAuthorArchive() override;
  explicit PROTOBUF_CONSTEXPR DeprecatedChangeAuthorArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeprecatedChangeAuthorArchive(const DeprecatedChangeAuthorArchive& from);
  DeprecatedChangeAuthorArchive(DeprecatedChangeAuthorArchive&& from) noexcept
    : DeprecatedChangeAuthorArchive() {
    *this = ::std::move(from);
  }

  inline DeprecatedChangeAuthorArchive& operator=(const DeprecatedChangeAuthorArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecatedChangeAuthorArchive& operator=(DeprecatedChangeAuthorArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeprecatedChangeAuthorArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeprecatedChangeAuthorArchive* internal_default_instance() {
    return reinterpret_cast<const DeprecatedChangeAuthorArchive*>(
               &_DeprecatedChangeAuthorArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DeprecatedChangeAuthorArchive& a, DeprecatedChangeAuthorArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecatedChangeAuthorArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeprecatedChangeAuthorArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeprecatedChangeAuthorArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeprecatedChangeAuthorArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeprecatedChangeAuthorArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeprecatedChangeAuthorArchive& from) {
    DeprecatedChangeAuthorArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecatedChangeAuthorArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.DeprecatedChangeAuthorArchive";
  }
  protected:
  explicit DeprecatedChangeAuthorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kChangeColorFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .TSP.Color change_color = 2;
  bool has_change_color() const;
  private:
  bool _internal_has_change_color() const;
  public:
  void clear_change_color();
  const ::TSP::Color& change_color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_change_color();
  ::TSP::Color* mutable_change_color();
  void set_allocated_change_color(::TSP::Color* change_color);
  private:
  const ::TSP::Color& _internal_change_color() const;
  ::TSP::Color* _internal_mutable_change_color();
  public:
  void unsafe_arena_set_allocated_change_color(
      ::TSP::Color* change_color);
  ::TSP::Color* unsafe_arena_release_change_color();

  // @@protoc_insertion_point(class_scope:TSK.DeprecatedChangeAuthorArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::TSP::Color* change_color_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class AnnotationAuthorStorageArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.AnnotationAuthorStorageArchive) */ {
 public:
  inline AnnotationAuthorStorageArchive() : AnnotationAuthorStorageArchive(nullptr) {}
  ~AnnotationAuthorStorageArchive() override;
  explicit PROTOBUF_CONSTEXPR AnnotationAuthorStorageArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnnotationAuthorStorageArchive(const AnnotationAuthorStorageArchive& from);
  AnnotationAuthorStorageArchive(AnnotationAuthorStorageArchive&& from) noexcept
    : AnnotationAuthorStorageArchive() {
    *this = ::std::move(from);
  }

  inline AnnotationAuthorStorageArchive& operator=(const AnnotationAuthorStorageArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnnotationAuthorStorageArchive& operator=(AnnotationAuthorStorageArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnnotationAuthorStorageArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnnotationAuthorStorageArchive* internal_default_instance() {
    return reinterpret_cast<const AnnotationAuthorStorageArchive*>(
               &_AnnotationAuthorStorageArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AnnotationAuthorStorageArchive& a, AnnotationAuthorStorageArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AnnotationAuthorStorageArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnnotationAuthorStorageArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnnotationAuthorStorageArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnnotationAuthorStorageArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnnotationAuthorStorageArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnnotationAuthorStorageArchive& from) {
    AnnotationAuthorStorageArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnnotationAuthorStorageArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.AnnotationAuthorStorageArchive";
  }
  protected:
  explicit AnnotationAuthorStorageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnnotationAuthorFieldNumber = 1,
  };
  // repeated .TSP.Reference annotation_author = 1;
  int annotation_author_size() const;
  private:
  int _internal_annotation_author_size() const;
  public:
  void clear_annotation_author();
  ::TSP::Reference* mutable_annotation_author(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_annotation_author();
  private:
  const ::TSP::Reference& _internal_annotation_author(int index) const;
  ::TSP::Reference* _internal_add_annotation_author();
  public:
  const ::TSP::Reference& annotation_author(int index) const;
  ::TSP::Reference* add_annotation_author();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      annotation_author() const;

  // @@protoc_insertion_point(class_scope:TSK.AnnotationAuthorStorageArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > annotation_author_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class AddAnnotationAuthorCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.AddAnnotationAuthorCommandArchive) */ {
 public:
  inline AddAnnotationAuthorCommandArchive() : AddAnnotationAuthorCommandArchive(nullptr) {}
  ~AddAnnotationAuthorCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR AddAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddAnnotationAuthorCommandArchive(const AddAnnotationAuthorCommandArchive& from);
  AddAnnotationAuthorCommandArchive(AddAnnotationAuthorCommandArchive&& from) noexcept
    : AddAnnotationAuthorCommandArchive() {
    *this = ::std::move(from);
  }

  inline AddAnnotationAuthorCommandArchive& operator=(const AddAnnotationAuthorCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddAnnotationAuthorCommandArchive& operator=(AddAnnotationAuthorCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddAnnotationAuthorCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddAnnotationAuthorCommandArchive* internal_default_instance() {
    return reinterpret_cast<const AddAnnotationAuthorCommandArchive*>(
               &_AddAnnotationAuthorCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AddAnnotationAuthorCommandArchive& a, AddAnnotationAuthorCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(AddAnnotationAuthorCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddAnnotationAuthorCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddAnnotationAuthorCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddAnnotationAuthorCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddAnnotationAuthorCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddAnnotationAuthorCommandArchive& from) {
    AddAnnotationAuthorCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddAnnotationAuthorCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.AddAnnotationAuthorCommandArchive";
  }
  protected:
  explicit AddAnnotationAuthorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kDocumentRootFieldNumber = 2,
    kAnnotationAuthorFieldNumber = 3,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference document_root = 2;
  bool has_document_root() const;
  private:
  bool _internal_has_document_root() const;
  public:
  void clear_document_root();
  const ::TSP::Reference& document_root() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_document_root();
  ::TSP::Reference* mutable_document_root();
  void set_allocated_document_root(::TSP::Reference* document_root);
  private:
  const ::TSP::Reference& _internal_document_root() const;
  ::TSP::Reference* _internal_mutable_document_root();
  public:
  void unsafe_arena_set_allocated_document_root(
      ::TSP::Reference* document_root);
  ::TSP::Reference* unsafe_arena_release_document_root();

  // optional .TSP.Reference annotation_author = 3;
  bool has_annotation_author() const;
  private:
  bool _internal_has_annotation_author() const;
  public:
  void clear_annotation_author();
  const ::TSP::Reference& annotation_author() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_annotation_author();
  ::TSP::Reference* mutable_annotation_author();
  void set_allocated_annotation_author(::TSP::Reference* annotation_author);
  private:
  const ::TSP::Reference& _internal_annotation_author() const;
  ::TSP::Reference* _internal_mutable_annotation_author();
  public:
  void unsafe_arena_set_allocated_annotation_author(
      ::TSP::Reference* annotation_author);
  ::TSP::Reference* unsafe_arena_release_annotation_author();

  // @@protoc_insertion_point(class_scope:TSK.AddAnnotationAuthorCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* document_root_;
    ::TSP::Reference* annotation_author_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// -------------------------------------------------------------------

class SetAnnotationAuthorColorCommandArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSK.SetAnnotationAuthorColorCommandArchive) */ {
 public:
  inline SetAnnotationAuthorColorCommandArchive() : SetAnnotationAuthorColorCommandArchive(nullptr) {}
  ~SetAnnotationAuthorColorCommandArchive() override;
  explicit PROTOBUF_CONSTEXPR SetAnnotationAuthorColorCommandArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAnnotationAuthorColorCommandArchive(const SetAnnotationAuthorColorCommandArchive& from);
  SetAnnotationAuthorColorCommandArchive(SetAnnotationAuthorColorCommandArchive&& from) noexcept
    : SetAnnotationAuthorColorCommandArchive() {
    *this = ::std::move(from);
  }

  inline SetAnnotationAuthorColorCommandArchive& operator=(const SetAnnotationAuthorColorCommandArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAnnotationAuthorColorCommandArchive& operator=(SetAnnotationAuthorColorCommandArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAnnotationAuthorColorCommandArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAnnotationAuthorColorCommandArchive* internal_default_instance() {
    return reinterpret_cast<const SetAnnotationAuthorColorCommandArchive*>(
               &_SetAnnotationAuthorColorCommandArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetAnnotationAuthorColorCommandArchive& a, SetAnnotationAuthorColorCommandArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAnnotationAuthorColorCommandArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAnnotationAuthorColorCommandArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAnnotationAuthorColorCommandArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAnnotationAuthorColorCommandArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAnnotationAuthorColorCommandArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetAnnotationAuthorColorCommandArchive& from) {
    SetAnnotationAuthorColorCommandArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAnnotationAuthorColorCommandArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSK.SetAnnotationAuthorColorCommandArchive";
  }
  protected:
  explicit SetAnnotationAuthorColorCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kAnnotationAuthorFieldNumber = 2,
    kColorFieldNumber = 3,
  };
  // required .TSK.CommandArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSK::CommandArchive& super() const;
  PROTOBUF_NODISCARD ::TSK::CommandArchive* release_super();
  ::TSK::CommandArchive* mutable_super();
  void set_allocated_super(::TSK::CommandArchive* super);
  private:
  const ::TSK::CommandArchive& _internal_super() const;
  ::TSK::CommandArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSK::CommandArchive* super);
  ::TSK::CommandArchive* unsafe_arena_release_super();

  // optional .TSP.Reference annotation_author = 2;
  bool has_annotation_author() const;
  private:
  bool _internal_has_annotation_author() const;
  public:
  void clear_annotation_author();
  const ::TSP::Reference& annotation_author() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_annotation_author();
  ::TSP::Reference* mutable_annotation_author();
  void set_allocated_annotation_author(::TSP::Reference* annotation_author);
  private:
  const ::TSP::Reference& _internal_annotation_author() const;
  ::TSP::Reference* _internal_mutable_annotation_author();
  public:
  void unsafe_arena_set_allocated_annotation_author(
      ::TSP::Reference* annotation_author);
  ::TSP::Reference* unsafe_arena_release_annotation_author();

  // optional .TSP.Color color = 3;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::TSP::Color& color() const;
  PROTOBUF_NODISCARD ::TSP::Color* release_color();
  ::TSP::Color* mutable_color();
  void set_allocated_color(::TSP::Color* color);
  private:
  const ::TSP::Color& _internal_color() const;
  ::TSP::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::TSP::Color* color);
  ::TSP::Color* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:TSK.SetAnnotationAuthorColorCommandArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSK::CommandArchive* super_;
    ::TSP::Reference* annotation_author_;
    ::TSP::Color* color_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSKArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TreeNode

// optional string name = 1;
inline bool TreeNode::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TreeNode::has_name() const {
  return _internal_has_name();
}
inline void TreeNode::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TreeNode::name() const {
  // @@protoc_insertion_point(field_get:TSK.TreeNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TreeNode::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.TreeNode.name)
}
inline std::string* TreeNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TSK.TreeNode.name)
  return _s;
}
inline const std::string& TreeNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TreeNode::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TreeNode::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TreeNode::release_name() {
  // @@protoc_insertion_point(field_release:TSK.TreeNode.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TreeNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.TreeNode.name)
}

// repeated .TSP.Reference children = 2;
inline int TreeNode::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int TreeNode::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* TreeNode::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.TreeNode.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
TreeNode::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TSK.TreeNode.children)
  return &_impl_.children_;
}
inline const ::TSP::Reference& TreeNode::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::TSP::Reference& TreeNode::children(int index) const {
  // @@protoc_insertion_point(field_get:TSK.TreeNode.children)
  return _internal_children(index);
}
inline ::TSP::Reference* TreeNode::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::TSP::Reference* TreeNode::add_children() {
  ::TSP::Reference* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:TSK.TreeNode.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
TreeNode::children() const {
  // @@protoc_insertion_point(field_list:TSK.TreeNode.children)
  return _impl_.children_;
}

// optional .TSP.Reference object = 3;
inline bool TreeNode::_internal_has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline bool TreeNode::has_object() const {
  return _internal_has_object();
}
inline const ::TSP::Reference& TreeNode::_internal_object() const {
  const ::TSP::Reference* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TreeNode::object() const {
  // @@protoc_insertion_point(field_get:TSK.TreeNode.object)
  return _internal_object();
}
inline void TreeNode::unsafe_arena_set_allocated_object(
    ::TSP::Reference* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.TreeNode.object)
}
inline ::TSP::Reference* TreeNode::release_object() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TreeNode::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:TSK.TreeNode.object)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TreeNode::_internal_mutable_object() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::TSP::Reference* TreeNode::mutable_object() {
  ::TSP::Reference* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:TSK.TreeNode.object)
  return _msg;
}
inline void TreeNode::set_allocated_object(::TSP::Reference* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object));
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:TSK.TreeNode.object)
}

// -------------------------------------------------------------------

// CommandHistory

// required uint32 undo_count = 1;
inline bool CommandHistory::_internal_has_undo_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandHistory::has_undo_count() const {
  return _internal_has_undo_count();
}
inline void CommandHistory::clear_undo_count() {
  _impl_.undo_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CommandHistory::_internal_undo_count() const {
  return _impl_.undo_count_;
}
inline uint32_t CommandHistory::undo_count() const {
  // @@protoc_insertion_point(field_get:TSK.CommandHistory.undo_count)
  return _internal_undo_count();
}
inline void CommandHistory::_internal_set_undo_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.undo_count_ = value;
}
inline void CommandHistory::set_undo_count(uint32_t value) {
  _internal_set_undo_count(value);
  // @@protoc_insertion_point(field_set:TSK.CommandHistory.undo_count)
}

// repeated .TSP.Reference commands = 2;
inline int CommandHistory::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int CommandHistory::commands_size() const {
  return _internal_commands_size();
}
inline ::TSP::Reference* CommandHistory::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CommandHistory.commands)
  return _impl_.commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CommandHistory::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CommandHistory.commands)
  return &_impl_.commands_;
}
inline const ::TSP::Reference& CommandHistory::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const ::TSP::Reference& CommandHistory::commands(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CommandHistory.commands)
  return _internal_commands(index);
}
inline ::TSP::Reference* CommandHistory::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline ::TSP::Reference* CommandHistory::add_commands() {
  ::TSP::Reference* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:TSK.CommandHistory.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CommandHistory::commands() const {
  // @@protoc_insertion_point(field_list:TSK.CommandHistory.commands)
  return _impl_.commands_;
}

// repeated .TSP.Reference marked_redo_commands = 3;
inline int CommandHistory::_internal_marked_redo_commands_size() const {
  return _impl_.marked_redo_commands_.size();
}
inline int CommandHistory::marked_redo_commands_size() const {
  return _internal_marked_redo_commands_size();
}
inline ::TSP::Reference* CommandHistory::mutable_marked_redo_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CommandHistory.marked_redo_commands)
  return _impl_.marked_redo_commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CommandHistory::mutable_marked_redo_commands() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CommandHistory.marked_redo_commands)
  return &_impl_.marked_redo_commands_;
}
inline const ::TSP::Reference& CommandHistory::_internal_marked_redo_commands(int index) const {
  return _impl_.marked_redo_commands_.Get(index);
}
inline const ::TSP::Reference& CommandHistory::marked_redo_commands(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CommandHistory.marked_redo_commands)
  return _internal_marked_redo_commands(index);
}
inline ::TSP::Reference* CommandHistory::_internal_add_marked_redo_commands() {
  return _impl_.marked_redo_commands_.Add();
}
inline ::TSP::Reference* CommandHistory::add_marked_redo_commands() {
  ::TSP::Reference* _add = _internal_add_marked_redo_commands();
  // @@protoc_insertion_point(field_add:TSK.CommandHistory.marked_redo_commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CommandHistory::marked_redo_commands() const {
  // @@protoc_insertion_point(field_list:TSK.CommandHistory.marked_redo_commands)
  return _impl_.marked_redo_commands_;
}

// optional .TSP.Reference pending_preflight_command = 4;
inline bool CommandHistory::_internal_has_pending_preflight_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pending_preflight_command_ != nullptr);
  return value;
}
inline bool CommandHistory::has_pending_preflight_command() const {
  return _internal_has_pending_preflight_command();
}
inline const ::TSP::Reference& CommandHistory::_internal_pending_preflight_command() const {
  const ::TSP::Reference* p = _impl_.pending_preflight_command_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommandHistory::pending_preflight_command() const {
  // @@protoc_insertion_point(field_get:TSK.CommandHistory.pending_preflight_command)
  return _internal_pending_preflight_command();
}
inline void CommandHistory::unsafe_arena_set_allocated_pending_preflight_command(
    ::TSP::Reference* pending_preflight_command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pending_preflight_command_);
  }
  _impl_.pending_preflight_command_ = pending_preflight_command;
  if (pending_preflight_command) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandHistory.pending_preflight_command)
}
inline ::TSP::Reference* CommandHistory::release_pending_preflight_command() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.pending_preflight_command_;
  _impl_.pending_preflight_command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommandHistory::unsafe_arena_release_pending_preflight_command() {
  // @@protoc_insertion_point(field_release:TSK.CommandHistory.pending_preflight_command)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.pending_preflight_command_;
  _impl_.pending_preflight_command_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommandHistory::_internal_mutable_pending_preflight_command() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pending_preflight_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.pending_preflight_command_ = p;
  }
  return _impl_.pending_preflight_command_;
}
inline ::TSP::Reference* CommandHistory::mutable_pending_preflight_command() {
  ::TSP::Reference* _msg = _internal_mutable_pending_preflight_command();
  // @@protoc_insertion_point(field_mutable:TSK.CommandHistory.pending_preflight_command)
  return _msg;
}
inline void CommandHistory::set_allocated_pending_preflight_command(::TSP::Reference* pending_preflight_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pending_preflight_command_);
  }
  if (pending_preflight_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pending_preflight_command));
    if (message_arena != submessage_arena) {
      pending_preflight_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pending_preflight_command, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pending_preflight_command_ = pending_preflight_command;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandHistory.pending_preflight_command)
}

// optional bool fixed_radar_13365177 = 10;
inline bool CommandHistory::_internal_has_fixed_radar_13365177() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandHistory::has_fixed_radar_13365177() const {
  return _internal_has_fixed_radar_13365177();
}
inline void CommandHistory::clear_fixed_radar_13365177() {
  _impl_.fixed_radar_13365177_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CommandHistory::_internal_fixed_radar_13365177() const {
  return _impl_.fixed_radar_13365177_;
}
inline bool CommandHistory::fixed_radar_13365177() const {
  // @@protoc_insertion_point(field_get:TSK.CommandHistory.fixed_radar_13365177)
  return _internal_fixed_radar_13365177();
}
inline void CommandHistory::_internal_set_fixed_radar_13365177(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fixed_radar_13365177_ = value;
}
inline void CommandHistory::set_fixed_radar_13365177(bool value) {
  _internal_set_fixed_radar_13365177(value);
  // @@protoc_insertion_point(field_set:TSK.CommandHistory.fixed_radar_13365177)
}

// -------------------------------------------------------------------

// DocumentArchive

// optional string locale_identifier = 4;
inline bool DocumentArchive::_internal_has_locale_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentArchive::has_locale_identifier() const {
  return _internal_has_locale_identifier();
}
inline void DocumentArchive::clear_locale_identifier() {
  _impl_.locale_identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentArchive::locale_identifier() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentArchive.locale_identifier)
  return _internal_locale_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentArchive::set_locale_identifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.locale_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.DocumentArchive.locale_identifier)
}
inline std::string* DocumentArchive::mutable_locale_identifier() {
  std::string* _s = _internal_mutable_locale_identifier();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentArchive.locale_identifier)
  return _s;
}
inline const std::string& DocumentArchive::_internal_locale_identifier() const {
  return _impl_.locale_identifier_.Get();
}
inline void DocumentArchive::_internal_set_locale_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.locale_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentArchive::_internal_mutable_locale_identifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.locale_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentArchive::release_locale_identifier() {
  // @@protoc_insertion_point(field_release:TSK.DocumentArchive.locale_identifier)
  if (!_internal_has_locale_identifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.locale_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.locale_identifier_.IsDefault()) {
    _impl_.locale_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentArchive::set_allocated_locale_identifier(std::string* locale_identifier) {
  if (locale_identifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.locale_identifier_.SetAllocated(locale_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.locale_identifier_.IsDefault()) {
    _impl_.locale_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentArchive.locale_identifier)
}

// optional .TSP.Reference annotation_author_storage = 7;
inline bool DocumentArchive::_internal_has_annotation_author_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.annotation_author_storage_ != nullptr);
  return value;
}
inline bool DocumentArchive::has_annotation_author_storage() const {
  return _internal_has_annotation_author_storage();
}
inline const ::TSP::Reference& DocumentArchive::_internal_annotation_author_storage() const {
  const ::TSP::Reference* p = _impl_.annotation_author_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentArchive::annotation_author_storage() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentArchive.annotation_author_storage)
  return _internal_annotation_author_storage();
}
inline void DocumentArchive::unsafe_arena_set_allocated_annotation_author_storage(
    ::TSP::Reference* annotation_author_storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_storage_);
  }
  _impl_.annotation_author_storage_ = annotation_author_storage;
  if (annotation_author_storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.DocumentArchive.annotation_author_storage)
}
inline ::TSP::Reference* DocumentArchive::release_annotation_author_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.annotation_author_storage_;
  _impl_.annotation_author_storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentArchive::unsafe_arena_release_annotation_author_storage() {
  // @@protoc_insertion_point(field_release:TSK.DocumentArchive.annotation_author_storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.annotation_author_storage_;
  _impl_.annotation_author_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentArchive::_internal_mutable_annotation_author_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.annotation_author_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.annotation_author_storage_ = p;
  }
  return _impl_.annotation_author_storage_;
}
inline ::TSP::Reference* DocumentArchive::mutable_annotation_author_storage() {
  ::TSP::Reference* _msg = _internal_mutable_annotation_author_storage();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentArchive.annotation_author_storage)
  return _msg;
}
inline void DocumentArchive::set_allocated_annotation_author_storage(::TSP::Reference* annotation_author_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_storage_);
  }
  if (annotation_author_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_author_storage));
    if (message_arena != submessage_arena) {
      annotation_author_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_author_storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.annotation_author_storage_ = annotation_author_storage;
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentArchive.annotation_author_storage)
}

// -------------------------------------------------------------------

// DocumentSupportArchive

// optional .TSP.Reference command_history = 1;
inline bool DocumentSupportArchive::_internal_has_command_history() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.command_history_ != nullptr);
  return value;
}
inline bool DocumentSupportArchive::has_command_history() const {
  return _internal_has_command_history();
}
inline const ::TSP::Reference& DocumentSupportArchive::_internal_command_history() const {
  const ::TSP::Reference* p = _impl_.command_history_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentSupportArchive::command_history() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.command_history)
  return _internal_command_history();
}
inline void DocumentSupportArchive::unsafe_arena_set_allocated_command_history(
    ::TSP::Reference* command_history) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_history_);
  }
  _impl_.command_history_ = command_history;
  if (command_history) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.DocumentSupportArchive.command_history)
}
inline ::TSP::Reference* DocumentSupportArchive::release_command_history() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.command_history_;
  _impl_.command_history_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::unsafe_arena_release_command_history() {
  // @@protoc_insertion_point(field_release:TSK.DocumentSupportArchive.command_history)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.command_history_;
  _impl_.command_history_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::_internal_mutable_command_history() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.command_history_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.command_history_ = p;
  }
  return _impl_.command_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_command_history() {
  ::TSP::Reference* _msg = _internal_mutable_command_history();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentSupportArchive.command_history)
  return _msg;
}
inline void DocumentSupportArchive::set_allocated_command_history(::TSP::Reference* command_history) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_history_);
  }
  if (command_history) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_history));
    if (message_arena != submessage_arena) {
      command_history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command_history, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.command_history_ = command_history;
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentSupportArchive.command_history)
}

// optional .TSP.Reference command_selection_behavior_history = 2;
inline bool DocumentSupportArchive::_internal_has_command_selection_behavior_history() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.command_selection_behavior_history_ != nullptr);
  return value;
}
inline bool DocumentSupportArchive::has_command_selection_behavior_history() const {
  return _internal_has_command_selection_behavior_history();
}
inline const ::TSP::Reference& DocumentSupportArchive::_internal_command_selection_behavior_history() const {
  const ::TSP::Reference* p = _impl_.command_selection_behavior_history_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentSupportArchive::command_selection_behavior_history() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.command_selection_behavior_history)
  return _internal_command_selection_behavior_history();
}
inline void DocumentSupportArchive::unsafe_arena_set_allocated_command_selection_behavior_history(
    ::TSP::Reference* command_selection_behavior_history) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_selection_behavior_history_);
  }
  _impl_.command_selection_behavior_history_ = command_selection_behavior_history;
  if (command_selection_behavior_history) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.DocumentSupportArchive.command_selection_behavior_history)
}
inline ::TSP::Reference* DocumentSupportArchive::release_command_selection_behavior_history() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.command_selection_behavior_history_;
  _impl_.command_selection_behavior_history_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::unsafe_arena_release_command_selection_behavior_history() {
  // @@protoc_insertion_point(field_release:TSK.DocumentSupportArchive.command_selection_behavior_history)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.command_selection_behavior_history_;
  _impl_.command_selection_behavior_history_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::_internal_mutable_command_selection_behavior_history() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.command_selection_behavior_history_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.command_selection_behavior_history_ = p;
  }
  return _impl_.command_selection_behavior_history_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_command_selection_behavior_history() {
  ::TSP::Reference* _msg = _internal_mutable_command_selection_behavior_history();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentSupportArchive.command_selection_behavior_history)
  return _msg;
}
inline void DocumentSupportArchive::set_allocated_command_selection_behavior_history(::TSP::Reference* command_selection_behavior_history) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_selection_behavior_history_);
  }
  if (command_selection_behavior_history) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_selection_behavior_history));
    if (message_arena != submessage_arena) {
      command_selection_behavior_history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command_selection_behavior_history, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.command_selection_behavior_history_ = command_selection_behavior_history;
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentSupportArchive.command_selection_behavior_history)
}

// optional uint32 undo_count = 4;
inline bool DocumentSupportArchive::_internal_has_undo_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DocumentSupportArchive::has_undo_count() const {
  return _internal_has_undo_count();
}
inline void DocumentSupportArchive::clear_undo_count() {
  _impl_.undo_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t DocumentSupportArchive::_internal_undo_count() const {
  return _impl_.undo_count_;
}
inline uint32_t DocumentSupportArchive::undo_count() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.undo_count)
  return _internal_undo_count();
}
inline void DocumentSupportArchive::_internal_set_undo_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.undo_count_ = value;
}
inline void DocumentSupportArchive::set_undo_count(uint32_t value) {
  _internal_set_undo_count(value);
  // @@protoc_insertion_point(field_set:TSK.DocumentSupportArchive.undo_count)
}

// optional uint32 redo_count = 5;
inline bool DocumentSupportArchive::_internal_has_redo_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DocumentSupportArchive::has_redo_count() const {
  return _internal_has_redo_count();
}
inline void DocumentSupportArchive::clear_redo_count() {
  _impl_.redo_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t DocumentSupportArchive::_internal_redo_count() const {
  return _impl_.redo_count_;
}
inline uint32_t DocumentSupportArchive::redo_count() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.redo_count)
  return _internal_redo_count();
}
inline void DocumentSupportArchive::_internal_set_redo_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.redo_count_ = value;
}
inline void DocumentSupportArchive::set_redo_count(uint32_t value) {
  _internal_set_redo_count(value);
  // @@protoc_insertion_point(field_set:TSK.DocumentSupportArchive.redo_count)
}

// optional string undo_action_string = 6;
inline bool DocumentSupportArchive::_internal_has_undo_action_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocumentSupportArchive::has_undo_action_string() const {
  return _internal_has_undo_action_string();
}
inline void DocumentSupportArchive::clear_undo_action_string() {
  _impl_.undo_action_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocumentSupportArchive::undo_action_string() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.undo_action_string)
  return _internal_undo_action_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentSupportArchive::set_undo_action_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.undo_action_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.DocumentSupportArchive.undo_action_string)
}
inline std::string* DocumentSupportArchive::mutable_undo_action_string() {
  std::string* _s = _internal_mutable_undo_action_string();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentSupportArchive.undo_action_string)
  return _s;
}
inline const std::string& DocumentSupportArchive::_internal_undo_action_string() const {
  return _impl_.undo_action_string_.Get();
}
inline void DocumentSupportArchive::_internal_set_undo_action_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.undo_action_string_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentSupportArchive::_internal_mutable_undo_action_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.undo_action_string_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentSupportArchive::release_undo_action_string() {
  // @@protoc_insertion_point(field_release:TSK.DocumentSupportArchive.undo_action_string)
  if (!_internal_has_undo_action_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.undo_action_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undo_action_string_.IsDefault()) {
    _impl_.undo_action_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentSupportArchive::set_allocated_undo_action_string(std::string* undo_action_string) {
  if (undo_action_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.undo_action_string_.SetAllocated(undo_action_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.undo_action_string_.IsDefault()) {
    _impl_.undo_action_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentSupportArchive.undo_action_string)
}

// optional string redo_action_string = 7;
inline bool DocumentSupportArchive::_internal_has_redo_action_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocumentSupportArchive::has_redo_action_string() const {
  return _internal_has_redo_action_string();
}
inline void DocumentSupportArchive::clear_redo_action_string() {
  _impl_.redo_action_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DocumentSupportArchive::redo_action_string() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.redo_action_string)
  return _internal_redo_action_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocumentSupportArchive::set_redo_action_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.redo_action_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.DocumentSupportArchive.redo_action_string)
}
inline std::string* DocumentSupportArchive::mutable_redo_action_string() {
  std::string* _s = _internal_mutable_redo_action_string();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentSupportArchive.redo_action_string)
  return _s;
}
inline const std::string& DocumentSupportArchive::_internal_redo_action_string() const {
  return _impl_.redo_action_string_.Get();
}
inline void DocumentSupportArchive::_internal_set_redo_action_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.redo_action_string_.Set(value, GetArenaForAllocation());
}
inline std::string* DocumentSupportArchive::_internal_mutable_redo_action_string() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.redo_action_string_.Mutable(GetArenaForAllocation());
}
inline std::string* DocumentSupportArchive::release_redo_action_string() {
  // @@protoc_insertion_point(field_release:TSK.DocumentSupportArchive.redo_action_string)
  if (!_internal_has_redo_action_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.redo_action_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.redo_action_string_.IsDefault()) {
    _impl_.redo_action_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocumentSupportArchive::set_allocated_redo_action_string(std::string* redo_action_string) {
  if (redo_action_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.redo_action_string_.SetAllocated(redo_action_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.redo_action_string_.IsDefault()) {
    _impl_.redo_action_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentSupportArchive.redo_action_string)
}

// optional .TSP.Reference web_state = 8;
inline bool DocumentSupportArchive::_internal_has_web_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.web_state_ != nullptr);
  return value;
}
inline bool DocumentSupportArchive::has_web_state() const {
  return _internal_has_web_state();
}
inline const ::TSP::Reference& DocumentSupportArchive::_internal_web_state() const {
  const ::TSP::Reference* p = _impl_.web_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DocumentSupportArchive::web_state() const {
  // @@protoc_insertion_point(field_get:TSK.DocumentSupportArchive.web_state)
  return _internal_web_state();
}
inline void DocumentSupportArchive::unsafe_arena_set_allocated_web_state(
    ::TSP::Reference* web_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_state_);
  }
  _impl_.web_state_ = web_state;
  if (web_state) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.DocumentSupportArchive.web_state)
}
inline ::TSP::Reference* DocumentSupportArchive::release_web_state() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.web_state_;
  _impl_.web_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::unsafe_arena_release_web_state() {
  // @@protoc_insertion_point(field_release:TSK.DocumentSupportArchive.web_state)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.web_state_;
  _impl_.web_state_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DocumentSupportArchive::_internal_mutable_web_state() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.web_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.web_state_ = p;
  }
  return _impl_.web_state_;
}
inline ::TSP::Reference* DocumentSupportArchive::mutable_web_state() {
  ::TSP::Reference* _msg = _internal_mutable_web_state();
  // @@protoc_insertion_point(field_mutable:TSK.DocumentSupportArchive.web_state)
  return _msg;
}
inline void DocumentSupportArchive::set_allocated_web_state(::TSP::Reference* web_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_state_);
  }
  if (web_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_state));
    if (message_arena != submessage_arena) {
      web_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.web_state_ = web_state;
  // @@protoc_insertion_point(field_set_allocated:TSK.DocumentSupportArchive.web_state)
}

// -------------------------------------------------------------------

// ViewStateArchive

// required .TSP.Reference view_state_root = 1;
inline bool ViewStateArchive::_internal_has_view_state_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.view_state_root_ != nullptr);
  return value;
}
inline bool ViewStateArchive::has_view_state_root() const {
  return _internal_has_view_state_root();
}
inline const ::TSP::Reference& ViewStateArchive::_internal_view_state_root() const {
  const ::TSP::Reference* p = _impl_.view_state_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ViewStateArchive::view_state_root() const {
  // @@protoc_insertion_point(field_get:TSK.ViewStateArchive.view_state_root)
  return _internal_view_state_root();
}
inline void ViewStateArchive::unsafe_arena_set_allocated_view_state_root(
    ::TSP::Reference* view_state_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_state_root_);
  }
  _impl_.view_state_root_ = view_state_root;
  if (view_state_root) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.ViewStateArchive.view_state_root)
}
inline ::TSP::Reference* ViewStateArchive::release_view_state_root() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.view_state_root_;
  _impl_.view_state_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ViewStateArchive::unsafe_arena_release_view_state_root() {
  // @@protoc_insertion_point(field_release:TSK.ViewStateArchive.view_state_root)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.view_state_root_;
  _impl_.view_state_root_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ViewStateArchive::_internal_mutable_view_state_root() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.view_state_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.view_state_root_ = p;
  }
  return _impl_.view_state_root_;
}
inline ::TSP::Reference* ViewStateArchive::mutable_view_state_root() {
  ::TSP::Reference* _msg = _internal_mutable_view_state_root();
  // @@protoc_insertion_point(field_mutable:TSK.ViewStateArchive.view_state_root)
  return _msg;
}
inline void ViewStateArchive::set_allocated_view_state_root(::TSP::Reference* view_state_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.view_state_root_);
  }
  if (view_state_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(view_state_root));
    if (message_arena != submessage_arena) {
      view_state_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_state_root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.view_state_root_ = view_state_root;
  // @@protoc_insertion_point(field_set_allocated:TSK.ViewStateArchive.view_state_root)
}

// -------------------------------------------------------------------

// CommandArchive

// optional .TSP.Reference undoRedoState = 1;
inline bool CommandArchive::_internal_has_undoredostate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undoredostate_ != nullptr);
  return value;
}
inline bool CommandArchive::has_undoredostate() const {
  return _internal_has_undoredostate();
}
inline const ::TSP::Reference& CommandArchive::_internal_undoredostate() const {
  const ::TSP::Reference* p = _impl_.undoredostate_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommandArchive::undoredostate() const {
  // @@protoc_insertion_point(field_get:TSK.CommandArchive.undoRedoState)
  return _internal_undoredostate();
}
inline void CommandArchive::unsafe_arena_set_allocated_undoredostate(
    ::TSP::Reference* undoredostate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undoredostate_);
  }
  _impl_.undoredostate_ = undoredostate;
  if (undoredostate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandArchive.undoRedoState)
}
inline ::TSP::Reference* CommandArchive::release_undoredostate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.undoredostate_;
  _impl_.undoredostate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommandArchive::unsafe_arena_release_undoredostate() {
  // @@protoc_insertion_point(field_release:TSK.CommandArchive.undoRedoState)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.undoredostate_;
  _impl_.undoredostate_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommandArchive::_internal_mutable_undoredostate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.undoredostate_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.undoredostate_ = p;
  }
  return _impl_.undoredostate_;
}
inline ::TSP::Reference* CommandArchive::mutable_undoredostate() {
  ::TSP::Reference* _msg = _internal_mutable_undoredostate();
  // @@protoc_insertion_point(field_mutable:TSK.CommandArchive.undoRedoState)
  return _msg;
}
inline void CommandArchive::set_allocated_undoredostate(::TSP::Reference* undoredostate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undoredostate_);
  }
  if (undoredostate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undoredostate));
    if (message_arena != submessage_arena) {
      undoredostate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undoredostate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.undoredostate_ = undoredostate;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandArchive.undoRedoState)
}

// optional .TSP.Reference undoCollection = 2;
inline bool CommandArchive::_internal_has_undocollection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undocollection_ != nullptr);
  return value;
}
inline bool CommandArchive::has_undocollection() const {
  return _internal_has_undocollection();
}
inline const ::TSP::Reference& CommandArchive::_internal_undocollection() const {
  const ::TSP::Reference* p = _impl_.undocollection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommandArchive::undocollection() const {
  // @@protoc_insertion_point(field_get:TSK.CommandArchive.undoCollection)
  return _internal_undocollection();
}
inline void CommandArchive::unsafe_arena_set_allocated_undocollection(
    ::TSP::Reference* undocollection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undocollection_);
  }
  _impl_.undocollection_ = undocollection;
  if (undocollection) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandArchive.undoCollection)
}
inline ::TSP::Reference* CommandArchive::release_undocollection() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.undocollection_;
  _impl_.undocollection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommandArchive::unsafe_arena_release_undocollection() {
  // @@protoc_insertion_point(field_release:TSK.CommandArchive.undoCollection)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.undocollection_;
  _impl_.undocollection_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommandArchive::_internal_mutable_undocollection() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.undocollection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.undocollection_ = p;
  }
  return _impl_.undocollection_;
}
inline ::TSP::Reference* CommandArchive::mutable_undocollection() {
  ::TSP::Reference* _msg = _internal_mutable_undocollection();
  // @@protoc_insertion_point(field_mutable:TSK.CommandArchive.undoCollection)
  return _msg;
}
inline void CommandArchive::set_allocated_undocollection(::TSP::Reference* undocollection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undocollection_);
  }
  if (undocollection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undocollection));
    if (message_arena != submessage_arena) {
      undocollection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undocollection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.undocollection_ = undocollection;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandArchive.undoCollection)
}

// -------------------------------------------------------------------

// CommandGroupArchive

// required .TSK.CommandArchive super = 1;
inline bool CommandGroupArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool CommandGroupArchive::has_super() const {
  return _internal_has_super();
}
inline void CommandGroupArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::CommandArchive& CommandGroupArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& CommandGroupArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.CommandGroupArchive.super)
  return _internal_super();
}
inline void CommandGroupArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandGroupArchive.super)
}
inline ::TSK::CommandArchive* CommandGroupArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* CommandGroupArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.CommandGroupArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* CommandGroupArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* CommandGroupArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.CommandGroupArchive.super)
  return _msg;
}
inline void CommandGroupArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandGroupArchive.super)
}

// repeated .TSP.Reference commands = 2;
inline int CommandGroupArchive::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int CommandGroupArchive::commands_size() const {
  return _internal_commands_size();
}
inline ::TSP::Reference* CommandGroupArchive::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CommandGroupArchive.commands)
  return _impl_.commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CommandGroupArchive::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CommandGroupArchive.commands)
  return &_impl_.commands_;
}
inline const ::TSP::Reference& CommandGroupArchive::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const ::TSP::Reference& CommandGroupArchive::commands(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CommandGroupArchive.commands)
  return _internal_commands(index);
}
inline ::TSP::Reference* CommandGroupArchive::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline ::TSP::Reference* CommandGroupArchive::add_commands() {
  ::TSP::Reference* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:TSK.CommandGroupArchive.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CommandGroupArchive::commands() const {
  // @@protoc_insertion_point(field_list:TSK.CommandGroupArchive.commands)
  return _impl_.commands_;
}

// optional .TSP.IndexSet process_results = 3;
inline bool CommandGroupArchive::_internal_has_process_results() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.process_results_ != nullptr);
  return value;
}
inline bool CommandGroupArchive::has_process_results() const {
  return _internal_has_process_results();
}
inline const ::TSP::IndexSet& CommandGroupArchive::_internal_process_results() const {
  const ::TSP::IndexSet* p = _impl_.process_results_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::IndexSet&>(
      ::TSP::_IndexSet_default_instance_);
}
inline const ::TSP::IndexSet& CommandGroupArchive::process_results() const {
  // @@protoc_insertion_point(field_get:TSK.CommandGroupArchive.process_results)
  return _internal_process_results();
}
inline void CommandGroupArchive::unsafe_arena_set_allocated_process_results(
    ::TSP::IndexSet* process_results) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_results_);
  }
  _impl_.process_results_ = process_results;
  if (process_results) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandGroupArchive.process_results)
}
inline ::TSP::IndexSet* CommandGroupArchive::release_process_results() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::IndexSet* temp = _impl_.process_results_;
  _impl_.process_results_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::IndexSet* CommandGroupArchive::unsafe_arena_release_process_results() {
  // @@protoc_insertion_point(field_release:TSK.CommandGroupArchive.process_results)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::IndexSet* temp = _impl_.process_results_;
  _impl_.process_results_ = nullptr;
  return temp;
}
inline ::TSP::IndexSet* CommandGroupArchive::_internal_mutable_process_results() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.process_results_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::IndexSet>(GetArenaForAllocation());
    _impl_.process_results_ = p;
  }
  return _impl_.process_results_;
}
inline ::TSP::IndexSet* CommandGroupArchive::mutable_process_results() {
  ::TSP::IndexSet* _msg = _internal_mutable_process_results();
  // @@protoc_insertion_point(field_mutable:TSK.CommandGroupArchive.process_results)
  return _msg;
}
inline void CommandGroupArchive::set_allocated_process_results(::TSP::IndexSet* process_results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.process_results_);
  }
  if (process_results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(process_results));
    if (message_arena != submessage_arena) {
      process_results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, process_results, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.process_results_ = process_results;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandGroupArchive.process_results)
}

// -------------------------------------------------------------------

// CommandContainerArchive

// repeated .TSP.Reference commands = 1;
inline int CommandContainerArchive::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int CommandContainerArchive::commands_size() const {
  return _internal_commands_size();
}
inline ::TSP::Reference* CommandContainerArchive::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CommandContainerArchive.commands)
  return _impl_.commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
CommandContainerArchive::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CommandContainerArchive.commands)
  return &_impl_.commands_;
}
inline const ::TSP::Reference& CommandContainerArchive::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const ::TSP::Reference& CommandContainerArchive::commands(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CommandContainerArchive.commands)
  return _internal_commands(index);
}
inline ::TSP::Reference* CommandContainerArchive::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline ::TSP::Reference* CommandContainerArchive::add_commands() {
  ::TSP::Reference* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:TSK.CommandContainerArchive.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
CommandContainerArchive::commands() const {
  // @@protoc_insertion_point(field_list:TSK.CommandContainerArchive.commands)
  return _impl_.commands_;
}

// -------------------------------------------------------------------

// ReplaceAllChildCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ReplaceAllChildCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReplaceAllChildCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void ReplaceAllChildCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::CommandArchive& ReplaceAllChildCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ReplaceAllChildCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllChildCommandArchive.super)
  return _internal_super();
}
inline void ReplaceAllChildCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.ReplaceAllChildCommandArchive.super)
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.ReplaceAllChildCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ReplaceAllChildCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.ReplaceAllChildCommandArchive.super)
  return _msg;
}
inline void ReplaceAllChildCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.ReplaceAllChildCommandArchive.super)
}

// -------------------------------------------------------------------

// ReplaceAllCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool ReplaceAllCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReplaceAllCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void ReplaceAllCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSK::CommandArchive& ReplaceAllCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& ReplaceAllCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllCommandArchive.super)
  return _internal_super();
}
inline void ReplaceAllCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.ReplaceAllCommandArchive.super)
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.ReplaceAllCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* ReplaceAllCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.ReplaceAllCommandArchive.super)
  return _msg;
}
inline void ReplaceAllCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.ReplaceAllCommandArchive.super)
}

// repeated .TSP.Reference commands = 2;
inline int ReplaceAllCommandArchive::_internal_commands_size() const {
  return _impl_.commands_.size();
}
inline int ReplaceAllCommandArchive::commands_size() const {
  return _internal_commands_size();
}
inline ::TSP::Reference* ReplaceAllCommandArchive::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.ReplaceAllCommandArchive.commands)
  return _impl_.commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ReplaceAllCommandArchive::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:TSK.ReplaceAllCommandArchive.commands)
  return &_impl_.commands_;
}
inline const ::TSP::Reference& ReplaceAllCommandArchive::_internal_commands(int index) const {
  return _impl_.commands_.Get(index);
}
inline const ::TSP::Reference& ReplaceAllCommandArchive::commands(int index) const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllCommandArchive.commands)
  return _internal_commands(index);
}
inline ::TSP::Reference* ReplaceAllCommandArchive::_internal_add_commands() {
  return _impl_.commands_.Add();
}
inline ::TSP::Reference* ReplaceAllCommandArchive::add_commands() {
  ::TSP::Reference* _add = _internal_add_commands();
  // @@protoc_insertion_point(field_add:TSK.ReplaceAllCommandArchive.commands)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ReplaceAllCommandArchive::commands() const {
  // @@protoc_insertion_point(field_list:TSK.ReplaceAllCommandArchive.commands)
  return _impl_.commands_;
}

// required string find_string = 3;
inline bool ReplaceAllCommandArchive::_internal_has_find_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplaceAllCommandArchive::has_find_string() const {
  return _internal_has_find_string();
}
inline void ReplaceAllCommandArchive::clear_find_string() {
  _impl_.find_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplaceAllCommandArchive::find_string() const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllCommandArchive.find_string)
  return _internal_find_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplaceAllCommandArchive::set_find_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.find_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.ReplaceAllCommandArchive.find_string)
}
inline std::string* ReplaceAllCommandArchive::mutable_find_string() {
  std::string* _s = _internal_mutable_find_string();
  // @@protoc_insertion_point(field_mutable:TSK.ReplaceAllCommandArchive.find_string)
  return _s;
}
inline const std::string& ReplaceAllCommandArchive::_internal_find_string() const {
  return _impl_.find_string_.Get();
}
inline void ReplaceAllCommandArchive::_internal_set_find_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.find_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplaceAllCommandArchive::_internal_mutable_find_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.find_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplaceAllCommandArchive::release_find_string() {
  // @@protoc_insertion_point(field_release:TSK.ReplaceAllCommandArchive.find_string)
  if (!_internal_has_find_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.find_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.find_string_.IsDefault()) {
    _impl_.find_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReplaceAllCommandArchive::set_allocated_find_string(std::string* find_string) {
  if (find_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.find_string_.SetAllocated(find_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.find_string_.IsDefault()) {
    _impl_.find_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.ReplaceAllCommandArchive.find_string)
}

// required string replace_string = 4;
inline bool ReplaceAllCommandArchive::_internal_has_replace_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplaceAllCommandArchive::has_replace_string() const {
  return _internal_has_replace_string();
}
inline void ReplaceAllCommandArchive::clear_replace_string() {
  _impl_.replace_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReplaceAllCommandArchive::replace_string() const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllCommandArchive.replace_string)
  return _internal_replace_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplaceAllCommandArchive::set_replace_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.replace_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.ReplaceAllCommandArchive.replace_string)
}
inline std::string* ReplaceAllCommandArchive::mutable_replace_string() {
  std::string* _s = _internal_mutable_replace_string();
  // @@protoc_insertion_point(field_mutable:TSK.ReplaceAllCommandArchive.replace_string)
  return _s;
}
inline const std::string& ReplaceAllCommandArchive::_internal_replace_string() const {
  return _impl_.replace_string_.Get();
}
inline void ReplaceAllCommandArchive::_internal_set_replace_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.replace_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplaceAllCommandArchive::_internal_mutable_replace_string() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.replace_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplaceAllCommandArchive::release_replace_string() {
  // @@protoc_insertion_point(field_release:TSK.ReplaceAllCommandArchive.replace_string)
  if (!_internal_has_replace_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.replace_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.replace_string_.IsDefault()) {
    _impl_.replace_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReplaceAllCommandArchive::set_allocated_replace_string(std::string* replace_string) {
  if (replace_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.replace_string_.SetAllocated(replace_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.replace_string_.IsDefault()) {
    _impl_.replace_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.ReplaceAllCommandArchive.replace_string)
}

// required uint32 options = 5;
inline bool ReplaceAllCommandArchive::_internal_has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReplaceAllCommandArchive::has_options() const {
  return _internal_has_options();
}
inline void ReplaceAllCommandArchive::clear_options() {
  _impl_.options_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ReplaceAllCommandArchive::_internal_options() const {
  return _impl_.options_;
}
inline uint32_t ReplaceAllCommandArchive::options() const {
  // @@protoc_insertion_point(field_get:TSK.ReplaceAllCommandArchive.options)
  return _internal_options();
}
inline void ReplaceAllCommandArchive::_internal_set_options(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.options_ = value;
}
inline void ReplaceAllCommandArchive::set_options(uint32_t value) {
  _internal_set_options(value);
  // @@protoc_insertion_point(field_set:TSK.ReplaceAllCommandArchive.options)
}

// -------------------------------------------------------------------

// ShuffleMappingArchive_Entry

// required uint32 from = 1;
inline bool ShuffleMappingArchive_Entry::_internal_has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShuffleMappingArchive_Entry::has_from() const {
  return _internal_has_from();
}
inline void ShuffleMappingArchive_Entry::clear_from() {
  _impl_.from_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ShuffleMappingArchive_Entry::_internal_from() const {
  return _impl_.from_;
}
inline uint32_t ShuffleMappingArchive_Entry::from() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.Entry.from)
  return _internal_from();
}
inline void ShuffleMappingArchive_Entry::_internal_set_from(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_ = value;
}
inline void ShuffleMappingArchive_Entry::set_from(uint32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.Entry.from)
}

// required uint32 to = 2;
inline bool ShuffleMappingArchive_Entry::_internal_has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShuffleMappingArchive_Entry::has_to() const {
  return _internal_has_to();
}
inline void ShuffleMappingArchive_Entry::clear_to() {
  _impl_.to_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ShuffleMappingArchive_Entry::_internal_to() const {
  return _impl_.to_;
}
inline uint32_t ShuffleMappingArchive_Entry::to() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.Entry.to)
  return _internal_to();
}
inline void ShuffleMappingArchive_Entry::_internal_set_to(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_ = value;
}
inline void ShuffleMappingArchive_Entry::set_to(uint32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.Entry.to)
}

// -------------------------------------------------------------------

// ShuffleMappingArchive

// required uint32 start_index = 1;
inline bool ShuffleMappingArchive::_internal_has_start_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_start_index() const {
  return _internal_has_start_index();
}
inline void ShuffleMappingArchive::clear_start_index() {
  _impl_.start_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ShuffleMappingArchive::_internal_start_index() const {
  return _impl_.start_index_;
}
inline uint32_t ShuffleMappingArchive::start_index() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.start_index)
  return _internal_start_index();
}
inline void ShuffleMappingArchive::_internal_set_start_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_index_ = value;
}
inline void ShuffleMappingArchive::set_start_index(uint32_t value) {
  _internal_set_start_index(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.start_index)
}

// required uint32 end_index = 2;
inline bool ShuffleMappingArchive::_internal_has_end_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_end_index() const {
  return _internal_has_end_index();
}
inline void ShuffleMappingArchive::clear_end_index() {
  _impl_.end_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ShuffleMappingArchive::_internal_end_index() const {
  return _impl_.end_index_;
}
inline uint32_t ShuffleMappingArchive::end_index() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.end_index)
  return _internal_end_index();
}
inline void ShuffleMappingArchive::_internal_set_end_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_index_ = value;
}
inline void ShuffleMappingArchive::set_end_index(uint32_t value) {
  _internal_set_end_index(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.end_index)
}

// repeated .TSK.ShuffleMappingArchive.Entry entries = 3;
inline int ShuffleMappingArchive::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int ShuffleMappingArchive::entries_size() const {
  return _internal_entries_size();
}
inline void ShuffleMappingArchive::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::TSK::ShuffleMappingArchive_Entry* ShuffleMappingArchive::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.ShuffleMappingArchive.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >*
ShuffleMappingArchive::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TSK.ShuffleMappingArchive.entries)
  return &_impl_.entries_;
}
inline const ::TSK::ShuffleMappingArchive_Entry& ShuffleMappingArchive::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::TSK::ShuffleMappingArchive_Entry& ShuffleMappingArchive::entries(int index) const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.entries)
  return _internal_entries(index);
}
inline ::TSK::ShuffleMappingArchive_Entry* ShuffleMappingArchive::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::TSK::ShuffleMappingArchive_Entry* ShuffleMappingArchive::add_entries() {
  ::TSK::ShuffleMappingArchive_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:TSK.ShuffleMappingArchive.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::ShuffleMappingArchive_Entry >&
ShuffleMappingArchive::entries() const {
  // @@protoc_insertion_point(field_list:TSK.ShuffleMappingArchive.entries)
  return _impl_.entries_;
}

// optional bool is_vertical = 4 [default = true];
inline bool ShuffleMappingArchive::_internal_has_is_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_is_vertical() const {
  return _internal_has_is_vertical();
}
inline void ShuffleMappingArchive::clear_is_vertical() {
  _impl_.is_vertical_ = true;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool ShuffleMappingArchive::_internal_is_vertical() const {
  return _impl_.is_vertical_;
}
inline bool ShuffleMappingArchive::is_vertical() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.is_vertical)
  return _internal_is_vertical();
}
inline void ShuffleMappingArchive::_internal_set_is_vertical(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_vertical_ = value;
}
inline void ShuffleMappingArchive::set_is_vertical(bool value) {
  _internal_set_is_vertical(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.is_vertical)
}

// optional bool is_move_operation = 5 [default = false];
inline bool ShuffleMappingArchive::_internal_has_is_move_operation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_is_move_operation() const {
  return _internal_has_is_move_operation();
}
inline void ShuffleMappingArchive::clear_is_move_operation() {
  _impl_.is_move_operation_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ShuffleMappingArchive::_internal_is_move_operation() const {
  return _impl_.is_move_operation_;
}
inline bool ShuffleMappingArchive::is_move_operation() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.is_move_operation)
  return _internal_is_move_operation();
}
inline void ShuffleMappingArchive::_internal_set_is_move_operation(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_move_operation_ = value;
}
inline void ShuffleMappingArchive::set_is_move_operation(bool value) {
  _internal_set_is_move_operation(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.is_move_operation)
}

// optional uint32 first_moved_index = 6 [default = 0];
inline bool ShuffleMappingArchive::_internal_has_first_moved_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_first_moved_index() const {
  return _internal_has_first_moved_index();
}
inline void ShuffleMappingArchive::clear_first_moved_index() {
  _impl_.first_moved_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShuffleMappingArchive::_internal_first_moved_index() const {
  return _impl_.first_moved_index_;
}
inline uint32_t ShuffleMappingArchive::first_moved_index() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.first_moved_index)
  return _internal_first_moved_index();
}
inline void ShuffleMappingArchive::_internal_set_first_moved_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.first_moved_index_ = value;
}
inline void ShuffleMappingArchive::set_first_moved_index(uint32_t value) {
  _internal_set_first_moved_index(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.first_moved_index)
}

// optional uint32 destination_index_for_move = 7 [default = 0];
inline bool ShuffleMappingArchive::_internal_has_destination_index_for_move() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_destination_index_for_move() const {
  return _internal_has_destination_index_for_move();
}
inline void ShuffleMappingArchive::clear_destination_index_for_move() {
  _impl_.destination_index_for_move_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ShuffleMappingArchive::_internal_destination_index_for_move() const {
  return _impl_.destination_index_for_move_;
}
inline uint32_t ShuffleMappingArchive::destination_index_for_move() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.destination_index_for_move)
  return _internal_destination_index_for_move();
}
inline void ShuffleMappingArchive::_internal_set_destination_index_for_move(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.destination_index_for_move_ = value;
}
inline void ShuffleMappingArchive::set_destination_index_for_move(uint32_t value) {
  _internal_set_destination_index_for_move(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.destination_index_for_move)
}

// optional uint32 number_of_indices_moved = 8 [default = 0];
inline bool ShuffleMappingArchive::_internal_has_number_of_indices_moved() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShuffleMappingArchive::has_number_of_indices_moved() const {
  return _internal_has_number_of_indices_moved();
}
inline void ShuffleMappingArchive::clear_number_of_indices_moved() {
  _impl_.number_of_indices_moved_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ShuffleMappingArchive::_internal_number_of_indices_moved() const {
  return _impl_.number_of_indices_moved_;
}
inline uint32_t ShuffleMappingArchive::number_of_indices_moved() const {
  // @@protoc_insertion_point(field_get:TSK.ShuffleMappingArchive.number_of_indices_moved)
  return _internal_number_of_indices_moved();
}
inline void ShuffleMappingArchive::_internal_set_number_of_indices_moved(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.number_of_indices_moved_ = value;
}
inline void ShuffleMappingArchive::set_number_of_indices_moved(uint32_t value) {
  _internal_set_number_of_indices_moved(value);
  // @@protoc_insertion_point(field_set:TSK.ShuffleMappingArchive.number_of_indices_moved)
}

// -------------------------------------------------------------------

// ProgressiveCommandGroupArchive

// required .TSK.CommandGroupArchive super = 1;
inline bool ProgressiveCommandGroupArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ProgressiveCommandGroupArchive::has_super() const {
  return _internal_has_super();
}
inline void ProgressiveCommandGroupArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::CommandGroupArchive& ProgressiveCommandGroupArchive::_internal_super() const {
  const ::TSK::CommandGroupArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandGroupArchive&>(
      ::TSK::_CommandGroupArchive_default_instance_);
}
inline const ::TSK::CommandGroupArchive& ProgressiveCommandGroupArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.ProgressiveCommandGroupArchive.super)
  return _internal_super();
}
inline void ProgressiveCommandGroupArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandGroupArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.ProgressiveCommandGroupArchive.super)
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandGroupArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.ProgressiveCommandGroupArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandGroupArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandGroupArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandGroupArchive* ProgressiveCommandGroupArchive::mutable_super() {
  ::TSK::CommandGroupArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.ProgressiveCommandGroupArchive.super)
  return _msg;
}
inline void ProgressiveCommandGroupArchive::set_allocated_super(::TSK::CommandGroupArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.ProgressiveCommandGroupArchive.super)
}

// -------------------------------------------------------------------

// CommandSelectionBehaviorHistoryArchive_Entry

// required .TSP.Reference command = 1;
inline bool CommandSelectionBehaviorHistoryArchive_Entry::_internal_has_command() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.command_ != nullptr);
  return value;
}
inline bool CommandSelectionBehaviorHistoryArchive_Entry::has_command() const {
  return _internal_has_command();
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::_internal_command() const {
  const ::TSP::Reference* p = _impl_.command_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::command() const {
  // @@protoc_insertion_point(field_get:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command)
  return _internal_command();
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::unsafe_arena_set_allocated_command(
    ::TSP::Reference* command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_);
  }
  _impl_.command_ = command;
  if (command) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command)
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::release_command() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.command_;
  _impl_.command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.command_;
  _impl_.command_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::_internal_mutable_command() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.command_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.command_ = p;
  }
  return _impl_.command_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::mutable_command() {
  ::TSP::Reference* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command)
  return _msg;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_allocated_command(::TSP::Reference* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_);
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command));
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.command_ = command;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command)
}

// required .TSP.Reference command_selection_behavior = 2;
inline bool CommandSelectionBehaviorHistoryArchive_Entry::_internal_has_command_selection_behavior() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.command_selection_behavior_ != nullptr);
  return value;
}
inline bool CommandSelectionBehaviorHistoryArchive_Entry::has_command_selection_behavior() const {
  return _internal_has_command_selection_behavior();
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::_internal_command_selection_behavior() const {
  const ::TSP::Reference* p = _impl_.command_selection_behavior_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& CommandSelectionBehaviorHistoryArchive_Entry::command_selection_behavior() const {
  // @@protoc_insertion_point(field_get:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command_selection_behavior)
  return _internal_command_selection_behavior();
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::unsafe_arena_set_allocated_command_selection_behavior(
    ::TSP::Reference* command_selection_behavior) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_selection_behavior_);
  }
  _impl_.command_selection_behavior_ = command_selection_behavior;
  if (command_selection_behavior) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command_selection_behavior)
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::release_command_selection_behavior() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.command_selection_behavior_;
  _impl_.command_selection_behavior_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::unsafe_arena_release_command_selection_behavior() {
  // @@protoc_insertion_point(field_release:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command_selection_behavior)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.command_selection_behavior_;
  _impl_.command_selection_behavior_ = nullptr;
  return temp;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::_internal_mutable_command_selection_behavior() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.command_selection_behavior_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.command_selection_behavior_ = p;
  }
  return _impl_.command_selection_behavior_;
}
inline ::TSP::Reference* CommandSelectionBehaviorHistoryArchive_Entry::mutable_command_selection_behavior() {
  ::TSP::Reference* _msg = _internal_mutable_command_selection_behavior();
  // @@protoc_insertion_point(field_mutable:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command_selection_behavior)
  return _msg;
}
inline void CommandSelectionBehaviorHistoryArchive_Entry::set_allocated_command_selection_behavior(::TSP::Reference* command_selection_behavior) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.command_selection_behavior_);
  }
  if (command_selection_behavior) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_selection_behavior));
    if (message_arena != submessage_arena) {
      command_selection_behavior = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command_selection_behavior, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.command_selection_behavior_ = command_selection_behavior;
  // @@protoc_insertion_point(field_set_allocated:TSK.CommandSelectionBehaviorHistoryArchive.Entry.command_selection_behavior)
}

// -------------------------------------------------------------------

// CommandSelectionBehaviorHistoryArchive

// repeated .TSK.CommandSelectionBehaviorHistoryArchive.Entry entries = 1;
inline int CommandSelectionBehaviorHistoryArchive::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int CommandSelectionBehaviorHistoryArchive::entries_size() const {
  return _internal_entries_size();
}
inline void CommandSelectionBehaviorHistoryArchive::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* CommandSelectionBehaviorHistoryArchive::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CommandSelectionBehaviorHistoryArchive.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >*
CommandSelectionBehaviorHistoryArchive::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CommandSelectionBehaviorHistoryArchive.entries)
  return &_impl_.entries_;
}
inline const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& CommandSelectionBehaviorHistoryArchive::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::TSK::CommandSelectionBehaviorHistoryArchive_Entry& CommandSelectionBehaviorHistoryArchive::entries(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CommandSelectionBehaviorHistoryArchive.entries)
  return _internal_entries(index);
}
inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* CommandSelectionBehaviorHistoryArchive::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* CommandSelectionBehaviorHistoryArchive::add_entries() {
  ::TSK::CommandSelectionBehaviorHistoryArchive_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:TSK.CommandSelectionBehaviorHistoryArchive.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CommandSelectionBehaviorHistoryArchive_Entry >&
CommandSelectionBehaviorHistoryArchive::entries() const {
  // @@protoc_insertion_point(field_list:TSK.CommandSelectionBehaviorHistoryArchive.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// UndoRedoStateCommandSelectionBehaviorArchive

// optional .TSP.Reference undo_redo_state = 2;
inline bool UndoRedoStateCommandSelectionBehaviorArchive::_internal_has_undo_redo_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.undo_redo_state_ != nullptr);
  return value;
}
inline bool UndoRedoStateCommandSelectionBehaviorArchive::has_undo_redo_state() const {
  return _internal_has_undo_redo_state();
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::_internal_undo_redo_state() const {
  const ::TSP::Reference* p = _impl_.undo_redo_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& UndoRedoStateCommandSelectionBehaviorArchive::undo_redo_state() const {
  // @@protoc_insertion_point(field_get:TSK.UndoRedoStateCommandSelectionBehaviorArchive.undo_redo_state)
  return _internal_undo_redo_state();
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::unsafe_arena_set_allocated_undo_redo_state(
    ::TSP::Reference* undo_redo_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_redo_state_);
  }
  _impl_.undo_redo_state_ = undo_redo_state;
  if (undo_redo_state) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.UndoRedoStateCommandSelectionBehaviorArchive.undo_redo_state)
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::release_undo_redo_state() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.undo_redo_state_;
  _impl_.undo_redo_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::unsafe_arena_release_undo_redo_state() {
  // @@protoc_insertion_point(field_release:TSK.UndoRedoStateCommandSelectionBehaviorArchive.undo_redo_state)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.undo_redo_state_;
  _impl_.undo_redo_state_ = nullptr;
  return temp;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::_internal_mutable_undo_redo_state() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.undo_redo_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.undo_redo_state_ = p;
  }
  return _impl_.undo_redo_state_;
}
inline ::TSP::Reference* UndoRedoStateCommandSelectionBehaviorArchive::mutable_undo_redo_state() {
  ::TSP::Reference* _msg = _internal_mutable_undo_redo_state();
  // @@protoc_insertion_point(field_mutable:TSK.UndoRedoStateCommandSelectionBehaviorArchive.undo_redo_state)
  return _msg;
}
inline void UndoRedoStateCommandSelectionBehaviorArchive::set_allocated_undo_redo_state(::TSP::Reference* undo_redo_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.undo_redo_state_);
  }
  if (undo_redo_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(undo_redo_state));
    if (message_arena != submessage_arena) {
      undo_redo_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, undo_redo_state, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.undo_redo_state_ = undo_redo_state;
  // @@protoc_insertion_point(field_set_allocated:TSK.UndoRedoStateCommandSelectionBehaviorArchive.undo_redo_state)
}

// -------------------------------------------------------------------

// FormatStructArchive

// required uint32 format_type = 1;
inline bool FormatStructArchive::_internal_has_format_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FormatStructArchive::has_format_type() const {
  return _internal_has_format_type();
}
inline void FormatStructArchive::clear_format_type() {
  _impl_.format_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t FormatStructArchive::_internal_format_type() const {
  return _impl_.format_type_;
}
inline uint32_t FormatStructArchive::format_type() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.format_type)
  return _internal_format_type();
}
inline void FormatStructArchive::_internal_set_format_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.format_type_ = value;
}
inline void FormatStructArchive::set_format_type(uint32_t value) {
  _internal_set_format_type(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.format_type)
}

// optional uint32 decimal_places = 2;
inline bool FormatStructArchive::_internal_has_decimal_places() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FormatStructArchive::has_decimal_places() const {
  return _internal_has_decimal_places();
}
inline void FormatStructArchive::clear_decimal_places() {
  _impl_.decimal_places_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t FormatStructArchive::_internal_decimal_places() const {
  return _impl_.decimal_places_;
}
inline uint32_t FormatStructArchive::decimal_places() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.decimal_places)
  return _internal_decimal_places();
}
inline void FormatStructArchive::_internal_set_decimal_places(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.decimal_places_ = value;
}
inline void FormatStructArchive::set_decimal_places(uint32_t value) {
  _internal_set_decimal_places(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.decimal_places)
}

// optional string currency_code = 3;
inline bool FormatStructArchive::_internal_has_currency_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FormatStructArchive::has_currency_code() const {
  return _internal_has_currency_code();
}
inline void FormatStructArchive::clear_currency_code() {
  _impl_.currency_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FormatStructArchive::currency_code() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.currency_code)
  return _internal_currency_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormatStructArchive::set_currency_code(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currency_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.currency_code)
}
inline std::string* FormatStructArchive::mutable_currency_code() {
  std::string* _s = _internal_mutable_currency_code();
  // @@protoc_insertion_point(field_mutable:TSK.FormatStructArchive.currency_code)
  return _s;
}
inline const std::string& FormatStructArchive::_internal_currency_code() const {
  return _impl_.currency_code_.Get();
}
inline void FormatStructArchive::_internal_set_currency_code(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* FormatStructArchive::_internal_mutable_currency_code() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currency_code_.Mutable(GetArenaForAllocation());
}
inline std::string* FormatStructArchive::release_currency_code() {
  // @@protoc_insertion_point(field_release:TSK.FormatStructArchive.currency_code)
  if (!_internal_has_currency_code()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currency_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_code_.IsDefault()) {
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FormatStructArchive::set_allocated_currency_code(std::string* currency_code) {
  if (currency_code != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currency_code_.SetAllocated(currency_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currency_code_.IsDefault()) {
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.FormatStructArchive.currency_code)
}

// optional uint32 negative_style = 4;
inline bool FormatStructArchive::_internal_has_negative_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FormatStructArchive::has_negative_style() const {
  return _internal_has_negative_style();
}
inline void FormatStructArchive::clear_negative_style() {
  _impl_.negative_style_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t FormatStructArchive::_internal_negative_style() const {
  return _impl_.negative_style_;
}
inline uint32_t FormatStructArchive::negative_style() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.negative_style)
  return _internal_negative_style();
}
inline void FormatStructArchive::_internal_set_negative_style(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.negative_style_ = value;
}
inline void FormatStructArchive::set_negative_style(uint32_t value) {
  _internal_set_negative_style(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.negative_style)
}

// optional bool show_thousands_separator = 5;
inline bool FormatStructArchive::_internal_has_show_thousands_separator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FormatStructArchive::has_show_thousands_separator() const {
  return _internal_has_show_thousands_separator();
}
inline void FormatStructArchive::clear_show_thousands_separator() {
  _impl_.show_thousands_separator_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool FormatStructArchive::_internal_show_thousands_separator() const {
  return _impl_.show_thousands_separator_;
}
inline bool FormatStructArchive::show_thousands_separator() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.show_thousands_separator)
  return _internal_show_thousands_separator();
}
inline void FormatStructArchive::_internal_set_show_thousands_separator(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.show_thousands_separator_ = value;
}
inline void FormatStructArchive::set_show_thousands_separator(bool value) {
  _internal_set_show_thousands_separator(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.show_thousands_separator)
}

// optional bool use_accounting_style = 6;
inline bool FormatStructArchive::_internal_has_use_accounting_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FormatStructArchive::has_use_accounting_style() const {
  return _internal_has_use_accounting_style();
}
inline void FormatStructArchive::clear_use_accounting_style() {
  _impl_.use_accounting_style_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool FormatStructArchive::_internal_use_accounting_style() const {
  return _impl_.use_accounting_style_;
}
inline bool FormatStructArchive::use_accounting_style() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.use_accounting_style)
  return _internal_use_accounting_style();
}
inline void FormatStructArchive::_internal_set_use_accounting_style(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.use_accounting_style_ = value;
}
inline void FormatStructArchive::set_use_accounting_style(bool value) {
  _internal_set_use_accounting_style(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.use_accounting_style)
}

// optional uint32 duration_style = 7;
inline bool FormatStructArchive::_internal_has_duration_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FormatStructArchive::has_duration_style() const {
  return _internal_has_duration_style();
}
inline void FormatStructArchive::clear_duration_style() {
  _impl_.duration_style_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t FormatStructArchive::_internal_duration_style() const {
  return _impl_.duration_style_;
}
inline uint32_t FormatStructArchive::duration_style() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.duration_style)
  return _internal_duration_style();
}
inline void FormatStructArchive::_internal_set_duration_style(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.duration_style_ = value;
}
inline void FormatStructArchive::set_duration_style(uint32_t value) {
  _internal_set_duration_style(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.duration_style)
}

// optional uint32 base = 8;
inline bool FormatStructArchive::_internal_has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FormatStructArchive::has_base() const {
  return _internal_has_base();
}
inline void FormatStructArchive::clear_base() {
  _impl_.base_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t FormatStructArchive::_internal_base() const {
  return _impl_.base_;
}
inline uint32_t FormatStructArchive::base() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.base)
  return _internal_base();
}
inline void FormatStructArchive::_internal_set_base(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.base_ = value;
}
inline void FormatStructArchive::set_base(uint32_t value) {
  _internal_set_base(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.base)
}

// optional uint32 base_places = 9;
inline bool FormatStructArchive::_internal_has_base_places() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_base_places() const {
  return _internal_has_base_places();
}
inline void FormatStructArchive::clear_base_places() {
  _impl_.base_places_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t FormatStructArchive::_internal_base_places() const {
  return _impl_.base_places_;
}
inline uint32_t FormatStructArchive::base_places() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.base_places)
  return _internal_base_places();
}
inline void FormatStructArchive::_internal_set_base_places(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.base_places_ = value;
}
inline void FormatStructArchive::set_base_places(uint32_t value) {
  _internal_set_base_places(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.base_places)
}

// optional bool base_use_minus_sign = 10;
inline bool FormatStructArchive::_internal_has_base_use_minus_sign() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FormatStructArchive::has_base_use_minus_sign() const {
  return _internal_has_base_use_minus_sign();
}
inline void FormatStructArchive::clear_base_use_minus_sign() {
  _impl_.base_use_minus_sign_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool FormatStructArchive::_internal_base_use_minus_sign() const {
  return _impl_.base_use_minus_sign_;
}
inline bool FormatStructArchive::base_use_minus_sign() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.base_use_minus_sign)
  return _internal_base_use_minus_sign();
}
inline void FormatStructArchive::_internal_set_base_use_minus_sign(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.base_use_minus_sign_ = value;
}
inline void FormatStructArchive::set_base_use_minus_sign(bool value) {
  _internal_set_base_use_minus_sign(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.base_use_minus_sign)
}

// optional uint32 fraction_accuracy = 11;
inline bool FormatStructArchive::_internal_has_fraction_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_fraction_accuracy() const {
  return _internal_has_fraction_accuracy();
}
inline void FormatStructArchive::clear_fraction_accuracy() {
  _impl_.fraction_accuracy_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline uint32_t FormatStructArchive::_internal_fraction_accuracy() const {
  return _impl_.fraction_accuracy_;
}
inline uint32_t FormatStructArchive::fraction_accuracy() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.fraction_accuracy)
  return _internal_fraction_accuracy();
}
inline void FormatStructArchive::_internal_set_fraction_accuracy(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.fraction_accuracy_ = value;
}
inline void FormatStructArchive::set_fraction_accuracy(uint32_t value) {
  _internal_set_fraction_accuracy(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.fraction_accuracy)
}

// optional bool suppress_date_format = 12;
inline bool FormatStructArchive::_internal_has_suppress_date_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_suppress_date_format() const {
  return _internal_has_suppress_date_format();
}
inline void FormatStructArchive::clear_suppress_date_format() {
  _impl_.suppress_date_format_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool FormatStructArchive::_internal_suppress_date_format() const {
  return _impl_.suppress_date_format_;
}
inline bool FormatStructArchive::suppress_date_format() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.suppress_date_format)
  return _internal_suppress_date_format();
}
inline void FormatStructArchive::_internal_set_suppress_date_format(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.suppress_date_format_ = value;
}
inline void FormatStructArchive::set_suppress_date_format(bool value) {
  _internal_set_suppress_date_format(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.suppress_date_format)
}

// optional bool suppress_time_format = 13;
inline bool FormatStructArchive::_internal_has_suppress_time_format() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_suppress_time_format() const {
  return _internal_has_suppress_time_format();
}
inline void FormatStructArchive::clear_suppress_time_format() {
  _impl_.suppress_time_format_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool FormatStructArchive::_internal_suppress_time_format() const {
  return _impl_.suppress_time_format_;
}
inline bool FormatStructArchive::suppress_time_format() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.suppress_time_format)
  return _internal_suppress_time_format();
}
inline void FormatStructArchive::_internal_set_suppress_time_format(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.suppress_time_format_ = value;
}
inline void FormatStructArchive::set_suppress_time_format(bool value) {
  _internal_set_suppress_time_format(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.suppress_time_format)
}

// optional string date_time_format = 14;
inline bool FormatStructArchive::_internal_has_date_time_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FormatStructArchive::has_date_time_format() const {
  return _internal_has_date_time_format();
}
inline void FormatStructArchive::clear_date_time_format() {
  _impl_.date_time_format_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FormatStructArchive::date_time_format() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.date_time_format)
  return _internal_date_time_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormatStructArchive::set_date_time_format(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.date_time_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.date_time_format)
}
inline std::string* FormatStructArchive::mutable_date_time_format() {
  std::string* _s = _internal_mutable_date_time_format();
  // @@protoc_insertion_point(field_mutable:TSK.FormatStructArchive.date_time_format)
  return _s;
}
inline const std::string& FormatStructArchive::_internal_date_time_format() const {
  return _impl_.date_time_format_.Get();
}
inline void FormatStructArchive::_internal_set_date_time_format(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.date_time_format_.Set(value, GetArenaForAllocation());
}
inline std::string* FormatStructArchive::_internal_mutable_date_time_format() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.date_time_format_.Mutable(GetArenaForAllocation());
}
inline std::string* FormatStructArchive::release_date_time_format() {
  // @@protoc_insertion_point(field_release:TSK.FormatStructArchive.date_time_format)
  if (!_internal_has_date_time_format()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.date_time_format_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_time_format_.IsDefault()) {
    _impl_.date_time_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FormatStructArchive::set_allocated_date_time_format(std::string* date_time_format) {
  if (date_time_format != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.date_time_format_.SetAllocated(date_time_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_time_format_.IsDefault()) {
    _impl_.date_time_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.FormatStructArchive.date_time_format)
}

// optional uint32 duration_unit_largest = 15;
inline bool FormatStructArchive::_internal_has_duration_unit_largest() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_duration_unit_largest() const {
  return _internal_has_duration_unit_largest();
}
inline void FormatStructArchive::clear_duration_unit_largest() {
  _impl_.duration_unit_largest_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline uint32_t FormatStructArchive::_internal_duration_unit_largest() const {
  return _impl_.duration_unit_largest_;
}
inline uint32_t FormatStructArchive::duration_unit_largest() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.duration_unit_largest)
  return _internal_duration_unit_largest();
}
inline void FormatStructArchive::_internal_set_duration_unit_largest(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.duration_unit_largest_ = value;
}
inline void FormatStructArchive::set_duration_unit_largest(uint32_t value) {
  _internal_set_duration_unit_largest(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.duration_unit_largest)
}

// optional uint32 duration_unit_smallest = 16;
inline bool FormatStructArchive::_internal_has_duration_unit_smallest() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_duration_unit_smallest() const {
  return _internal_has_duration_unit_smallest();
}
inline void FormatStructArchive::clear_duration_unit_smallest() {
  _impl_.duration_unit_smallest_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t FormatStructArchive::_internal_duration_unit_smallest() const {
  return _impl_.duration_unit_smallest_;
}
inline uint32_t FormatStructArchive::duration_unit_smallest() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.duration_unit_smallest)
  return _internal_duration_unit_smallest();
}
inline void FormatStructArchive::_internal_set_duration_unit_smallest(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.duration_unit_smallest_ = value;
}
inline void FormatStructArchive::set_duration_unit_smallest(uint32_t value) {
  _internal_set_duration_unit_smallest(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.duration_unit_smallest)
}

// optional uint32 custom_id = 17;
inline bool FormatStructArchive::_internal_has_custom_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_custom_id() const {
  return _internal_has_custom_id();
}
inline void FormatStructArchive::clear_custom_id() {
  _impl_.custom_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t FormatStructArchive::_internal_custom_id() const {
  return _impl_.custom_id_;
}
inline uint32_t FormatStructArchive::custom_id() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.custom_id)
  return _internal_custom_id();
}
inline void FormatStructArchive::_internal_set_custom_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.custom_id_ = value;
}
inline void FormatStructArchive::set_custom_id(uint32_t value) {
  _internal_set_custom_id(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.custom_id)
}

// optional string custom_format_string = 18;
inline bool FormatStructArchive::_internal_has_custom_format_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FormatStructArchive::has_custom_format_string() const {
  return _internal_has_custom_format_string();
}
inline void FormatStructArchive::clear_custom_format_string() {
  _impl_.custom_format_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FormatStructArchive::custom_format_string() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.custom_format_string)
  return _internal_custom_format_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FormatStructArchive::set_custom_format_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.custom_format_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.custom_format_string)
}
inline std::string* FormatStructArchive::mutable_custom_format_string() {
  std::string* _s = _internal_mutable_custom_format_string();
  // @@protoc_insertion_point(field_mutable:TSK.FormatStructArchive.custom_format_string)
  return _s;
}
inline const std::string& FormatStructArchive::_internal_custom_format_string() const {
  return _impl_.custom_format_string_.Get();
}
inline void FormatStructArchive::_internal_set_custom_format_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.custom_format_string_.Set(value, GetArenaForAllocation());
}
inline std::string* FormatStructArchive::_internal_mutable_custom_format_string() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.custom_format_string_.Mutable(GetArenaForAllocation());
}
inline std::string* FormatStructArchive::release_custom_format_string() {
  // @@protoc_insertion_point(field_release:TSK.FormatStructArchive.custom_format_string)
  if (!_internal_has_custom_format_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.custom_format_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_format_string_.IsDefault()) {
    _impl_.custom_format_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FormatStructArchive::set_allocated_custom_format_string(std::string* custom_format_string) {
  if (custom_format_string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.custom_format_string_.SetAllocated(custom_format_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.custom_format_string_.IsDefault()) {
    _impl_.custom_format_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.FormatStructArchive.custom_format_string)
}

// optional double scale_factor = 19;
inline bool FormatStructArchive::_internal_has_scale_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_scale_factor() const {
  return _internal_has_scale_factor();
}
inline void FormatStructArchive::clear_scale_factor() {
  _impl_.scale_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline double FormatStructArchive::_internal_scale_factor() const {
  return _impl_.scale_factor_;
}
inline double FormatStructArchive::scale_factor() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.scale_factor)
  return _internal_scale_factor();
}
inline void FormatStructArchive::_internal_set_scale_factor(double value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.scale_factor_ = value;
}
inline void FormatStructArchive::set_scale_factor(double value) {
  _internal_set_scale_factor(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.scale_factor)
}

// optional bool requires_fraction_replacement = 20;
inline bool FormatStructArchive::_internal_has_requires_fraction_replacement() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_requires_fraction_replacement() const {
  return _internal_has_requires_fraction_replacement();
}
inline void FormatStructArchive::clear_requires_fraction_replacement() {
  _impl_.requires_fraction_replacement_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool FormatStructArchive::_internal_requires_fraction_replacement() const {
  return _impl_.requires_fraction_replacement_;
}
inline bool FormatStructArchive::requires_fraction_replacement() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.requires_fraction_replacement)
  return _internal_requires_fraction_replacement();
}
inline void FormatStructArchive::_internal_set_requires_fraction_replacement(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.requires_fraction_replacement_ = value;
}
inline void FormatStructArchive::set_requires_fraction_replacement(bool value) {
  _internal_set_requires_fraction_replacement(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.requires_fraction_replacement)
}

// optional double control_minimum = 21;
inline bool FormatStructArchive::_internal_has_control_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_control_minimum() const {
  return _internal_has_control_minimum();
}
inline void FormatStructArchive::clear_control_minimum() {
  _impl_.control_minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline double FormatStructArchive::_internal_control_minimum() const {
  return _impl_.control_minimum_;
}
inline double FormatStructArchive::control_minimum() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.control_minimum)
  return _internal_control_minimum();
}
inline void FormatStructArchive::_internal_set_control_minimum(double value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.control_minimum_ = value;
}
inline void FormatStructArchive::set_control_minimum(double value) {
  _internal_set_control_minimum(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.control_minimum)
}

// optional double control_maximum = 22;
inline bool FormatStructArchive::_internal_has_control_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_control_maximum() const {
  return _internal_has_control_maximum();
}
inline void FormatStructArchive::clear_control_maximum() {
  _impl_.control_maximum_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline double FormatStructArchive::_internal_control_maximum() const {
  return _impl_.control_maximum_;
}
inline double FormatStructArchive::control_maximum() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.control_maximum)
  return _internal_control_maximum();
}
inline void FormatStructArchive::_internal_set_control_maximum(double value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.control_maximum_ = value;
}
inline void FormatStructArchive::set_control_maximum(double value) {
  _internal_set_control_maximum(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.control_maximum)
}

// optional double control_increment = 23;
inline bool FormatStructArchive::_internal_has_control_increment() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_control_increment() const {
  return _internal_has_control_increment();
}
inline void FormatStructArchive::clear_control_increment() {
  _impl_.control_increment_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline double FormatStructArchive::_internal_control_increment() const {
  return _impl_.control_increment_;
}
inline double FormatStructArchive::control_increment() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.control_increment)
  return _internal_control_increment();
}
inline void FormatStructArchive::_internal_set_control_increment(double value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.control_increment_ = value;
}
inline void FormatStructArchive::set_control_increment(double value) {
  _internal_set_control_increment(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.control_increment)
}

// optional uint32 control_format_type = 24;
inline bool FormatStructArchive::_internal_has_control_format_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_control_format_type() const {
  return _internal_has_control_format_type();
}
inline void FormatStructArchive::clear_control_format_type() {
  _impl_.control_format_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline uint32_t FormatStructArchive::_internal_control_format_type() const {
  return _impl_.control_format_type_;
}
inline uint32_t FormatStructArchive::control_format_type() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.control_format_type)
  return _internal_control_format_type();
}
inline void FormatStructArchive::_internal_set_control_format_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.control_format_type_ = value;
}
inline void FormatStructArchive::set_control_format_type(uint32_t value) {
  _internal_set_control_format_type(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.control_format_type)
}

// optional uint32 slider_orientation = 25;
inline bool FormatStructArchive::_internal_has_slider_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_slider_orientation() const {
  return _internal_has_slider_orientation();
}
inline void FormatStructArchive::clear_slider_orientation() {
  _impl_.slider_orientation_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t FormatStructArchive::_internal_slider_orientation() const {
  return _impl_.slider_orientation_;
}
inline uint32_t FormatStructArchive::slider_orientation() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.slider_orientation)
  return _internal_slider_orientation();
}
inline void FormatStructArchive::_internal_set_slider_orientation(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.slider_orientation_ = value;
}
inline void FormatStructArchive::set_slider_orientation(uint32_t value) {
  _internal_set_slider_orientation(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.slider_orientation)
}

// optional uint32 slider_position = 26;
inline bool FormatStructArchive::_internal_has_slider_position() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_slider_position() const {
  return _internal_has_slider_position();
}
inline void FormatStructArchive::clear_slider_position() {
  _impl_.slider_position_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t FormatStructArchive::_internal_slider_position() const {
  return _impl_.slider_position_;
}
inline uint32_t FormatStructArchive::slider_position() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.slider_position)
  return _internal_slider_position();
}
inline void FormatStructArchive::_internal_set_slider_position(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.slider_position_ = value;
}
inline void FormatStructArchive::set_slider_position(uint32_t value) {
  _internal_set_slider_position(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.slider_position)
}

// optional uint32 decimal_width = 27;
inline bool FormatStructArchive::_internal_has_decimal_width() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_decimal_width() const {
  return _internal_has_decimal_width();
}
inline void FormatStructArchive::clear_decimal_width() {
  _impl_.decimal_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t FormatStructArchive::_internal_decimal_width() const {
  return _impl_.decimal_width_;
}
inline uint32_t FormatStructArchive::decimal_width() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.decimal_width)
  return _internal_decimal_width();
}
inline void FormatStructArchive::_internal_set_decimal_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.decimal_width_ = value;
}
inline void FormatStructArchive::set_decimal_width(uint32_t value) {
  _internal_set_decimal_width(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.decimal_width)
}

// optional uint32 min_integer_width = 28;
inline bool FormatStructArchive::_internal_has_min_integer_width() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_min_integer_width() const {
  return _internal_has_min_integer_width();
}
inline void FormatStructArchive::clear_min_integer_width() {
  _impl_.min_integer_width_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline uint32_t FormatStructArchive::_internal_min_integer_width() const {
  return _impl_.min_integer_width_;
}
inline uint32_t FormatStructArchive::min_integer_width() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.min_integer_width)
  return _internal_min_integer_width();
}
inline void FormatStructArchive::_internal_set_min_integer_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.min_integer_width_ = value;
}
inline void FormatStructArchive::set_min_integer_width(uint32_t value) {
  _internal_set_min_integer_width(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.min_integer_width)
}

// optional uint32 num_nonspace_integer_digits = 29;
inline bool FormatStructArchive::_internal_has_num_nonspace_integer_digits() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_num_nonspace_integer_digits() const {
  return _internal_has_num_nonspace_integer_digits();
}
inline void FormatStructArchive::clear_num_nonspace_integer_digits() {
  _impl_.num_nonspace_integer_digits_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline uint32_t FormatStructArchive::_internal_num_nonspace_integer_digits() const {
  return _impl_.num_nonspace_integer_digits_;
}
inline uint32_t FormatStructArchive::num_nonspace_integer_digits() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.num_nonspace_integer_digits)
  return _internal_num_nonspace_integer_digits();
}
inline void FormatStructArchive::_internal_set_num_nonspace_integer_digits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.num_nonspace_integer_digits_ = value;
}
inline void FormatStructArchive::set_num_nonspace_integer_digits(uint32_t value) {
  _internal_set_num_nonspace_integer_digits(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.num_nonspace_integer_digits)
}

// optional uint32 num_nonspace_decimal_digits = 30;
inline bool FormatStructArchive::_internal_has_num_nonspace_decimal_digits() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool FormatStructArchive::has_num_nonspace_decimal_digits() const {
  return _internal_has_num_nonspace_decimal_digits();
}
inline void FormatStructArchive::clear_num_nonspace_decimal_digits() {
  _impl_.num_nonspace_decimal_digits_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline uint32_t FormatStructArchive::_internal_num_nonspace_decimal_digits() const {
  return _impl_.num_nonspace_decimal_digits_;
}
inline uint32_t FormatStructArchive::num_nonspace_decimal_digits() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.num_nonspace_decimal_digits)
  return _internal_num_nonspace_decimal_digits();
}
inline void FormatStructArchive::_internal_set_num_nonspace_decimal_digits(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.num_nonspace_decimal_digits_ = value;
}
inline void FormatStructArchive::set_num_nonspace_decimal_digits(uint32_t value) {
  _internal_set_num_nonspace_decimal_digits(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.num_nonspace_decimal_digits)
}

// optional uint32 index_from_right_last_integer = 31;
inline bool FormatStructArchive::_internal_has_index_from_right_last_integer() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool FormatStructArchive::has_index_from_right_last_integer() const {
  return _internal_has_index_from_right_last_integer();
}
inline void FormatStructArchive::clear_index_from_right_last_integer() {
  _impl_.index_from_right_last_integer_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline uint32_t FormatStructArchive::_internal_index_from_right_last_integer() const {
  return _impl_.index_from_right_last_integer_;
}
inline uint32_t FormatStructArchive::index_from_right_last_integer() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.index_from_right_last_integer)
  return _internal_index_from_right_last_integer();
}
inline void FormatStructArchive::_internal_set_index_from_right_last_integer(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.index_from_right_last_integer_ = value;
}
inline void FormatStructArchive::set_index_from_right_last_integer(uint32_t value) {
  _internal_set_index_from_right_last_integer(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.index_from_right_last_integer)
}

// repeated string interstitial_strings = 32;
inline int FormatStructArchive::_internal_interstitial_strings_size() const {
  return _impl_.interstitial_strings_.size();
}
inline int FormatStructArchive::interstitial_strings_size() const {
  return _internal_interstitial_strings_size();
}
inline void FormatStructArchive::clear_interstitial_strings() {
  _impl_.interstitial_strings_.Clear();
}
inline std::string* FormatStructArchive::add_interstitial_strings() {
  std::string* _s = _internal_add_interstitial_strings();
  // @@protoc_insertion_point(field_add_mutable:TSK.FormatStructArchive.interstitial_strings)
  return _s;
}
inline const std::string& FormatStructArchive::_internal_interstitial_strings(int index) const {
  return _impl_.interstitial_strings_.Get(index);
}
inline const std::string& FormatStructArchive::interstitial_strings(int index) const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.interstitial_strings)
  return _internal_interstitial_strings(index);
}
inline std::string* FormatStructArchive::mutable_interstitial_strings(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.FormatStructArchive.interstitial_strings)
  return _impl_.interstitial_strings_.Mutable(index);
}
inline void FormatStructArchive::set_interstitial_strings(int index, const std::string& value) {
  _impl_.interstitial_strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::set_interstitial_strings(int index, std::string&& value) {
  _impl_.interstitial_strings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::set_interstitial_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interstitial_strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::set_interstitial_strings(int index, const char* value, size_t size) {
  _impl_.interstitial_strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TSK.FormatStructArchive.interstitial_strings)
}
inline std::string* FormatStructArchive::_internal_add_interstitial_strings() {
  return _impl_.interstitial_strings_.Add();
}
inline void FormatStructArchive::add_interstitial_strings(const std::string& value) {
  _impl_.interstitial_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::add_interstitial_strings(std::string&& value) {
  _impl_.interstitial_strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::add_interstitial_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.interstitial_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TSK.FormatStructArchive.interstitial_strings)
}
inline void FormatStructArchive::add_interstitial_strings(const char* value, size_t size) {
  _impl_.interstitial_strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TSK.FormatStructArchive.interstitial_strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FormatStructArchive::interstitial_strings() const {
  // @@protoc_insertion_point(field_list:TSK.FormatStructArchive.interstitial_strings)
  return _impl_.interstitial_strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FormatStructArchive::mutable_interstitial_strings() {
  // @@protoc_insertion_point(field_mutable_list:TSK.FormatStructArchive.interstitial_strings)
  return &_impl_.interstitial_strings_;
}

// optional .TSP.IndexSet inters_str_insertion_indexes = 33;
inline bool FormatStructArchive::_internal_has_inters_str_insertion_indexes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inters_str_insertion_indexes_ != nullptr);
  return value;
}
inline bool FormatStructArchive::has_inters_str_insertion_indexes() const {
  return _internal_has_inters_str_insertion_indexes();
}
inline const ::TSP::IndexSet& FormatStructArchive::_internal_inters_str_insertion_indexes() const {
  const ::TSP::IndexSet* p = _impl_.inters_str_insertion_indexes_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::IndexSet&>(
      ::TSP::_IndexSet_default_instance_);
}
inline const ::TSP::IndexSet& FormatStructArchive::inters_str_insertion_indexes() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.inters_str_insertion_indexes)
  return _internal_inters_str_insertion_indexes();
}
inline void FormatStructArchive::unsafe_arena_set_allocated_inters_str_insertion_indexes(
    ::TSP::IndexSet* inters_str_insertion_indexes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inters_str_insertion_indexes_);
  }
  _impl_.inters_str_insertion_indexes_ = inters_str_insertion_indexes;
  if (inters_str_insertion_indexes) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.FormatStructArchive.inters_str_insertion_indexes)
}
inline ::TSP::IndexSet* FormatStructArchive::release_inters_str_insertion_indexes() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::IndexSet* temp = _impl_.inters_str_insertion_indexes_;
  _impl_.inters_str_insertion_indexes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::IndexSet* FormatStructArchive::unsafe_arena_release_inters_str_insertion_indexes() {
  // @@protoc_insertion_point(field_release:TSK.FormatStructArchive.inters_str_insertion_indexes)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::IndexSet* temp = _impl_.inters_str_insertion_indexes_;
  _impl_.inters_str_insertion_indexes_ = nullptr;
  return temp;
}
inline ::TSP::IndexSet* FormatStructArchive::_internal_mutable_inters_str_insertion_indexes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.inters_str_insertion_indexes_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::IndexSet>(GetArenaForAllocation());
    _impl_.inters_str_insertion_indexes_ = p;
  }
  return _impl_.inters_str_insertion_indexes_;
}
inline ::TSP::IndexSet* FormatStructArchive::mutable_inters_str_insertion_indexes() {
  ::TSP::IndexSet* _msg = _internal_mutable_inters_str_insertion_indexes();
  // @@protoc_insertion_point(field_mutable:TSK.FormatStructArchive.inters_str_insertion_indexes)
  return _msg;
}
inline void FormatStructArchive::set_allocated_inters_str_insertion_indexes(::TSP::IndexSet* inters_str_insertion_indexes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inters_str_insertion_indexes_);
  }
  if (inters_str_insertion_indexes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inters_str_insertion_indexes));
    if (message_arena != submessage_arena) {
      inters_str_insertion_indexes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inters_str_insertion_indexes, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.inters_str_insertion_indexes_ = inters_str_insertion_indexes;
  // @@protoc_insertion_point(field_set_allocated:TSK.FormatStructArchive.inters_str_insertion_indexes)
}

// optional uint32 num_hash_decimal_digits = 34;
inline bool FormatStructArchive::_internal_has_num_hash_decimal_digits() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool FormatStructArchive::has_num_hash_decimal_digits() const {
  return _internal_has_num_hash_decimal_digits();
}
inline void FormatStructArchive::clear_num_hash_decimal_digits() {
  _impl_.num_hash_decimal_digits_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t FormatStructArchive::_internal_num_hash_decimal_digits() const {
  return _impl_.num_hash_decimal_digits_;
}
inline uint32_t FormatStructArchive::num_hash_decimal_digits() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.num_hash_decimal_digits)
  return _internal_num_hash_decimal_digits();
}
inline void FormatStructArchive::_internal_set_num_hash_decimal_digits(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.num_hash_decimal_digits_ = value;
}
inline void FormatStructArchive::set_num_hash_decimal_digits(uint32_t value) {
  _internal_set_num_hash_decimal_digits(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.num_hash_decimal_digits)
}

// optional uint32 total_num_decimal_digits = 35;
inline bool FormatStructArchive::_internal_has_total_num_decimal_digits() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool FormatStructArchive::has_total_num_decimal_digits() const {
  return _internal_has_total_num_decimal_digits();
}
inline void FormatStructArchive::clear_total_num_decimal_digits() {
  _impl_.total_num_decimal_digits_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline uint32_t FormatStructArchive::_internal_total_num_decimal_digits() const {
  return _impl_.total_num_decimal_digits_;
}
inline uint32_t FormatStructArchive::total_num_decimal_digits() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.total_num_decimal_digits)
  return _internal_total_num_decimal_digits();
}
inline void FormatStructArchive::_internal_set_total_num_decimal_digits(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.total_num_decimal_digits_ = value;
}
inline void FormatStructArchive::set_total_num_decimal_digits(uint32_t value) {
  _internal_set_total_num_decimal_digits(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.total_num_decimal_digits)
}

// optional bool is_complex = 36;
inline bool FormatStructArchive::_internal_has_is_complex() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_is_complex() const {
  return _internal_has_is_complex();
}
inline void FormatStructArchive::clear_is_complex() {
  _impl_.is_complex_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool FormatStructArchive::_internal_is_complex() const {
  return _impl_.is_complex_;
}
inline bool FormatStructArchive::is_complex() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.is_complex)
  return _internal_is_complex();
}
inline void FormatStructArchive::_internal_set_is_complex(bool value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.is_complex_ = value;
}
inline void FormatStructArchive::set_is_complex(bool value) {
  _internal_set_is_complex(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.is_complex)
}

// optional bool contains_integer_token = 37;
inline bool FormatStructArchive::_internal_has_contains_integer_token() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool FormatStructArchive::has_contains_integer_token() const {
  return _internal_has_contains_integer_token();
}
inline void FormatStructArchive::clear_contains_integer_token() {
  _impl_.contains_integer_token_ = false;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline bool FormatStructArchive::_internal_contains_integer_token() const {
  return _impl_.contains_integer_token_;
}
inline bool FormatStructArchive::contains_integer_token() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.contains_integer_token)
  return _internal_contains_integer_token();
}
inline void FormatStructArchive::_internal_set_contains_integer_token(bool value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.contains_integer_token_ = value;
}
inline void FormatStructArchive::set_contains_integer_token(bool value) {
  _internal_set_contains_integer_token(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.contains_integer_token)
}

// optional uint32 multiple_choice_list_initial_value = 38;
inline bool FormatStructArchive::_internal_has_multiple_choice_list_initial_value() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool FormatStructArchive::has_multiple_choice_list_initial_value() const {
  return _internal_has_multiple_choice_list_initial_value();
}
inline void FormatStructArchive::clear_multiple_choice_list_initial_value() {
  _impl_.multiple_choice_list_initial_value_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline uint32_t FormatStructArchive::_internal_multiple_choice_list_initial_value() const {
  return _impl_.multiple_choice_list_initial_value_;
}
inline uint32_t FormatStructArchive::multiple_choice_list_initial_value() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.multiple_choice_list_initial_value)
  return _internal_multiple_choice_list_initial_value();
}
inline void FormatStructArchive::_internal_set_multiple_choice_list_initial_value(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.multiple_choice_list_initial_value_ = value;
}
inline void FormatStructArchive::set_multiple_choice_list_initial_value(uint32_t value) {
  _internal_set_multiple_choice_list_initial_value(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.multiple_choice_list_initial_value)
}

// optional uint32 multiple_choice_list_id = 39;
inline bool FormatStructArchive::_internal_has_multiple_choice_list_id() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool FormatStructArchive::has_multiple_choice_list_id() const {
  return _internal_has_multiple_choice_list_id();
}
inline void FormatStructArchive::clear_multiple_choice_list_id() {
  _impl_.multiple_choice_list_id_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline uint32_t FormatStructArchive::_internal_multiple_choice_list_id() const {
  return _impl_.multiple_choice_list_id_;
}
inline uint32_t FormatStructArchive::multiple_choice_list_id() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.multiple_choice_list_id)
  return _internal_multiple_choice_list_id();
}
inline void FormatStructArchive::_internal_set_multiple_choice_list_id(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.multiple_choice_list_id_ = value;
}
inline void FormatStructArchive::set_multiple_choice_list_id(uint32_t value) {
  _internal_set_multiple_choice_list_id(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.multiple_choice_list_id)
}

// optional bool use_automatic_duration_units = 40;
inline bool FormatStructArchive::_internal_has_use_automatic_duration_units() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool FormatStructArchive::has_use_automatic_duration_units() const {
  return _internal_has_use_automatic_duration_units();
}
inline void FormatStructArchive::clear_use_automatic_duration_units() {
  _impl_.use_automatic_duration_units_ = false;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline bool FormatStructArchive::_internal_use_automatic_duration_units() const {
  return _impl_.use_automatic_duration_units_;
}
inline bool FormatStructArchive::use_automatic_duration_units() const {
  // @@protoc_insertion_point(field_get:TSK.FormatStructArchive.use_automatic_duration_units)
  return _internal_use_automatic_duration_units();
}
inline void FormatStructArchive::_internal_set_use_automatic_duration_units(bool value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.use_automatic_duration_units_ = value;
}
inline void FormatStructArchive::set_use_automatic_duration_units(bool value) {
  _internal_set_use_automatic_duration_units(value);
  // @@protoc_insertion_point(field_set:TSK.FormatStructArchive.use_automatic_duration_units)
}

// -------------------------------------------------------------------

// CustomFormatArchive_Condition

// required uint32 condition_type = 1;
inline bool CustomFormatArchive_Condition::_internal_has_condition_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomFormatArchive_Condition::has_condition_type() const {
  return _internal_has_condition_type();
}
inline void CustomFormatArchive_Condition::clear_condition_type() {
  _impl_.condition_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CustomFormatArchive_Condition::_internal_condition_type() const {
  return _impl_.condition_type_;
}
inline uint32_t CustomFormatArchive_Condition::condition_type() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.Condition.condition_type)
  return _internal_condition_type();
}
inline void CustomFormatArchive_Condition::_internal_set_condition_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.condition_type_ = value;
}
inline void CustomFormatArchive_Condition::set_condition_type(uint32_t value) {
  _internal_set_condition_type(value);
  // @@protoc_insertion_point(field_set:TSK.CustomFormatArchive.Condition.condition_type)
}

// optional float condition_value = 2;
inline bool CustomFormatArchive_Condition::_internal_has_condition_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CustomFormatArchive_Condition::has_condition_value() const {
  return _internal_has_condition_value();
}
inline void CustomFormatArchive_Condition::clear_condition_value() {
  _impl_.condition_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float CustomFormatArchive_Condition::_internal_condition_value() const {
  return _impl_.condition_value_;
}
inline float CustomFormatArchive_Condition::condition_value() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.Condition.condition_value)
  return _internal_condition_value();
}
inline void CustomFormatArchive_Condition::_internal_set_condition_value(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.condition_value_ = value;
}
inline void CustomFormatArchive_Condition::set_condition_value(float value) {
  _internal_set_condition_value(value);
  // @@protoc_insertion_point(field_set:TSK.CustomFormatArchive.Condition.condition_value)
}

// required .TSK.FormatStructArchive condition_format = 3;
inline bool CustomFormatArchive_Condition::_internal_has_condition_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.condition_format_ != nullptr);
  return value;
}
inline bool CustomFormatArchive_Condition::has_condition_format() const {
  return _internal_has_condition_format();
}
inline void CustomFormatArchive_Condition::clear_condition_format() {
  if (_impl_.condition_format_ != nullptr) _impl_.condition_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive_Condition::_internal_condition_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.condition_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive_Condition::condition_format() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.Condition.condition_format)
  return _internal_condition_format();
}
inline void CustomFormatArchive_Condition::unsafe_arena_set_allocated_condition_format(
    ::TSK::FormatStructArchive* condition_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.condition_format_);
  }
  _impl_.condition_format_ = condition_format;
  if (condition_format) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CustomFormatArchive.Condition.condition_format)
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::release_condition_format() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::FormatStructArchive* temp = _impl_.condition_format_;
  _impl_.condition_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::unsafe_arena_release_condition_format() {
  // @@protoc_insertion_point(field_release:TSK.CustomFormatArchive.Condition.condition_format)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::FormatStructArchive* temp = _impl_.condition_format_;
  _impl_.condition_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::_internal_mutable_condition_format() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.condition_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.condition_format_ = p;
  }
  return _impl_.condition_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive_Condition::mutable_condition_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_condition_format();
  // @@protoc_insertion_point(field_mutable:TSK.CustomFormatArchive.Condition.condition_format)
  return _msg;
}
inline void CustomFormatArchive_Condition::set_allocated_condition_format(::TSK::FormatStructArchive* condition_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.condition_format_;
  }
  if (condition_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(condition_format);
    if (message_arena != submessage_arena) {
      condition_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.condition_format_ = condition_format;
  // @@protoc_insertion_point(field_set_allocated:TSK.CustomFormatArchive.Condition.condition_format)
}

// optional double condition_value_dbl = 4;
inline bool CustomFormatArchive_Condition::_internal_has_condition_value_dbl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CustomFormatArchive_Condition::has_condition_value_dbl() const {
  return _internal_has_condition_value_dbl();
}
inline void CustomFormatArchive_Condition::clear_condition_value_dbl() {
  _impl_.condition_value_dbl_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double CustomFormatArchive_Condition::_internal_condition_value_dbl() const {
  return _impl_.condition_value_dbl_;
}
inline double CustomFormatArchive_Condition::condition_value_dbl() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.Condition.condition_value_dbl)
  return _internal_condition_value_dbl();
}
inline void CustomFormatArchive_Condition::_internal_set_condition_value_dbl(double value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.condition_value_dbl_ = value;
}
inline void CustomFormatArchive_Condition::set_condition_value_dbl(double value) {
  _internal_set_condition_value_dbl(value);
  // @@protoc_insertion_point(field_set:TSK.CustomFormatArchive.Condition.condition_value_dbl)
}

// -------------------------------------------------------------------

// CustomFormatArchive

// required string name = 1;
inline bool CustomFormatArchive::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomFormatArchive::has_name() const {
  return _internal_has_name();
}
inline void CustomFormatArchive::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomFormatArchive::name() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomFormatArchive::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.CustomFormatArchive.name)
}
inline std::string* CustomFormatArchive::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TSK.CustomFormatArchive.name)
  return _s;
}
inline const std::string& CustomFormatArchive::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CustomFormatArchive::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomFormatArchive::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomFormatArchive::release_name() {
  // @@protoc_insertion_point(field_release:TSK.CustomFormatArchive.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomFormatArchive::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.CustomFormatArchive.name)
}

// required uint32 format_type = 2;
inline bool CustomFormatArchive::_internal_has_format_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CustomFormatArchive::has_format_type() const {
  return _internal_has_format_type();
}
inline void CustomFormatArchive::clear_format_type() {
  _impl_.format_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CustomFormatArchive::_internal_format_type() const {
  return _impl_.format_type_;
}
inline uint32_t CustomFormatArchive::format_type() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.format_type)
  return _internal_format_type();
}
inline void CustomFormatArchive::_internal_set_format_type(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.format_type_ = value;
}
inline void CustomFormatArchive::set_format_type(uint32_t value) {
  _internal_set_format_type(value);
  // @@protoc_insertion_point(field_set:TSK.CustomFormatArchive.format_type)
}

// required .TSK.FormatStructArchive default_format = 3;
inline bool CustomFormatArchive::_internal_has_default_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.default_format_ != nullptr);
  return value;
}
inline bool CustomFormatArchive::has_default_format() const {
  return _internal_has_default_format();
}
inline void CustomFormatArchive::clear_default_format() {
  if (_impl_.default_format_ != nullptr) _impl_.default_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive::_internal_default_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.default_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& CustomFormatArchive::default_format() const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.default_format)
  return _internal_default_format();
}
inline void CustomFormatArchive::unsafe_arena_set_allocated_default_format(
    ::TSK::FormatStructArchive* default_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.default_format_);
  }
  _impl_.default_format_ = default_format;
  if (default_format) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.CustomFormatArchive.default_format)
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::release_default_format() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::FormatStructArchive* temp = _impl_.default_format_;
  _impl_.default_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::unsafe_arena_release_default_format() {
  // @@protoc_insertion_point(field_release:TSK.CustomFormatArchive.default_format)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSK::FormatStructArchive* temp = _impl_.default_format_;
  _impl_.default_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::_internal_mutable_default_format() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.default_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.default_format_ = p;
  }
  return _impl_.default_format_;
}
inline ::TSK::FormatStructArchive* CustomFormatArchive::mutable_default_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_default_format();
  // @@protoc_insertion_point(field_mutable:TSK.CustomFormatArchive.default_format)
  return _msg;
}
inline void CustomFormatArchive::set_allocated_default_format(::TSK::FormatStructArchive* default_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.default_format_;
  }
  if (default_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(default_format);
    if (message_arena != submessage_arena) {
      default_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.default_format_ = default_format;
  // @@protoc_insertion_point(field_set_allocated:TSK.CustomFormatArchive.default_format)
}

// repeated .TSK.CustomFormatArchive.Condition conditions = 4;
inline int CustomFormatArchive::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int CustomFormatArchive::conditions_size() const {
  return _internal_conditions_size();
}
inline void CustomFormatArchive::clear_conditions() {
  _impl_.conditions_.Clear();
}
inline ::TSK::CustomFormatArchive_Condition* CustomFormatArchive::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.CustomFormatArchive.conditions)
  return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >*
CustomFormatArchive::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:TSK.CustomFormatArchive.conditions)
  return &_impl_.conditions_;
}
inline const ::TSK::CustomFormatArchive_Condition& CustomFormatArchive::_internal_conditions(int index) const {
  return _impl_.conditions_.Get(index);
}
inline const ::TSK::CustomFormatArchive_Condition& CustomFormatArchive::conditions(int index) const {
  // @@protoc_insertion_point(field_get:TSK.CustomFormatArchive.conditions)
  return _internal_conditions(index);
}
inline ::TSK::CustomFormatArchive_Condition* CustomFormatArchive::_internal_add_conditions() {
  return _impl_.conditions_.Add();
}
inline ::TSK::CustomFormatArchive_Condition* CustomFormatArchive::add_conditions() {
  ::TSK::CustomFormatArchive_Condition* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:TSK.CustomFormatArchive.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSK::CustomFormatArchive_Condition >&
CustomFormatArchive::conditions() const {
  // @@protoc_insertion_point(field_list:TSK.CustomFormatArchive.conditions)
  return _impl_.conditions_;
}

// -------------------------------------------------------------------

// AnnotationAuthorArchive

// optional string name = 1;
inline bool AnnotationAuthorArchive::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnnotationAuthorArchive::has_name() const {
  return _internal_has_name();
}
inline void AnnotationAuthorArchive::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AnnotationAuthorArchive::name() const {
  // @@protoc_insertion_point(field_get:TSK.AnnotationAuthorArchive.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnnotationAuthorArchive::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.AnnotationAuthorArchive.name)
}
inline std::string* AnnotationAuthorArchive::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TSK.AnnotationAuthorArchive.name)
  return _s;
}
inline const std::string& AnnotationAuthorArchive::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AnnotationAuthorArchive::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AnnotationAuthorArchive::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AnnotationAuthorArchive::release_name() {
  // @@protoc_insertion_point(field_release:TSK.AnnotationAuthorArchive.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AnnotationAuthorArchive::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.AnnotationAuthorArchive.name)
}

// optional .TSP.Color color = 2;
inline bool AnnotationAuthorArchive::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool AnnotationAuthorArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& AnnotationAuthorArchive::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& AnnotationAuthorArchive::color() const {
  // @@protoc_insertion_point(field_get:TSK.AnnotationAuthorArchive.color)
  return _internal_color();
}
inline void AnnotationAuthorArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.AnnotationAuthorArchive.color)
}
inline ::TSP::Color* AnnotationAuthorArchive::release_color() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* AnnotationAuthorArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSK.AnnotationAuthorArchive.color)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* AnnotationAuthorArchive::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* AnnotationAuthorArchive::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSK.AnnotationAuthorArchive.color)
  return _msg;
}
inline void AnnotationAuthorArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSK.AnnotationAuthorArchive.color)
}

// -------------------------------------------------------------------

// DeprecatedChangeAuthorArchive

// optional string name = 1;
inline bool DeprecatedChangeAuthorArchive::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeprecatedChangeAuthorArchive::has_name() const {
  return _internal_has_name();
}
inline void DeprecatedChangeAuthorArchive::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeprecatedChangeAuthorArchive::name() const {
  // @@protoc_insertion_point(field_get:TSK.DeprecatedChangeAuthorArchive.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeprecatedChangeAuthorArchive::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TSK.DeprecatedChangeAuthorArchive.name)
}
inline std::string* DeprecatedChangeAuthorArchive::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:TSK.DeprecatedChangeAuthorArchive.name)
  return _s;
}
inline const std::string& DeprecatedChangeAuthorArchive::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeprecatedChangeAuthorArchive::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeprecatedChangeAuthorArchive::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeprecatedChangeAuthorArchive::release_name() {
  // @@protoc_insertion_point(field_release:TSK.DeprecatedChangeAuthorArchive.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeprecatedChangeAuthorArchive::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TSK.DeprecatedChangeAuthorArchive.name)
}

// optional .TSP.Color change_color = 2;
inline bool DeprecatedChangeAuthorArchive::_internal_has_change_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_color_ != nullptr);
  return value;
}
inline bool DeprecatedChangeAuthorArchive::has_change_color() const {
  return _internal_has_change_color();
}
inline const ::TSP::Color& DeprecatedChangeAuthorArchive::_internal_change_color() const {
  const ::TSP::Color* p = _impl_.change_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& DeprecatedChangeAuthorArchive::change_color() const {
  // @@protoc_insertion_point(field_get:TSK.DeprecatedChangeAuthorArchive.change_color)
  return _internal_change_color();
}
inline void DeprecatedChangeAuthorArchive::unsafe_arena_set_allocated_change_color(
    ::TSP::Color* change_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_color_);
  }
  _impl_.change_color_ = change_color;
  if (change_color) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.DeprecatedChangeAuthorArchive.change_color)
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::release_change_color() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.change_color_;
  _impl_.change_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::unsafe_arena_release_change_color() {
  // @@protoc_insertion_point(field_release:TSK.DeprecatedChangeAuthorArchive.change_color)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Color* temp = _impl_.change_color_;
  _impl_.change_color_ = nullptr;
  return temp;
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::_internal_mutable_change_color() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.change_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.change_color_ = p;
  }
  return _impl_.change_color_;
}
inline ::TSP::Color* DeprecatedChangeAuthorArchive::mutable_change_color() {
  ::TSP::Color* _msg = _internal_mutable_change_color();
  // @@protoc_insertion_point(field_mutable:TSK.DeprecatedChangeAuthorArchive.change_color)
  return _msg;
}
inline void DeprecatedChangeAuthorArchive::set_allocated_change_color(::TSP::Color* change_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.change_color_);
  }
  if (change_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(change_color));
    if (message_arena != submessage_arena) {
      change_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.change_color_ = change_color;
  // @@protoc_insertion_point(field_set_allocated:TSK.DeprecatedChangeAuthorArchive.change_color)
}

// -------------------------------------------------------------------

// AnnotationAuthorStorageArchive

// repeated .TSP.Reference annotation_author = 1;
inline int AnnotationAuthorStorageArchive::_internal_annotation_author_size() const {
  return _impl_.annotation_author_.size();
}
inline int AnnotationAuthorStorageArchive::annotation_author_size() const {
  return _internal_annotation_author_size();
}
inline ::TSP::Reference* AnnotationAuthorStorageArchive::mutable_annotation_author(int index) {
  // @@protoc_insertion_point(field_mutable:TSK.AnnotationAuthorStorageArchive.annotation_author)
  return _impl_.annotation_author_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
AnnotationAuthorStorageArchive::mutable_annotation_author() {
  // @@protoc_insertion_point(field_mutable_list:TSK.AnnotationAuthorStorageArchive.annotation_author)
  return &_impl_.annotation_author_;
}
inline const ::TSP::Reference& AnnotationAuthorStorageArchive::_internal_annotation_author(int index) const {
  return _impl_.annotation_author_.Get(index);
}
inline const ::TSP::Reference& AnnotationAuthorStorageArchive::annotation_author(int index) const {
  // @@protoc_insertion_point(field_get:TSK.AnnotationAuthorStorageArchive.annotation_author)
  return _internal_annotation_author(index);
}
inline ::TSP::Reference* AnnotationAuthorStorageArchive::_internal_add_annotation_author() {
  return _impl_.annotation_author_.Add();
}
inline ::TSP::Reference* AnnotationAuthorStorageArchive::add_annotation_author() {
  ::TSP::Reference* _add = _internal_add_annotation_author();
  // @@protoc_insertion_point(field_add:TSK.AnnotationAuthorStorageArchive.annotation_author)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
AnnotationAuthorStorageArchive::annotation_author() const {
  // @@protoc_insertion_point(field_list:TSK.AnnotationAuthorStorageArchive.annotation_author)
  return _impl_.annotation_author_;
}

// -------------------------------------------------------------------

// AddAnnotationAuthorCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool AddAnnotationAuthorCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool AddAnnotationAuthorCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void AddAnnotationAuthorCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::CommandArchive& AddAnnotationAuthorCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& AddAnnotationAuthorCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.AddAnnotationAuthorCommandArchive.super)
  return _internal_super();
}
inline void AddAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.AddAnnotationAuthorCommandArchive.super)
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.AddAnnotationAuthorCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* AddAnnotationAuthorCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.AddAnnotationAuthorCommandArchive.super)
  return _msg;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.AddAnnotationAuthorCommandArchive.super)
}

// optional .TSP.Reference document_root = 2;
inline bool AddAnnotationAuthorCommandArchive::_internal_has_document_root() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.document_root_ != nullptr);
  return value;
}
inline bool AddAnnotationAuthorCommandArchive::has_document_root() const {
  return _internal_has_document_root();
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::_internal_document_root() const {
  const ::TSP::Reference* p = _impl_.document_root_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::document_root() const {
  // @@protoc_insertion_point(field_get:TSK.AddAnnotationAuthorCommandArchive.document_root)
  return _internal_document_root();
}
inline void AddAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_document_root(
    ::TSP::Reference* document_root) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_root_);
  }
  _impl_.document_root_ = document_root;
  if (document_root) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.AddAnnotationAuthorCommandArchive.document_root)
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::release_document_root() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.document_root_;
  _impl_.document_root_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::unsafe_arena_release_document_root() {
  // @@protoc_insertion_point(field_release:TSK.AddAnnotationAuthorCommandArchive.document_root)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.document_root_;
  _impl_.document_root_ = nullptr;
  return temp;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::_internal_mutable_document_root() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.document_root_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.document_root_ = p;
  }
  return _impl_.document_root_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::mutable_document_root() {
  ::TSP::Reference* _msg = _internal_mutable_document_root();
  // @@protoc_insertion_point(field_mutable:TSK.AddAnnotationAuthorCommandArchive.document_root)
  return _msg;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_document_root(::TSP::Reference* document_root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_root_);
  }
  if (document_root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_root));
    if (message_arena != submessage_arena) {
      document_root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document_root, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.document_root_ = document_root;
  // @@protoc_insertion_point(field_set_allocated:TSK.AddAnnotationAuthorCommandArchive.document_root)
}

// optional .TSP.Reference annotation_author = 3;
inline bool AddAnnotationAuthorCommandArchive::_internal_has_annotation_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.annotation_author_ != nullptr);
  return value;
}
inline bool AddAnnotationAuthorCommandArchive::has_annotation_author() const {
  return _internal_has_annotation_author();
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::_internal_annotation_author() const {
  const ::TSP::Reference* p = _impl_.annotation_author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& AddAnnotationAuthorCommandArchive::annotation_author() const {
  // @@protoc_insertion_point(field_get:TSK.AddAnnotationAuthorCommandArchive.annotation_author)
  return _internal_annotation_author();
}
inline void AddAnnotationAuthorCommandArchive::unsafe_arena_set_allocated_annotation_author(
    ::TSP::Reference* annotation_author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_);
  }
  _impl_.annotation_author_ = annotation_author;
  if (annotation_author) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.AddAnnotationAuthorCommandArchive.annotation_author)
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::release_annotation_author() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.annotation_author_;
  _impl_.annotation_author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::unsafe_arena_release_annotation_author() {
  // @@protoc_insertion_point(field_release:TSK.AddAnnotationAuthorCommandArchive.annotation_author)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.annotation_author_;
  _impl_.annotation_author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::_internal_mutable_annotation_author() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.annotation_author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.annotation_author_ = p;
  }
  return _impl_.annotation_author_;
}
inline ::TSP::Reference* AddAnnotationAuthorCommandArchive::mutable_annotation_author() {
  ::TSP::Reference* _msg = _internal_mutable_annotation_author();
  // @@protoc_insertion_point(field_mutable:TSK.AddAnnotationAuthorCommandArchive.annotation_author)
  return _msg;
}
inline void AddAnnotationAuthorCommandArchive::set_allocated_annotation_author(::TSP::Reference* annotation_author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_);
  }
  if (annotation_author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_author));
    if (message_arena != submessage_arena) {
      annotation_author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_author, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.annotation_author_ = annotation_author;
  // @@protoc_insertion_point(field_set_allocated:TSK.AddAnnotationAuthorCommandArchive.annotation_author)
}

// -------------------------------------------------------------------

// SetAnnotationAuthorColorCommandArchive

// required .TSK.CommandArchive super = 1;
inline bool SetAnnotationAuthorColorCommandArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool SetAnnotationAuthorColorCommandArchive::has_super() const {
  return _internal_has_super();
}
inline void SetAnnotationAuthorColorCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSK::CommandArchive& SetAnnotationAuthorColorCommandArchive::_internal_super() const {
  const ::TSK::CommandArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CommandArchive&>(
      ::TSK::_CommandArchive_default_instance_);
}
inline const ::TSK::CommandArchive& SetAnnotationAuthorColorCommandArchive::super() const {
  // @@protoc_insertion_point(field_get:TSK.SetAnnotationAuthorColorCommandArchive.super)
  return _internal_super();
}
inline void SetAnnotationAuthorColorCommandArchive::unsafe_arena_set_allocated_super(
    ::TSK::CommandArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.super)
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TSK.SetAnnotationAuthorColorCommandArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSK::CommandArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CommandArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSK::CommandArchive* SetAnnotationAuthorColorCommandArchive::mutable_super() {
  ::TSK::CommandArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TSK.SetAnnotationAuthorColorCommandArchive.super)
  return _msg;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_super(::TSK::CommandArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.super)
}

// optional .TSP.Reference annotation_author = 2;
inline bool SetAnnotationAuthorColorCommandArchive::_internal_has_annotation_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.annotation_author_ != nullptr);
  return value;
}
inline bool SetAnnotationAuthorColorCommandArchive::has_annotation_author() const {
  return _internal_has_annotation_author();
}
inline const ::TSP::Reference& SetAnnotationAuthorColorCommandArchive::_internal_annotation_author() const {
  const ::TSP::Reference* p = _impl_.annotation_author_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& SetAnnotationAuthorColorCommandArchive::annotation_author() const {
  // @@protoc_insertion_point(field_get:TSK.SetAnnotationAuthorColorCommandArchive.annotation_author)
  return _internal_annotation_author();
}
inline void SetAnnotationAuthorColorCommandArchive::unsafe_arena_set_allocated_annotation_author(
    ::TSP::Reference* annotation_author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_);
  }
  _impl_.annotation_author_ = annotation_author;
  if (annotation_author) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.annotation_author)
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::release_annotation_author() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.annotation_author_;
  _impl_.annotation_author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::unsafe_arena_release_annotation_author() {
  // @@protoc_insertion_point(field_release:TSK.SetAnnotationAuthorColorCommandArchive.annotation_author)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.annotation_author_;
  _impl_.annotation_author_ = nullptr;
  return temp;
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::_internal_mutable_annotation_author() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.annotation_author_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.annotation_author_ = p;
  }
  return _impl_.annotation_author_;
}
inline ::TSP::Reference* SetAnnotationAuthorColorCommandArchive::mutable_annotation_author() {
  ::TSP::Reference* _msg = _internal_mutable_annotation_author();
  // @@protoc_insertion_point(field_mutable:TSK.SetAnnotationAuthorColorCommandArchive.annotation_author)
  return _msg;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_annotation_author(::TSP::Reference* annotation_author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_author_);
  }
  if (annotation_author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation_author));
    if (message_arena != submessage_arena) {
      annotation_author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation_author, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.annotation_author_ = annotation_author;
  // @@protoc_insertion_point(field_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.annotation_author)
}

// optional .TSP.Color color = 3;
inline bool SetAnnotationAuthorColorCommandArchive::_internal_has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline bool SetAnnotationAuthorColorCommandArchive::has_color() const {
  return _internal_has_color();
}
inline const ::TSP::Color& SetAnnotationAuthorColorCommandArchive::_internal_color() const {
  const ::TSP::Color* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Color&>(
      ::TSP::_Color_default_instance_);
}
inline const ::TSP::Color& SetAnnotationAuthorColorCommandArchive::color() const {
  // @@protoc_insertion_point(field_get:TSK.SetAnnotationAuthorColorCommandArchive.color)
  return _internal_color();
}
inline void SetAnnotationAuthorColorCommandArchive::unsafe_arena_set_allocated_color(
    ::TSP::Color* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.color)
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::release_color() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:TSK.SetAnnotationAuthorColorCommandArchive.color)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Color* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::_internal_mutable_color() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Color>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::TSP::Color* SetAnnotationAuthorColorCommandArchive::mutable_color() {
  ::TSP::Color* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:TSK.SetAnnotationAuthorColorCommandArchive.color)
  return _msg;
}
inline void SetAnnotationAuthorColorCommandArchive::set_allocated_color(::TSP::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:TSK.SetAnnotationAuthorColorCommandArchive.color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSK

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSKArchives_2eproto
