// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSPMessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSPMessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSPMessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSPMessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSPMessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSPMessages_2eproto;
namespace TSP {
class Color;
struct ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class DataReference;
struct DataReferenceDefaultTypeInternal;
extern DataReferenceDefaultTypeInternal _DataReference_default_instance_;
class Date;
struct DateDefaultTypeInternal;
extern DateDefaultTypeInternal _Date_default_instance_;
class IndexSet;
struct IndexSetDefaultTypeInternal;
extern IndexSetDefaultTypeInternal _IndexSet_default_instance_;
class ObjectContainer;
struct ObjectContainerDefaultTypeInternal;
extern ObjectContainerDefaultTypeInternal _ObjectContainer_default_instance_;
class PasteboardObject;
struct PasteboardObjectDefaultTypeInternal;
extern PasteboardObjectDefaultTypeInternal _PasteboardObject_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Path_Element;
struct Path_ElementDefaultTypeInternal;
extern Path_ElementDefaultTypeInternal _Path_Element_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Range;
struct RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class ReferenceDictionary;
struct ReferenceDictionaryDefaultTypeInternal;
extern ReferenceDictionaryDefaultTypeInternal _ReferenceDictionary_default_instance_;
class ReferenceDictionary_Entry;
struct ReferenceDictionary_EntryDefaultTypeInternal;
extern ReferenceDictionary_EntryDefaultTypeInternal _ReferenceDictionary_Entry_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
}  // namespace TSP
PROTOBUF_NAMESPACE_OPEN
template<> ::TSP::Color* Arena::CreateMaybeMessage<::TSP::Color>(Arena*);
template<> ::TSP::DataReference* Arena::CreateMaybeMessage<::TSP::DataReference>(Arena*);
template<> ::TSP::Date* Arena::CreateMaybeMessage<::TSP::Date>(Arena*);
template<> ::TSP::IndexSet* Arena::CreateMaybeMessage<::TSP::IndexSet>(Arena*);
template<> ::TSP::ObjectContainer* Arena::CreateMaybeMessage<::TSP::ObjectContainer>(Arena*);
template<> ::TSP::PasteboardObject* Arena::CreateMaybeMessage<::TSP::PasteboardObject>(Arena*);
template<> ::TSP::Path* Arena::CreateMaybeMessage<::TSP::Path>(Arena*);
template<> ::TSP::Path_Element* Arena::CreateMaybeMessage<::TSP::Path_Element>(Arena*);
template<> ::TSP::Point* Arena::CreateMaybeMessage<::TSP::Point>(Arena*);
template<> ::TSP::Range* Arena::CreateMaybeMessage<::TSP::Range>(Arena*);
template<> ::TSP::Reference* Arena::CreateMaybeMessage<::TSP::Reference>(Arena*);
template<> ::TSP::ReferenceDictionary* Arena::CreateMaybeMessage<::TSP::ReferenceDictionary>(Arena*);
template<> ::TSP::ReferenceDictionary_Entry* Arena::CreateMaybeMessage<::TSP::ReferenceDictionary_Entry>(Arena*);
template<> ::TSP::Size* Arena::CreateMaybeMessage<::TSP::Size>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TSP {

enum Color_ColorModel : int {
  Color_ColorModel_rgb = 1,
  Color_ColorModel_cmyk = 2,
  Color_ColorModel_white = 3
};
bool Color_ColorModel_IsValid(int value);
constexpr Color_ColorModel Color_ColorModel_ColorModel_MIN = Color_ColorModel_rgb;
constexpr Color_ColorModel Color_ColorModel_ColorModel_MAX = Color_ColorModel_white;
constexpr int Color_ColorModel_ColorModel_ARRAYSIZE = Color_ColorModel_ColorModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_ColorModel_descriptor();
template<typename T>
inline const std::string& Color_ColorModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Color_ColorModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Color_ColorModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Color_ColorModel_descriptor(), enum_t_value);
}
inline bool Color_ColorModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Color_ColorModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Color_ColorModel>(
    Color_ColorModel_descriptor(), name, value);
}
enum Path_ElementType : int {
  Path_ElementType_moveTo = 1,
  Path_ElementType_lineTo = 2,
  Path_ElementType_quadCurveTo = 3,
  Path_ElementType_curveTo = 4,
  Path_ElementType_closeSubpath = 5
};
bool Path_ElementType_IsValid(int value);
constexpr Path_ElementType Path_ElementType_ElementType_MIN = Path_ElementType_moveTo;
constexpr Path_ElementType Path_ElementType_ElementType_MAX = Path_ElementType_closeSubpath;
constexpr int Path_ElementType_ElementType_ARRAYSIZE = Path_ElementType_ElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Path_ElementType_descriptor();
template<typename T>
inline const std::string& Path_ElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Path_ElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Path_ElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Path_ElementType_descriptor(), enum_t_value);
}
inline bool Path_ElementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Path_ElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Path_ElementType>(
    Path_ElementType_descriptor(), name, value);
}
// ===================================================================

class Reference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  explicit PROTOBUF_CONSTEXPR Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reference(const Reference& from);
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reference& from) {
    Reference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Reference";
  }
  protected:
  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kDeprecatedTypeFieldNumber = 2,
    kDeprecatedIsExternalFieldNumber = 3,
  };
  // required uint64 identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  uint64_t identifier() const;
  void set_identifier(uint64_t value);
  private:
  uint64_t _internal_identifier() const;
  void _internal_set_identifier(uint64_t value);
  public:

  // optional int32 deprecated_type = 2;
  bool has_deprecated_type() const;
  private:
  bool _internal_has_deprecated_type() const;
  public:
  void clear_deprecated_type();
  int32_t deprecated_type() const;
  void set_deprecated_type(int32_t value);
  private:
  int32_t _internal_deprecated_type() const;
  void _internal_set_deprecated_type(int32_t value);
  public:

  // optional bool deprecated_is_external = 3;
  bool has_deprecated_is_external() const;
  private:
  bool _internal_has_deprecated_is_external() const;
  public:
  void clear_deprecated_is_external();
  bool deprecated_is_external() const;
  void set_deprecated_is_external(bool value);
  private:
  bool _internal_deprecated_is_external() const;
  void _internal_set_deprecated_is_external(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Reference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t identifier_;
    int32_t deprecated_type_;
    bool deprecated_is_external_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class DataReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.DataReference) */ {
 public:
  inline DataReference() : DataReference(nullptr) {}
  ~DataReference() override;
  explicit PROTOBUF_CONSTEXPR DataReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataReference(const DataReference& from);
  DataReference(DataReference&& from) noexcept
    : DataReference() {
    *this = ::std::move(from);
  }

  inline DataReference& operator=(const DataReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataReference& operator=(DataReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataReference* internal_default_instance() {
    return reinterpret_cast<const DataReference*>(
               &_DataReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataReference& a, DataReference& b) {
    a.Swap(&b);
  }
  inline void Swap(DataReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataReference& from) {
    DataReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.DataReference";
  }
  protected:
  explicit DataReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
  };
  // required uint64 identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  uint64_t identifier() const;
  void set_identifier(uint64_t value);
  private:
  uint64_t _internal_identifier() const;
  void _internal_set_identifier(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.DataReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t identifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Point)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit PROTOBUF_CONSTEXPR Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Size& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Size& from) {
    Size::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // required float width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // required float height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Size)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float width_;
    float height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Range final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Range) */ {
 public:
  inline Range() : Range(nullptr) {}
  ~Range() override;
  explicit PROTOBUF_CONSTEXPR Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Range(const Range& from);
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline Range& operator=(Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }
  inline void Swap(Range* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Range& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Range& from) {
    Range::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Range";
  }
  protected:
  explicit Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // required uint32 location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  uint32_t location() const;
  void set_location(uint32_t value);
  private:
  uint32_t _internal_location() const;
  void _internal_set_location(uint32_t value);
  public:

  // required uint32 length = 2;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Range)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t location_;
    uint32_t length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Date final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Date) */ {
 public:
  inline Date() : Date(nullptr) {}
  ~Date() override;
  explicit PROTOBUF_CONSTEXPR Date(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Date(const Date& from);
  Date(Date&& from) noexcept
    : Date() {
    *this = ::std::move(from);
  }

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }
  inline Date& operator=(Date&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Date& default_instance() {
    return *internal_default_instance();
  }
  static inline const Date* internal_default_instance() {
    return reinterpret_cast<const Date*>(
               &_Date_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Date& a, Date& b) {
    a.Swap(&b);
  }
  inline void Swap(Date* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Date* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Date* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Date>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Date& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Date& from) {
    Date::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Date* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Date";
  }
  protected:
  explicit Date(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
  };
  // required double seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Date)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double seconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class IndexSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.IndexSet) */ {
 public:
  inline IndexSet() : IndexSet(nullptr) {}
  ~IndexSet() override;
  explicit PROTOBUF_CONSTEXPR IndexSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexSet(const IndexSet& from);
  IndexSet(IndexSet&& from) noexcept
    : IndexSet() {
    *this = ::std::move(from);
  }

  inline IndexSet& operator=(const IndexSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexSet& operator=(IndexSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexSet* internal_default_instance() {
    return reinterpret_cast<const IndexSet*>(
               &_IndexSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IndexSet& a, IndexSet& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IndexSet& from) {
    IndexSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.IndexSet";
  }
  protected:
  explicit IndexSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangesFieldNumber = 1,
  };
  // repeated .TSP.Range ranges = 1;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::TSP::Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Range >*
      mutable_ranges();
  private:
  const ::TSP::Range& _internal_ranges(int index) const;
  ::TSP::Range* _internal_add_ranges();
  public:
  const ::TSP::Range& ranges(int index) const;
  ::TSP::Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Range >&
      ranges() const;

  // @@protoc_insertion_point(class_scope:TSP.IndexSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Range > ranges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Color final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  ~Color() override;
  explicit PROTOBUF_CONSTEXPR Color(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Color& default_instance() {
    return *internal_default_instance();
  }
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Color& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Color& from) {
    Color::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Color_ColorModel ColorModel;
  static constexpr ColorModel rgb =
    Color_ColorModel_rgb;
  static constexpr ColorModel cmyk =
    Color_ColorModel_cmyk;
  static constexpr ColorModel white =
    Color_ColorModel_white;
  static inline bool ColorModel_IsValid(int value) {
    return Color_ColorModel_IsValid(value);
  }
  static constexpr ColorModel ColorModel_MIN =
    Color_ColorModel_ColorModel_MIN;
  static constexpr ColorModel ColorModel_MAX =
    Color_ColorModel_ColorModel_MAX;
  static constexpr int ColorModel_ARRAYSIZE =
    Color_ColorModel_ColorModel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ColorModel_descriptor() {
    return Color_ColorModel_descriptor();
  }
  template<typename T>
  static inline const std::string& ColorModel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorModel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorModel_Name.");
    return Color_ColorModel_Name(enum_t_value);
  }
  static inline bool ColorModel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ColorModel* value) {
    return Color_ColorModel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 3,
    kGFieldNumber = 4,
    kBFieldNumber = 5,
    kCFieldNumber = 7,
    kMFieldNumber = 8,
    kYFieldNumber = 9,
    kKFieldNumber = 10,
    kWFieldNumber = 11,
    kModelFieldNumber = 1,
    kAFieldNumber = 6,
  };
  // optional float r = 3;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // optional float g = 4;
  bool has_g() const;
  private:
  bool _internal_has_g() const;
  public:
  void clear_g();
  float g() const;
  void set_g(float value);
  private:
  float _internal_g() const;
  void _internal_set_g(float value);
  public:

  // optional float b = 5;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  float b() const;
  void set_b(float value);
  private:
  float _internal_b() const;
  void _internal_set_b(float value);
  public:

  // optional float c = 7;
  bool has_c() const;
  private:
  bool _internal_has_c() const;
  public:
  void clear_c();
  float c() const;
  void set_c(float value);
  private:
  float _internal_c() const;
  void _internal_set_c(float value);
  public:

  // optional float m = 8;
  bool has_m() const;
  private:
  bool _internal_has_m() const;
  public:
  void clear_m();
  float m() const;
  void set_m(float value);
  private:
  float _internal_m() const;
  void _internal_set_m(float value);
  public:

  // optional float y = 9;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float k = 10;
  bool has_k() const;
  private:
  bool _internal_has_k() const;
  public:
  void clear_k();
  float k() const;
  void set_k(float value);
  private:
  float _internal_k() const;
  void _internal_set_k(float value);
  public:

  // optional float w = 11;
  bool has_w() const;
  private:
  bool _internal_has_w() const;
  public:
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // required .TSP.Color.ColorModel model = 1;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  ::TSP::Color_ColorModel model() const;
  void set_model(::TSP::Color_ColorModel value);
  private:
  ::TSP::Color_ColorModel _internal_model() const;
  void _internal_set_model(::TSP::Color_ColorModel value);
  public:

  // optional float a = 6 [default = 1];
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  float a() const;
  void set_a(float value);
  private:
  float _internal_a() const;
  void _internal_set_a(float value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float r_;
    float g_;
    float b_;
    float c_;
    float m_;
    float y_;
    float k_;
    float w_;
    int model_;
    float a_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Path_Element final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Path.Element) */ {
 public:
  inline Path_Element() : Path_Element(nullptr) {}
  ~Path_Element() override;
  explicit PROTOBUF_CONSTEXPR Path_Element(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path_Element(const Path_Element& from);
  Path_Element(Path_Element&& from) noexcept
    : Path_Element() {
    *this = ::std::move(from);
  }

  inline Path_Element& operator=(const Path_Element& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path_Element& operator=(Path_Element&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path_Element& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path_Element* internal_default_instance() {
    return reinterpret_cast<const Path_Element*>(
               &_Path_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Path_Element& a, Path_Element& b) {
    a.Swap(&b);
  }
  inline void Swap(Path_Element* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path_Element* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path_Element* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path_Element>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path_Element& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path_Element& from) {
    Path_Element::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path_Element* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Path.Element";
  }
  protected:
  explicit Path_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .TSP.Point points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::TSP::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Point >*
      mutable_points();
  private:
  const ::TSP::Point& _internal_points(int index) const;
  ::TSP::Point* _internal_add_points();
  public:
  const ::TSP::Point& points(int index) const;
  ::TSP::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Point >&
      points() const;

  // required .TSP.Path.ElementType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TSP::Path_ElementType type() const;
  void set_type(::TSP::Path_ElementType value);
  private:
  ::TSP::Path_ElementType _internal_type() const;
  void _internal_set_type(::TSP::Path_ElementType value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.Path.Element)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Point > points_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit PROTOBUF_CONSTEXPR Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Path_Element Element;

  typedef Path_ElementType ElementType;
  static constexpr ElementType moveTo =
    Path_ElementType_moveTo;
  static constexpr ElementType lineTo =
    Path_ElementType_lineTo;
  static constexpr ElementType quadCurveTo =
    Path_ElementType_quadCurveTo;
  static constexpr ElementType curveTo =
    Path_ElementType_curveTo;
  static constexpr ElementType closeSubpath =
    Path_ElementType_closeSubpath;
  static inline bool ElementType_IsValid(int value) {
    return Path_ElementType_IsValid(value);
  }
  static constexpr ElementType ElementType_MIN =
    Path_ElementType_ElementType_MIN;
  static constexpr ElementType ElementType_MAX =
    Path_ElementType_ElementType_MAX;
  static constexpr int ElementType_ARRAYSIZE =
    Path_ElementType_ElementType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ElementType_descriptor() {
    return Path_ElementType_descriptor();
  }
  template<typename T>
  static inline const std::string& ElementType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ElementType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ElementType_Name.");
    return Path_ElementType_Name(enum_t_value);
  }
  static inline bool ElementType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ElementType* value) {
    return Path_ElementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .TSP.Path.Element elements = 1;
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::TSP::Path_Element* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Path_Element >*
      mutable_elements();
  private:
  const ::TSP::Path_Element& _internal_elements(int index) const;
  ::TSP::Path_Element* _internal_add_elements();
  public:
  const ::TSP::Path_Element& elements(int index) const;
  ::TSP::Path_Element* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Path_Element >&
      elements() const;

  // @@protoc_insertion_point(class_scope:TSP.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Path_Element > elements_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class ReferenceDictionary_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.ReferenceDictionary.Entry) */ {
 public:
  inline ReferenceDictionary_Entry() : ReferenceDictionary_Entry(nullptr) {}
  ~ReferenceDictionary_Entry() override;
  explicit PROTOBUF_CONSTEXPR ReferenceDictionary_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceDictionary_Entry(const ReferenceDictionary_Entry& from);
  ReferenceDictionary_Entry(ReferenceDictionary_Entry&& from) noexcept
    : ReferenceDictionary_Entry() {
    *this = ::std::move(from);
  }

  inline ReferenceDictionary_Entry& operator=(const ReferenceDictionary_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceDictionary_Entry& operator=(ReferenceDictionary_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceDictionary_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceDictionary_Entry* internal_default_instance() {
    return reinterpret_cast<const ReferenceDictionary_Entry*>(
               &_ReferenceDictionary_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReferenceDictionary_Entry& a, ReferenceDictionary_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceDictionary_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceDictionary_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceDictionary_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceDictionary_Entry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceDictionary_Entry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferenceDictionary_Entry& from) {
    ReferenceDictionary_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceDictionary_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.ReferenceDictionary.Entry";
  }
  protected:
  explicit ReferenceDictionary_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required .TSP.Reference key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::TSP::Reference& key() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_key();
  ::TSP::Reference* mutable_key();
  void set_allocated_key(::TSP::Reference* key);
  private:
  const ::TSP::Reference& _internal_key() const;
  ::TSP::Reference* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::TSP::Reference* key);
  ::TSP::Reference* unsafe_arena_release_key();

  // required .TSP.Reference value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::TSP::Reference& value() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_value();
  ::TSP::Reference* mutable_value();
  void set_allocated_value(::TSP::Reference* value);
  private:
  const ::TSP::Reference& _internal_value() const;
  ::TSP::Reference* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::TSP::Reference* value);
  ::TSP::Reference* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:TSP.ReferenceDictionary.Entry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* key_;
    ::TSP::Reference* value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class ReferenceDictionary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.ReferenceDictionary) */ {
 public:
  inline ReferenceDictionary() : ReferenceDictionary(nullptr) {}
  ~ReferenceDictionary() override;
  explicit PROTOBUF_CONSTEXPR ReferenceDictionary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceDictionary(const ReferenceDictionary& from);
  ReferenceDictionary(ReferenceDictionary&& from) noexcept
    : ReferenceDictionary() {
    *this = ::std::move(from);
  }

  inline ReferenceDictionary& operator=(const ReferenceDictionary& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceDictionary& operator=(ReferenceDictionary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceDictionary& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceDictionary* internal_default_instance() {
    return reinterpret_cast<const ReferenceDictionary*>(
               &_ReferenceDictionary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ReferenceDictionary& a, ReferenceDictionary& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceDictionary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceDictionary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceDictionary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceDictionary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceDictionary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferenceDictionary& from) {
    ReferenceDictionary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceDictionary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.ReferenceDictionary";
  }
  protected:
  explicit ReferenceDictionary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReferenceDictionary_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .TSP.ReferenceDictionary.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::TSP::ReferenceDictionary_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::ReferenceDictionary_Entry >*
      mutable_entries();
  private:
  const ::TSP::ReferenceDictionary_Entry& _internal_entries(int index) const;
  ::TSP::ReferenceDictionary_Entry* _internal_add_entries();
  public:
  const ::TSP::ReferenceDictionary_Entry& entries(int index) const;
  ::TSP::ReferenceDictionary_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::ReferenceDictionary_Entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:TSP.ReferenceDictionary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::ReferenceDictionary_Entry > entries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class PasteboardObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.PasteboardObject) */ {
 public:
  inline PasteboardObject() : PasteboardObject(nullptr) {}
  ~PasteboardObject() override;
  explicit PROTOBUF_CONSTEXPR PasteboardObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PasteboardObject(const PasteboardObject& from);
  PasteboardObject(PasteboardObject&& from) noexcept
    : PasteboardObject() {
    *this = ::std::move(from);
  }

  inline PasteboardObject& operator=(const PasteboardObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasteboardObject& operator=(PasteboardObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasteboardObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasteboardObject* internal_default_instance() {
    return reinterpret_cast<const PasteboardObject*>(
               &_PasteboardObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PasteboardObject& a, PasteboardObject& b) {
    a.Swap(&b);
  }
  inline void Swap(PasteboardObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasteboardObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasteboardObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasteboardObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PasteboardObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PasteboardObject& from) {
    PasteboardObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PasteboardObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.PasteboardObject";
  }
  protected:
  explicit PasteboardObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDrawablesFieldNumber = 2,
    kStylesFieldNumber = 3,
    kStylesheetFieldNumber = 1,
    kThemeFieldNumber = 4,
    kWpStorageFieldNumber = 5,
    kAppNativeObjectFieldNumber = 6,
    kGuideStorageFieldNumber = 9,
    kIsTextPrimaryFieldNumber = 7,
    kIsSmartFieldNumber = 8,
  };
  // repeated .TSP.Reference drawables = 2;
  int drawables_size() const;
  private:
  int _internal_drawables_size() const;
  public:
  void clear_drawables();
  ::TSP::Reference* mutable_drawables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_drawables();
  private:
  const ::TSP::Reference& _internal_drawables(int index) const;
  ::TSP::Reference* _internal_add_drawables();
  public:
  const ::TSP::Reference& drawables(int index) const;
  ::TSP::Reference* add_drawables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      drawables() const;

  // repeated .TSP.Reference styles = 3;
  int styles_size() const;
  private:
  int _internal_styles_size() const;
  public:
  void clear_styles();
  ::TSP::Reference* mutable_styles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_styles();
  private:
  const ::TSP::Reference& _internal_styles(int index) const;
  ::TSP::Reference* _internal_add_styles();
  public:
  const ::TSP::Reference& styles(int index) const;
  ::TSP::Reference* add_styles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      styles() const;

  // optional .TSP.Reference stylesheet = 1;
  bool has_stylesheet() const;
  private:
  bool _internal_has_stylesheet() const;
  public:
  void clear_stylesheet();
  const ::TSP::Reference& stylesheet() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_stylesheet();
  ::TSP::Reference* mutable_stylesheet();
  void set_allocated_stylesheet(::TSP::Reference* stylesheet);
  private:
  const ::TSP::Reference& _internal_stylesheet() const;
  ::TSP::Reference* _internal_mutable_stylesheet();
  public:
  void unsafe_arena_set_allocated_stylesheet(
      ::TSP::Reference* stylesheet);
  ::TSP::Reference* unsafe_arena_release_stylesheet();

  // optional .TSP.Reference theme = 4;
  bool has_theme() const;
  private:
  bool _internal_has_theme() const;
  public:
  void clear_theme();
  const ::TSP::Reference& theme() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_theme();
  ::TSP::Reference* mutable_theme();
  void set_allocated_theme(::TSP::Reference* theme);
  private:
  const ::TSP::Reference& _internal_theme() const;
  ::TSP::Reference* _internal_mutable_theme();
  public:
  void unsafe_arena_set_allocated_theme(
      ::TSP::Reference* theme);
  ::TSP::Reference* unsafe_arena_release_theme();

  // optional .TSP.Reference wp_storage = 5;
  bool has_wp_storage() const;
  private:
  bool _internal_has_wp_storage() const;
  public:
  void clear_wp_storage();
  const ::TSP::Reference& wp_storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_wp_storage();
  ::TSP::Reference* mutable_wp_storage();
  void set_allocated_wp_storage(::TSP::Reference* wp_storage);
  private:
  const ::TSP::Reference& _internal_wp_storage() const;
  ::TSP::Reference* _internal_mutable_wp_storage();
  public:
  void unsafe_arena_set_allocated_wp_storage(
      ::TSP::Reference* wp_storage);
  ::TSP::Reference* unsafe_arena_release_wp_storage();

  // optional .TSP.Reference app_native_object = 6;
  bool has_app_native_object() const;
  private:
  bool _internal_has_app_native_object() const;
  public:
  void clear_app_native_object();
  const ::TSP::Reference& app_native_object() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_app_native_object();
  ::TSP::Reference* mutable_app_native_object();
  void set_allocated_app_native_object(::TSP::Reference* app_native_object);
  private:
  const ::TSP::Reference& _internal_app_native_object() const;
  ::TSP::Reference* _internal_mutable_app_native_object();
  public:
  void unsafe_arena_set_allocated_app_native_object(
      ::TSP::Reference* app_native_object);
  ::TSP::Reference* unsafe_arena_release_app_native_object();

  // optional .TSP.Reference guide_storage = 9;
  bool has_guide_storage() const;
  private:
  bool _internal_has_guide_storage() const;
  public:
  void clear_guide_storage();
  const ::TSP::Reference& guide_storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_guide_storage();
  ::TSP::Reference* mutable_guide_storage();
  void set_allocated_guide_storage(::TSP::Reference* guide_storage);
  private:
  const ::TSP::Reference& _internal_guide_storage() const;
  ::TSP::Reference* _internal_mutable_guide_storage();
  public:
  void unsafe_arena_set_allocated_guide_storage(
      ::TSP::Reference* guide_storage);
  ::TSP::Reference* unsafe_arena_release_guide_storage();

  // optional bool is_text_primary = 7 [default = false];
  bool has_is_text_primary() const;
  private:
  bool _internal_has_is_text_primary() const;
  public:
  void clear_is_text_primary();
  bool is_text_primary() const;
  void set_is_text_primary(bool value);
  private:
  bool _internal_is_text_primary() const;
  void _internal_set_is_text_primary(bool value);
  public:

  // optional bool is_smart = 8 [default = false];
  bool has_is_smart() const;
  private:
  bool _internal_has_is_smart() const;
  public:
  void clear_is_smart();
  bool is_smart() const;
  void set_is_smart(bool value);
  private:
  bool _internal_is_smart() const;
  void _internal_set_is_smart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.PasteboardObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > drawables_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > styles_;
    ::TSP::Reference* stylesheet_;
    ::TSP::Reference* theme_;
    ::TSP::Reference* wp_storage_;
    ::TSP::Reference* app_native_object_;
    ::TSP::Reference* guide_storage_;
    bool is_text_primary_;
    bool is_smart_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// -------------------------------------------------------------------

class ObjectContainer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TSP.ObjectContainer) */ {
 public:
  inline ObjectContainer() : ObjectContainer(nullptr) {}
  ~ObjectContainer() override;
  explicit PROTOBUF_CONSTEXPR ObjectContainer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectContainer(const ObjectContainer& from);
  ObjectContainer(ObjectContainer&& from) noexcept
    : ObjectContainer() {
    *this = ::std::move(from);
  }

  inline ObjectContainer& operator=(const ObjectContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectContainer& operator=(ObjectContainer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectContainer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectContainer* internal_default_instance() {
    return reinterpret_cast<const ObjectContainer*>(
               &_ObjectContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ObjectContainer& a, ObjectContainer& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectContainer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectContainer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectContainer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectContainer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectContainer& from) {
    ObjectContainer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectContainer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TSP.ObjectContainer";
  }
  protected:
  explicit ObjectContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 2,
    kIdentifierFieldNumber = 1,
  };
  // repeated .TSP.Reference objects = 2;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::TSP::Reference* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_objects();
  private:
  const ::TSP::Reference& _internal_objects(int index) const;
  ::TSP::Reference* _internal_add_objects();
  public:
  const ::TSP::Reference& objects(int index) const;
  ::TSP::Reference* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      objects() const;

  // optional uint32 identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  uint32_t identifier() const;
  void set_identifier(uint32_t value);
  private:
  uint32_t _internal_identifier() const;
  void _internal_set_identifier(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TSP.ObjectContainer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > objects_;
    uint32_t identifier_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSPMessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Reference

// required uint64 identifier = 1;
inline bool Reference::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reference::has_identifier() const {
  return _internal_has_identifier();
}
inline void Reference::clear_identifier() {
  _impl_.identifier_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Reference::_internal_identifier() const {
  return _impl_.identifier_;
}
inline uint64_t Reference::identifier() const {
  // @@protoc_insertion_point(field_get:TSP.Reference.identifier)
  return _internal_identifier();
}
inline void Reference::_internal_set_identifier(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identifier_ = value;
}
inline void Reference::set_identifier(uint64_t value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:TSP.Reference.identifier)
}

// optional int32 deprecated_type = 2;
inline bool Reference::_internal_has_deprecated_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reference::has_deprecated_type() const {
  return _internal_has_deprecated_type();
}
inline void Reference::clear_deprecated_type() {
  _impl_.deprecated_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Reference::_internal_deprecated_type() const {
  return _impl_.deprecated_type_;
}
inline int32_t Reference::deprecated_type() const {
  // @@protoc_insertion_point(field_get:TSP.Reference.deprecated_type)
  return _internal_deprecated_type();
}
inline void Reference::_internal_set_deprecated_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.deprecated_type_ = value;
}
inline void Reference::set_deprecated_type(int32_t value) {
  _internal_set_deprecated_type(value);
  // @@protoc_insertion_point(field_set:TSP.Reference.deprecated_type)
}

// optional bool deprecated_is_external = 3;
inline bool Reference::_internal_has_deprecated_is_external() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Reference::has_deprecated_is_external() const {
  return _internal_has_deprecated_is_external();
}
inline void Reference::clear_deprecated_is_external() {
  _impl_.deprecated_is_external_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Reference::_internal_deprecated_is_external() const {
  return _impl_.deprecated_is_external_;
}
inline bool Reference::deprecated_is_external() const {
  // @@protoc_insertion_point(field_get:TSP.Reference.deprecated_is_external)
  return _internal_deprecated_is_external();
}
inline void Reference::_internal_set_deprecated_is_external(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.deprecated_is_external_ = value;
}
inline void Reference::set_deprecated_is_external(bool value) {
  _internal_set_deprecated_is_external(value);
  // @@protoc_insertion_point(field_set:TSP.Reference.deprecated_is_external)
}

// -------------------------------------------------------------------

// DataReference

// required uint64 identifier = 1;
inline bool DataReference::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataReference::has_identifier() const {
  return _internal_has_identifier();
}
inline void DataReference::clear_identifier() {
  _impl_.identifier_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t DataReference::_internal_identifier() const {
  return _impl_.identifier_;
}
inline uint64_t DataReference::identifier() const {
  // @@protoc_insertion_point(field_get:TSP.DataReference.identifier)
  return _internal_identifier();
}
inline void DataReference::_internal_set_identifier(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identifier_ = value;
}
inline void DataReference::set_identifier(uint64_t value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:TSP.DataReference.identifier)
}

// -------------------------------------------------------------------

// Point

// required float x = 1;
inline bool Point::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point::has_x() const {
  return _internal_has_x();
}
inline void Point::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Point::_internal_x() const {
  return _impl_.x_;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:TSP.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Point::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TSP.Point.x)
}

// required float y = 2;
inline bool Point::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point::has_y() const {
  return _internal_has_y();
}
inline void Point::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Point::_internal_y() const {
  return _impl_.y_;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:TSP.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Point::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSP.Point.y)
}

// -------------------------------------------------------------------

// Size

// required float width = 1;
inline bool Size::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Size::has_width() const {
  return _internal_has_width();
}
inline void Size::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Size::_internal_width() const {
  return _impl_.width_;
}
inline float Size::width() const {
  // @@protoc_insertion_point(field_get:TSP.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void Size::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TSP.Size.width)
}

// required float height = 2;
inline bool Size::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Size::has_height() const {
  return _internal_has_height();
}
inline void Size::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Size::_internal_height() const {
  return _impl_.height_;
}
inline float Size::height() const {
  // @@protoc_insertion_point(field_get:TSP.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void Size::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TSP.Size.height)
}

// -------------------------------------------------------------------

// Range

// required uint32 location = 1;
inline bool Range::_internal_has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Range::has_location() const {
  return _internal_has_location();
}
inline void Range::clear_location() {
  _impl_.location_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Range::_internal_location() const {
  return _impl_.location_;
}
inline uint32_t Range::location() const {
  // @@protoc_insertion_point(field_get:TSP.Range.location)
  return _internal_location();
}
inline void Range::_internal_set_location(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.location_ = value;
}
inline void Range::set_location(uint32_t value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:TSP.Range.location)
}

// required uint32 length = 2;
inline bool Range::_internal_has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Range::has_length() const {
  return _internal_has_length();
}
inline void Range::clear_length() {
  _impl_.length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Range::_internal_length() const {
  return _impl_.length_;
}
inline uint32_t Range::length() const {
  // @@protoc_insertion_point(field_get:TSP.Range.length)
  return _internal_length();
}
inline void Range::_internal_set_length(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.length_ = value;
}
inline void Range::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:TSP.Range.length)
}

// -------------------------------------------------------------------

// Date

// required double seconds = 1;
inline bool Date::_internal_has_seconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Date::has_seconds() const {
  return _internal_has_seconds();
}
inline void Date::clear_seconds() {
  _impl_.seconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Date::_internal_seconds() const {
  return _impl_.seconds_;
}
inline double Date::seconds() const {
  // @@protoc_insertion_point(field_get:TSP.Date.seconds)
  return _internal_seconds();
}
inline void Date::_internal_set_seconds(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.seconds_ = value;
}
inline void Date::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:TSP.Date.seconds)
}

// -------------------------------------------------------------------

// IndexSet

// repeated .TSP.Range ranges = 1;
inline int IndexSet::_internal_ranges_size() const {
  return _impl_.ranges_.size();
}
inline int IndexSet::ranges_size() const {
  return _internal_ranges_size();
}
inline void IndexSet::clear_ranges() {
  _impl_.ranges_.Clear();
}
inline ::TSP::Range* IndexSet::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.IndexSet.ranges)
  return _impl_.ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Range >*
IndexSet::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:TSP.IndexSet.ranges)
  return &_impl_.ranges_;
}
inline const ::TSP::Range& IndexSet::_internal_ranges(int index) const {
  return _impl_.ranges_.Get(index);
}
inline const ::TSP::Range& IndexSet::ranges(int index) const {
  // @@protoc_insertion_point(field_get:TSP.IndexSet.ranges)
  return _internal_ranges(index);
}
inline ::TSP::Range* IndexSet::_internal_add_ranges() {
  return _impl_.ranges_.Add();
}
inline ::TSP::Range* IndexSet::add_ranges() {
  ::TSP::Range* _add = _internal_add_ranges();
  // @@protoc_insertion_point(field_add:TSP.IndexSet.ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Range >&
IndexSet::ranges() const {
  // @@protoc_insertion_point(field_list:TSP.IndexSet.ranges)
  return _impl_.ranges_;
}

// -------------------------------------------------------------------

// Color

// required .TSP.Color.ColorModel model = 1;
inline bool Color::_internal_has_model() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Color::has_model() const {
  return _internal_has_model();
}
inline void Color::clear_model() {
  _impl_.model_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::TSP::Color_ColorModel Color::_internal_model() const {
  return static_cast< ::TSP::Color_ColorModel >(_impl_.model_);
}
inline ::TSP::Color_ColorModel Color::model() const {
  // @@protoc_insertion_point(field_get:TSP.Color.model)
  return _internal_model();
}
inline void Color::_internal_set_model(::TSP::Color_ColorModel value) {
  assert(::TSP::Color_ColorModel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.model_ = value;
}
inline void Color::set_model(::TSP::Color_ColorModel value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:TSP.Color.model)
}

// optional float r = 3;
inline bool Color::_internal_has_r() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Color::has_r() const {
  return _internal_has_r();
}
inline void Color::clear_r() {
  _impl_.r_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Color::_internal_r() const {
  return _impl_.r_;
}
inline float Color::r() const {
  // @@protoc_insertion_point(field_get:TSP.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.r_ = value;
}
inline void Color::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:TSP.Color.r)
}

// optional float g = 4;
inline bool Color::_internal_has_g() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Color::has_g() const {
  return _internal_has_g();
}
inline void Color::clear_g() {
  _impl_.g_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Color::_internal_g() const {
  return _impl_.g_;
}
inline float Color::g() const {
  // @@protoc_insertion_point(field_get:TSP.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.g_ = value;
}
inline void Color::set_g(float value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:TSP.Color.g)
}

// optional float b = 5;
inline bool Color::_internal_has_b() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Color::has_b() const {
  return _internal_has_b();
}
inline void Color::clear_b() {
  _impl_.b_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Color::_internal_b() const {
  return _impl_.b_;
}
inline float Color::b() const {
  // @@protoc_insertion_point(field_get:TSP.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.b_ = value;
}
inline void Color::set_b(float value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:TSP.Color.b)
}

// optional float a = 6 [default = 1];
inline bool Color::_internal_has_a() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Color::has_a() const {
  return _internal_has_a();
}
inline void Color::clear_a() {
  _impl_.a_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float Color::_internal_a() const {
  return _impl_.a_;
}
inline float Color::a() const {
  // @@protoc_insertion_point(field_get:TSP.Color.a)
  return _internal_a();
}
inline void Color::_internal_set_a(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.a_ = value;
}
inline void Color::set_a(float value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:TSP.Color.a)
}

// optional float c = 7;
inline bool Color::_internal_has_c() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Color::has_c() const {
  return _internal_has_c();
}
inline void Color::clear_c() {
  _impl_.c_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Color::_internal_c() const {
  return _impl_.c_;
}
inline float Color::c() const {
  // @@protoc_insertion_point(field_get:TSP.Color.c)
  return _internal_c();
}
inline void Color::_internal_set_c(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.c_ = value;
}
inline void Color::set_c(float value) {
  _internal_set_c(value);
  // @@protoc_insertion_point(field_set:TSP.Color.c)
}

// optional float m = 8;
inline bool Color::_internal_has_m() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Color::has_m() const {
  return _internal_has_m();
}
inline void Color::clear_m() {
  _impl_.m_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Color::_internal_m() const {
  return _impl_.m_;
}
inline float Color::m() const {
  // @@protoc_insertion_point(field_get:TSP.Color.m)
  return _internal_m();
}
inline void Color::_internal_set_m(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_ = value;
}
inline void Color::set_m(float value) {
  _internal_set_m(value);
  // @@protoc_insertion_point(field_set:TSP.Color.m)
}

// optional float y = 9;
inline bool Color::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Color::has_y() const {
  return _internal_has_y();
}
inline void Color::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Color::_internal_y() const {
  return _impl_.y_;
}
inline float Color::y() const {
  // @@protoc_insertion_point(field_get:TSP.Color.y)
  return _internal_y();
}
inline void Color::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.y_ = value;
}
inline void Color::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TSP.Color.y)
}

// optional float k = 10;
inline bool Color::_internal_has_k() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Color::has_k() const {
  return _internal_has_k();
}
inline void Color::clear_k() {
  _impl_.k_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float Color::_internal_k() const {
  return _impl_.k_;
}
inline float Color::k() const {
  // @@protoc_insertion_point(field_get:TSP.Color.k)
  return _internal_k();
}
inline void Color::_internal_set_k(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.k_ = value;
}
inline void Color::set_k(float value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:TSP.Color.k)
}

// optional float w = 11;
inline bool Color::_internal_has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Color::has_w() const {
  return _internal_has_w();
}
inline void Color::clear_w() {
  _impl_.w_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float Color::_internal_w() const {
  return _impl_.w_;
}
inline float Color::w() const {
  // @@protoc_insertion_point(field_get:TSP.Color.w)
  return _internal_w();
}
inline void Color::_internal_set_w(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.w_ = value;
}
inline void Color::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:TSP.Color.w)
}

// -------------------------------------------------------------------

// Path_Element

// required .TSP.Path.ElementType type = 1;
inline bool Path_Element::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Path_Element::has_type() const {
  return _internal_has_type();
}
inline void Path_Element::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TSP::Path_ElementType Path_Element::_internal_type() const {
  return static_cast< ::TSP::Path_ElementType >(_impl_.type_);
}
inline ::TSP::Path_ElementType Path_Element::type() const {
  // @@protoc_insertion_point(field_get:TSP.Path.Element.type)
  return _internal_type();
}
inline void Path_Element::_internal_set_type(::TSP::Path_ElementType value) {
  assert(::TSP::Path_ElementType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void Path_Element::set_type(::TSP::Path_ElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TSP.Path.Element.type)
}

// repeated .TSP.Point points = 2;
inline int Path_Element::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Path_Element::points_size() const {
  return _internal_points_size();
}
inline void Path_Element::clear_points() {
  _impl_.points_.Clear();
}
inline ::TSP::Point* Path_Element::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.Path.Element.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Point >*
Path_Element::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TSP.Path.Element.points)
  return &_impl_.points_;
}
inline const ::TSP::Point& Path_Element::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::TSP::Point& Path_Element::points(int index) const {
  // @@protoc_insertion_point(field_get:TSP.Path.Element.points)
  return _internal_points(index);
}
inline ::TSP::Point* Path_Element::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::TSP::Point* Path_Element::add_points() {
  ::TSP::Point* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:TSP.Path.Element.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Point >&
Path_Element::points() const {
  // @@protoc_insertion_point(field_list:TSP.Path.Element.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// Path

// repeated .TSP.Path.Element elements = 1;
inline int Path::_internal_elements_size() const {
  return _impl_.elements_.size();
}
inline int Path::elements_size() const {
  return _internal_elements_size();
}
inline void Path::clear_elements() {
  _impl_.elements_.Clear();
}
inline ::TSP::Path_Element* Path::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.Path.elements)
  return _impl_.elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Path_Element >*
Path::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:TSP.Path.elements)
  return &_impl_.elements_;
}
inline const ::TSP::Path_Element& Path::_internal_elements(int index) const {
  return _impl_.elements_.Get(index);
}
inline const ::TSP::Path_Element& Path::elements(int index) const {
  // @@protoc_insertion_point(field_get:TSP.Path.elements)
  return _internal_elements(index);
}
inline ::TSP::Path_Element* Path::_internal_add_elements() {
  return _impl_.elements_.Add();
}
inline ::TSP::Path_Element* Path::add_elements() {
  ::TSP::Path_Element* _add = _internal_add_elements();
  // @@protoc_insertion_point(field_add:TSP.Path.elements)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Path_Element >&
Path::elements() const {
  // @@protoc_insertion_point(field_list:TSP.Path.elements)
  return _impl_.elements_;
}

// -------------------------------------------------------------------

// ReferenceDictionary_Entry

// required .TSP.Reference key = 1;
inline bool ReferenceDictionary_Entry::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool ReferenceDictionary_Entry::has_key() const {
  return _internal_has_key();
}
inline void ReferenceDictionary_Entry::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSP::Reference& ReferenceDictionary_Entry::_internal_key() const {
  const ::TSP::Reference* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReferenceDictionary_Entry::key() const {
  // @@protoc_insertion_point(field_get:TSP.ReferenceDictionary.Entry.key)
  return _internal_key();
}
inline void ReferenceDictionary_Entry::unsafe_arena_set_allocated_key(
    ::TSP::Reference* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.ReferenceDictionary.Entry.key)
}
inline ::TSP::Reference* ReferenceDictionary_Entry::release_key() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:TSP.ReferenceDictionary.Entry.key)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::mutable_key() {
  ::TSP::Reference* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:TSP.ReferenceDictionary.Entry.key)
  return _msg;
}
inline void ReferenceDictionary_Entry::set_allocated_key(::TSP::Reference* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:TSP.ReferenceDictionary.Entry.key)
}

// required .TSP.Reference value = 2;
inline bool ReferenceDictionary_Entry::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool ReferenceDictionary_Entry::has_value() const {
  return _internal_has_value();
}
inline void ReferenceDictionary_Entry::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSP::Reference& ReferenceDictionary_Entry::_internal_value() const {
  const ::TSP::Reference* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ReferenceDictionary_Entry::value() const {
  // @@protoc_insertion_point(field_get:TSP.ReferenceDictionary.Entry.value)
  return _internal_value();
}
inline void ReferenceDictionary_Entry::unsafe_arena_set_allocated_value(
    ::TSP::Reference* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.ReferenceDictionary.Entry.value)
}
inline ::TSP::Reference* ReferenceDictionary_Entry::release_value() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:TSP.ReferenceDictionary.Entry.value)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::TSP::Reference* ReferenceDictionary_Entry::mutable_value() {
  ::TSP::Reference* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TSP.ReferenceDictionary.Entry.value)
  return _msg;
}
inline void ReferenceDictionary_Entry::set_allocated_value(::TSP::Reference* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:TSP.ReferenceDictionary.Entry.value)
}

// -------------------------------------------------------------------

// ReferenceDictionary

// repeated .TSP.ReferenceDictionary.Entry entries = 1;
inline int ReferenceDictionary::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int ReferenceDictionary::entries_size() const {
  return _internal_entries_size();
}
inline void ReferenceDictionary::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::TSP::ReferenceDictionary_Entry* ReferenceDictionary::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.ReferenceDictionary.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::ReferenceDictionary_Entry >*
ReferenceDictionary::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TSP.ReferenceDictionary.entries)
  return &_impl_.entries_;
}
inline const ::TSP::ReferenceDictionary_Entry& ReferenceDictionary::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::TSP::ReferenceDictionary_Entry& ReferenceDictionary::entries(int index) const {
  // @@protoc_insertion_point(field_get:TSP.ReferenceDictionary.entries)
  return _internal_entries(index);
}
inline ::TSP::ReferenceDictionary_Entry* ReferenceDictionary::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::TSP::ReferenceDictionary_Entry* ReferenceDictionary::add_entries() {
  ::TSP::ReferenceDictionary_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:TSP.ReferenceDictionary.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::ReferenceDictionary_Entry >&
ReferenceDictionary::entries() const {
  // @@protoc_insertion_point(field_list:TSP.ReferenceDictionary.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// PasteboardObject

// optional .TSP.Reference stylesheet = 1;
inline bool PasteboardObject::_internal_has_stylesheet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stylesheet_ != nullptr);
  return value;
}
inline bool PasteboardObject::has_stylesheet() const {
  return _internal_has_stylesheet();
}
inline void PasteboardObject::clear_stylesheet() {
  if (_impl_.stylesheet_ != nullptr) _impl_.stylesheet_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TSP::Reference& PasteboardObject::_internal_stylesheet() const {
  const ::TSP::Reference* p = _impl_.stylesheet_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteboardObject::stylesheet() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.stylesheet)
  return _internal_stylesheet();
}
inline void PasteboardObject::unsafe_arena_set_allocated_stylesheet(
    ::TSP::Reference* stylesheet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stylesheet_);
  }
  _impl_.stylesheet_ = stylesheet;
  if (stylesheet) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.PasteboardObject.stylesheet)
}
inline ::TSP::Reference* PasteboardObject::release_stylesheet() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.stylesheet_;
  _impl_.stylesheet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteboardObject::unsafe_arena_release_stylesheet() {
  // @@protoc_insertion_point(field_release:TSP.PasteboardObject.stylesheet)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.stylesheet_;
  _impl_.stylesheet_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteboardObject::_internal_mutable_stylesheet() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stylesheet_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.stylesheet_ = p;
  }
  return _impl_.stylesheet_;
}
inline ::TSP::Reference* PasteboardObject::mutable_stylesheet() {
  ::TSP::Reference* _msg = _internal_mutable_stylesheet();
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.stylesheet)
  return _msg;
}
inline void PasteboardObject::set_allocated_stylesheet(::TSP::Reference* stylesheet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stylesheet_;
  }
  if (stylesheet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stylesheet);
    if (message_arena != submessage_arena) {
      stylesheet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stylesheet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stylesheet_ = stylesheet;
  // @@protoc_insertion_point(field_set_allocated:TSP.PasteboardObject.stylesheet)
}

// repeated .TSP.Reference drawables = 2;
inline int PasteboardObject::_internal_drawables_size() const {
  return _impl_.drawables_.size();
}
inline int PasteboardObject::drawables_size() const {
  return _internal_drawables_size();
}
inline void PasteboardObject::clear_drawables() {
  _impl_.drawables_.Clear();
}
inline ::TSP::Reference* PasteboardObject::mutable_drawables(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.drawables)
  return _impl_.drawables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
PasteboardObject::mutable_drawables() {
  // @@protoc_insertion_point(field_mutable_list:TSP.PasteboardObject.drawables)
  return &_impl_.drawables_;
}
inline const ::TSP::Reference& PasteboardObject::_internal_drawables(int index) const {
  return _impl_.drawables_.Get(index);
}
inline const ::TSP::Reference& PasteboardObject::drawables(int index) const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.drawables)
  return _internal_drawables(index);
}
inline ::TSP::Reference* PasteboardObject::_internal_add_drawables() {
  return _impl_.drawables_.Add();
}
inline ::TSP::Reference* PasteboardObject::add_drawables() {
  ::TSP::Reference* _add = _internal_add_drawables();
  // @@protoc_insertion_point(field_add:TSP.PasteboardObject.drawables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
PasteboardObject::drawables() const {
  // @@protoc_insertion_point(field_list:TSP.PasteboardObject.drawables)
  return _impl_.drawables_;
}

// repeated .TSP.Reference styles = 3;
inline int PasteboardObject::_internal_styles_size() const {
  return _impl_.styles_.size();
}
inline int PasteboardObject::styles_size() const {
  return _internal_styles_size();
}
inline void PasteboardObject::clear_styles() {
  _impl_.styles_.Clear();
}
inline ::TSP::Reference* PasteboardObject::mutable_styles(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.styles)
  return _impl_.styles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
PasteboardObject::mutable_styles() {
  // @@protoc_insertion_point(field_mutable_list:TSP.PasteboardObject.styles)
  return &_impl_.styles_;
}
inline const ::TSP::Reference& PasteboardObject::_internal_styles(int index) const {
  return _impl_.styles_.Get(index);
}
inline const ::TSP::Reference& PasteboardObject::styles(int index) const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.styles)
  return _internal_styles(index);
}
inline ::TSP::Reference* PasteboardObject::_internal_add_styles() {
  return _impl_.styles_.Add();
}
inline ::TSP::Reference* PasteboardObject::add_styles() {
  ::TSP::Reference* _add = _internal_add_styles();
  // @@protoc_insertion_point(field_add:TSP.PasteboardObject.styles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
PasteboardObject::styles() const {
  // @@protoc_insertion_point(field_list:TSP.PasteboardObject.styles)
  return _impl_.styles_;
}

// optional .TSP.Reference theme = 4;
inline bool PasteboardObject::_internal_has_theme() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.theme_ != nullptr);
  return value;
}
inline bool PasteboardObject::has_theme() const {
  return _internal_has_theme();
}
inline void PasteboardObject::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TSP::Reference& PasteboardObject::_internal_theme() const {
  const ::TSP::Reference* p = _impl_.theme_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteboardObject::theme() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.theme)
  return _internal_theme();
}
inline void PasteboardObject::unsafe_arena_set_allocated_theme(
    ::TSP::Reference* theme) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.theme_);
  }
  _impl_.theme_ = theme;
  if (theme) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.PasteboardObject.theme)
}
inline ::TSP::Reference* PasteboardObject::release_theme() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteboardObject::unsafe_arena_release_theme() {
  // @@protoc_insertion_point(field_release:TSP.PasteboardObject.theme)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.theme_;
  _impl_.theme_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteboardObject::_internal_mutable_theme() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.theme_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.theme_ = p;
  }
  return _impl_.theme_;
}
inline ::TSP::Reference* PasteboardObject::mutable_theme() {
  ::TSP::Reference* _msg = _internal_mutable_theme();
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.theme)
  return _msg;
}
inline void PasteboardObject::set_allocated_theme(::TSP::Reference* theme) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.theme_;
  }
  if (theme) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(theme);
    if (message_arena != submessage_arena) {
      theme = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, theme, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.theme_ = theme;
  // @@protoc_insertion_point(field_set_allocated:TSP.PasteboardObject.theme)
}

// optional .TSP.Reference wp_storage = 5;
inline bool PasteboardObject::_internal_has_wp_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wp_storage_ != nullptr);
  return value;
}
inline bool PasteboardObject::has_wp_storage() const {
  return _internal_has_wp_storage();
}
inline void PasteboardObject::clear_wp_storage() {
  if (_impl_.wp_storage_ != nullptr) _impl_.wp_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TSP::Reference& PasteboardObject::_internal_wp_storage() const {
  const ::TSP::Reference* p = _impl_.wp_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteboardObject::wp_storage() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.wp_storage)
  return _internal_wp_storage();
}
inline void PasteboardObject::unsafe_arena_set_allocated_wp_storage(
    ::TSP::Reference* wp_storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wp_storage_);
  }
  _impl_.wp_storage_ = wp_storage;
  if (wp_storage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.PasteboardObject.wp_storage)
}
inline ::TSP::Reference* PasteboardObject::release_wp_storage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.wp_storage_;
  _impl_.wp_storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteboardObject::unsafe_arena_release_wp_storage() {
  // @@protoc_insertion_point(field_release:TSP.PasteboardObject.wp_storage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.wp_storage_;
  _impl_.wp_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteboardObject::_internal_mutable_wp_storage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.wp_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.wp_storage_ = p;
  }
  return _impl_.wp_storage_;
}
inline ::TSP::Reference* PasteboardObject::mutable_wp_storage() {
  ::TSP::Reference* _msg = _internal_mutable_wp_storage();
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.wp_storage)
  return _msg;
}
inline void PasteboardObject::set_allocated_wp_storage(::TSP::Reference* wp_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wp_storage_;
  }
  if (wp_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wp_storage);
    if (message_arena != submessage_arena) {
      wp_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wp_storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.wp_storage_ = wp_storage;
  // @@protoc_insertion_point(field_set_allocated:TSP.PasteboardObject.wp_storage)
}

// optional .TSP.Reference guide_storage = 9;
inline bool PasteboardObject::_internal_has_guide_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.guide_storage_ != nullptr);
  return value;
}
inline bool PasteboardObject::has_guide_storage() const {
  return _internal_has_guide_storage();
}
inline void PasteboardObject::clear_guide_storage() {
  if (_impl_.guide_storage_ != nullptr) _impl_.guide_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TSP::Reference& PasteboardObject::_internal_guide_storage() const {
  const ::TSP::Reference* p = _impl_.guide_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteboardObject::guide_storage() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.guide_storage)
  return _internal_guide_storage();
}
inline void PasteboardObject::unsafe_arena_set_allocated_guide_storage(
    ::TSP::Reference* guide_storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guide_storage_);
  }
  _impl_.guide_storage_ = guide_storage;
  if (guide_storage) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.PasteboardObject.guide_storage)
}
inline ::TSP::Reference* PasteboardObject::release_guide_storage() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.guide_storage_;
  _impl_.guide_storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteboardObject::unsafe_arena_release_guide_storage() {
  // @@protoc_insertion_point(field_release:TSP.PasteboardObject.guide_storage)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.guide_storage_;
  _impl_.guide_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteboardObject::_internal_mutable_guide_storage() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.guide_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.guide_storage_ = p;
  }
  return _impl_.guide_storage_;
}
inline ::TSP::Reference* PasteboardObject::mutable_guide_storage() {
  ::TSP::Reference* _msg = _internal_mutable_guide_storage();
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.guide_storage)
  return _msg;
}
inline void PasteboardObject::set_allocated_guide_storage(::TSP::Reference* guide_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guide_storage_;
  }
  if (guide_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guide_storage);
    if (message_arena != submessage_arena) {
      guide_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guide_storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.guide_storage_ = guide_storage;
  // @@protoc_insertion_point(field_set_allocated:TSP.PasteboardObject.guide_storage)
}

// optional .TSP.Reference app_native_object = 6;
inline bool PasteboardObject::_internal_has_app_native_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_native_object_ != nullptr);
  return value;
}
inline bool PasteboardObject::has_app_native_object() const {
  return _internal_has_app_native_object();
}
inline void PasteboardObject::clear_app_native_object() {
  if (_impl_.app_native_object_ != nullptr) _impl_.app_native_object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TSP::Reference& PasteboardObject::_internal_app_native_object() const {
  const ::TSP::Reference* p = _impl_.app_native_object_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& PasteboardObject::app_native_object() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.app_native_object)
  return _internal_app_native_object();
}
inline void PasteboardObject::unsafe_arena_set_allocated_app_native_object(
    ::TSP::Reference* app_native_object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_native_object_);
  }
  _impl_.app_native_object_ = app_native_object;
  if (app_native_object) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TSP.PasteboardObject.app_native_object)
}
inline ::TSP::Reference* PasteboardObject::release_app_native_object() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.app_native_object_;
  _impl_.app_native_object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* PasteboardObject::unsafe_arena_release_app_native_object() {
  // @@protoc_insertion_point(field_release:TSP.PasteboardObject.app_native_object)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.app_native_object_;
  _impl_.app_native_object_ = nullptr;
  return temp;
}
inline ::TSP::Reference* PasteboardObject::_internal_mutable_app_native_object() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.app_native_object_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.app_native_object_ = p;
  }
  return _impl_.app_native_object_;
}
inline ::TSP::Reference* PasteboardObject::mutable_app_native_object() {
  ::TSP::Reference* _msg = _internal_mutable_app_native_object();
  // @@protoc_insertion_point(field_mutable:TSP.PasteboardObject.app_native_object)
  return _msg;
}
inline void PasteboardObject::set_allocated_app_native_object(::TSP::Reference* app_native_object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.app_native_object_;
  }
  if (app_native_object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_native_object);
    if (message_arena != submessage_arena) {
      app_native_object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_native_object, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.app_native_object_ = app_native_object;
  // @@protoc_insertion_point(field_set_allocated:TSP.PasteboardObject.app_native_object)
}

// optional bool is_text_primary = 7 [default = false];
inline bool PasteboardObject::_internal_has_is_text_primary() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PasteboardObject::has_is_text_primary() const {
  return _internal_has_is_text_primary();
}
inline void PasteboardObject::clear_is_text_primary() {
  _impl_.is_text_primary_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PasteboardObject::_internal_is_text_primary() const {
  return _impl_.is_text_primary_;
}
inline bool PasteboardObject::is_text_primary() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.is_text_primary)
  return _internal_is_text_primary();
}
inline void PasteboardObject::_internal_set_is_text_primary(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.is_text_primary_ = value;
}
inline void PasteboardObject::set_is_text_primary(bool value) {
  _internal_set_is_text_primary(value);
  // @@protoc_insertion_point(field_set:TSP.PasteboardObject.is_text_primary)
}

// optional bool is_smart = 8 [default = false];
inline bool PasteboardObject::_internal_has_is_smart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PasteboardObject::has_is_smart() const {
  return _internal_has_is_smart();
}
inline void PasteboardObject::clear_is_smart() {
  _impl_.is_smart_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool PasteboardObject::_internal_is_smart() const {
  return _impl_.is_smart_;
}
inline bool PasteboardObject::is_smart() const {
  // @@protoc_insertion_point(field_get:TSP.PasteboardObject.is_smart)
  return _internal_is_smart();
}
inline void PasteboardObject::_internal_set_is_smart(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.is_smart_ = value;
}
inline void PasteboardObject::set_is_smart(bool value) {
  _internal_set_is_smart(value);
  // @@protoc_insertion_point(field_set:TSP.PasteboardObject.is_smart)
}

// -------------------------------------------------------------------

// ObjectContainer

// optional uint32 identifier = 1;
inline bool ObjectContainer::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectContainer::has_identifier() const {
  return _internal_has_identifier();
}
inline void ObjectContainer::clear_identifier() {
  _impl_.identifier_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ObjectContainer::_internal_identifier() const {
  return _impl_.identifier_;
}
inline uint32_t ObjectContainer::identifier() const {
  // @@protoc_insertion_point(field_get:TSP.ObjectContainer.identifier)
  return _internal_identifier();
}
inline void ObjectContainer::_internal_set_identifier(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identifier_ = value;
}
inline void ObjectContainer::set_identifier(uint32_t value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:TSP.ObjectContainer.identifier)
}

// repeated .TSP.Reference objects = 2;
inline int ObjectContainer::_internal_objects_size() const {
  return _impl_.objects_.size();
}
inline int ObjectContainer::objects_size() const {
  return _internal_objects_size();
}
inline void ObjectContainer::clear_objects() {
  _impl_.objects_.Clear();
}
inline ::TSP::Reference* ObjectContainer::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:TSP.ObjectContainer.objects)
  return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ObjectContainer::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:TSP.ObjectContainer.objects)
  return &_impl_.objects_;
}
inline const ::TSP::Reference& ObjectContainer::_internal_objects(int index) const {
  return _impl_.objects_.Get(index);
}
inline const ::TSP::Reference& ObjectContainer::objects(int index) const {
  // @@protoc_insertion_point(field_get:TSP.ObjectContainer.objects)
  return _internal_objects(index);
}
inline ::TSP::Reference* ObjectContainer::_internal_add_objects() {
  return _impl_.objects_.Add();
}
inline ::TSP::Reference* ObjectContainer::add_objects() {
  ::TSP::Reference* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:TSP.ObjectContainer.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ObjectContainer::objects() const {
  // @@protoc_insertion_point(field_list:TSP.ObjectContainer.objects)
  return _impl_.objects_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TSP

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TSP::Color_ColorModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSP::Color_ColorModel>() {
  return ::TSP::Color_ColorModel_descriptor();
}
template <> struct is_proto_enum< ::TSP::Path_ElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TSP::Path_ElementType>() {
  return ::TSP::Path_ElementType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSPMessages_2eproto
