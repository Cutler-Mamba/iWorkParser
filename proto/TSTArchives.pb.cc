// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSTArchives.proto

#include "TSTArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TST {
PROTOBUF_CONSTEXPR CellID::CellID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.packeddata_)*/0u} {}
struct CellIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellIDDefaultTypeInternal() {}
  union {
    CellID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellIDDefaultTypeInternal _CellID_default_instance_;
PROTOBUF_CONSTEXPR TableSize::TableSize(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.packeddata_)*/0u} {}
struct TableSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableSizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableSizeDefaultTypeInternal() {}
  union {
    TableSize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableSizeDefaultTypeInternal _TableSize_default_instance_;
PROTOBUF_CONSTEXPR CellRange::CellRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr} {}
struct CellRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellRangeDefaultTypeInternal() {}
  union {
    CellRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellRangeDefaultTypeInternal _CellRange_default_instance_;
PROTOBUF_CONSTEXPR TableSelection::TableSelection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellrange_)*/nullptr
  , /*decltype(_impl_.extendedcellrange_)*/nullptr
  , /*decltype(_impl_.extendedcellrangevalid_)*/false
  , /*decltype(_impl_.selection_type_)*/0} {}
struct TableSelectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableSelectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableSelectionDefaultTypeInternal() {}
  union {
    TableSelection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableSelectionDefaultTypeInternal _TableSelection_default_instance_;
PROTOBUF_CONSTEXPR TileRowInfo::TileRowInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellstoragebuffer_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.celloffsets_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tilerowindex_)*/0u
  , /*decltype(_impl_.cellcount_)*/0u
  , /*decltype(_impl_.storage_version_)*/0u} {}
struct TileRowInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TileRowInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TileRowInfoDefaultTypeInternal() {}
  union {
    TileRowInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TileRowInfoDefaultTypeInternal _TileRowInfo_default_instance_;
PROTOBUF_CONSTEXPR Tile::Tile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rowinfos_)*/{}
  , /*decltype(_impl_.maxcolumn_)*/0u
  , /*decltype(_impl_.maxrow_)*/0u
  , /*decltype(_impl_.numcells_)*/0u
  , /*decltype(_impl_.numrows_)*/0u
  , /*decltype(_impl_.storage_version_)*/0u} {}
struct TileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TileDefaultTypeInternal() {}
  union {
    Tile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TileDefaultTypeInternal _Tile_default_instance_;
PROTOBUF_CONSTEXPR TileStorage_Tile::TileStorage_Tile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tile_)*/nullptr
  , /*decltype(_impl_.tileid_)*/0u} {}
struct TileStorage_TileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TileStorage_TileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TileStorage_TileDefaultTypeInternal() {}
  union {
    TileStorage_Tile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TileStorage_TileDefaultTypeInternal _TileStorage_Tile_default_instance_;
PROTOBUF_CONSTEXPR TileStorage::TileStorage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tiles_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TileStorageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TileStorageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TileStorageDefaultTypeInternal() {}
  union {
    TileStorage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TileStorageDefaultTypeInternal _TileStorage_default_instance_;
PROTOBUF_CONSTEXPR PopUpMenuModel_CellValue::PopUpMenuModel_CellValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.boolean_value_)*/nullptr
  , /*decltype(_impl_.date_value_)*/nullptr
  , /*decltype(_impl_.number_value_)*/nullptr
  , /*decltype(_impl_.string_value_)*/nullptr
  , /*decltype(_impl_.cell_value_type_)*/1} {}
struct PopUpMenuModel_CellValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PopUpMenuModel_CellValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PopUpMenuModel_CellValueDefaultTypeInternal() {}
  union {
    PopUpMenuModel_CellValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PopUpMenuModel_CellValueDefaultTypeInternal _PopUpMenuModel_CellValue_default_instance_;
PROTOBUF_CONSTEXPR PopUpMenuModel::PopUpMenuModel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.item_)*/{}
  , /*decltype(_impl_.tsce_item_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PopUpMenuModelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PopUpMenuModelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PopUpMenuModelDefaultTypeInternal() {}
  union {
    PopUpMenuModel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PopUpMenuModelDefaultTypeInternal _PopUpMenuModel_default_instance_;
PROTOBUF_CONSTEXPR TableDataList_ListEntry::TableDataList_ListEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reference_)*/nullptr
  , /*decltype(_impl_.formula_)*/nullptr
  , /*decltype(_impl_.format_)*/nullptr
  , /*decltype(_impl_.region_)*/nullptr
  , /*decltype(_impl_.custom_format_)*/nullptr
  , /*decltype(_impl_.richtextpayload_)*/nullptr
  , /*decltype(_impl_.comment_storage_)*/nullptr
  , /*decltype(_impl_.key_)*/0u
  , /*decltype(_impl_.refcount_)*/0u} {}
struct TableDataList_ListEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableDataList_ListEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableDataList_ListEntryDefaultTypeInternal() {}
  union {
    TableDataList_ListEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableDataList_ListEntryDefaultTypeInternal _TableDataList_ListEntry_default_instance_;
PROTOBUF_CONSTEXPR TableDataList::TableDataList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.nextlistid_)*/0u
  , /*decltype(_impl_.listtype_)*/1} {}
struct TableDataListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableDataListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableDataListDefaultTypeInternal() {}
  union {
    TableDataList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableDataListDefaultTypeInternal _TableDataList_default_instance_;
PROTOBUF_CONSTEXPR TableRBTree_Node::TableRBTree_Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.key_)*/0u
  , /*decltype(_impl_.value_)*/0u} {}
struct TableRBTree_NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableRBTree_NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableRBTree_NodeDefaultTypeInternal() {}
  union {
    TableRBTree_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableRBTree_NodeDefaultTypeInternal _TableRBTree_Node_default_instance_;
PROTOBUF_CONSTEXPR TableRBTree::TableRBTree(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TableRBTreeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableRBTreeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableRBTreeDefaultTypeInternal() {}
  union {
    TableRBTree _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableRBTreeDefaultTypeInternal _TableRBTree_default_instance_;
PROTOBUF_CONSTEXPR HeaderStorageBucket_Header::HeaderStorageBucket_Header(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_style_)*/nullptr
  , /*decltype(_impl_.text_style_)*/nullptr
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.size_)*/0
  , /*decltype(_impl_.hidingstate_)*/0u
  , /*decltype(_impl_.numberofcells_)*/0u} {}
struct HeaderStorageBucket_HeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderStorageBucket_HeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderStorageBucket_HeaderDefaultTypeInternal() {}
  union {
    HeaderStorageBucket_Header _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderStorageBucket_HeaderDefaultTypeInternal _HeaderStorageBucket_Header_default_instance_;
PROTOBUF_CONSTEXPR HeaderStorageBucket::HeaderStorageBucket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_.buckethashfunction_)*/0u} {}
struct HeaderStorageBucketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderStorageBucketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderStorageBucketDefaultTypeInternal() {}
  union {
    HeaderStorageBucket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderStorageBucketDefaultTypeInternal _HeaderStorageBucket_default_instance_;
PROTOBUF_CONSTEXPR HeaderStorage::HeaderStorage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.buckets_)*/{}
  , /*decltype(_impl_.buckethashfunction_)*/0u} {}
struct HeaderStorageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeaderStorageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeaderStorageDefaultTypeInternal() {}
  union {
    HeaderStorage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeaderStorageDefaultTypeInternal _HeaderStorage_default_instance_;
PROTOBUF_CONSTEXPR DataStore::DataStore(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rowheaders_)*/nullptr
  , /*decltype(_impl_.columnheaders_)*/nullptr
  , /*decltype(_impl_.tiles_)*/nullptr
  , /*decltype(_impl_.stringtable_)*/nullptr
  , /*decltype(_impl_.styletable_)*/nullptr
  , /*decltype(_impl_.formulatable_)*/nullptr
  , /*decltype(_impl_.rowtiletree_)*/nullptr
  , /*decltype(_impl_.columntiletree_)*/nullptr
  , /*decltype(_impl_.formattable_)*/nullptr
  , /*decltype(_impl_.formulaerrortable_)*/nullptr
  , /*decltype(_impl_.merge_region_map_)*/nullptr
  , /*decltype(_impl_.customformattable_)*/nullptr
  , /*decltype(_impl_.multiplechoicelistformattable_)*/nullptr
  , /*decltype(_impl_.richtextpayloadtable_)*/nullptr
  , /*decltype(_impl_.conditionalstyletable_)*/nullptr
  , /*decltype(_impl_.commentstoragetable_)*/nullptr
  , /*decltype(_impl_.nextrowstripid_)*/0u
  , /*decltype(_impl_.nextcolumnstripid_)*/0u
  , /*decltype(_impl_.storage_version_)*/0u} {}
struct DataStoreDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataStoreDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataStoreDefaultTypeInternal() {}
  union {
    DataStore _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataStoreDefaultTypeInternal _DataStore_default_instance_;
PROTOBUF_CONSTEXPR TableInfoArchive::TableInfoArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.tablemodel_)*/nullptr
  , /*decltype(_impl_.editingstate_)*/nullptr} {}
struct TableInfoArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableInfoArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableInfoArchiveDefaultTypeInternal() {}
  union {
    TableInfoArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableInfoArchiveDefaultTypeInternal _TableInfoArchive_default_instance_;
PROTOBUF_CONSTEXPR EditingStateArchive::EditingStateArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.editingstorage_)*/nullptr
  , /*decltype(_impl_.editingcell_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.lasteditingcellid_)*/nullptr
  , /*decltype(_impl_.editingcellid_)*/nullptr
  , /*decltype(_impl_.deprecated_setup_textundoredotransaction_)*/nullptr
  , /*decltype(_impl_.cell_was_edited_in_current_session_)*/false} {}
struct EditingStateArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditingStateArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditingStateArchiveDefaultTypeInternal() {}
  union {
    EditingStateArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditingStateArchiveDefaultTypeInternal _EditingStateArchive_default_instance_;
PROTOBUF_CONSTEXPR WPTableInfoArchive::WPTableInfoArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr} {}
struct WPTableInfoArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WPTableInfoArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WPTableInfoArchiveDefaultTypeInternal() {}
  union {
    WPTableInfoArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WPTableInfoArchiveDefaultTypeInternal _WPTableInfoArchive_default_instance_;
PROTOBUF_CONSTEXPR TableStyleNetworkArchive::TableStyleNetworkArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.body_text_style_)*/nullptr
  , /*decltype(_impl_.header_row_text_style_)*/nullptr
  , /*decltype(_impl_.header_column_text_style_)*/nullptr
  , /*decltype(_impl_.footer_row_text_style_)*/nullptr
  , /*decltype(_impl_.body_cell_style_)*/nullptr
  , /*decltype(_impl_.header_row_style_)*/nullptr
  , /*decltype(_impl_.header_column_style_)*/nullptr
  , /*decltype(_impl_.footer_row_style_)*/nullptr
  , /*decltype(_impl_.table_style_)*/nullptr
  , /*decltype(_impl_.table_name_style_)*/nullptr
  , /*decltype(_impl_.table_name_shape_style_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0u} {}
struct TableStyleNetworkArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableStyleNetworkArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableStyleNetworkArchiveDefaultTypeInternal() {}
  union {
    TableStyleNetworkArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableStyleNetworkArchiveDefaultTypeInternal _TableStyleNetworkArchive_default_instance_;
PROTOBUF_CONSTEXPR TableModelArchive::TableModelArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.table_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_table_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_style_)*/nullptr
  , /*decltype(_impl_.data_store_)*/nullptr
  , /*decltype(_impl_.provider_)*/nullptr
  , /*decltype(_impl_.body_cell_style_)*/nullptr
  , /*decltype(_impl_.header_row_style_)*/nullptr
  , /*decltype(_impl_.header_column_style_)*/nullptr
  , /*decltype(_impl_.footer_row_style_)*/nullptr
  , /*decltype(_impl_.origin_offset_)*/nullptr
  , /*decltype(_impl_.body_text_style_)*/nullptr
  , /*decltype(_impl_.header_row_text_style_)*/nullptr
  , /*decltype(_impl_.header_column_text_style_)*/nullptr
  , /*decltype(_impl_.footer_row_text_style_)*/nullptr
  , /*decltype(_impl_.table_name_style_)*/nullptr
  , /*decltype(_impl_.hidden_state_formula_owner_for_columns_)*/nullptr
  , /*decltype(_impl_.hidden_state_formula_owner_for_rows_)*/nullptr
  , /*decltype(_impl_.table_name_shape_style_)*/nullptr
  , /*decltype(_impl_.filter_set_)*/nullptr
  , /*decltype(_impl_.conditional_style_formula_owner_id_)*/nullptr
  , /*decltype(_impl_.number_of_rows_)*/0u
  , /*decltype(_impl_.number_of_columns_)*/0u
  , /*decltype(_impl_.number_of_header_rows_)*/0u
  , /*decltype(_impl_.number_of_header_columns_)*/0u
  , /*decltype(_impl_.number_of_footer_rows_)*/0u
  , /*decltype(_impl_.number_of_hidden_rows_)*/0u
  , /*decltype(_impl_.default_row_height_)*/0
  , /*decltype(_impl_.default_column_width_)*/0
  , /*decltype(_impl_.number_of_hidden_columns_)*/0u
  , /*decltype(_impl_.table_name_enabled_)*/false
  , /*decltype(_impl_.table_name_border_enabled_)*/false
  , /*decltype(_impl_.header_rows_frozen_)*/false
  , /*decltype(_impl_.header_columns_frozen_)*/false
  , /*decltype(_impl_.preset_index_)*/0u
  , /*decltype(_impl_.repeating_header_rows_enabled_)*/false
  , /*decltype(_impl_.repeating_header_columns_enabled_)*/false
  , /*decltype(_impl_.style_apply_clears_all_)*/false
  , /*decltype(_impl_.table_name_height_)*/0
  , /*decltype(_impl_.number_of_filtered_rows_)*/0u
  , /*decltype(_impl_.number_of_user_hidden_rows_)*/0u
  , /*decltype(_impl_.number_of_user_hidden_columns_)*/0u} {}
struct TableModelArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableModelArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableModelArchiveDefaultTypeInternal() {}
  union {
    TableModelArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableModelArchiveDefaultTypeInternal _TableModelArchive_default_instance_;
PROTOBUF_CONSTEXPR DurationWrapperArchive::DurationWrapperArchive(
    ::_pbi::ConstantInitialized) {}
struct DurationWrapperArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationWrapperArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationWrapperArchiveDefaultTypeInternal() {}
  union {
    DurationWrapperArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationWrapperArchiveDefaultTypeInternal _DurationWrapperArchive_default_instance_;
PROTOBUF_CONSTEXPR Cell::Cell(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stringvalue_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cell_style_)*/nullptr
  , /*decltype(_impl_.text_style_)*/nullptr
  , /*decltype(_impl_.formula_)*/nullptr
  , /*decltype(_impl_.current_format_)*/nullptr
  , /*decltype(_impl_.formulaerror_)*/nullptr
  , /*decltype(_impl_.number_format_)*/nullptr
  , /*decltype(_impl_.currency_format_)*/nullptr
  , /*decltype(_impl_.duration_format_)*/nullptr
  , /*decltype(_impl_.date_format_)*/nullptr
  , /*decltype(_impl_.control_format_)*/nullptr
  , /*decltype(_impl_.custom_format_)*/nullptr
  , /*decltype(_impl_.base_format_)*/nullptr
  , /*decltype(_impl_.multiple_choice_list_format_)*/nullptr
  , /*decltype(_impl_.richtextpayload_)*/nullptr
  , /*decltype(_impl_.conditional_style_)*/nullptr
  , /*decltype(_impl_.multiple_choice_list_)*/nullptr
  , /*decltype(_impl_.comment_storage_)*/nullptr
  , /*decltype(_impl_.valuetype_)*/0
  , /*decltype(_impl_.boolvalue_)*/false
  , /*decltype(_impl_.numbervalue_)*/0
  , /*decltype(_impl_.explicit_format_flags_)*/0u
  , /*decltype(_impl_.conditional_style_applied_rule_)*/0u} {}
struct CellDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellDefaultTypeInternal() {}
  union {
    Cell _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellDefaultTypeInternal _Cell_default_instance_;
PROTOBUF_CONSTEXPR MergeRegionMapArchive::MergeRegionMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cell_range_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MergeRegionMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MergeRegionMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MergeRegionMapArchiveDefaultTypeInternal() {}
  union {
    MergeRegionMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MergeRegionMapArchiveDefaultTypeInternal _MergeRegionMapArchive_default_instance_;
PROTOBUF_CONSTEXPR CellMapArchive_CellMapEntry::CellMapArchive_CellMapEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellid_)*/nullptr
  , /*decltype(_impl_.cell_)*/nullptr} {}
struct CellMapArchive_CellMapEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellMapArchive_CellMapEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellMapArchive_CellMapEntryDefaultTypeInternal() {}
  union {
    CellMapArchive_CellMapEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellMapArchive_CellMapEntryDefaultTypeInternal _CellMapArchive_CellMapEntry_default_instance_;
PROTOBUF_CONSTEXPR CellMapArchive::CellMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellmapentry_)*/{}
  , /*decltype(_impl_.capacity_)*/0u
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.applies_to_hidden_)*/false
  , /*decltype(_impl_.may_modify_formulas_in_cells_)*/true
  , /*decltype(_impl_.may_modify_values_referenced_by_formulas_)*/true} {}
struct CellMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellMapArchiveDefaultTypeInternal() {}
  union {
    CellMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellMapArchiveDefaultTypeInternal _CellMapArchive_default_instance_;
PROTOBUF_CONSTEXPR DoubleStyleMapArchive_DoubleStyleMapEntryArchive::DoubleStyleMapArchive_DoubleStyleMapEntryArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_id_)*/nullptr
  , /*decltype(_impl_.old_style_)*/nullptr
  , /*decltype(_impl_.new_style_)*/nullptr} {}
struct DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal() {}
  union {
    DoubleStyleMapArchive_DoubleStyleMapEntryArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal _DoubleStyleMapArchive_DoubleStyleMapEntryArchive_default_instance_;
PROTOBUF_CONSTEXPR DoubleStyleMapArchive::DoubleStyleMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_map_entry_)*/{}
  , /*decltype(_impl_.capacity_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct DoubleStyleMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleStyleMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleStyleMapArchiveDefaultTypeInternal() {}
  union {
    DoubleStyleMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleStyleMapArchiveDefaultTypeInternal _DoubleStyleMapArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleTableMapArchive_StyleTableMapEntryArchive::StyleTableMapArchive_StyleTableMapEntryArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.old_style_)*/nullptr
  , /*decltype(_impl_.new_style_)*/nullptr
  , /*decltype(_impl_.key_)*/0u} {}
struct StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal() {}
  union {
    StyleTableMapArchive_StyleTableMapEntryArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal _StyleTableMapArchive_StyleTableMapEntryArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleTableMapArchive::StyleTableMapArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.map_entry_)*/{}
  , /*decltype(_impl_.capacity_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct StyleTableMapArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleTableMapArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleTableMapArchiveDefaultTypeInternal() {}
  union {
    StyleTableMapArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleTableMapArchiveDefaultTypeInternal _StyleTableMapArchive_default_instance_;
PROTOBUF_CONSTEXPR SelectionArchive::SelectionArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_ranges_)*/{}
  , /*decltype(_impl_.base_ranges_)*/{}
  , /*decltype(_impl_.tablemodel_)*/nullptr
  , /*decltype(_impl_.anchor_cell_)*/nullptr
  , /*decltype(_impl_.cursor_cell_)*/nullptr
  , /*decltype(_impl_.selection_type_)*/0} {}
struct SelectionArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectionArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectionArchiveDefaultTypeInternal() {}
  union {
    SelectionArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectionArchiveDefaultTypeInternal _SelectionArchive_default_instance_;
PROTOBUF_CONSTEXPR FilterRuleArchive::FilterRuleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.predicate_)*/nullptr
  , /*decltype(_impl_.disabled_)*/false} {}
struct FilterRuleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterRuleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterRuleArchiveDefaultTypeInternal() {}
  union {
    FilterRuleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterRuleArchiveDefaultTypeInternal _FilterRuleArchive_default_instance_;
PROTOBUF_CONSTEXPR TableStyleArchive::TableStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.table_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct TableStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableStyleArchiveDefaultTypeInternal() {}
  union {
    TableStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableStyleArchiveDefaultTypeInternal _TableStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR CellStyleArchive::CellStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.cell_properties_)*/nullptr
  , /*decltype(_impl_.override_count_)*/0u} {}
struct CellStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellStyleArchiveDefaultTypeInternal() {}
  union {
    CellStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellStyleArchiveDefaultTypeInternal _CellStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR FormulaPredicateArchive::FormulaPredicateArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.formula_)*/nullptr
  , /*decltype(_impl_.predicate_type_)*/0
  , /*decltype(_impl_.qualifier1_)*/0
  , /*decltype(_impl_.qualifier2_)*/0
  , /*decltype(_impl_.param_index1_)*/0
  , /*decltype(_impl_.param_index2_)*/0
  , /*decltype(_impl_.param_index0_)*/0} {}
struct FormulaPredicateArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormulaPredicateArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormulaPredicateArchiveDefaultTypeInternal() {}
  union {
    FormulaPredicateArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormulaPredicateArchiveDefaultTypeInternal _FormulaPredicateArchive_default_instance_;
PROTOBUF_CONSTEXPR ConditionalStyleSetArchive_ConditionalStyleRule::ConditionalStyleSetArchive_ConditionalStyleRule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.predicate_)*/nullptr
  , /*decltype(_impl_.cell_style_)*/nullptr
  , /*decltype(_impl_.text_style_)*/nullptr} {}
struct ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal() {}
  union {
    ConditionalStyleSetArchive_ConditionalStyleRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal _ConditionalStyleSetArchive_ConditionalStyleRule_default_instance_;
PROTOBUF_CONSTEXPR ConditionalStyleSetArchive::ConditionalStyleSetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rules_)*/{}
  , /*decltype(_impl_.cellid_)*/nullptr
  , /*decltype(_impl_.rulecount_)*/0u} {}
struct ConditionalStyleSetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConditionalStyleSetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConditionalStyleSetArchiveDefaultTypeInternal() {}
  union {
    ConditionalStyleSetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConditionalStyleSetArchiveDefaultTypeInternal _ConditionalStyleSetArchive_default_instance_;
PROTOBUF_CONSTEXPR FilterSetArchive::FilterSetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filter_rules_)*/{}
  , /*decltype(_impl_.filter_offsets_)*/{}
  , /*decltype(_impl_.filter_enabled_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.needs_formula_rewrite_for_import_)*/false
  , /*decltype(_impl_.is_enabled_)*/true} {}
struct FilterSetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterSetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterSetArchiveDefaultTypeInternal() {}
  union {
    FilterSetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterSetArchiveDefaultTypeInternal _FilterSetArchive_default_instance_;
PROTOBUF_CONSTEXPR TokenAttachmentArchive::TokenAttachmentArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.expressionnode_)*/nullptr} {}
struct TokenAttachmentArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TokenAttachmentArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TokenAttachmentArchiveDefaultTypeInternal() {}
  union {
    TokenAttachmentArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TokenAttachmentArchiveDefaultTypeInternal _TokenAttachmentArchive_default_instance_;
PROTOBUF_CONSTEXPR FormulaArchive::FormulaArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.expressiontree_)*/nullptr} {}
struct FormulaArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormulaArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormulaArchiveDefaultTypeInternal() {}
  union {
    FormulaArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormulaArchiveDefaultTypeInternal _FormulaArchive_default_instance_;
PROTOBUF_CONSTEXPR ExpressionNodeArchive::ExpressionNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.first_index_)*/uint64_t{0u}
  , /*decltype(_impl_.last_index_)*/uint64_t{0u}} {}
struct ExpressionNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpressionNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpressionNodeArchiveDefaultTypeInternal() {}
  union {
    ExpressionNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpressionNodeArchiveDefaultTypeInternal _ExpressionNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR BooleanNodeArchive::BooleanNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.value_)*/false} {}
struct BooleanNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanNodeArchiveDefaultTypeInternal() {}
  union {
    BooleanNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanNodeArchiveDefaultTypeInternal _BooleanNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR NumberNodeArchive::NumberNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.number_)*/0} {}
struct NumberNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NumberNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NumberNodeArchiveDefaultTypeInternal() {}
  union {
    NumberNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NumberNodeArchiveDefaultTypeInternal _NumberNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR StringNodeArchive::StringNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct StringNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringNodeArchiveDefaultTypeInternal() {}
  union {
    StringNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringNodeArchiveDefaultTypeInternal _StringNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR IdentifierNodeArchive::IdentifierNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.identifier_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct IdentifierNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IdentifierNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IdentifierNodeArchiveDefaultTypeInternal() {}
  union {
    IdentifierNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IdentifierNodeArchiveDefaultTypeInternal _IdentifierNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR ArrayNodeArchive::ArrayNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.columns_)*/0u
  , /*decltype(_impl_.rows_)*/0u} {}
struct ArrayNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArrayNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArrayNodeArchiveDefaultTypeInternal() {}
  union {
    ArrayNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArrayNodeArchiveDefaultTypeInternal _ArrayNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR ListNodeArchive::ListNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ListNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListNodeArchiveDefaultTypeInternal() {}
  union {
    ListNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListNodeArchiveDefaultTypeInternal _ListNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR OperatorNodeArchive::OperatorNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.operatorchar_)*/0u} {}
struct OperatorNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperatorNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperatorNodeArchiveDefaultTypeInternal() {}
  union {
    OperatorNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperatorNodeArchiveDefaultTypeInternal _OperatorNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR PostfixOperatorNodeArchive::PostfixOperatorNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct PostfixOperatorNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PostfixOperatorNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PostfixOperatorNodeArchiveDefaultTypeInternal() {}
  union {
    PostfixOperatorNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PostfixOperatorNodeArchiveDefaultTypeInternal _PostfixOperatorNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR PrefixOperatorNodeArchive::PrefixOperatorNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct PrefixOperatorNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrefixOperatorNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrefixOperatorNodeArchiveDefaultTypeInternal() {}
  union {
    PrefixOperatorNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrefixOperatorNodeArchiveDefaultTypeInternal _PrefixOperatorNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR FunctionNodeArchive::FunctionNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.invalidfunctionname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.functionindex_)*/0u} {}
struct FunctionNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FunctionNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FunctionNodeArchiveDefaultTypeInternal() {}
  union {
    FunctionNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FunctionNodeArchiveDefaultTypeInternal _FunctionNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR FunctionEndNodeArchive::FunctionEndNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct FunctionEndNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FunctionEndNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FunctionEndNodeArchiveDefaultTypeInternal() {}
  union {
    FunctionEndNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FunctionEndNodeArchiveDefaultTypeInternal _FunctionEndNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR DateNodeArchive::DateNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.format_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct DateNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateNodeArchiveDefaultTypeInternal() {}
  union {
    DateNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateNodeArchiveDefaultTypeInternal _DateNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR ReferenceNodeArchive::ReferenceNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hosttableid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.rangereference_)*/nullptr
  , /*decltype(_impl_.stickybits_)*/0u} {}
struct ReferenceNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReferenceNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReferenceNodeArchiveDefaultTypeInternal() {}
  union {
    ReferenceNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferenceNodeArchiveDefaultTypeInternal _ReferenceNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR DurationNodeArchive::DurationNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.timeinterval_)*/0
  , /*decltype(_impl_.smallest_)*/0u
  , /*decltype(_impl_.largest_)*/0u
  , /*decltype(_impl_.style_)*/0u} {}
struct DurationNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationNodeArchiveDefaultTypeInternal() {}
  union {
    DurationNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationNodeArchiveDefaultTypeInternal _DurationNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR ArgumentPlaceholderNodeArchive::ArgumentPlaceholderNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.functionindex_)*/0u
  , /*decltype(_impl_.argumentindex_)*/0u
  , /*decltype(_impl_.mode_)*/0u} {}
struct ArgumentPlaceholderNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArgumentPlaceholderNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArgumentPlaceholderNodeArchiveDefaultTypeInternal() {}
  union {
    ArgumentPlaceholderNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArgumentPlaceholderNodeArchiveDefaultTypeInternal _ArgumentPlaceholderNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR EmptyExpressionNodeArchive::EmptyExpressionNodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct EmptyExpressionNodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyExpressionNodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyExpressionNodeArchiveDefaultTypeInternal() {}
  union {
    EmptyExpressionNodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyExpressionNodeArchiveDefaultTypeInternal _EmptyExpressionNodeArchive_default_instance_;
PROTOBUF_CONSTEXPR LayoutHintArchive::LayoutHintArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellrange_)*/nullptr
  , /*decltype(_impl_.hintid_)*/nullptr
  , /*decltype(_impl_.maximumsize_)*/nullptr
  , /*decltype(_impl_.effectivesize_)*/nullptr
  , /*decltype(_impl_.isvalid_)*/false
  , /*decltype(_impl_.horizontal_)*/false
  , /*decltype(_impl_.partitionposition_)*/0u
  , /*decltype(_impl_.partitioningpass_)*/0u} {}
struct LayoutHintArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LayoutHintArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LayoutHintArchiveDefaultTypeInternal() {}
  union {
    LayoutHintArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LayoutHintArchiveDefaultTypeInternal _LayoutHintArchive_default_instance_;
PROTOBUF_CONSTEXPR CompletionTokenAttachmentArchive::CompletionTokenAttachmentArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.completiontext_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.caretposition_)*/0u
  , /*decltype(_impl_.prefixstart_)*/0u} {}
struct CompletionTokenAttachmentArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CompletionTokenAttachmentArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CompletionTokenAttachmentArchiveDefaultTypeInternal() {}
  union {
    CompletionTokenAttachmentArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CompletionTokenAttachmentArchiveDefaultTypeInternal _CompletionTokenAttachmentArchive_default_instance_;
PROTOBUF_CONSTEXPR HiddenStateFormulaOwnerArchive::HiddenStateFormulaOwnerArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.threshold_value_)*/{}
  , /*decltype(_impl_.owner_id_)*/nullptr
  , /*decltype(_impl_.needs_to_update_filter_set_for_import_)*/false} {}
struct HiddenStateFormulaOwnerArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HiddenStateFormulaOwnerArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HiddenStateFormulaOwnerArchiveDefaultTypeInternal() {}
  union {
    HiddenStateFormulaOwnerArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HiddenStateFormulaOwnerArchiveDefaultTypeInternal _HiddenStateFormulaOwnerArchive_default_instance_;
PROTOBUF_CONSTEXPR RichTextPayloadArchive::RichTextPayloadArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.range_)*/nullptr
  , /*decltype(_impl_.cellid_)*/nullptr} {}
struct RichTextPayloadArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RichTextPayloadArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RichTextPayloadArchiveDefaultTypeInternal() {}
  union {
    RichTextPayloadArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RichTextPayloadArchiveDefaultTypeInternal _RichTextPayloadArchive_default_instance_;
PROTOBUF_CONSTEXPR FormulaEqualsTokenAttachmentArchive::FormulaEqualsTokenAttachmentArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal() {}
  union {
    FormulaEqualsTokenAttachmentArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal _FormulaEqualsTokenAttachmentArchive_default_instance_;
PROTOBUF_CONSTEXPR CellRegion::CellRegion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cell_ranges_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CellRegionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellRegionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellRegionDefaultTypeInternal() {}
  union {
    CellRegion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellRegionDefaultTypeInternal _CellRegion_default_instance_;
}  // namespace TST
static ::_pb::Metadata file_level_metadata_TSTArchives_2eproto[65];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSTArchives_2eproto[11];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSTArchives_2eproto = nullptr;

const uint32_t TableStruct_TSTArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TST::CellID, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CellID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellID, _impl_.packeddata_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::TableSize, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableSize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableSize, _impl_.packeddata_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CellRange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CellRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellRange, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::TST::CellRange, _impl_.size_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _impl_.cellrange_),
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _impl_.extendedcellrange_),
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _impl_.extendedcellrangevalid_),
  PROTOBUF_FIELD_OFFSET(::TST::TableSelection, _impl_.selection_type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_.storage_version_),
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_.tilerowindex_),
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_.cellcount_),
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_.cellstoragebuffer_),
  PROTOBUF_FIELD_OFFSET(::TST::TileRowInfo, _impl_.celloffsets_),
  4,
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.maxcolumn_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.maxrow_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.numcells_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.numrows_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.storage_version_),
  PROTOBUF_FIELD_OFFSET(::TST::Tile, _impl_.rowinfos_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage_Tile, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage_Tile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage_Tile, _impl_.tileid_),
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage_Tile, _impl_.tile_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TileStorage, _impl_.tiles_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_.cell_value_type_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_.boolean_value_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_.date_value_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_.number_value_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel_CellValue, _impl_.string_value_),
  4,
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel, _impl_.item_),
  PROTOBUF_FIELD_OFFSET(::TST::PopUpMenuModel, _impl_.tsce_item_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.refcount_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.string_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.reference_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.formula_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.custom_format_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.richtextpayload_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList_ListEntry, _impl_.comment_storage_),
  8,
  9,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList, _impl_.listtype_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList, _impl_.nextlistid_),
  PROTOBUF_FIELD_OFFSET(::TST::TableDataList, _impl_.entries_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree_Node, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree_Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree_Node, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree_Node, _impl_.value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableRBTree, _impl_.nodes_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.hidingstate_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.numberofcells_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket_Header, _impl_.text_style_),
  2,
  3,
  4,
  5,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket, _impl_.buckethashfunction_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorageBucket, _impl_.headers_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorage, _impl_.buckethashfunction_),
  PROTOBUF_FIELD_OFFSET(::TST::HeaderStorage, _impl_.buckets_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.rowheaders_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.columnheaders_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.tiles_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.stringtable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.styletable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.formulatable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.formulaerrortable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.formattable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.multiplechoicelistformattable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.merge_region_map_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.customformattable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.nextrowstripid_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.nextcolumnstripid_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.rowtiletree_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.columntiletree_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.storage_version_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.richtextpayloadtable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.conditionalstyletable_),
  PROTOBUF_FIELD_OFFSET(::TST::DataStore, _impl_.commentstoragetable_),
  0,
  1,
  2,
  3,
  4,
  5,
  9,
  8,
  12,
  10,
  11,
  16,
  17,
  6,
  7,
  18,
  13,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoArchive, _impl_.tablemodel_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoArchive, _impl_.editingstate_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.editingstorage_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.editingcell_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.lasteditingcellid_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.editingcellid_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.deprecated_setup_textundoredotransaction_),
  PROTOBUF_FIELD_OFFSET(::TST::EditingStateArchive, _impl_.cell_was_edited_in_current_session_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TST::WPTableInfoArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::WPTableInfoArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::WPTableInfoArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::WPTableInfoArchive, _impl_.storage_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.table_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.body_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.header_row_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.header_column_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.footer_row_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.body_cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.header_row_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.header_column_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.footer_row_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.table_name_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.table_name_shape_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleNetworkArchive, _impl_.preset_index_),
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_id_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.from_table_id_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.body_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_row_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_column_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.footer_row_text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.body_cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_row_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_column_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.footer_row_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_shape_style_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.data_store_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.provider_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_height_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.table_name_border_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_header_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_header_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_footer_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_rows_frozen_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.header_columns_frozen_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_hidden_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_hidden_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_user_hidden_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_user_hidden_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.number_of_filtered_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.default_row_height_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.default_column_width_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.origin_offset_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.preset_index_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.repeating_header_rows_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.repeating_header_columns_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.style_apply_clears_all_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.hidden_state_formula_owner_for_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.hidden_state_formula_owner_for_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.filter_set_),
  PROTOBUF_FIELD_OFFSET(::TST::TableModelArchive, _impl_.conditional_style_formula_owner_id_),
  0,
  2,
  3,
  11,
  12,
  13,
  14,
  6,
  7,
  8,
  9,
  15,
  18,
  4,
  5,
  21,
  22,
  1,
  30,
  38,
  31,
  23,
  24,
  25,
  32,
  33,
  26,
  29,
  40,
  41,
  39,
  27,
  28,
  10,
  34,
  35,
  36,
  37,
  16,
  17,
  19,
  20,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::DurationWrapperArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.valuetype_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.numbervalue_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.stringvalue_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.boolvalue_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.text_style_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.formula_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.formulaerror_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.current_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.number_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.currency_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.duration_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.date_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.control_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.custom_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.base_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.multiple_choice_list_format_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.explicit_format_flags_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.richtextpayload_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.conditional_style_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.multiple_choice_list_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.comment_storage_),
  PROTOBUF_FIELD_OFFSET(::TST::Cell, _impl_.conditional_style_applied_rule_),
  18,
  20,
  0,
  19,
  1,
  2,
  3,
  5,
  4,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  21,
  14,
  15,
  16,
  17,
  22,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::MergeRegionMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::MergeRegionMapArchive, _impl_.cell_range_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive_CellMapEntry, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive_CellMapEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive_CellMapEntry, _impl_.cellid_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive_CellMapEntry, _impl_.cell_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.cellmapentry_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.may_modify_formulas_in_cells_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.may_modify_values_referenced_by_formulas_),
  PROTOBUF_FIELD_OFFSET(::TST::CellMapArchive, _impl_.applies_to_hidden_),
  0,
  1,
  ~0u,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_.cell_id_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_.old_style_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_.new_style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::DoubleStyleMapArchive, _impl_.cell_map_entry_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive_StyleTableMapEntryArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive_StyleTableMapEntryArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive_StyleTableMapEntryArchive, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive_StyleTableMapEntryArchive, _impl_.old_style_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive_StyleTableMapEntryArchive, _impl_.new_style_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive, _impl_.capacity_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::StyleTableMapArchive, _impl_.map_entry_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.tablemodel_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.selection_type_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.anchor_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.cell_ranges_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.base_ranges_),
  PROTOBUF_FIELD_OFFSET(::TST::SelectionArchive, _impl_.cursor_cell_),
  0,
  3,
  1,
  ~0u,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::FilterRuleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterRuleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FilterRuleArchive, _impl_.predicate_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterRuleArchive, _impl_.disabled_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TST::TableStyleArchive, _impl_.table_properties_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CellStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CellStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CellStyleArchive, _impl_.override_count_),
  PROTOBUF_FIELD_OFFSET(::TST::CellStyleArchive, _impl_.cell_properties_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.formula_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.predicate_type_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.qualifier1_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.qualifier2_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.param_index1_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.param_index2_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaPredicateArchive, _impl_.param_index0_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive_ConditionalStyleRule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive_ConditionalStyleRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive_ConditionalStyleRule, _impl_.predicate_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive_ConditionalStyleRule, _impl_.cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive_ConditionalStyleRule, _impl_.text_style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive, _impl_.rulecount_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive, _impl_.rules_),
  PROTOBUF_FIELD_OFFSET(::TST::ConditionalStyleSetArchive, _impl_.cellid_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.is_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.filter_rules_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.needs_formula_rewrite_for_import_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.filter_offsets_),
  PROTOBUF_FIELD_OFFSET(::TST::FilterSetArchive, _impl_.filter_enabled_),
  0,
  2,
  ~0u,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::TokenAttachmentArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TokenAttachmentArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TokenAttachmentArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::TokenAttachmentArchive, _impl_.expressionnode_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::FormulaArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FormulaArchive, _impl_.expressiontree_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::ExpressionNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ExpressionNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ExpressionNodeArchive, _impl_.children_),
  PROTOBUF_FIELD_OFFSET(::TST::ExpressionNodeArchive, _impl_.first_index_),
  PROTOBUF_FIELD_OFFSET(::TST::ExpressionNodeArchive, _impl_.last_index_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::BooleanNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::BooleanNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::BooleanNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::BooleanNodeArchive, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::NumberNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::NumberNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::NumberNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::NumberNodeArchive, _impl_.number_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::StringNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::StringNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::StringNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::StringNodeArchive, _impl_.value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::IdentifierNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::IdentifierNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::IdentifierNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::IdentifierNodeArchive, _impl_.identifier_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::ArrayNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ArrayNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ArrayNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::ArrayNodeArchive, _impl_.columns_),
  PROTOBUF_FIELD_OFFSET(::TST::ArrayNodeArchive, _impl_.rows_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::ListNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ListNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ListNodeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::OperatorNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::OperatorNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::OperatorNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::OperatorNodeArchive, _impl_.operatorchar_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::PostfixOperatorNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::PostfixOperatorNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::PostfixOperatorNodeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::PrefixOperatorNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::PrefixOperatorNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::PrefixOperatorNodeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::FunctionNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FunctionNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FunctionNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::FunctionNodeArchive, _impl_.functionindex_),
  PROTOBUF_FIELD_OFFSET(::TST::FunctionNodeArchive, _impl_.invalidfunctionname_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::FunctionEndNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FunctionEndNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FunctionEndNodeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::DateNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DateNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DateNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::DateNodeArchive, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::TST::DateNodeArchive, _impl_.format_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _impl_.rangereference_),
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _impl_.stickybits_),
  PROTOBUF_FIELD_OFFSET(::TST::ReferenceNodeArchive, _impl_.hosttableid_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_.timeinterval_),
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_.smallest_),
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_.largest_),
  PROTOBUF_FIELD_OFFSET(::TST::DurationNodeArchive, _impl_.style_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _impl_.functionindex_),
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _impl_.argumentindex_),
  PROTOBUF_FIELD_OFFSET(::TST::ArgumentPlaceholderNodeArchive, _impl_.mode_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::EmptyExpressionNodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::EmptyExpressionNodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::EmptyExpressionNodeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.isvalid_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.cellrange_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.hintid_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.maximumsize_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.partitionposition_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.horizontal_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.effectivesize_),
  PROTOBUF_FIELD_OFFSET(::TST::LayoutHintArchive, _impl_.partitioningpass_),
  4,
  0,
  1,
  2,
  6,
  5,
  3,
  7,
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _impl_.completiontext_),
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _impl_.caretposition_),
  PROTOBUF_FIELD_OFFSET(::TST::CompletionTokenAttachmentArchive, _impl_.prefixstart_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::HiddenStateFormulaOwnerArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::HiddenStateFormulaOwnerArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::HiddenStateFormulaOwnerArchive, _impl_.owner_id_),
  PROTOBUF_FIELD_OFFSET(::TST::HiddenStateFormulaOwnerArchive, _impl_.threshold_value_),
  PROTOBUF_FIELD_OFFSET(::TST::HiddenStateFormulaOwnerArchive, _impl_.needs_to_update_filter_set_for_import_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::RichTextPayloadArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::RichTextPayloadArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::RichTextPayloadArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TST::RichTextPayloadArchive, _impl_.range_),
  PROTOBUF_FIELD_OFFSET(::TST::RichTextPayloadArchive, _impl_.cellid_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEqualsTokenAttachmentArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEqualsTokenAttachmentArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEqualsTokenAttachmentArchive, _impl_.super_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TST::CellRegion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CellRegion, _impl_.cell_ranges_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::TST::CellID)},
  { 8, 15, -1, sizeof(::TST::TableSize)},
  { 16, 24, -1, sizeof(::TST::CellRange)},
  { 26, 36, -1, sizeof(::TST::TableSelection)},
  { 40, 51, -1, sizeof(::TST::TileRowInfo)},
  { 56, 68, -1, sizeof(::TST::Tile)},
  { 74, 82, -1, sizeof(::TST::TileStorage_Tile)},
  { 84, -1, -1, sizeof(::TST::TileStorage)},
  { 91, 102, -1, sizeof(::TST::PopUpMenuModel_CellValue)},
  { 107, -1, -1, sizeof(::TST::PopUpMenuModel)},
  { 115, 131, -1, sizeof(::TST::TableDataList_ListEntry)},
  { 141, 150, -1, sizeof(::TST::TableDataList)},
  { 153, 161, -1, sizeof(::TST::TableRBTree_Node)},
  { 163, -1, -1, sizeof(::TST::TableRBTree)},
  { 170, 182, -1, sizeof(::TST::HeaderStorageBucket_Header)},
  { 188, 196, -1, sizeof(::TST::HeaderStorageBucket)},
  { 198, 206, -1, sizeof(::TST::HeaderStorage)},
  { 208, 233, -1, sizeof(::TST::DataStore)},
  { 252, 261, -1, sizeof(::TST::TableInfoArchive)},
  { 264, 277, -1, sizeof(::TST::EditingStateArchive)},
  { 284, 292, -1, sizeof(::TST::WPTableInfoArchive)},
  { 294, 312, -1, sizeof(::TST::TableStyleNetworkArchive)},
  { 324, 372, -1, sizeof(::TST::TableModelArchive)},
  { 414, -1, -1, sizeof(::TST::DurationWrapperArchive)},
  { 420, 449, -1, sizeof(::TST::Cell)},
  { 472, -1, -1, sizeof(::TST::MergeRegionMapArchive)},
  { 479, 487, -1, sizeof(::TST::CellMapArchive_CellMapEntry)},
  { 489, 501, -1, sizeof(::TST::CellMapArchive)},
  { 507, 516, -1, sizeof(::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive)},
  { 519, 528, -1, sizeof(::TST::DoubleStyleMapArchive)},
  { 531, 540, -1, sizeof(::TST::StyleTableMapArchive_StyleTableMapEntryArchive)},
  { 543, 552, -1, sizeof(::TST::StyleTableMapArchive)},
  { 555, 567, -1, sizeof(::TST::SelectionArchive)},
  { 573, 581, -1, sizeof(::TST::FilterRuleArchive)},
  { 583, 592, -1, sizeof(::TST::TableStyleArchive)},
  { 595, 604, -1, sizeof(::TST::CellStyleArchive)},
  { 607, 620, -1, sizeof(::TST::FormulaPredicateArchive)},
  { 627, 636, -1, sizeof(::TST::ConditionalStyleSetArchive_ConditionalStyleRule)},
  { 639, 648, -1, sizeof(::TST::ConditionalStyleSetArchive)},
  { 651, 663, -1, sizeof(::TST::FilterSetArchive)},
  { 669, 677, -1, sizeof(::TST::TokenAttachmentArchive)},
  { 679, 686, -1, sizeof(::TST::FormulaArchive)},
  { 687, 696, -1, sizeof(::TST::ExpressionNodeArchive)},
  { 699, 707, -1, sizeof(::TST::BooleanNodeArchive)},
  { 709, 717, -1, sizeof(::TST::NumberNodeArchive)},
  { 719, 727, -1, sizeof(::TST::StringNodeArchive)},
  { 729, 737, -1, sizeof(::TST::IdentifierNodeArchive)},
  { 739, 748, -1, sizeof(::TST::ArrayNodeArchive)},
  { 751, 758, -1, sizeof(::TST::ListNodeArchive)},
  { 759, 767, -1, sizeof(::TST::OperatorNodeArchive)},
  { 769, 776, -1, sizeof(::TST::PostfixOperatorNodeArchive)},
  { 777, 784, -1, sizeof(::TST::PrefixOperatorNodeArchive)},
  { 785, 794, -1, sizeof(::TST::FunctionNodeArchive)},
  { 797, 804, -1, sizeof(::TST::FunctionEndNodeArchive)},
  { 805, 814, -1, sizeof(::TST::DateNodeArchive)},
  { 817, 827, -1, sizeof(::TST::ReferenceNodeArchive)},
  { 831, 842, -1, sizeof(::TST::DurationNodeArchive)},
  { 847, 857, -1, sizeof(::TST::ArgumentPlaceholderNodeArchive)},
  { 861, 868, -1, sizeof(::TST::EmptyExpressionNodeArchive)},
  { 869, 883, -1, sizeof(::TST::LayoutHintArchive)},
  { 891, 901, -1, sizeof(::TST::CompletionTokenAttachmentArchive)},
  { 905, 914, -1, sizeof(::TST::HiddenStateFormulaOwnerArchive)},
  { 917, 926, -1, sizeof(::TST::RichTextPayloadArchive)},
  { 929, 936, -1, sizeof(::TST::FormulaEqualsTokenAttachmentArchive)},
  { 937, -1, -1, sizeof(::TST::CellRegion)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TST::_CellID_default_instance_._instance,
  &::TST::_TableSize_default_instance_._instance,
  &::TST::_CellRange_default_instance_._instance,
  &::TST::_TableSelection_default_instance_._instance,
  &::TST::_TileRowInfo_default_instance_._instance,
  &::TST::_Tile_default_instance_._instance,
  &::TST::_TileStorage_Tile_default_instance_._instance,
  &::TST::_TileStorage_default_instance_._instance,
  &::TST::_PopUpMenuModel_CellValue_default_instance_._instance,
  &::TST::_PopUpMenuModel_default_instance_._instance,
  &::TST::_TableDataList_ListEntry_default_instance_._instance,
  &::TST::_TableDataList_default_instance_._instance,
  &::TST::_TableRBTree_Node_default_instance_._instance,
  &::TST::_TableRBTree_default_instance_._instance,
  &::TST::_HeaderStorageBucket_Header_default_instance_._instance,
  &::TST::_HeaderStorageBucket_default_instance_._instance,
  &::TST::_HeaderStorage_default_instance_._instance,
  &::TST::_DataStore_default_instance_._instance,
  &::TST::_TableInfoArchive_default_instance_._instance,
  &::TST::_EditingStateArchive_default_instance_._instance,
  &::TST::_WPTableInfoArchive_default_instance_._instance,
  &::TST::_TableStyleNetworkArchive_default_instance_._instance,
  &::TST::_TableModelArchive_default_instance_._instance,
  &::TST::_DurationWrapperArchive_default_instance_._instance,
  &::TST::_Cell_default_instance_._instance,
  &::TST::_MergeRegionMapArchive_default_instance_._instance,
  &::TST::_CellMapArchive_CellMapEntry_default_instance_._instance,
  &::TST::_CellMapArchive_default_instance_._instance,
  &::TST::_DoubleStyleMapArchive_DoubleStyleMapEntryArchive_default_instance_._instance,
  &::TST::_DoubleStyleMapArchive_default_instance_._instance,
  &::TST::_StyleTableMapArchive_StyleTableMapEntryArchive_default_instance_._instance,
  &::TST::_StyleTableMapArchive_default_instance_._instance,
  &::TST::_SelectionArchive_default_instance_._instance,
  &::TST::_FilterRuleArchive_default_instance_._instance,
  &::TST::_TableStyleArchive_default_instance_._instance,
  &::TST::_CellStyleArchive_default_instance_._instance,
  &::TST::_FormulaPredicateArchive_default_instance_._instance,
  &::TST::_ConditionalStyleSetArchive_ConditionalStyleRule_default_instance_._instance,
  &::TST::_ConditionalStyleSetArchive_default_instance_._instance,
  &::TST::_FilterSetArchive_default_instance_._instance,
  &::TST::_TokenAttachmentArchive_default_instance_._instance,
  &::TST::_FormulaArchive_default_instance_._instance,
  &::TST::_ExpressionNodeArchive_default_instance_._instance,
  &::TST::_BooleanNodeArchive_default_instance_._instance,
  &::TST::_NumberNodeArchive_default_instance_._instance,
  &::TST::_StringNodeArchive_default_instance_._instance,
  &::TST::_IdentifierNodeArchive_default_instance_._instance,
  &::TST::_ArrayNodeArchive_default_instance_._instance,
  &::TST::_ListNodeArchive_default_instance_._instance,
  &::TST::_OperatorNodeArchive_default_instance_._instance,
  &::TST::_PostfixOperatorNodeArchive_default_instance_._instance,
  &::TST::_PrefixOperatorNodeArchive_default_instance_._instance,
  &::TST::_FunctionNodeArchive_default_instance_._instance,
  &::TST::_FunctionEndNodeArchive_default_instance_._instance,
  &::TST::_DateNodeArchive_default_instance_._instance,
  &::TST::_ReferenceNodeArchive_default_instance_._instance,
  &::TST::_DurationNodeArchive_default_instance_._instance,
  &::TST::_ArgumentPlaceholderNodeArchive_default_instance_._instance,
  &::TST::_EmptyExpressionNodeArchive_default_instance_._instance,
  &::TST::_LayoutHintArchive_default_instance_._instance,
  &::TST::_CompletionTokenAttachmentArchive_default_instance_._instance,
  &::TST::_HiddenStateFormulaOwnerArchive_default_instance_._instance,
  &::TST::_RichTextPayloadArchive_default_instance_._instance,
  &::TST::_FormulaEqualsTokenAttachmentArchive_default_instance_._instance,
  &::TST::_CellRegion_default_instance_._instance,
};

const char descriptor_table_protodef_TSTArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021TSTArchives.proto\022\003TST\032\021TSPMessages.pr"
  "oto\032\021TSDArchives.proto\032\021TSKArchives.prot"
  "o\032\021TSSArchives.proto\032\022TSCEArchives.proto"
  "\032\022TSWPArchives.proto\032\037TSTStylePropertyAr"
  "chiving.proto\"\034\n\006CellID\022\022\n\npackedData\030\001 "
  "\002(\007\"\037\n\tTableSize\022\022\n\npackedData\030\001 \002(\007\"F\n\t"
  "CellRange\022\033\n\006origin\030\001 \002(\0132\013.TST.CellID\022\034"
  "\n\004size\030\002 \002(\0132\016.TST.TableSize\"\261\001\n\016TableSe"
  "lection\022!\n\tcellRange\030\001 \002(\0132\016.TST.CellRan"
  "ge\022)\n\021extendedCellRange\030\002 \002(\0132\016.TST.Cell"
  "Range\022\036\n\026extendedCellRangeValid\030\003 \002(\010\0221\n"
  "\016selection_type\030\004 \002(\0162\031.TST.SelectionTyp"
  "eArchive\"\177\n\013TileRowInfo\022\027\n\017storage_versi"
  "on\030\005 \001(\r\022\024\n\014tileRowIndex\030\001 \002(\r\022\021\n\tcellCo"
  "unt\030\002 \002(\r\022\031\n\021cellStorageBuffer\030\003 \002(\014\022\023\n\013"
  "cellOffsets\030\004 \002(\014\"\211\001\n\004Tile\022\021\n\tmaxColumn\030"
  "\001 \002(\r\022\016\n\006maxRow\030\002 \002(\r\022\020\n\010numCells\030\003 \002(\r\022"
  "\017\n\007numrows\030\004 \002(\r\022\027\n\017storage_version\030\006 \001("
  "\r\022\"\n\010rowInfos\030\005 \003(\0132\020.TST.TileRowInfo\"i\n"
  "\013TileStorage\022$\n\005tiles\030\001 \003(\0132\025.TST.TileSt"
  "orage.Tile\0324\n\004Tile\022\016\n\006tileid\030\001 \002(\r\022\034\n\004ti"
  "le\030\002 \002(\0132\016.TSP.Reference\"\346\003\n\016PopUpMenuMo"
  "del\022/\n\004item\030\001 \003(\0132\035.TST.PopUpMenuModel.C"
  "ellValueB\002\030\001\022)\n\ttsce_item\030\002 \003(\0132\026.TSCE.C"
  "ellValueArchive\032\225\002\n\tCellValue\022:\n\017cell_va"
  "lue_type\030\001 \002(\0162!.TST.PopUpMenuModel.Cell"
  "ValueType\0224\n\rboolean_value\030\002 \001(\0132\035.TSCE."
  "BooleanCellValueArchive\022.\n\ndate_value\030\003 "
  "\001(\0132\032.TSCE.DateCellValueArchive\0222\n\014numbe"
  "r_value\030\004 \001(\0132\034.TSCE.NumberCellValueArch"
  "ive\0222\n\014string_value\030\005 \001(\0132\034.TSCE.StringC"
  "ellValueArchive\"`\n\rCellValueType\022\014\n\010NIL_"
  "TYPE\020\001\022\020\n\014BOOLEAN_TYPE\020\002\022\r\n\tDATE_TYPE\020\003\022"
  "\017\n\013NUMBER_TYPE\020\004\022\017\n\013STRING_TYPE\020\005\"\234\005\n\rTa"
  "bleDataList\022-\n\010listType\030\001 \002(\0162\033.TST.Tabl"
  "eDataList.ListType\022\022\n\nnextListID\030\002 \002(\r\022-"
  "\n\007entries\030\003 \003(\0132\034.TST.TableDataList.List"
  "Entry\032\321\002\n\tListEntry\022\013\n\003key\030\001 \002(\r\022\020\n\010refc"
  "ount\030\002 \002(\r\022\016\n\006string\030\003 \001(\t\022!\n\treference\030"
  "\004 \001(\0132\016.TSP.Reference\022%\n\007formula\030\005 \001(\0132\024"
  ".TSCE.FormulaArchive\022(\n\006format\030\006 \001(\0132\030.T"
  "SK.FormatStructArchive\022\036\n\006region\030\007 \001(\0132\016"
  ".TST.CellRange\022/\n\rcustom_format\030\010 \001(\0132\030."
  "TSK.CustomFormatArchive\022\'\n\017richTextPaylo"
  "ad\030\t \001(\0132\016.TSP.Reference\022\'\n\017comment_stor"
  "age\030\n \001(\0132\016.TSP.Reference\"\304\001\n\010ListType\022\n"
  "\n\006STRING\020\001\022\n\n\006FORMAT\020\002\022\013\n\007FORMULA\020\003\022\t\n\005S"
  "TYLE\020\004\022\021\n\rFORMULA_ERROR\020\005\022\021\n\rCUSTOM_FORM"
  "AT\020\006\022\037\n\033MULTIPLE_CHOICE_LIST_FORMAT\020\007\022\025\n"
  "\021RICH_TEXT_PAYLOAD\020\010\022\025\n\021CONDITIONAL_STYL"
  "E\020\t\022\023\n\017COMMENT_STORAGE\020\n\"W\n\013TableRBTree\022"
  "$\n\005nodes\030\001 \003(\0132\025.TST.TableRBTree.Node\032\"\n"
  "\004Node\022\013\n\003key\030\001 \002(\r\022\r\n\005value\030\002 \002(\r\"\377\001\n\023He"
  "aderStorageBucket\022\032\n\022bucketHashFunction\030"
  "\001 \002(\r\0220\n\007headers\030\002 \003(\0132\037.TST.HeaderStora"
  "geBucket.Header\032\231\001\n\006Header\022\r\n\005index\030\001 \002("
  "\r\022\014\n\004size\030\002 \002(\002\022\023\n\013hidingState\030\003 \002(\r\022\025\n\r"
  "numberOfCells\030\004 \002(\r\022\"\n\ncell_style\030\005 \001(\0132"
  "\016.TSP.Reference\022\"\n\ntext_style\030\006 \001(\0132\016.TS"
  "P.Reference\"L\n\rHeaderStorage\022\032\n\022bucketHa"
  "shFunction\030\001 \002(\r\022\037\n\007buckets\030\002 \003(\0132\016.TSP."
  "Reference\"\355\005\n\tDataStore\022&\n\nrowHeaders\030\001 "
  "\002(\0132\022.TST.HeaderStorage\022%\n\rcolumnHeaders"
  "\030\002 \002(\0132\016.TSP.Reference\022\037\n\005tiles\030\003 \002(\0132\020."
  "TST.TileStorage\022#\n\013stringTable\030\004 \002(\0132\016.T"
  "SP.Reference\022\"\n\nstyleTable\030\005 \002(\0132\016.TSP.R"
  "eference\022$\n\014formulaTable\030\006 \002(\0132\016.TSP.Ref"
  "erence\022)\n\021formulaErrorTable\030\014 \001(\0132\016.TSP."
  "Reference\022#\n\013formatTable\030\013 \002(\0132\016.TSP.Ref"
  "erence\0225\n\035multipleChoiceListFormatTable\030"
  "\020 \001(\0132\016.TSP.Reference\022(\n\020merge_region_ma"
  "p\030\r \001(\0132\016.TSP.Reference\022)\n\021customFormatT"
  "able\030\017 \001(\0132\016.TSP.Reference\022\026\n\016nextRowStr"
  "ipID\030\007 \002(\r\022\031\n\021nextColumnStripID\030\010 \002(\r\022%\n"
  "\013rowTileTree\030\t \002(\0132\020.TST.TableRBTree\022(\n\016"
  "columnTileTree\030\n \002(\0132\020.TST.TableRBTree\022\027"
  "\n\017storage_version\030\016 \001(\r\022,\n\024richTextPaylo"
  "adTable\030\021 \001(\0132\016.TSP.Reference\022-\n\025conditi"
  "onalstyletable\030\022 \001(\0132\016.TSP.Reference\022+\n\023"
  "commentStorageTable\030\023 \001(\0132\016.TSP.Referenc"
  "e\"\201\001\n\020TableInfoArchive\022#\n\005super\030\001 \002(\0132\024."
  "TSD.DrawableArchive\022\"\n\ntableModel\030\002 \002(\0132"
  "\016.TSP.Reference\022$\n\014editingState\030\003 \001(\0132\016."
  "TSP.Reference\"\310\002\n\023EditingStateArchive\022&\n"
  "\016editingStorage\030\001 \001(\0132\016.TSP.Reference\022\036\n"
  "\013editingCell\030\002 \002(\0132\t.TST.Cell\022(\n\tselecti"
  "on\030\003 \001(\0132\025.TST.SelectionArchive\022&\n\021laste"
  "ditingcellid\030\004 \001(\0132\013.TST.CellID\022\"\n\rediti"
  "ngcellid\030\005 \001(\0132\013.TST.CellID\022G\n(deprecate"
  "d_setup_textUndoRedoTransaction\030\006 \001(\0132\025."
  "TSWP.UndoTransaction\022*\n\"cell_was_edited_"
  "in_current_session\030\007 \001(\010\"[\n\022WPTableInfoA"
  "rchive\022$\n\005super\030\001 \002(\0132\025.TST.TableInfoArc"
  "hive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\"\222\004"
  "\n\030TableStyleNetworkArchive\022#\n\013table_styl"
  "e\030\t \002(\0132\016.TSP.Reference\022\'\n\017body_text_sty"
  "le\030\001 \002(\0132\016.TSP.Reference\022-\n\025header_row_t"
  "ext_style\030\002 \002(\0132\016.TSP.Reference\0220\n\030heade"
  "r_column_text_style\030\003 \002(\0132\016.TSP.Referenc"
  "e\022-\n\025footer_row_text_style\030\004 \002(\0132\016.TSP.R"
  "eference\022\'\n\017body_cell_style\030\005 \002(\0132\016.TSP."
  "Reference\022(\n\020header_row_style\030\006 \002(\0132\016.TS"
  "P.Reference\022+\n\023header_column_style\030\007 \002(\013"
  "2\016.TSP.Reference\022(\n\020footer_row_style\030\010 \002"
  "(\0132\016.TSP.Reference\022(\n\020table_name_style\030\n"
  " \001(\0132\016.TSP.Reference\022.\n\026table_name_shape"
  "_style\030\013 \001(\0132\016.TSP.Reference\022\024\n\014preset_i"
  "ndex\030\014 \001(\r\"\230\014\n\021TableModelArchive\022\020\n\010tabl"
  "e_id\030\001 \002(\t\022\025\n\rfrom_table_id\030+ \001(\t\022#\n\013tab"
  "le_style\030\003 \002(\0132\016.TSP.Reference\022\'\n\017body_t"
  "ext_style\030\030 \002(\0132\016.TSP.Reference\022-\n\025heade"
  "r_row_text_style\030\031 \002(\0132\016.TSP.Reference\0220"
  "\n\030header_column_text_style\030\032 \002(\0132\016.TSP.R"
  "eference\022-\n\025footer_row_text_style\030\033 \002(\0132"
  "\016.TSP.Reference\022\'\n\017body_cell_style\030\022 \002(\013"
  "2\016.TSP.Reference\022(\n\020header_row_style\030\023 \002"
  "(\0132\016.TSP.Reference\022+\n\023header_column_styl"
  "e\030\024 \002(\0132\016.TSP.Reference\022(\n\020footer_row_st"
  "yle\030\025 \002(\0132\016.TSP.Reference\022(\n\020table_name_"
  "style\030\036 \001(\0132\016.TSP.Reference\022.\n\026table_nam"
  "e_shape_style\030$ \001(\0132\016.TSP.Reference\022\"\n\nd"
  "ata_store\030\004 \002(\0132\016.TST.DataStore\022 \n\010provi"
  "der\030\005 \001(\0132\016.TSP.Reference\022\026\n\016number_of_r"
  "ows\030\006 \002(\r\022\031\n\021number_of_columns\030\007 \002(\r\022\022\n\n"
  "table_name\030\010 \002(\t\022\032\n\022table_name_enabled\030\026"
  " \001(\010\022\031\n\021table_name_height\030! \001(\001\022!\n\031table"
  "_name_border_enabled\030% \001(\010\022\035\n\025number_of_"
  "header_rows\030\t \001(\r\022 \n\030number_of_header_co"
  "lumns\030\n \001(\r\022\035\n\025number_of_footer_rows\030\013 \001"
  "(\r\022\032\n\022header_rows_frozen\030\014 \001(\010\022\035\n\025header"
  "_columns_frozen\030\r \001(\010\022\035\n\025number_of_hidde"
  "n_rows\030\016 \001(\r\022 \n\030number_of_hidden_columns"
  "\030\017 \001(\r\022\"\n\032number_of_user_hidden_rows\030) \001"
  "(\r\022%\n\035number_of_user_hidden_columns\030* \001("
  "\r\022\037\n\027number_of_filtered_rows\030( \001(\r\022\032\n\022de"
  "fault_row_height\030\020 \002(\001\022\034\n\024default_column"
  "_width\030\021 \002(\001\022&\n\rorigin_offset\030\027 \001(\0132\013.TS"
  "T.CellIDB\002\030\001\022\024\n\014preset_index\030\034 \002(\r\022%\n\035re"
  "peating_header_rows_enabled\030\035 \001(\010\022(\n rep"
  "eating_header_columns_enabled\030  \001(\010\022\036\n\026s"
  "tyle_apply_clears_all\030\037 \001(\010\022>\n&hidden_st"
  "ate_formula_owner_for_columns\030\" \001(\0132\016.TS"
  "P.Reference\022;\n#hidden_state_formula_owne"
  "r_for_rows\030# \001(\0132\016.TSP.Reference\022\"\n\nfilt"
  "er_set\030& \001(\0132\016.TSP.Reference\022\?\n\"conditio"
  "nal_style_formula_owner_id\030\' \001(\0132\023.TSCE."
  "CFUUIDArchive\"\030\n\026DurationWrapperArchive\""
  "\272\007\n\004Cell\022%\n\tvalueType\030\002 \002(\0162\022.TST.CellVa"
  "lueType\022\023\n\013numberValue\030\005 \001(\001\022\023\n\013stringVa"
  "lue\030\006 \001(\t\022\021\n\tboolValue\030\007 \001(\010\022\"\n\ncell_sty"
  "le\030\003 \001(\0132\016.TSP.Reference\022\"\n\ntext_style\030\004"
  " \001(\0132\016.TSP.Reference\022%\n\007formula\030\010 \001(\0132\024."
  "TSCE.FormulaArchive\022$\n\014formulaError\030\n \001("
  "\0132\016.TSP.Reference\0220\n\016current_format\030\t \001("
  "\0132\030.TSK.FormatStructArchive\022/\n\rnumber_fo"
  "rmat\030\013 \001(\0132\030.TSK.FormatStructArchive\0221\n\017"
  "currency_format\030\014 \001(\0132\030.TSK.FormatStruct"
  "Archive\0221\n\017duration_format\030\r \001(\0132\030.TSK.F"
  "ormatStructArchive\022-\n\013date_format\030\016 \001(\0132"
  "\030.TSK.FormatStructArchive\0220\n\016control_for"
  "mat\030\017 \001(\0132\030.TSK.FormatStructArchive\022/\n\rc"
  "ustom_format\030\020 \001(\0132\030.TSK.FormatStructArc"
  "hive\022-\n\013base_format\030\021 \001(\0132\030.TSK.FormatSt"
  "ructArchive\022=\n\033multiple_choice_list_form"
  "at\030\022 \001(\0132\030.TSK.FormatStructArchive\022\035\n\025ex"
  "plicit_format_flags\030\023 \001(\r\022\'\n\017richTextPay"
  "load\030\024 \001(\0132\016.TSP.Reference\022)\n\021conditiona"
  "l_style\030\025 \001(\0132\016.TSP.Reference\022,\n\024multipl"
  "e_choice_list\030\026 \001(\0132\016.TSP.Reference\022\'\n\017c"
  "omment_storage\030\027 \001(\0132\016.TSP.Reference\022&\n\036"
  "conditional_style_applied_rule\030\030 \001(\r\";\n\025"
  "MergeRegionMapArchive\022\"\n\ncell_range\030\001 \003("
  "\0132\016.TST.CellRange\"\265\002\n\016CellMapArchive\022\020\n\010"
  "capacity\030\001 \002(\r\022\r\n\005count\030\002 \002(\r\0226\n\014cellMap"
  "Entry\030\003 \003(\0132 .TST.CellMapArchive.CellMap"
  "Entry\022*\n\034may_modify_formulas_in_cells\030\004 "
  "\001(\010:\004true\0226\n(may_modify_values_reference"
  "d_by_formulas\030\005 \001(\010:\004true\022 \n\021applies_to_"
  "hidden\030\006 \001(\010:\005false\032D\n\014CellMapEntry\022\033\n\006c"
  "ellID\030\001 \002(\0132\013.TST.CellID\022\027\n\004cell\030\002 \001(\0132\t"
  ".TST.Cell\"\212\002\n\025DoubleStyleMapArchive\022\020\n\010c"
  "apacity\030\001 \002(\r\022\r\n\005count\030\002 \002(\r\022M\n\016cell_map"
  "_entry\030\003 \003(\01325.TST.DoubleStyleMapArchive"
  ".DoubleStyleMapEntryArchive\032\200\001\n\032DoubleSt"
  "yleMapEntryArchive\022\034\n\007cell_id\030\001 \002(\0132\013.TS"
  "T.CellID\022!\n\told_style\030\002 \002(\0132\016.TSP.Refere"
  "nce\022!\n\tnew_style\030\003 \002(\0132\016.TSP.Reference\"\357"
  "\001\n\024StyleTableMapArchive\022\020\n\010capacity\030\001 \002("
  "\r\022\r\n\005count\030\002 \002(\r\022F\n\tmap_entry\030\003 \003(\01323.TS"
  "T.StyleTableMapArchive.StyleTableMapEntr"
  "yArchive\032n\n\031StyleTableMapEntryArchive\022\013\n"
  "\003key\030\001 \002(\r\022!\n\told_style\030\002 \002(\0132\016.TSP.Refe"
  "rence\022!\n\tnew_style\030\003 \002(\0132\016.TSP.Reference"
  "\"\373\001\n\020SelectionArchive\022&\n\ntableModel\030\001 \001("
  "\0132\016.TSP.ReferenceB\002\030\001\0221\n\016selection_type\030"
  "\004 \002(\0162\031.TST.SelectionTypeArchive\022 \n\013anch"
  "or_cell\030\005 \001(\0132\013.TST.CellID\022#\n\013cell_range"
  "s\030\006 \003(\0132\016.TST.CellRange\022#\n\013base_ranges\030\007"
  " \003(\0132\016.TST.CellRange\022 \n\013cursor_cell\030\010 \001("
  "\0132\013.TST.CellID\"V\n\021FilterRuleArchive\022/\n\tp"
  "redicate\030\001 \002(\0132\034.TST.FormulaPredicateArc"
  "hive\022\020\n\010disabled\030\002 \001(\010\"\214\001\n\021TableStyleArc"
  "hive\022 \n\005super\030\001 \002(\0132\021.TSS.StyleArchive\022\031"
  "\n\016override_count\030\n \001(\r:\0010\022:\n\020table_prope"
  "rties\030\013 \001(\0132 .TST.TableStylePropertiesAr"
  "chive\"\211\001\n\020CellStyleArchive\022 \n\005super\030\001 \002("
  "\0132\021.TSS.StyleArchive\022\031\n\016override_count\030\n"
  " \001(\r:\0010\0228\n\017cell_properties\030\013 \001(\0132\037.TST.C"
  "ellStylePropertiesArchive\"\342\013\n\027FormulaPre"
  "dicateArchive\022%\n\007formula\030\001 \002(\0132\024.TSCE.Fo"
  "rmulaArchive\022I\n\016predicate_type\030\002 \002(\01621.T"
  "ST.FormulaPredicateArchive.FormulaPredic"
  "ateType\022>\n\nqualifier1\030\003 \002(\0162*.TST.Formul"
  "aPredicateArchive.QualifierType\022>\n\nquali"
  "fier2\030\004 \002(\0162*.TST.FormulaPredicateArchiv"
  "e.QualifierType\022\024\n\014param_index1\030\005 \002(\005\022\024\n"
  "\014param_index2\030\006 \002(\005\022\024\n\014param_index0\030\007 \002("
  "\005\"\211\010\n\024FormulaPredicateType\022\014\n\010PredNone\020\000"
  "\022\022\n\016TextStartsWith\020\001\022\020\n\014TextEndsWith\020\002\022\020"
  "\n\014TextContains\020\003\022\026\n\022TextDoesNotContain\020\004"
  "\022\016\n\nValueEqual\020\005\022\021\n\rValueNotEqual\020\006\022\024\n\020V"
  "alueGreaterThan\020\007\022\033\n\027ValueGreaterThanOrE"
  "qual\020\010\022\021\n\rValueLessThan\020\t\022\030\n\024ValueLessTh"
  "anOrEqual\020\n\022\025\n\021ValueAboveAverage\020\013\022\025\n\021Va"
  "lueBelowAverage\020\014\022\020\n\014ValueBetween\020\r\022\013\n\007F"
  "ormula\020\016\022\016\n\nDuplicates\020\017\022\013\n\007Uniques\020\020\022\017\n"
  "\013DateIsToday\020\021\022\023\n\017DateIsYesterday\020\022\022\022\n\016D"
  "ateIsTomorrow\020\023\022\021\n\rDateIsTheDate\020\024\022\025\n\021Da"
  "teBeforeTheDate\020\025\022\024\n\020DateAfterTheDate\020\026\022"
  "\024\n\020DateIsInTheRange\020\027\022\021\n\rDateInTheNext\020\030"
  "\022\021\n\rDateInTheLast\020\031\022\021\n\rDateIsExactly\020\032\022\026"
  "\n\022DateBeforeRelative\020\033\022\025\n\021DateAfterRelat"
  "ive\020\034\022\027\n\023DateBetweenRelative\020\035\022\014\n\010ValueT"
  "op\020\036\022\017\n\013ValueBottom\020\037\022\023\n\017ValueNotBetween"
  "\020 \022\016\n\nDateInThis\020!\022\013\n\007IsBlank\020\"\022\016\n\nIsNot"
  "Blank\020#\022\n\n\006TextIs\020$\022\r\n\tTextIsNot\020%\022\021\n\rDu"
  "rationEqual\020&\022\024\n\020DurationNotEqual\020\'\022\027\n\023D"
  "urationGreaterThan\020(\022\036\n\032DurationGreaterT"
  "hanOrEqual\020)\022\024\n\020DurationLessThan\020*\022\033\n\027Du"
  "rationLessThanOrEqual\020+\022\023\n\017DurationBetwe"
  "en\020,\022\026\n\022DurationNotBetween\020-\022\030\n\024Duration"
  "AboveAverage\020.\022\030\n\024DurationBelowAverage\020/"
  "\022\017\n\013DurationTop\0200\022\022\n\016DurationBottom\0201\"\206\001"
  "\n\rQualifierType\022\014\n\010QualNone\020\000\022\010\n\004Days\020\002\022"
  "\t\n\005Weeks\020\003\022\n\n\006Months\020\004\022\t\n\005Years\020\005\022\007\n\003Ago"
  "\020\006\022\013\n\007FromNow\020\007\022\014\n\010Quarters\020\010\022\013\n\007Percent"
  "\020\t\022\n\n\006Values\020\n\"\243\002\n\032ConditionalStyleSetAr"
  "chive\022\021\n\truleCount\030\001 \002(\r\022C\n\005rules\030\002 \003(\0132"
  "4.TST.ConditionalStyleSetArchive.Conditi"
  "onalStyleRule\022\033\n\006cellID\030\003 \001(\0132\013.TST.Cell"
  "ID\032\217\001\n\024ConditionalStyleRule\022/\n\tpredicate"
  "\030\001 \002(\0132\034.TST.FormulaPredicateArchive\022\"\n\n"
  "cell_style\030\002 \002(\0132\016.TSP.Reference\022\"\n\ntext"
  "_style\030\003 \002(\0132\016.TSP.Reference\"\322\002\n\020FilterS"
  "etArchive\022J\n\004type\030\001 \001(\0162#.TST.FilterSetA"
  "rchive.FilterSetType:\027FilterSetArchiveTy"
  "peAll\022\030\n\nis_enabled\030\002 \001(\010:\004true\022,\n\014filte"
  "r_rules\030\003 \003(\0132\026.TST.FilterRuleArchive\022/\n"
  " needs_formula_rewrite_for_import\030\004 \001(\010:"
  "\005false\022\026\n\016filter_offsets\030\005 \003(\r\022\026\n\016filter"
  "_enabled\030\006 \003(\010\"I\n\rFilterSetType\022\033\n\027Filte"
  "rSetArchiveTypeAll\020\000\022\033\n\027FilterSetArchive"
  "TypeAny\020\001\"l\n\026TokenAttachmentArchive\022*\n\005s"
  "uper\030\001 \002(\0132\033.TSWP.UIGraphicalAttachment\022"
  "&\n\016expressionNode\030\002 \001(\0132\016.TSP.Reference\""
  "8\n\016FormulaArchive\022&\n\016expressionTree\030\001 \001("
  "\0132\016.TSP.Reference\"h\n\025ExpressionNodeArchi"
  "ve\022 \n\010children\030\001 \003(\0132\016.TSP.Reference\022\026\n\013"
  "first_index\030\002 \001(\004:\0010\022\025\n\nlast_index\030\003 \001(\004"
  ":\0010\"N\n\022BooleanNodeArchive\022)\n\005super\030\001 \002(\013"
  "2\032.TST.ExpressionNodeArchive\022\r\n\005value\030\002 "
  "\002(\010\"N\n\021NumberNodeArchive\022)\n\005super\030\001 \002(\0132"
  "\032.TST.ExpressionNodeArchive\022\016\n\006number\030\002 "
  "\002(\001\"M\n\021StringNodeArchive\022)\n\005super\030\001 \002(\0132"
  "\032.TST.ExpressionNodeArchive\022\r\n\005value\030\002 \002"
  "(\t\"V\n\025IdentifierNodeArchive\022)\n\005super\030\001 \002"
  "(\0132\032.TST.ExpressionNodeArchive\022\022\n\nidenti"
  "fier\030\002 \001(\t\"\\\n\020ArrayNodeArchive\022)\n\005super\030"
  "\001 \002(\0132\032.TST.ExpressionNodeArchive\022\017\n\007col"
  "umns\030\002 \001(\r\022\014\n\004rows\030\003 \001(\r\"<\n\017ListNodeArch"
  "ive\022)\n\005super\030\001 \002(\0132\032.TST.ExpressionNodeA"
  "rchive\"V\n\023OperatorNodeArchive\022)\n\005super\030\001"
  " \002(\0132\032.TST.ExpressionNodeArchive\022\024\n\014oper"
  "atorChar\030\002 \002(\r\"E\n\032PostfixOperatorNodeArc"
  "hive\022\'\n\005super\030\001 \002(\0132\030.TST.OperatorNodeAr"
  "chive\"D\n\031PrefixOperatorNodeArchive\022\'\n\005su"
  "per\030\001 \002(\0132\030.TST.OperatorNodeArchive\"t\n\023F"
  "unctionNodeArchive\022)\n\005super\030\001 \002(\0132\032.TST."
  "ExpressionNodeArchive\022\025\n\rfunctionIndex\030\002"
  " \002(\r\022\033\n\023invalidFunctionName\030\003 \001(\t\"C\n\026Fun"
  "ctionEndNodeArchive\022)\n\005super\030\001 \002(\0132\032.TST"
  ".ExpressionNodeArchive\"[\n\017DateNodeArchiv"
  "e\022)\n\005super\030\001 \002(\0132\032.TST.ExpressionNodeArc"
  "hive\022\r\n\005value\030\002 \002(\t\022\016\n\006format\030\003 \001(\t\"\237\001\n\024"
  "ReferenceNodeArchive\022)\n\005super\030\001 \002(\0132\032.TS"
  "T.ExpressionNodeArchive\0223\n\016rangeReferenc"
  "e\030\002 \002(\0132\033.TSCE.RangeReferenceArchive\022\022\n\n"
  "stickyBits\030\003 \002(\r\022\023\n\013hostTableID\030\004 \001(\t\"\210\001"
  "\n\023DurationNodeArchive\022)\n\005super\030\001 \002(\0132\032.T"
  "ST.ExpressionNodeArchive\022\024\n\014timeinterval"
  "\030\002 \002(\001\022\020\n\010smallest\030\003 \002(\r\022\017\n\007largest\030\004 \002("
  "\r\022\r\n\005style\030\005 \002(\r\"\207\001\n\036ArgumentPlaceholder"
  "NodeArchive\022)\n\005super\030\001 \002(\0132\032.TST.Express"
  "ionNodeArchive\022\025\n\rfunctionIndex\030\002 \002(\r\022\025\n"
  "\rargumentIndex\030\003 \002(\r\022\014\n\004mode\030\004 \001(\r\"G\n\032Em"
  "ptyExpressionNodeArchive\022)\n\005super\030\001 \002(\0132"
  "\032.TST.ExpressionNodeArchive\"\357\001\n\021LayoutHi"
  "ntArchive\022\017\n\007isValid\030\001 \002(\010\022!\n\tcellRange\030"
  "\002 \002(\0132\016.TST.CellRange\022\033\n\006hintID\030\003 \002(\0132\013."
  "TST.CellID\022\036\n\013maximumSize\030\004 \002(\0132\t.TSP.Si"
  "ze\022\031\n\021partitionPosition\030\005 \002(\r\022\022\n\nhorizon"
  "tal\030\006 \002(\010\022 \n\reffectiveSize\030\007 \001(\0132\t.TSP.S"
  "ize\022\030\n\020partitioningPass\030\010 \001(\r\"\222\001\n Comple"
  "tionTokenAttachmentArchive\022*\n\005super\030\001 \002("
  "\0132\033.TST.TokenAttachmentArchive\022\026\n\016comple"
  "tionText\030\002 \001(\t\022\025\n\rcaretPosition\030\003 \001(\r\022\023\n"
  "\013prefixStart\030\004 \001(\r\"\256\001\n\036HiddenStateFormul"
  "aOwnerArchive\022%\n\010owner_id\030\001 \001(\0132\023.TSCE.C"
  "FUUIDArchive\022/\n\017threshold_value\030\002 \003(\0132\026."
  "TSCE.CellValueArchive\0224\n%needs_to_update"
  "_filter_set_for_import\030\003 \001(\010:\005false\"q\n\026R"
  "ichTextPayloadArchive\022\037\n\007storage\030\001 \002(\0132\016"
  ".TSP.Reference\022\031\n\005range\030\002 \001(\0132\n.TSP.Rang"
  "e\022\033\n\006cellid\030\003 \002(\0132\013.TST.CellID\"Q\n#Formul"
  "aEqualsTokenAttachmentArchive\022*\n\005super\030\001"
  " \002(\0132\033.TSWP.UIGraphicalAttachment\"1\n\nCel"
  "lRegion\022#\n\013cell_ranges\030\001 \003(\0132\016.TST.CellR"
  "ange*\327\001\n\010CellType\022\023\n\017genericCellType\020\000\022\020"
  "\n\014spanCellType\020\001\022\022\n\016numberCellType\020\002\022\020\n\014"
  "textCellType\020\003\022\023\n\017formulaCellType\020\004\022\020\n\014d"
  "ateCellType\020\005\022\020\n\014boolCellType\020\006\022\024\n\020durat"
  "ionCellType\020\007\022\030\n\024formulaErrorCellType\020\010\022"
  "\025\n\021automaticCellType\020\t*\353\001\n\rCellValueType"
  "\022\026\n\022emptyCellValueType\020\000\022\027\n\023numberCellVa"
  "lueType\020\001\022\027\n\023stringCellValueType\020\002\022\031\n\025pr"
  "ovidedCellValueType\020\003\022\025\n\021dateCellValueTy"
  "pe\020\004\022\025\n\021boolCellValueType\020\005\022\031\n\025durationC"
  "ellValueType\020\006\022\026\n\022errorCellValueType\020\007\022\024"
  "\n\020richTextCellType\020\010*\256\001\n\024SelectionTypeAr"
  "chive\022\025\n\021cellSelectionType\020\000\022\024\n\020rowSelec"
  "tionType\020\001\022\027\n\023columnSelectionType\020\002\022\034\n\030c"
  "ellEditingSelectionType\020\003\022\032\n\026tableNameSe"
  "lectionType\020\004\022\026\n\022tableSelectionType\020\005*y\n"
  "\024FillDirectionArchive\022\027\n\023kTSTFillDownArc"
  "hive\020\001\022\025\n\021kTSTFillUpArchive\020\002\022\030\n\024kTSTFil"
  "lRightArchive\020\003\022\027\n\023kTSTFillLeftArchive\020\004"
  "*B\n\022MergeActionArchive\022\024\n\020mergeActionMer"
  "ge\020\000\022\026\n\022mergeActionUnmerge\020\001*G\n\025HideShow"
  "ActionArchive\022\026\n\022hideShowActionHide\020\000\022\026\n"
  "\022hideShowActionShow\020\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSTArchives_2eproto_deps[7] = {
  &::descriptor_table_TSCEArchives_2eproto,
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
  &::descriptor_table_TSTStylePropertyArchiving_2eproto,
  &::descriptor_table_TSWPArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSTArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSTArchives_2eproto = {
    false, false, 13981, descriptor_table_protodef_TSTArchives_2eproto,
    "TSTArchives.proto",
    &descriptor_table_TSTArchives_2eproto_once, descriptor_table_TSTArchives_2eproto_deps, 7, 65,
    schemas, file_default_instances, TableStruct_TSTArchives_2eproto::offsets,
    file_level_metadata_TSTArchives_2eproto, file_level_enum_descriptors_TSTArchives_2eproto,
    file_level_service_descriptors_TSTArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSTArchives_2eproto_getter() {
  return &descriptor_table_TSTArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSTArchives_2eproto(&descriptor_table_TSTArchives_2eproto);
namespace TST {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PopUpMenuModel_CellValueType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[0];
}
bool PopUpMenuModel_CellValueType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::NIL_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::BOOLEAN_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::DATE_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::NUMBER_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::STRING_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::CellValueType_MIN;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel::CellValueType_MAX;
constexpr int PopUpMenuModel::CellValueType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TableDataList_ListType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[1];
}
bool TableDataList_ListType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TableDataList_ListType TableDataList::STRING;
constexpr TableDataList_ListType TableDataList::FORMAT;
constexpr TableDataList_ListType TableDataList::FORMULA;
constexpr TableDataList_ListType TableDataList::STYLE;
constexpr TableDataList_ListType TableDataList::FORMULA_ERROR;
constexpr TableDataList_ListType TableDataList::CUSTOM_FORMAT;
constexpr TableDataList_ListType TableDataList::MULTIPLE_CHOICE_LIST_FORMAT;
constexpr TableDataList_ListType TableDataList::RICH_TEXT_PAYLOAD;
constexpr TableDataList_ListType TableDataList::CONDITIONAL_STYLE;
constexpr TableDataList_ListType TableDataList::COMMENT_STORAGE;
constexpr TableDataList_ListType TableDataList::ListType_MIN;
constexpr TableDataList_ListType TableDataList::ListType_MAX;
constexpr int TableDataList::ListType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FormulaPredicateArchive_FormulaPredicateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[2];
}
bool FormulaPredicateArchive_FormulaPredicateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::PredNone;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextStartsWith;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextEndsWith;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextContains;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextDoesNotContain;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueNotEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueGreaterThan;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueGreaterThanOrEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueLessThan;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueLessThanOrEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueAboveAverage;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueBelowAverage;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueBetween;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::Formula;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::Duplicates;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::Uniques;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsToday;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsYesterday;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsTomorrow;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsTheDate;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateBeforeTheDate;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateAfterTheDate;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsInTheRange;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateInTheNext;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateInTheLast;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateIsExactly;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateBeforeRelative;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateAfterRelative;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateBetweenRelative;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueTop;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueBottom;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::ValueNotBetween;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DateInThis;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::IsBlank;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::IsNotBlank;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextIs;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::TextIsNot;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationNotEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationGreaterThan;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationGreaterThanOrEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationLessThan;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationLessThanOrEqual;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationBetween;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationNotBetween;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationAboveAverage;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationBelowAverage;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationTop;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::DurationBottom;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::FormulaPredicateType_MIN;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::FormulaPredicateType_MAX;
constexpr int FormulaPredicateArchive::FormulaPredicateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FormulaPredicateArchive_QualifierType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[3];
}
bool FormulaPredicateArchive_QualifierType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::QualNone;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Days;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Weeks;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Months;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Years;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Ago;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::FromNow;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Quarters;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Percent;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::Values;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::QualifierType_MIN;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive::QualifierType_MAX;
constexpr int FormulaPredicateArchive::QualifierType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterSetArchive_FilterSetType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[4];
}
bool FilterSetArchive_FilterSetType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FilterSetArchive_FilterSetType FilterSetArchive::FilterSetArchiveTypeAll;
constexpr FilterSetArchive_FilterSetType FilterSetArchive::FilterSetArchiveTypeAny;
constexpr FilterSetArchive_FilterSetType FilterSetArchive::FilterSetType_MIN;
constexpr FilterSetArchive_FilterSetType FilterSetArchive::FilterSetType_MAX;
constexpr int FilterSetArchive::FilterSetType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CellType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[5];
}
bool CellType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CellValueType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[6];
}
bool CellValueType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelectionTypeArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[7];
}
bool SelectionTypeArchive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FillDirectionArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[8];
}
bool FillDirectionArchive_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MergeActionArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[9];
}
bool MergeActionArchive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HideShowActionArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTArchives_2eproto);
  return file_level_enum_descriptors_TSTArchives_2eproto[10];
}
bool HideShowActionArchive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CellID::_Internal {
 public:
  using HasBits = decltype(std::declval<CellID>()._impl_._has_bits_);
  static void set_has_packeddata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CellID::CellID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellID)
}
CellID::CellID(const CellID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packeddata_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.packeddata_ = from._impl_.packeddata_;
  // @@protoc_insertion_point(copy_constructor:TST.CellID)
}

inline void CellID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packeddata_){0u}
  };
}

CellID::~CellID() {
  // @@protoc_insertion_point(destructor:TST.CellID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CellID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellID::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packeddata_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required fixed32 packedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_packeddata(&has_bits);
          _impl_.packeddata_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required fixed32 packedData = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_packeddata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellID)
  return target;
}

size_t CellID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellID)
  size_t total_size = 0;

  // required fixed32 packedData = 1;
  if (_internal_has_packeddata()) {
    total_size += 1 + 4;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellID::GetClassData() const { return &_class_data_; }


void CellID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellID*>(&to_msg);
  auto& from = static_cast<const CellID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_packeddata()) {
    _this->_internal_set_packeddata(from._internal_packeddata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellID::CopyFrom(const CellID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellID::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CellID::InternalSwap(CellID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.packeddata_, other->_impl_.packeddata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CellID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[0]);
}

// ===================================================================

class TableSize::_Internal {
 public:
  using HasBits = decltype(std::declval<TableSize>()._impl_._has_bits_);
  static void set_has_packeddata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TableSize::TableSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableSize)
}
TableSize::TableSize(const TableSize& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableSize* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packeddata_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.packeddata_ = from._impl_.packeddata_;
  // @@protoc_insertion_point(copy_constructor:TST.TableSize)
}

inline void TableSize::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packeddata_){0u}
  };
}

TableSize::~TableSize() {
  // @@protoc_insertion_point(destructor:TST.TableSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TableSize::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableSize::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packeddata_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required fixed32 packedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_packeddata(&has_bits);
          _impl_.packeddata_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required fixed32 packedData = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_packeddata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableSize)
  return target;
}

size_t TableSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableSize)
  size_t total_size = 0;

  // required fixed32 packedData = 1;
  if (_internal_has_packeddata()) {
    total_size += 1 + 4;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableSize::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableSize::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableSize::GetClassData() const { return &_class_data_; }


void TableSize::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableSize*>(&to_msg);
  auto& from = static_cast<const TableSize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableSize)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_packeddata()) {
    _this->_internal_set_packeddata(from._internal_packeddata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableSize::CopyFrom(const TableSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableSize::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TableSize::InternalSwap(TableSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.packeddata_, other->_impl_.packeddata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableSize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[1]);
}

// ===================================================================

class CellRange::_Internal {
 public:
  using HasBits = decltype(std::declval<CellRange>()._impl_._has_bits_);
  static const ::TST::CellID& origin(const CellRange* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::TableSize& size(const CellRange* msg);
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CellID&
CellRange::_Internal::origin(const CellRange* msg) {
  return *msg->_impl_.origin_;
}
const ::TST::TableSize&
CellRange::_Internal::size(const CellRange* msg) {
  return *msg->_impl_.size_;
}
CellRange::CellRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellRange)
}
CellRange::CellRange(const CellRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.size_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::TST::CellID(*from._impl_.origin_);
  }
  if (from._internal_has_size()) {
    _this->_impl_.size_ = new ::TST::TableSize(*from._impl_.size_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CellRange)
}

inline void CellRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.size_){nullptr}
  };
}

CellRange::~CellRange() {
  // @@protoc_insertion_point(destructor:TST.CellRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.size_;
}

void CellRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellRange::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.size_ != nullptr);
      _impl_.size_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableSize size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableSize size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellRange)
  return target;
}

size_t CellRange::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CellRange)
  size_t total_size = 0;

  if (_internal_has_origin()) {
    // required .TST.CellID origin = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.origin_);
  }

  if (_internal_has_size()) {
    // required .TST.TableSize size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_);
  }

  return total_size;
}
size_t CellRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellRange)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CellID origin = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.origin_);

    // required .TST.TableSize size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellRange::GetClassData() const { return &_class_data_; }


void CellRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellRange*>(&to_msg);
  auto& from = static_cast<const CellRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::TST::CellID::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_size()->::TST::TableSize::MergeFrom(
          from._internal_size());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellRange::CopyFrom(const CellRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellRange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_origin()) {
    if (!_impl_.origin_->IsInitialized()) return false;
  }
  if (_internal_has_size()) {
    if (!_impl_.size_->IsInitialized()) return false;
  }
  return true;
}

void CellRange::InternalSwap(CellRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CellRange, _impl_.size_)
      + sizeof(CellRange::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(CellRange, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CellRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[2]);
}

// ===================================================================

class TableSelection::_Internal {
 public:
  using HasBits = decltype(std::declval<TableSelection>()._impl_._has_bits_);
  static const ::TST::CellRange& cellrange(const TableSelection* msg);
  static void set_has_cellrange(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellRange& extendedcellrange(const TableSelection* msg);
  static void set_has_extendedcellrange(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_extendedcellrangevalid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::CellRange&
TableSelection::_Internal::cellrange(const TableSelection* msg) {
  return *msg->_impl_.cellrange_;
}
const ::TST::CellRange&
TableSelection::_Internal::extendedcellrange(const TableSelection* msg) {
  return *msg->_impl_.extendedcellrange_;
}
TableSelection::TableSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableSelection)
}
TableSelection::TableSelection(const TableSelection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableSelection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellrange_){nullptr}
    , decltype(_impl_.extendedcellrange_){nullptr}
    , decltype(_impl_.extendedcellrangevalid_){}
    , decltype(_impl_.selection_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellrange()) {
    _this->_impl_.cellrange_ = new ::TST::CellRange(*from._impl_.cellrange_);
  }
  if (from._internal_has_extendedcellrange()) {
    _this->_impl_.extendedcellrange_ = new ::TST::CellRange(*from._impl_.extendedcellrange_);
  }
  ::memcpy(&_impl_.extendedcellrangevalid_, &from._impl_.extendedcellrangevalid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_type_) -
    reinterpret_cast<char*>(&_impl_.extendedcellrangevalid_)) + sizeof(_impl_.selection_type_));
  // @@protoc_insertion_point(copy_constructor:TST.TableSelection)
}

inline void TableSelection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellrange_){nullptr}
    , decltype(_impl_.extendedcellrange_){nullptr}
    , decltype(_impl_.extendedcellrangevalid_){false}
    , decltype(_impl_.selection_type_){0}
  };
}

TableSelection::~TableSelection() {
  // @@protoc_insertion_point(destructor:TST.TableSelection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableSelection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellrange_;
  if (this != internal_default_instance()) delete _impl_.extendedcellrange_;
}

void TableSelection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableSelection::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableSelection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellrange_ != nullptr);
      _impl_.cellrange_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.extendedcellrange_ != nullptr);
      _impl_.extendedcellrange_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.extendedcellrangevalid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_type_) -
        reinterpret_cast<char*>(&_impl_.extendedcellrangevalid_)) + sizeof(_impl_.selection_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableSelection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellRange cellRange = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellRange extendedCellRange = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_extendedcellrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool extendedCellRangeValid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_extendedcellrangevalid(&has_bits);
          _impl_.extendedcellrangevalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionTypeArchive selection_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::SelectionTypeArchive_IsValid(val))) {
            _internal_set_selection_type(static_cast<::TST::SelectionTypeArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableSelection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableSelection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellRange cellRange = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cellrange(this),
        _Internal::cellrange(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellRange extendedCellRange = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::extendedcellrange(this),
        _Internal::extendedcellrange(this).GetCachedSize(), target, stream);
  }

  // required bool extendedCellRangeValid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_extendedcellrangevalid(), target);
  }

  // required .TST.SelectionTypeArchive selection_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_selection_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableSelection)
  return target;
}

size_t TableSelection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableSelection)
  size_t total_size = 0;

  if (_internal_has_cellrange()) {
    // required .TST.CellRange cellRange = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellrange_);
  }

  if (_internal_has_extendedcellrange()) {
    // required .TST.CellRange extendedCellRange = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.extendedcellrange_);
  }

  if (_internal_has_extendedcellrangevalid()) {
    // required bool extendedCellRangeValid = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_selection_type()) {
    // required .TST.SelectionTypeArchive selection_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_selection_type());
  }

  return total_size;
}
size_t TableSelection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableSelection)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.CellRange cellRange = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellrange_);

    // required .TST.CellRange extendedCellRange = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.extendedcellrange_);

    // required bool extendedCellRangeValid = 3;
    total_size += 1 + 1;

    // required .TST.SelectionTypeArchive selection_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_selection_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableSelection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableSelection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableSelection::GetClassData() const { return &_class_data_; }


void TableSelection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableSelection*>(&to_msg);
  auto& from = static_cast<const TableSelection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableSelection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellrange()->::TST::CellRange::MergeFrom(
          from._internal_cellrange());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_extendedcellrange()->::TST::CellRange::MergeFrom(
          from._internal_extendedcellrange());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.extendedcellrangevalid_ = from._impl_.extendedcellrangevalid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_type_ = from._impl_.selection_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableSelection::CopyFrom(const TableSelection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableSelection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableSelection::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellrange()) {
    if (!_impl_.cellrange_->IsInitialized()) return false;
  }
  if (_internal_has_extendedcellrange()) {
    if (!_impl_.extendedcellrange_->IsInitialized()) return false;
  }
  return true;
}

void TableSelection::InternalSwap(TableSelection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableSelection, _impl_.selection_type_)
      + sizeof(TableSelection::_impl_.selection_type_)
      - PROTOBUF_FIELD_OFFSET(TableSelection, _impl_.cellrange_)>(
          reinterpret_cast<char*>(&_impl_.cellrange_),
          reinterpret_cast<char*>(&other->_impl_.cellrange_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableSelection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[3]);
}

// ===================================================================

class TileRowInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TileRowInfo>()._impl_._has_bits_);
  static void set_has_storage_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_tilerowindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cellcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cellstoragebuffer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_celloffsets(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TileRowInfo::TileRowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TileRowInfo)
}
TileRowInfo::TileRowInfo(const TileRowInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TileRowInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellstoragebuffer_){}
    , decltype(_impl_.celloffsets_){}
    , decltype(_impl_.tilerowindex_){}
    , decltype(_impl_.cellcount_){}
    , decltype(_impl_.storage_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cellstoragebuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cellstoragebuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cellstoragebuffer()) {
    _this->_impl_.cellstoragebuffer_.Set(from._internal_cellstoragebuffer(), 
      _this->GetArenaForAllocation());
  }
  _impl_.celloffsets_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.celloffsets_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_celloffsets()) {
    _this->_impl_.celloffsets_.Set(from._internal_celloffsets(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tilerowindex_, &from._impl_.tilerowindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storage_version_) -
    reinterpret_cast<char*>(&_impl_.tilerowindex_)) + sizeof(_impl_.storage_version_));
  // @@protoc_insertion_point(copy_constructor:TST.TileRowInfo)
}

inline void TileRowInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellstoragebuffer_){}
    , decltype(_impl_.celloffsets_){}
    , decltype(_impl_.tilerowindex_){0u}
    , decltype(_impl_.cellcount_){0u}
    , decltype(_impl_.storage_version_){0u}
  };
  _impl_.cellstoragebuffer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cellstoragebuffer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.celloffsets_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.celloffsets_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TileRowInfo::~TileRowInfo() {
  // @@protoc_insertion_point(destructor:TST.TileRowInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TileRowInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cellstoragebuffer_.Destroy();
  _impl_.celloffsets_.Destroy();
}

void TileRowInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TileRowInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TileRowInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.cellstoragebuffer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.celloffsets_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.tilerowindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.storage_version_) -
        reinterpret_cast<char*>(&_impl_.tilerowindex_)) + sizeof(_impl_.storage_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TileRowInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 tileRowIndex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tilerowindex(&has_bits);
          _impl_.tilerowindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 cellCount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cellcount(&has_bits);
          _impl_.cellcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes cellStorageBuffer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_cellstoragebuffer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes cellOffsets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_celloffsets();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 storage_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_storage_version(&has_bits);
          _impl_.storage_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TileRowInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TileRowInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 tileRowIndex = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tilerowindex(), target);
  }

  // required uint32 cellCount = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cellcount(), target);
  }

  // required bytes cellStorageBuffer = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_cellstoragebuffer(), target);
  }

  // required bytes cellOffsets = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_celloffsets(), target);
  }

  // optional uint32 storage_version = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_storage_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TileRowInfo)
  return target;
}

size_t TileRowInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TileRowInfo)
  size_t total_size = 0;

  if (_internal_has_cellstoragebuffer()) {
    // required bytes cellStorageBuffer = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_cellstoragebuffer());
  }

  if (_internal_has_celloffsets()) {
    // required bytes cellOffsets = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_celloffsets());
  }

  if (_internal_has_tilerowindex()) {
    // required uint32 tileRowIndex = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tilerowindex());
  }

  if (_internal_has_cellcount()) {
    // required uint32 cellCount = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cellcount());
  }

  return total_size;
}
size_t TileRowInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TileRowInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes cellStorageBuffer = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_cellstoragebuffer());

    // required bytes cellOffsets = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_celloffsets());

    // required uint32 tileRowIndex = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tilerowindex());

    // required uint32 cellCount = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cellcount());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 storage_version = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_storage_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TileRowInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TileRowInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TileRowInfo::GetClassData() const { return &_class_data_; }


void TileRowInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TileRowInfo*>(&to_msg);
  auto& from = static_cast<const TileRowInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TileRowInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cellstoragebuffer(from._internal_cellstoragebuffer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_celloffsets(from._internal_celloffsets());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tilerowindex_ = from._impl_.tilerowindex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cellcount_ = from._impl_.cellcount_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.storage_version_ = from._impl_.storage_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TileRowInfo::CopyFrom(const TileRowInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TileRowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TileRowInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TileRowInfo::InternalSwap(TileRowInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cellstoragebuffer_, lhs_arena,
      &other->_impl_.cellstoragebuffer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.celloffsets_, lhs_arena,
      &other->_impl_.celloffsets_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TileRowInfo, _impl_.storage_version_)
      + sizeof(TileRowInfo::_impl_.storage_version_)
      - PROTOBUF_FIELD_OFFSET(TileRowInfo, _impl_.tilerowindex_)>(
          reinterpret_cast<char*>(&_impl_.tilerowindex_),
          reinterpret_cast<char*>(&other->_impl_.tilerowindex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TileRowInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[4]);
}

// ===================================================================

class Tile::_Internal {
 public:
  using HasBits = decltype(std::declval<Tile>()._impl_._has_bits_);
  static void set_has_maxcolumn(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maxrow(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_numcells(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numrows(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_storage_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

Tile::Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.Tile)
}
Tile::Tile(const Tile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowinfos_){from._impl_.rowinfos_}
    , decltype(_impl_.maxcolumn_){}
    , decltype(_impl_.maxrow_){}
    , decltype(_impl_.numcells_){}
    , decltype(_impl_.numrows_){}
    , decltype(_impl_.storage_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.maxcolumn_, &from._impl_.maxcolumn_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storage_version_) -
    reinterpret_cast<char*>(&_impl_.maxcolumn_)) + sizeof(_impl_.storage_version_));
  // @@protoc_insertion_point(copy_constructor:TST.Tile)
}

inline void Tile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowinfos_){arena}
    , decltype(_impl_.maxcolumn_){0u}
    , decltype(_impl_.maxrow_){0u}
    , decltype(_impl_.numcells_){0u}
    , decltype(_impl_.numrows_){0u}
    , decltype(_impl_.storage_version_){0u}
  };
}

Tile::~Tile() {
  // @@protoc_insertion_point(destructor:TST.Tile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rowinfos_.~RepeatedPtrField();
}

void Tile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tile::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.Tile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rowinfos_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.maxcolumn_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.storage_version_) -
        reinterpret_cast<char*>(&_impl_.maxcolumn_)) + sizeof(_impl_.storage_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 maxColumn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_maxcolumn(&has_bits);
          _impl_.maxcolumn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 maxRow = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maxrow(&has_bits);
          _impl_.maxrow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numCells = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numcells(&has_bits);
          _impl_.numcells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numrows = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numrows(&has_bits);
          _impl_.numrows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.TileRowInfo rowInfos = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rowinfos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 storage_version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_storage_version(&has_bits);
          _impl_.storage_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.Tile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 maxColumn = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_maxcolumn(), target);
  }

  // required uint32 maxRow = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_maxrow(), target);
  }

  // required uint32 numCells = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_numcells(), target);
  }

  // required uint32 numrows = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_numrows(), target);
  }

  // repeated .TST.TileRowInfo rowInfos = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rowinfos_size()); i < n; i++) {
    const auto& repfield = this->_internal_rowinfos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 storage_version = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_storage_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.Tile)
  return target;
}

size_t Tile::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.Tile)
  size_t total_size = 0;

  if (_internal_has_maxcolumn()) {
    // required uint32 maxColumn = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxcolumn());
  }

  if (_internal_has_maxrow()) {
    // required uint32 maxRow = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxrow());
  }

  if (_internal_has_numcells()) {
    // required uint32 numCells = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numcells());
  }

  if (_internal_has_numrows()) {
    // required uint32 numrows = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numrows());
  }

  return total_size;
}
size_t Tile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.Tile)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 maxColumn = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxcolumn());

    // required uint32 maxRow = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxrow());

    // required uint32 numCells = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numcells());

    // required uint32 numrows = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numrows());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.TileRowInfo rowInfos = 5;
  total_size += 1UL * this->_internal_rowinfos_size();
  for (const auto& msg : this->_impl_.rowinfos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 storage_version = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_storage_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tile::GetClassData() const { return &_class_data_; }


void Tile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tile*>(&to_msg);
  auto& from = static_cast<const Tile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.Tile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rowinfos_.MergeFrom(from._impl_.rowinfos_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.maxcolumn_ = from._impl_.maxcolumn_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maxrow_ = from._impl_.maxrow_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.numcells_ = from._impl_.numcells_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.numrows_ = from._impl_.numrows_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.storage_version_ = from._impl_.storage_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tile::CopyFrom(const Tile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.Tile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tile::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.rowinfos_))
    return false;
  return true;
}

void Tile::InternalSwap(Tile* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rowinfos_.InternalSwap(&other->_impl_.rowinfos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tile, _impl_.storage_version_)
      + sizeof(Tile::_impl_.storage_version_)
      - PROTOBUF_FIELD_OFFSET(Tile, _impl_.maxcolumn_)>(
          reinterpret_cast<char*>(&_impl_.maxcolumn_),
          reinterpret_cast<char*>(&other->_impl_.maxcolumn_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[5]);
}

// ===================================================================

class TileStorage_Tile::_Internal {
 public:
  using HasBits = decltype(std::declval<TileStorage_Tile>()._impl_._has_bits_);
  static void set_has_tileid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& tile(const TileStorage_Tile* msg);
  static void set_has_tile(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::Reference&
TileStorage_Tile::_Internal::tile(const TileStorage_Tile* msg) {
  return *msg->_impl_.tile_;
}
void TileStorage_Tile::clear_tile() {
  if (_impl_.tile_ != nullptr) _impl_.tile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
TileStorage_Tile::TileStorage_Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TileStorage.Tile)
}
TileStorage_Tile::TileStorage_Tile(const TileStorage_Tile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TileStorage_Tile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tile_){nullptr}
    , decltype(_impl_.tileid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tile()) {
    _this->_impl_.tile_ = new ::TSP::Reference(*from._impl_.tile_);
  }
  _this->_impl_.tileid_ = from._impl_.tileid_;
  // @@protoc_insertion_point(copy_constructor:TST.TileStorage.Tile)
}

inline void TileStorage_Tile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tile_){nullptr}
    , decltype(_impl_.tileid_){0u}
  };
}

TileStorage_Tile::~TileStorage_Tile() {
  // @@protoc_insertion_point(destructor:TST.TileStorage.Tile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TileStorage_Tile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tile_;
}

void TileStorage_Tile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TileStorage_Tile::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TileStorage.Tile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tile_ != nullptr);
    _impl_.tile_->Clear();
  }
  _impl_.tileid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TileStorage_Tile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 tileid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tileid(&has_bits);
          _impl_.tileid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference tile = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tile(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TileStorage_Tile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TileStorage.Tile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 tileid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tileid(), target);
  }

  // required .TSP.Reference tile = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tile(this),
        _Internal::tile(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TileStorage.Tile)
  return target;
}

size_t TileStorage_Tile::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TileStorage.Tile)
  size_t total_size = 0;

  if (_internal_has_tile()) {
    // required .TSP.Reference tile = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tile_);
  }

  if (_internal_has_tileid()) {
    // required uint32 tileid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tileid());
  }

  return total_size;
}
size_t TileStorage_Tile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TileStorage.Tile)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.Reference tile = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tile_);

    // required uint32 tileid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tileid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TileStorage_Tile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TileStorage_Tile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TileStorage_Tile::GetClassData() const { return &_class_data_; }


void TileStorage_Tile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TileStorage_Tile*>(&to_msg);
  auto& from = static_cast<const TileStorage_Tile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TileStorage.Tile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tile()->::TSP::Reference::MergeFrom(
          from._internal_tile());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tileid_ = from._impl_.tileid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TileStorage_Tile::CopyFrom(const TileStorage_Tile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TileStorage.Tile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TileStorage_Tile::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_tile()) {
    if (!_impl_.tile_->IsInitialized()) return false;
  }
  return true;
}

void TileStorage_Tile::InternalSwap(TileStorage_Tile* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TileStorage_Tile, _impl_.tileid_)
      + sizeof(TileStorage_Tile::_impl_.tileid_)
      - PROTOBUF_FIELD_OFFSET(TileStorage_Tile, _impl_.tile_)>(
          reinterpret_cast<char*>(&_impl_.tile_),
          reinterpret_cast<char*>(&other->_impl_.tile_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TileStorage_Tile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[6]);
}

// ===================================================================

class TileStorage::_Internal {
 public:
};

TileStorage::TileStorage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TileStorage)
}
TileStorage::TileStorage(const TileStorage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TileStorage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tiles_){from._impl_.tiles_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.TileStorage)
}

inline void TileStorage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tiles_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TileStorage::~TileStorage() {
  // @@protoc_insertion_point(destructor:TST.TileStorage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TileStorage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tiles_.~RepeatedPtrField();
}

void TileStorage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TileStorage::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TileStorage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tiles_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TileStorage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TST.TileStorage.Tile tiles = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tiles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TileStorage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TileStorage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TST.TileStorage.Tile tiles = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tiles_size()); i < n; i++) {
    const auto& repfield = this->_internal_tiles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TileStorage)
  return target;
}

size_t TileStorage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TileStorage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.TileStorage.Tile tiles = 1;
  total_size += 1UL * this->_internal_tiles_size();
  for (const auto& msg : this->_impl_.tiles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TileStorage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TileStorage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TileStorage::GetClassData() const { return &_class_data_; }


void TileStorage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TileStorage*>(&to_msg);
  auto& from = static_cast<const TileStorage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TileStorage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tiles_.MergeFrom(from._impl_.tiles_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TileStorage::CopyFrom(const TileStorage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TileStorage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TileStorage::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.tiles_))
    return false;
  return true;
}

void TileStorage::InternalSwap(TileStorage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tiles_.InternalSwap(&other->_impl_.tiles_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TileStorage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[7]);
}

// ===================================================================

class PopUpMenuModel_CellValue::_Internal {
 public:
  using HasBits = decltype(std::declval<PopUpMenuModel_CellValue>()._impl_._has_bits_);
  static void set_has_cell_value_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSCE::BooleanCellValueArchive& boolean_value(const PopUpMenuModel_CellValue* msg);
  static void set_has_boolean_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::DateCellValueArchive& date_value(const PopUpMenuModel_CellValue* msg);
  static void set_has_date_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::NumberCellValueArchive& number_value(const PopUpMenuModel_CellValue* msg);
  static void set_has_number_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::StringCellValueArchive& string_value(const PopUpMenuModel_CellValue* msg);
  static void set_has_string_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

const ::TSCE::BooleanCellValueArchive&
PopUpMenuModel_CellValue::_Internal::boolean_value(const PopUpMenuModel_CellValue* msg) {
  return *msg->_impl_.boolean_value_;
}
const ::TSCE::DateCellValueArchive&
PopUpMenuModel_CellValue::_Internal::date_value(const PopUpMenuModel_CellValue* msg) {
  return *msg->_impl_.date_value_;
}
const ::TSCE::NumberCellValueArchive&
PopUpMenuModel_CellValue::_Internal::number_value(const PopUpMenuModel_CellValue* msg) {
  return *msg->_impl_.number_value_;
}
const ::TSCE::StringCellValueArchive&
PopUpMenuModel_CellValue::_Internal::string_value(const PopUpMenuModel_CellValue* msg) {
  return *msg->_impl_.string_value_;
}
void PopUpMenuModel_CellValue::clear_boolean_value() {
  if (_impl_.boolean_value_ != nullptr) _impl_.boolean_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PopUpMenuModel_CellValue::clear_date_value() {
  if (_impl_.date_value_ != nullptr) _impl_.date_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PopUpMenuModel_CellValue::clear_number_value() {
  if (_impl_.number_value_ != nullptr) _impl_.number_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PopUpMenuModel_CellValue::clear_string_value() {
  if (_impl_.string_value_ != nullptr) _impl_.string_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PopUpMenuModel_CellValue::PopUpMenuModel_CellValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.PopUpMenuModel.CellValue)
}
PopUpMenuModel_CellValue::PopUpMenuModel_CellValue(const PopUpMenuModel_CellValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PopUpMenuModel_CellValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boolean_value_){nullptr}
    , decltype(_impl_.date_value_){nullptr}
    , decltype(_impl_.number_value_){nullptr}
    , decltype(_impl_.string_value_){nullptr}
    , decltype(_impl_.cell_value_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_boolean_value()) {
    _this->_impl_.boolean_value_ = new ::TSCE::BooleanCellValueArchive(*from._impl_.boolean_value_);
  }
  if (from._internal_has_date_value()) {
    _this->_impl_.date_value_ = new ::TSCE::DateCellValueArchive(*from._impl_.date_value_);
  }
  if (from._internal_has_number_value()) {
    _this->_impl_.number_value_ = new ::TSCE::NumberCellValueArchive(*from._impl_.number_value_);
  }
  if (from._internal_has_string_value()) {
    _this->_impl_.string_value_ = new ::TSCE::StringCellValueArchive(*from._impl_.string_value_);
  }
  _this->_impl_.cell_value_type_ = from._impl_.cell_value_type_;
  // @@protoc_insertion_point(copy_constructor:TST.PopUpMenuModel.CellValue)
}

inline void PopUpMenuModel_CellValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.boolean_value_){nullptr}
    , decltype(_impl_.date_value_){nullptr}
    , decltype(_impl_.number_value_){nullptr}
    , decltype(_impl_.string_value_){nullptr}
    , decltype(_impl_.cell_value_type_){1}
  };
}

PopUpMenuModel_CellValue::~PopUpMenuModel_CellValue() {
  // @@protoc_insertion_point(destructor:TST.PopUpMenuModel.CellValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PopUpMenuModel_CellValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.boolean_value_;
  if (this != internal_default_instance()) delete _impl_.date_value_;
  if (this != internal_default_instance()) delete _impl_.number_value_;
  if (this != internal_default_instance()) delete _impl_.string_value_;
}

void PopUpMenuModel_CellValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PopUpMenuModel_CellValue::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.PopUpMenuModel.CellValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.boolean_value_ != nullptr);
      _impl_.boolean_value_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.date_value_ != nullptr);
      _impl_.date_value_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.number_value_ != nullptr);
      _impl_.number_value_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.string_value_ != nullptr);
      _impl_.string_value_->Clear();
    }
    _impl_.cell_value_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PopUpMenuModel_CellValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::PopUpMenuModel_CellValueType_IsValid(val))) {
            _internal_set_cell_value_type(static_cast<::TST::PopUpMenuModel_CellValueType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolean_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.DateCellValueArchive date_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_date_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.NumberCellValueArchive number_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_number_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.StringCellValueArchive string_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_string_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PopUpMenuModel_CellValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.PopUpMenuModel.CellValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_cell_value_type(), target);
  }

  // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::boolean_value(this),
        _Internal::boolean_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.DateCellValueArchive date_value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::date_value(this),
        _Internal::date_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.NumberCellValueArchive number_value = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::number_value(this),
        _Internal::number_value(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.StringCellValueArchive string_value = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::string_value(this),
        _Internal::string_value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.PopUpMenuModel.CellValue)
  return target;
}

size_t PopUpMenuModel_CellValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.PopUpMenuModel.CellValue)
  size_t total_size = 0;

  // required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
  if (_internal_has_cell_value_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_cell_value_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.boolean_value_);
    }

    // optional .TSCE.DateCellValueArchive date_value = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_value_);
    }

    // optional .TSCE.NumberCellValueArchive number_value = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.number_value_);
    }

    // optional .TSCE.StringCellValueArchive string_value = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.string_value_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PopUpMenuModel_CellValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PopUpMenuModel_CellValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PopUpMenuModel_CellValue::GetClassData() const { return &_class_data_; }


void PopUpMenuModel_CellValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PopUpMenuModel_CellValue*>(&to_msg);
  auto& from = static_cast<const PopUpMenuModel_CellValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.PopUpMenuModel.CellValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_boolean_value()->::TSCE::BooleanCellValueArchive::MergeFrom(
          from._internal_boolean_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_date_value()->::TSCE::DateCellValueArchive::MergeFrom(
          from._internal_date_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_number_value()->::TSCE::NumberCellValueArchive::MergeFrom(
          from._internal_number_value());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_string_value()->::TSCE::StringCellValueArchive::MergeFrom(
          from._internal_string_value());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.cell_value_type_ = from._impl_.cell_value_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PopUpMenuModel_CellValue::CopyFrom(const PopUpMenuModel_CellValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.PopUpMenuModel.CellValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PopUpMenuModel_CellValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_boolean_value()) {
    if (!_impl_.boolean_value_->IsInitialized()) return false;
  }
  if (_internal_has_date_value()) {
    if (!_impl_.date_value_->IsInitialized()) return false;
  }
  if (_internal_has_number_value()) {
    if (!_impl_.number_value_->IsInitialized()) return false;
  }
  if (_internal_has_string_value()) {
    if (!_impl_.string_value_->IsInitialized()) return false;
  }
  return true;
}

void PopUpMenuModel_CellValue::InternalSwap(PopUpMenuModel_CellValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PopUpMenuModel_CellValue, _impl_.string_value_)
      + sizeof(PopUpMenuModel_CellValue::_impl_.string_value_)
      - PROTOBUF_FIELD_OFFSET(PopUpMenuModel_CellValue, _impl_.boolean_value_)>(
          reinterpret_cast<char*>(&_impl_.boolean_value_),
          reinterpret_cast<char*>(&other->_impl_.boolean_value_));
  swap(_impl_.cell_value_type_, other->_impl_.cell_value_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PopUpMenuModel_CellValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[8]);
}

// ===================================================================

class PopUpMenuModel::_Internal {
 public:
};

void PopUpMenuModel::clear_tsce_item() {
  _impl_.tsce_item_.Clear();
}
PopUpMenuModel::PopUpMenuModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.PopUpMenuModel)
}
PopUpMenuModel::PopUpMenuModel(const PopUpMenuModel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PopUpMenuModel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){from._impl_.item_}
    , decltype(_impl_.tsce_item_){from._impl_.tsce_item_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.PopUpMenuModel)
}

inline void PopUpMenuModel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.item_){arena}
    , decltype(_impl_.tsce_item_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PopUpMenuModel::~PopUpMenuModel() {
  // @@protoc_insertion_point(destructor:TST.PopUpMenuModel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PopUpMenuModel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.item_.~RepeatedPtrField();
  _impl_.tsce_item_.~RepeatedPtrField();
}

void PopUpMenuModel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PopUpMenuModel::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.PopUpMenuModel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_.Clear();
  _impl_.tsce_item_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PopUpMenuModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_item(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TSCE.CellValueArchive tsce_item = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tsce_item(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PopUpMenuModel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.PopUpMenuModel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_item_size()); i < n; i++) {
    const auto& repfield = this->_internal_item(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TSCE.CellValueArchive tsce_item = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tsce_item_size()); i < n; i++) {
    const auto& repfield = this->_internal_tsce_item(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.PopUpMenuModel)
  return target;
}

size_t PopUpMenuModel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.PopUpMenuModel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
  total_size += 1UL * this->_internal_item_size();
  for (const auto& msg : this->_impl_.item_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TSCE.CellValueArchive tsce_item = 2;
  total_size += 1UL * this->_internal_tsce_item_size();
  for (const auto& msg : this->_impl_.tsce_item_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PopUpMenuModel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PopUpMenuModel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PopUpMenuModel::GetClassData() const { return &_class_data_; }


void PopUpMenuModel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PopUpMenuModel*>(&to_msg);
  auto& from = static_cast<const PopUpMenuModel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.PopUpMenuModel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.item_.MergeFrom(from._impl_.item_);
  _this->_impl_.tsce_item_.MergeFrom(from._impl_.tsce_item_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PopUpMenuModel::CopyFrom(const PopUpMenuModel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.PopUpMenuModel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PopUpMenuModel::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.item_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.tsce_item_))
    return false;
  return true;
}

void PopUpMenuModel::InternalSwap(PopUpMenuModel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.item_.InternalSwap(&other->_impl_.item_);
  _impl_.tsce_item_.InternalSwap(&other->_impl_.tsce_item_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PopUpMenuModel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[9]);
}

// ===================================================================

class TableDataList_ListEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<TableDataList_ListEntry>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_refcount(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& reference(const TableDataList_ListEntry* msg);
  static void set_has_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::FormulaArchive& formula(const TableDataList_ListEntry* msg);
  static void set_has_formula(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSK::FormatStructArchive& format(const TableDataList_ListEntry* msg);
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellRange& region(const TableDataList_ListEntry* msg);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSK::CustomFormatArchive& custom_format(const TableDataList_ListEntry* msg);
  static void set_has_custom_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& richtextpayload(const TableDataList_ListEntry* msg);
  static void set_has_richtextpayload(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& comment_storage(const TableDataList_ListEntry* msg);
  static void set_has_comment_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000300) ^ 0x00000300) != 0;
  }
};

const ::TSP::Reference&
TableDataList_ListEntry::_Internal::reference(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.reference_;
}
const ::TSCE::FormulaArchive&
TableDataList_ListEntry::_Internal::formula(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.formula_;
}
const ::TSK::FormatStructArchive&
TableDataList_ListEntry::_Internal::format(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.format_;
}
const ::TST::CellRange&
TableDataList_ListEntry::_Internal::region(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.region_;
}
const ::TSK::CustomFormatArchive&
TableDataList_ListEntry::_Internal::custom_format(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.custom_format_;
}
const ::TSP::Reference&
TableDataList_ListEntry::_Internal::richtextpayload(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.richtextpayload_;
}
const ::TSP::Reference&
TableDataList_ListEntry::_Internal::comment_storage(const TableDataList_ListEntry* msg) {
  return *msg->_impl_.comment_storage_;
}
void TableDataList_ListEntry::clear_reference() {
  if (_impl_.reference_ != nullptr) _impl_.reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableDataList_ListEntry::clear_formula() {
  if (_impl_.formula_ != nullptr) _impl_.formula_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TableDataList_ListEntry::clear_format() {
  if (_impl_.format_ != nullptr) _impl_.format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TableDataList_ListEntry::clear_custom_format() {
  if (_impl_.custom_format_ != nullptr) _impl_.custom_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void TableDataList_ListEntry::clear_richtextpayload() {
  if (_impl_.richtextpayload_ != nullptr) _impl_.richtextpayload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void TableDataList_ListEntry::clear_comment_storage() {
  if (_impl_.comment_storage_ != nullptr) _impl_.comment_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
TableDataList_ListEntry::TableDataList_ListEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableDataList.ListEntry)
}
TableDataList_ListEntry::TableDataList_ListEntry(const TableDataList_ListEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableDataList_ListEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_){}
    , decltype(_impl_.reference_){nullptr}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.format_){nullptr}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.custom_format_){nullptr}
    , decltype(_impl_.richtextpayload_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}
    , decltype(_impl_.key_){}
    , decltype(_impl_.refcount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string()) {
    _this->_impl_.string_.Set(from._internal_string(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_reference()) {
    _this->_impl_.reference_ = new ::TSP::Reference(*from._impl_.reference_);
  }
  if (from._internal_has_formula()) {
    _this->_impl_.formula_ = new ::TSCE::FormulaArchive(*from._impl_.formula_);
  }
  if (from._internal_has_format()) {
    _this->_impl_.format_ = new ::TSK::FormatStructArchive(*from._impl_.format_);
  }
  if (from._internal_has_region()) {
    _this->_impl_.region_ = new ::TST::CellRange(*from._impl_.region_);
  }
  if (from._internal_has_custom_format()) {
    _this->_impl_.custom_format_ = new ::TSK::CustomFormatArchive(*from._impl_.custom_format_);
  }
  if (from._internal_has_richtextpayload()) {
    _this->_impl_.richtextpayload_ = new ::TSP::Reference(*from._impl_.richtextpayload_);
  }
  if (from._internal_has_comment_storage()) {
    _this->_impl_.comment_storage_ = new ::TSP::Reference(*from._impl_.comment_storage_);
  }
  ::memcpy(&_impl_.key_, &from._impl_.key_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.refcount_) -
    reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.refcount_));
  // @@protoc_insertion_point(copy_constructor:TST.TableDataList.ListEntry)
}

inline void TableDataList_ListEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_){}
    , decltype(_impl_.reference_){nullptr}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.format_){nullptr}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.custom_format_){nullptr}
    , decltype(_impl_.richtextpayload_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}
    , decltype(_impl_.key_){0u}
    , decltype(_impl_.refcount_){0u}
  };
  _impl_.string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableDataList_ListEntry::~TableDataList_ListEntry() {
  // @@protoc_insertion_point(destructor:TST.TableDataList.ListEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableDataList_ListEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.string_.Destroy();
  if (this != internal_default_instance()) delete _impl_.reference_;
  if (this != internal_default_instance()) delete _impl_.formula_;
  if (this != internal_default_instance()) delete _impl_.format_;
  if (this != internal_default_instance()) delete _impl_.region_;
  if (this != internal_default_instance()) delete _impl_.custom_format_;
  if (this != internal_default_instance()) delete _impl_.richtextpayload_;
  if (this != internal_default_instance()) delete _impl_.comment_storage_;
}

void TableDataList_ListEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableDataList_ListEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableDataList.ListEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.reference_ != nullptr);
      _impl_.reference_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.formula_ != nullptr);
      _impl_.formula_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.format_ != nullptr);
      _impl_.format_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.region_ != nullptr);
      _impl_.region_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.custom_format_ != nullptr);
      _impl_.custom_format_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.richtextpayload_ != nullptr);
      _impl_.richtextpayload_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.comment_storage_ != nullptr);
      _impl_.comment_storage_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.key_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.refcount_) -
        reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.refcount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableDataList_ListEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 refcount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_refcount(&has_bits);
          _impl_.refcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.TableDataList.ListEntry.string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference reference = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.FormulaArchive formula = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive format = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellRange region = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_region(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.CustomFormatArchive custom_format = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference richTextPayload = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_richtextpayload(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference comment_storage = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableDataList_ListEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableDataList.ListEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 key = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_key(), target);
  }

  // required uint32 refcount = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_refcount(), target);
  }

  // optional string string = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_string().data(), static_cast<int>(this->_internal_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.TableDataList.ListEntry.string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_string(), target);
  }

  // optional .TSP.Reference reference = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::reference(this),
        _Internal::reference(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.FormulaArchive formula = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::formula(this),
        _Internal::formula(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive format = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::format(this),
        _Internal::format(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellRange region = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::region(this),
        _Internal::region(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.CustomFormatArchive custom_format = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::custom_format(this),
        _Internal::custom_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference richTextPayload = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::richtextpayload(this),
        _Internal::richtextpayload(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference comment_storage = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::comment_storage(this),
        _Internal::comment_storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableDataList.ListEntry)
  return target;
}

size_t TableDataList_ListEntry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableDataList.ListEntry)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());
  }

  if (_internal_has_refcount()) {
    // required uint32 refcount = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_refcount());
  }

  return total_size;
}
size_t TableDataList_ListEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableDataList.ListEntry)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000300) ^ 0x00000300) == 0) {  // All required fields are present.
    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());

    // required uint32 refcount = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_refcount());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string string = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string());
    }

    // optional .TSP.Reference reference = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.reference_);
    }

    // optional .TSCE.FormulaArchive formula = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formula_);
    }

    // optional .TSK.FormatStructArchive format = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.format_);
    }

    // optional .TST.CellRange region = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.region_);
    }

    // optional .TSK.CustomFormatArchive custom_format = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.custom_format_);
    }

    // optional .TSP.Reference richTextPayload = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.richtextpayload_);
    }

    // optional .TSP.Reference comment_storage = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.comment_storage_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableDataList_ListEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableDataList_ListEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableDataList_ListEntry::GetClassData() const { return &_class_data_; }


void TableDataList_ListEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableDataList_ListEntry*>(&to_msg);
  auto& from = static_cast<const TableDataList_ListEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableDataList.ListEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_string(from._internal_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_reference()->::TSP::Reference::MergeFrom(
          from._internal_reference());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_formula()->::TSCE::FormulaArchive::MergeFrom(
          from._internal_formula());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_format());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_region()->::TST::CellRange::MergeFrom(
          from._internal_region());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_custom_format()->::TSK::CustomFormatArchive::MergeFrom(
          from._internal_custom_format());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_richtextpayload()->::TSP::Reference::MergeFrom(
          from._internal_richtextpayload());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_comment_storage()->::TSP::Reference::MergeFrom(
          from._internal_comment_storage());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.refcount_ = from._impl_.refcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableDataList_ListEntry::CopyFrom(const TableDataList_ListEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableDataList.ListEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableDataList_ListEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_reference()) {
    if (!_impl_.reference_->IsInitialized()) return false;
  }
  if (_internal_has_formula()) {
    if (!_impl_.formula_->IsInitialized()) return false;
  }
  if (_internal_has_format()) {
    if (!_impl_.format_->IsInitialized()) return false;
  }
  if (_internal_has_region()) {
    if (!_impl_.region_->IsInitialized()) return false;
  }
  if (_internal_has_custom_format()) {
    if (!_impl_.custom_format_->IsInitialized()) return false;
  }
  if (_internal_has_richtextpayload()) {
    if (!_impl_.richtextpayload_->IsInitialized()) return false;
  }
  if (_internal_has_comment_storage()) {
    if (!_impl_.comment_storage_->IsInitialized()) return false;
  }
  return true;
}

void TableDataList_ListEntry::InternalSwap(TableDataList_ListEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_, lhs_arena,
      &other->_impl_.string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableDataList_ListEntry, _impl_.refcount_)
      + sizeof(TableDataList_ListEntry::_impl_.refcount_)
      - PROTOBUF_FIELD_OFFSET(TableDataList_ListEntry, _impl_.reference_)>(
          reinterpret_cast<char*>(&_impl_.reference_),
          reinterpret_cast<char*>(&other->_impl_.reference_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableDataList_ListEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[10]);
}

// ===================================================================

class TableDataList::_Internal {
 public:
  using HasBits = decltype(std::declval<TableDataList>()._impl_._has_bits_);
  static void set_has_listtype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nextlistid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TableDataList::TableDataList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableDataList)
}
TableDataList::TableDataList(const TableDataList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableDataList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.nextlistid_){}
    , decltype(_impl_.listtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.nextlistid_, &from._impl_.nextlistid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.listtype_) -
    reinterpret_cast<char*>(&_impl_.nextlistid_)) + sizeof(_impl_.listtype_));
  // @@protoc_insertion_point(copy_constructor:TST.TableDataList)
}

inline void TableDataList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entries_){arena}
    , decltype(_impl_.nextlistid_){0u}
    , decltype(_impl_.listtype_){1}
  };
}

TableDataList::~TableDataList() {
  // @@protoc_insertion_point(destructor:TST.TableDataList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableDataList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void TableDataList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableDataList::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableDataList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.nextlistid_ = 0u;
    _impl_.listtype_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableDataList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableDataList.ListType listType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::TableDataList_ListType_IsValid(val))) {
            _internal_set_listtype(static_cast<::TST::TableDataList_ListType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 nextListID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nextlistid(&has_bits);
          _impl_.nextlistid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.TableDataList.ListEntry entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableDataList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableDataList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableDataList.ListType listType = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_listtype(), target);
  }

  // required uint32 nextListID = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_nextlistid(), target);
  }

  // repeated .TST.TableDataList.ListEntry entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableDataList)
  return target;
}

size_t TableDataList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableDataList)
  size_t total_size = 0;

  if (_internal_has_nextlistid()) {
    // required uint32 nextListID = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextlistid());
  }

  if (_internal_has_listtype()) {
    // required .TST.TableDataList.ListType listType = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_listtype());
  }

  return total_size;
}
size_t TableDataList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableDataList)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 nextListID = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextlistid());

    // required .TST.TableDataList.ListType listType = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_listtype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.TableDataList.ListEntry entries = 3;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableDataList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableDataList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableDataList::GetClassData() const { return &_class_data_; }


void TableDataList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableDataList*>(&to_msg);
  auto& from = static_cast<const TableDataList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableDataList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.nextlistid_ = from._impl_.nextlistid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.listtype_ = from._impl_.listtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableDataList::CopyFrom(const TableDataList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableDataList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableDataList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entries_))
    return false;
  return true;
}

void TableDataList::InternalSwap(TableDataList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  swap(_impl_.nextlistid_, other->_impl_.nextlistid_);
  swap(_impl_.listtype_, other->_impl_.listtype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableDataList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[11]);
}

// ===================================================================

class TableRBTree_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<TableRBTree_Node>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TableRBTree_Node::TableRBTree_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableRBTree.Node)
}
TableRBTree_Node::TableRBTree_Node(const TableRBTree_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableRBTree_Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.key_, &from._impl_.key_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.value_) -
    reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.value_));
  // @@protoc_insertion_point(copy_constructor:TST.TableRBTree.Node)
}

inline void TableRBTree_Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.key_){0u}
    , decltype(_impl_.value_){0u}
  };
}

TableRBTree_Node::~TableRBTree_Node() {
  // @@protoc_insertion_point(destructor:TST.TableRBTree.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableRBTree_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TableRBTree_Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableRBTree_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableRBTree.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.key_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.value_) -
        reinterpret_cast<char*>(&_impl_.key_)) + sizeof(_impl_.value_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableRBTree_Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableRBTree_Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableRBTree.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_key(), target);
  }

  // required uint32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableRBTree.Node)
  return target;
}

size_t TableRBTree_Node::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableRBTree.Node)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());
  }

  if (_internal_has_value()) {
    // required uint32 value = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());
  }

  return total_size;
}
size_t TableRBTree_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableRBTree.Node)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());

    // required uint32 value = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableRBTree_Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableRBTree_Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableRBTree_Node::GetClassData() const { return &_class_data_; }


void TableRBTree_Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableRBTree_Node*>(&to_msg);
  auto& from = static_cast<const TableRBTree_Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableRBTree.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableRBTree_Node::CopyFrom(const TableRBTree_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableRBTree.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableRBTree_Node::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TableRBTree_Node::InternalSwap(TableRBTree_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableRBTree_Node, _impl_.value_)
      + sizeof(TableRBTree_Node::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(TableRBTree_Node, _impl_.key_)>(
          reinterpret_cast<char*>(&_impl_.key_),
          reinterpret_cast<char*>(&other->_impl_.key_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableRBTree_Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[12]);
}

// ===================================================================

class TableRBTree::_Internal {
 public:
};

TableRBTree::TableRBTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableRBTree)
}
TableRBTree::TableRBTree(const TableRBTree& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableRBTree* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.TableRBTree)
}

inline void TableRBTree::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TableRBTree::~TableRBTree() {
  // @@protoc_insertion_point(destructor:TST.TableRBTree)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableRBTree::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void TableRBTree::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableRBTree::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableRBTree)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableRBTree::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TST.TableRBTree.Node nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableRBTree::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableRBTree)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TST.TableRBTree.Node nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableRBTree)
  return target;
}

size_t TableRBTree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableRBTree)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.TableRBTree.Node nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableRBTree::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableRBTree::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableRBTree::GetClassData() const { return &_class_data_; }


void TableRBTree::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableRBTree*>(&to_msg);
  auto& from = static_cast<const TableRBTree&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableRBTree)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableRBTree::CopyFrom(const TableRBTree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableRBTree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableRBTree::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.nodes_))
    return false;
  return true;
}

void TableRBTree::InternalSwap(TableRBTree* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TableRBTree::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[13]);
}

// ===================================================================

class HeaderStorageBucket_Header::_Internal {
 public:
  using HasBits = decltype(std::declval<HeaderStorageBucket_Header>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hidingstate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_numberofcells(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& cell_style(const HeaderStorageBucket_Header* msg);
  static void set_has_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& text_style(const HeaderStorageBucket_Header* msg);
  static void set_has_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003c) ^ 0x0000003c) != 0;
  }
};

const ::TSP::Reference&
HeaderStorageBucket_Header::_Internal::cell_style(const HeaderStorageBucket_Header* msg) {
  return *msg->_impl_.cell_style_;
}
const ::TSP::Reference&
HeaderStorageBucket_Header::_Internal::text_style(const HeaderStorageBucket_Header* msg) {
  return *msg->_impl_.text_style_;
}
void HeaderStorageBucket_Header::clear_cell_style() {
  if (_impl_.cell_style_ != nullptr) _impl_.cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void HeaderStorageBucket_Header::clear_text_style() {
  if (_impl_.text_style_ != nullptr) _impl_.text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
HeaderStorageBucket_Header::HeaderStorageBucket_Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.HeaderStorageBucket.Header)
}
HeaderStorageBucket_Header::HeaderStorageBucket_Header(const HeaderStorageBucket_Header& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeaderStorageBucket_Header* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.index_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.hidingstate_){}
    , decltype(_impl_.numberofcells_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cell_style()) {
    _this->_impl_.cell_style_ = new ::TSP::Reference(*from._impl_.cell_style_);
  }
  if (from._internal_has_text_style()) {
    _this->_impl_.text_style_ = new ::TSP::Reference(*from._impl_.text_style_);
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.numberofcells_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.numberofcells_));
  // @@protoc_insertion_point(copy_constructor:TST.HeaderStorageBucket.Header)
}

inline void HeaderStorageBucket_Header::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.size_){0}
    , decltype(_impl_.hidingstate_){0u}
    , decltype(_impl_.numberofcells_){0u}
  };
}

HeaderStorageBucket_Header::~HeaderStorageBucket_Header() {
  // @@protoc_insertion_point(destructor:TST.HeaderStorageBucket.Header)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeaderStorageBucket_Header::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cell_style_;
  if (this != internal_default_instance()) delete _impl_.text_style_;
}

void HeaderStorageBucket_Header::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeaderStorageBucket_Header::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.HeaderStorageBucket.Header)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cell_style_ != nullptr);
      _impl_.cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.text_style_ != nullptr);
      _impl_.text_style_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.numberofcells_) -
        reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.numberofcells_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeaderStorageBucket_Header::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required uint32 hidingState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_hidingstate(&has_bits);
          _impl_.hidingstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 numberOfCells = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numberofcells(&has_bits);
          _impl_.numberofcells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference cell_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_style = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeaderStorageBucket_Header::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.HeaderStorageBucket.Header)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 index = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // required float size = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_size(), target);
  }

  // required uint32 hidingState = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hidingstate(), target);
  }

  // required uint32 numberOfCells = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_numberofcells(), target);
  }

  // optional .TSP.Reference cell_style = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cell_style(this),
        _Internal::cell_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_style = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::text_style(this),
        _Internal::text_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.HeaderStorageBucket.Header)
  return target;
}

size_t HeaderStorageBucket_Header::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.HeaderStorageBucket.Header)
  size_t total_size = 0;

  if (_internal_has_index()) {
    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  if (_internal_has_size()) {
    // required float size = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_hidingstate()) {
    // required uint32 hidingState = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hidingstate());
  }

  if (_internal_has_numberofcells()) {
    // required uint32 numberOfCells = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numberofcells());
  }

  return total_size;
}
size_t HeaderStorageBucket_Header::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.HeaderStorageBucket.Header)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003c) ^ 0x0000003c) == 0) {  // All required fields are present.
    // required uint32 index = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

    // required float size = 2;
    total_size += 1 + 4;

    // required uint32 hidingState = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hidingstate());

    // required uint32 numberOfCells = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numberofcells());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference cell_style = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cell_style_);
    }

    // optional .TSP.Reference text_style = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeaderStorageBucket_Header::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeaderStorageBucket_Header::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeaderStorageBucket_Header::GetClassData() const { return &_class_data_; }


void HeaderStorageBucket_Header::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeaderStorageBucket_Header*>(&to_msg);
  auto& from = static_cast<const HeaderStorageBucket_Header&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.HeaderStorageBucket.Header)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_cell_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_text_style()->::TSP::Reference::MergeFrom(
          from._internal_text_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hidingstate_ = from._impl_.hidingstate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.numberofcells_ = from._impl_.numberofcells_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeaderStorageBucket_Header::CopyFrom(const HeaderStorageBucket_Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.HeaderStorageBucket.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderStorageBucket_Header::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cell_style()) {
    if (!_impl_.cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_text_style()) {
    if (!_impl_.text_style_->IsInitialized()) return false;
  }
  return true;
}

void HeaderStorageBucket_Header::InternalSwap(HeaderStorageBucket_Header* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeaderStorageBucket_Header, _impl_.numberofcells_)
      + sizeof(HeaderStorageBucket_Header::_impl_.numberofcells_)
      - PROTOBUF_FIELD_OFFSET(HeaderStorageBucket_Header, _impl_.cell_style_)>(
          reinterpret_cast<char*>(&_impl_.cell_style_),
          reinterpret_cast<char*>(&other->_impl_.cell_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeaderStorageBucket_Header::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[14]);
}

// ===================================================================

class HeaderStorageBucket::_Internal {
 public:
  using HasBits = decltype(std::declval<HeaderStorageBucket>()._impl_._has_bits_);
  static void set_has_buckethashfunction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

HeaderStorageBucket::HeaderStorageBucket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.HeaderStorageBucket)
}
HeaderStorageBucket::HeaderStorageBucket(const HeaderStorageBucket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeaderStorageBucket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){from._impl_.headers_}
    , decltype(_impl_.buckethashfunction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.buckethashfunction_ = from._impl_.buckethashfunction_;
  // @@protoc_insertion_point(copy_constructor:TST.HeaderStorageBucket)
}

inline void HeaderStorageBucket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.headers_){arena}
    , decltype(_impl_.buckethashfunction_){0u}
  };
}

HeaderStorageBucket::~HeaderStorageBucket() {
  // @@protoc_insertion_point(destructor:TST.HeaderStorageBucket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeaderStorageBucket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
}

void HeaderStorageBucket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeaderStorageBucket::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.HeaderStorageBucket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  _impl_.buckethashfunction_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeaderStorageBucket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 bucketHashFunction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buckethashfunction(&has_bits);
          _impl_.buckethashfunction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.HeaderStorageBucket.Header headers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeaderStorageBucket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.HeaderStorageBucket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 bucketHashFunction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_buckethashfunction(), target);
  }

  // repeated .TST.HeaderStorageBucket.Header headers = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.HeaderStorageBucket)
  return target;
}

size_t HeaderStorageBucket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.HeaderStorageBucket)
  size_t total_size = 0;

  // required uint32 bucketHashFunction = 1;
  if (_internal_has_buckethashfunction()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_buckethashfunction());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.HeaderStorageBucket.Header headers = 2;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeaderStorageBucket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeaderStorageBucket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeaderStorageBucket::GetClassData() const { return &_class_data_; }


void HeaderStorageBucket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeaderStorageBucket*>(&to_msg);
  auto& from = static_cast<const HeaderStorageBucket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.HeaderStorageBucket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  if (from._internal_has_buckethashfunction()) {
    _this->_internal_set_buckethashfunction(from._internal_buckethashfunction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeaderStorageBucket::CopyFrom(const HeaderStorageBucket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.HeaderStorageBucket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderStorageBucket::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.headers_))
    return false;
  return true;
}

void HeaderStorageBucket::InternalSwap(HeaderStorageBucket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  swap(_impl_.buckethashfunction_, other->_impl_.buckethashfunction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeaderStorageBucket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[15]);
}

// ===================================================================

class HeaderStorage::_Internal {
 public:
  using HasBits = decltype(std::declval<HeaderStorage>()._impl_._has_bits_);
  static void set_has_buckethashfunction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void HeaderStorage::clear_buckets() {
  _impl_.buckets_.Clear();
}
HeaderStorage::HeaderStorage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.HeaderStorage)
}
HeaderStorage::HeaderStorage(const HeaderStorage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeaderStorage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buckets_){from._impl_.buckets_}
    , decltype(_impl_.buckethashfunction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.buckethashfunction_ = from._impl_.buckethashfunction_;
  // @@protoc_insertion_point(copy_constructor:TST.HeaderStorage)
}

inline void HeaderStorage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.buckets_){arena}
    , decltype(_impl_.buckethashfunction_){0u}
  };
}

HeaderStorage::~HeaderStorage() {
  // @@protoc_insertion_point(destructor:TST.HeaderStorage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeaderStorage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.buckets_.~RepeatedPtrField();
}

void HeaderStorage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeaderStorage::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.HeaderStorage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.buckets_.Clear();
  _impl_.buckethashfunction_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeaderStorage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 bucketHashFunction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_buckethashfunction(&has_bits);
          _impl_.buckethashfunction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference buckets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buckets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeaderStorage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.HeaderStorage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 bucketHashFunction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_buckethashfunction(), target);
  }

  // repeated .TSP.Reference buckets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buckets_size()); i < n; i++) {
    const auto& repfield = this->_internal_buckets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.HeaderStorage)
  return target;
}

size_t HeaderStorage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.HeaderStorage)
  size_t total_size = 0;

  // required uint32 bucketHashFunction = 1;
  if (_internal_has_buckethashfunction()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_buckethashfunction());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference buckets = 2;
  total_size += 1UL * this->_internal_buckets_size();
  for (const auto& msg : this->_impl_.buckets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeaderStorage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeaderStorage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeaderStorage::GetClassData() const { return &_class_data_; }


void HeaderStorage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeaderStorage*>(&to_msg);
  auto& from = static_cast<const HeaderStorage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.HeaderStorage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.buckets_.MergeFrom(from._impl_.buckets_);
  if (from._internal_has_buckethashfunction()) {
    _this->_internal_set_buckethashfunction(from._internal_buckethashfunction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeaderStorage::CopyFrom(const HeaderStorage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.HeaderStorage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderStorage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.buckets_))
    return false;
  return true;
}

void HeaderStorage::InternalSwap(HeaderStorage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.buckets_.InternalSwap(&other->_impl_.buckets_);
  swap(_impl_.buckethashfunction_, other->_impl_.buckethashfunction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HeaderStorage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[16]);
}

// ===================================================================

class DataStore::_Internal {
 public:
  using HasBits = decltype(std::declval<DataStore>()._impl_._has_bits_);
  static const ::TST::HeaderStorage& rowheaders(const DataStore* msg);
  static void set_has_rowheaders(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& columnheaders(const DataStore* msg);
  static void set_has_columnheaders(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TileStorage& tiles(const DataStore* msg);
  static void set_has_tiles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& stringtable(const DataStore* msg);
  static void set_has_stringtable(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& styletable(const DataStore* msg);
  static void set_has_styletable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& formulatable(const DataStore* msg);
  static void set_has_formulatable(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& formulaerrortable(const DataStore* msg);
  static void set_has_formulaerrortable(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Reference& formattable(const DataStore* msg);
  static void set_has_formattable(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& multiplechoicelistformattable(const DataStore* msg);
  static void set_has_multiplechoicelistformattable(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::Reference& merge_region_map(const DataStore* msg);
  static void set_has_merge_region_map(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSP::Reference& customformattable(const DataStore* msg);
  static void set_has_customformattable(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_nextrowstripid(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_nextcolumnstripid(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::TST::TableRBTree& rowtiletree(const DataStore* msg);
  static void set_has_rowtiletree(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::TableRBTree& columntiletree(const DataStore* msg);
  static void set_has_columntiletree(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_storage_version(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::TSP::Reference& richtextpayloadtable(const DataStore* msg);
  static void set_has_richtextpayloadtable(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSP::Reference& conditionalstyletable(const DataStore* msg);
  static void set_has_conditionalstyletable(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::TSP::Reference& commentstoragetable(const DataStore* msg);
  static void set_has_commentstoragetable(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000301ff) ^ 0x000301ff) != 0;
  }
};

const ::TST::HeaderStorage&
DataStore::_Internal::rowheaders(const DataStore* msg) {
  return *msg->_impl_.rowheaders_;
}
const ::TSP::Reference&
DataStore::_Internal::columnheaders(const DataStore* msg) {
  return *msg->_impl_.columnheaders_;
}
const ::TST::TileStorage&
DataStore::_Internal::tiles(const DataStore* msg) {
  return *msg->_impl_.tiles_;
}
const ::TSP::Reference&
DataStore::_Internal::stringtable(const DataStore* msg) {
  return *msg->_impl_.stringtable_;
}
const ::TSP::Reference&
DataStore::_Internal::styletable(const DataStore* msg) {
  return *msg->_impl_.styletable_;
}
const ::TSP::Reference&
DataStore::_Internal::formulatable(const DataStore* msg) {
  return *msg->_impl_.formulatable_;
}
const ::TSP::Reference&
DataStore::_Internal::formulaerrortable(const DataStore* msg) {
  return *msg->_impl_.formulaerrortable_;
}
const ::TSP::Reference&
DataStore::_Internal::formattable(const DataStore* msg) {
  return *msg->_impl_.formattable_;
}
const ::TSP::Reference&
DataStore::_Internal::multiplechoicelistformattable(const DataStore* msg) {
  return *msg->_impl_.multiplechoicelistformattable_;
}
const ::TSP::Reference&
DataStore::_Internal::merge_region_map(const DataStore* msg) {
  return *msg->_impl_.merge_region_map_;
}
const ::TSP::Reference&
DataStore::_Internal::customformattable(const DataStore* msg) {
  return *msg->_impl_.customformattable_;
}
const ::TST::TableRBTree&
DataStore::_Internal::rowtiletree(const DataStore* msg) {
  return *msg->_impl_.rowtiletree_;
}
const ::TST::TableRBTree&
DataStore::_Internal::columntiletree(const DataStore* msg) {
  return *msg->_impl_.columntiletree_;
}
const ::TSP::Reference&
DataStore::_Internal::richtextpayloadtable(const DataStore* msg) {
  return *msg->_impl_.richtextpayloadtable_;
}
const ::TSP::Reference&
DataStore::_Internal::conditionalstyletable(const DataStore* msg) {
  return *msg->_impl_.conditionalstyletable_;
}
const ::TSP::Reference&
DataStore::_Internal::commentstoragetable(const DataStore* msg) {
  return *msg->_impl_.commentstoragetable_;
}
void DataStore::clear_columnheaders() {
  if (_impl_.columnheaders_ != nullptr) _impl_.columnheaders_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DataStore::clear_stringtable() {
  if (_impl_.stringtable_ != nullptr) _impl_.stringtable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void DataStore::clear_styletable() {
  if (_impl_.styletable_ != nullptr) _impl_.styletable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void DataStore::clear_formulatable() {
  if (_impl_.formulatable_ != nullptr) _impl_.formulatable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void DataStore::clear_formulaerrortable() {
  if (_impl_.formulaerrortable_ != nullptr) _impl_.formulaerrortable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void DataStore::clear_formattable() {
  if (_impl_.formattable_ != nullptr) _impl_.formattable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void DataStore::clear_multiplechoicelistformattable() {
  if (_impl_.multiplechoicelistformattable_ != nullptr) _impl_.multiplechoicelistformattable_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void DataStore::clear_merge_region_map() {
  if (_impl_.merge_region_map_ != nullptr) _impl_.merge_region_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void DataStore::clear_customformattable() {
  if (_impl_.customformattable_ != nullptr) _impl_.customformattable_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void DataStore::clear_richtextpayloadtable() {
  if (_impl_.richtextpayloadtable_ != nullptr) _impl_.richtextpayloadtable_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void DataStore::clear_conditionalstyletable() {
  if (_impl_.conditionalstyletable_ != nullptr) _impl_.conditionalstyletable_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
void DataStore::clear_commentstoragetable() {
  if (_impl_.commentstoragetable_ != nullptr) _impl_.commentstoragetable_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
DataStore::DataStore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DataStore)
}
DataStore::DataStore(const DataStore& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DataStore* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowheaders_){nullptr}
    , decltype(_impl_.columnheaders_){nullptr}
    , decltype(_impl_.tiles_){nullptr}
    , decltype(_impl_.stringtable_){nullptr}
    , decltype(_impl_.styletable_){nullptr}
    , decltype(_impl_.formulatable_){nullptr}
    , decltype(_impl_.rowtiletree_){nullptr}
    , decltype(_impl_.columntiletree_){nullptr}
    , decltype(_impl_.formattable_){nullptr}
    , decltype(_impl_.formulaerrortable_){nullptr}
    , decltype(_impl_.merge_region_map_){nullptr}
    , decltype(_impl_.customformattable_){nullptr}
    , decltype(_impl_.multiplechoicelistformattable_){nullptr}
    , decltype(_impl_.richtextpayloadtable_){nullptr}
    , decltype(_impl_.conditionalstyletable_){nullptr}
    , decltype(_impl_.commentstoragetable_){nullptr}
    , decltype(_impl_.nextrowstripid_){}
    , decltype(_impl_.nextcolumnstripid_){}
    , decltype(_impl_.storage_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rowheaders()) {
    _this->_impl_.rowheaders_ = new ::TST::HeaderStorage(*from._impl_.rowheaders_);
  }
  if (from._internal_has_columnheaders()) {
    _this->_impl_.columnheaders_ = new ::TSP::Reference(*from._impl_.columnheaders_);
  }
  if (from._internal_has_tiles()) {
    _this->_impl_.tiles_ = new ::TST::TileStorage(*from._impl_.tiles_);
  }
  if (from._internal_has_stringtable()) {
    _this->_impl_.stringtable_ = new ::TSP::Reference(*from._impl_.stringtable_);
  }
  if (from._internal_has_styletable()) {
    _this->_impl_.styletable_ = new ::TSP::Reference(*from._impl_.styletable_);
  }
  if (from._internal_has_formulatable()) {
    _this->_impl_.formulatable_ = new ::TSP::Reference(*from._impl_.formulatable_);
  }
  if (from._internal_has_rowtiletree()) {
    _this->_impl_.rowtiletree_ = new ::TST::TableRBTree(*from._impl_.rowtiletree_);
  }
  if (from._internal_has_columntiletree()) {
    _this->_impl_.columntiletree_ = new ::TST::TableRBTree(*from._impl_.columntiletree_);
  }
  if (from._internal_has_formattable()) {
    _this->_impl_.formattable_ = new ::TSP::Reference(*from._impl_.formattable_);
  }
  if (from._internal_has_formulaerrortable()) {
    _this->_impl_.formulaerrortable_ = new ::TSP::Reference(*from._impl_.formulaerrortable_);
  }
  if (from._internal_has_merge_region_map()) {
    _this->_impl_.merge_region_map_ = new ::TSP::Reference(*from._impl_.merge_region_map_);
  }
  if (from._internal_has_customformattable()) {
    _this->_impl_.customformattable_ = new ::TSP::Reference(*from._impl_.customformattable_);
  }
  if (from._internal_has_multiplechoicelistformattable()) {
    _this->_impl_.multiplechoicelistformattable_ = new ::TSP::Reference(*from._impl_.multiplechoicelistformattable_);
  }
  if (from._internal_has_richtextpayloadtable()) {
    _this->_impl_.richtextpayloadtable_ = new ::TSP::Reference(*from._impl_.richtextpayloadtable_);
  }
  if (from._internal_has_conditionalstyletable()) {
    _this->_impl_.conditionalstyletable_ = new ::TSP::Reference(*from._impl_.conditionalstyletable_);
  }
  if (from._internal_has_commentstoragetable()) {
    _this->_impl_.commentstoragetable_ = new ::TSP::Reference(*from._impl_.commentstoragetable_);
  }
  ::memcpy(&_impl_.nextrowstripid_, &from._impl_.nextrowstripid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storage_version_) -
    reinterpret_cast<char*>(&_impl_.nextrowstripid_)) + sizeof(_impl_.storage_version_));
  // @@protoc_insertion_point(copy_constructor:TST.DataStore)
}

inline void DataStore::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowheaders_){nullptr}
    , decltype(_impl_.columnheaders_){nullptr}
    , decltype(_impl_.tiles_){nullptr}
    , decltype(_impl_.stringtable_){nullptr}
    , decltype(_impl_.styletable_){nullptr}
    , decltype(_impl_.formulatable_){nullptr}
    , decltype(_impl_.rowtiletree_){nullptr}
    , decltype(_impl_.columntiletree_){nullptr}
    , decltype(_impl_.formattable_){nullptr}
    , decltype(_impl_.formulaerrortable_){nullptr}
    , decltype(_impl_.merge_region_map_){nullptr}
    , decltype(_impl_.customformattable_){nullptr}
    , decltype(_impl_.multiplechoicelistformattable_){nullptr}
    , decltype(_impl_.richtextpayloadtable_){nullptr}
    , decltype(_impl_.conditionalstyletable_){nullptr}
    , decltype(_impl_.commentstoragetable_){nullptr}
    , decltype(_impl_.nextrowstripid_){0u}
    , decltype(_impl_.nextcolumnstripid_){0u}
    , decltype(_impl_.storage_version_){0u}
  };
}

DataStore::~DataStore() {
  // @@protoc_insertion_point(destructor:TST.DataStore)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataStore::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rowheaders_;
  if (this != internal_default_instance()) delete _impl_.columnheaders_;
  if (this != internal_default_instance()) delete _impl_.tiles_;
  if (this != internal_default_instance()) delete _impl_.stringtable_;
  if (this != internal_default_instance()) delete _impl_.styletable_;
  if (this != internal_default_instance()) delete _impl_.formulatable_;
  if (this != internal_default_instance()) delete _impl_.rowtiletree_;
  if (this != internal_default_instance()) delete _impl_.columntiletree_;
  if (this != internal_default_instance()) delete _impl_.formattable_;
  if (this != internal_default_instance()) delete _impl_.formulaerrortable_;
  if (this != internal_default_instance()) delete _impl_.merge_region_map_;
  if (this != internal_default_instance()) delete _impl_.customformattable_;
  if (this != internal_default_instance()) delete _impl_.multiplechoicelistformattable_;
  if (this != internal_default_instance()) delete _impl_.richtextpayloadtable_;
  if (this != internal_default_instance()) delete _impl_.conditionalstyletable_;
  if (this != internal_default_instance()) delete _impl_.commentstoragetable_;
}

void DataStore::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DataStore::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DataStore)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rowheaders_ != nullptr);
      _impl_.rowheaders_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.columnheaders_ != nullptr);
      _impl_.columnheaders_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.tiles_ != nullptr);
      _impl_.tiles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.stringtable_ != nullptr);
      _impl_.stringtable_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.styletable_ != nullptr);
      _impl_.styletable_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.formulatable_ != nullptr);
      _impl_.formulatable_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.rowtiletree_ != nullptr);
      _impl_.rowtiletree_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.columntiletree_ != nullptr);
      _impl_.columntiletree_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.formattable_ != nullptr);
      _impl_.formattable_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.formulaerrortable_ != nullptr);
      _impl_.formulaerrortable_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.merge_region_map_ != nullptr);
      _impl_.merge_region_map_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.customformattable_ != nullptr);
      _impl_.customformattable_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.multiplechoicelistformattable_ != nullptr);
      _impl_.multiplechoicelistformattable_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.richtextpayloadtable_ != nullptr);
      _impl_.richtextpayloadtable_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.conditionalstyletable_ != nullptr);
      _impl_.conditionalstyletable_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.commentstoragetable_ != nullptr);
      _impl_.commentstoragetable_->Clear();
    }
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.nextrowstripid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.storage_version_) -
        reinterpret_cast<char*>(&_impl_.nextrowstripid_)) + sizeof(_impl_.storage_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DataStore::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.HeaderStorage rowHeaders = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rowheaders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference columnHeaders = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_columnheaders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TileStorage tiles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tiles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference stringTable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringtable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference styleTable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_styletable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference formulaTable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_formulatable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 nextRowStripID = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_nextrowstripid(&has_bits);
          _impl_.nextrowstripid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 nextColumnStripID = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_nextcolumnstripid(&has_bits);
          _impl_.nextcolumnstripid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableRBTree rowTileTree = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rowtiletree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableRBTree columnTileTree = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_columntiletree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference formatTable = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_formattable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formulaErrorTable = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_formulaerrortable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference merge_region_map = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_merge_region_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 storage_version = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_storage_version(&has_bits);
          _impl_.storage_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference customFormatTable = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_customformattable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference multipleChoiceListFormatTable = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiplechoicelistformattable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference richTextPayloadTable = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_richtextpayloadtable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference conditionalstyletable = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditionalstyletable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference commentStorageTable = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_commentstoragetable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataStore::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DataStore)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.HeaderStorage rowHeaders = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rowheaders(this),
        _Internal::rowheaders(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference columnHeaders = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::columnheaders(this),
        _Internal::columnheaders(this).GetCachedSize(), target, stream);
  }

  // required .TST.TileStorage tiles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tiles(this),
        _Internal::tiles(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference stringTable = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stringtable(this),
        _Internal::stringtable(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference styleTable = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::styletable(this),
        _Internal::styletable(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference formulaTable = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::formulatable(this),
        _Internal::formulatable(this).GetCachedSize(), target, stream);
  }

  // required uint32 nextRowStripID = 7;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_nextrowstripid(), target);
  }

  // required uint32 nextColumnStripID = 8;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_nextcolumnstripid(), target);
  }

  // required .TST.TableRBTree rowTileTree = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::rowtiletree(this),
        _Internal::rowtiletree(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableRBTree columnTileTree = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::columntiletree(this),
        _Internal::columntiletree(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference formatTable = 11;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::formattable(this),
        _Internal::formattable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference formulaErrorTable = 12;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::formulaerrortable(this),
        _Internal::formulaerrortable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference merge_region_map = 13;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::merge_region_map(this),
        _Internal::merge_region_map(this).GetCachedSize(), target, stream);
  }

  // optional uint32 storage_version = 14;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_storage_version(), target);
  }

  // optional .TSP.Reference customFormatTable = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::customformattable(this),
        _Internal::customformattable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference multipleChoiceListFormatTable = 16;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::multiplechoicelistformattable(this),
        _Internal::multiplechoicelistformattable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference richTextPayloadTable = 17;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::richtextpayloadtable(this),
        _Internal::richtextpayloadtable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference conditionalstyletable = 18;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::conditionalstyletable(this),
        _Internal::conditionalstyletable(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference commentStorageTable = 19;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::commentstoragetable(this),
        _Internal::commentstoragetable(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DataStore)
  return target;
}

size_t DataStore::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.DataStore)
  size_t total_size = 0;

  if (_internal_has_rowheaders()) {
    // required .TST.HeaderStorage rowHeaders = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rowheaders_);
  }

  if (_internal_has_columnheaders()) {
    // required .TSP.Reference columnHeaders = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.columnheaders_);
  }

  if (_internal_has_tiles()) {
    // required .TST.TileStorage tiles = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tiles_);
  }

  if (_internal_has_stringtable()) {
    // required .TSP.Reference stringTable = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stringtable_);
  }

  if (_internal_has_styletable()) {
    // required .TSP.Reference styleTable = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.styletable_);
  }

  if (_internal_has_formulatable()) {
    // required .TSP.Reference formulaTable = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formulatable_);
  }

  if (_internal_has_rowtiletree()) {
    // required .TST.TableRBTree rowTileTree = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rowtiletree_);
  }

  if (_internal_has_columntiletree()) {
    // required .TST.TableRBTree columnTileTree = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.columntiletree_);
  }

  if (_internal_has_formattable()) {
    // required .TSP.Reference formatTable = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formattable_);
  }

  if (_internal_has_nextrowstripid()) {
    // required uint32 nextRowStripID = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextrowstripid());
  }

  if (_internal_has_nextcolumnstripid()) {
    // required uint32 nextColumnStripID = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextcolumnstripid());
  }

  return total_size;
}
size_t DataStore::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DataStore)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000301ff) ^ 0x000301ff) == 0) {  // All required fields are present.
    // required .TST.HeaderStorage rowHeaders = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rowheaders_);

    // required .TSP.Reference columnHeaders = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.columnheaders_);

    // required .TST.TileStorage tiles = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tiles_);

    // required .TSP.Reference stringTable = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.stringtable_);

    // required .TSP.Reference styleTable = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.styletable_);

    // required .TSP.Reference formulaTable = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formulatable_);

    // required .TST.TableRBTree rowTileTree = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rowtiletree_);

    // required .TST.TableRBTree columnTileTree = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.columntiletree_);

    // required .TSP.Reference formatTable = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formattable_);

    // required uint32 nextRowStripID = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextrowstripid());

    // required uint32 nextColumnStripID = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_nextcolumnstripid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000fe00u) {
    // optional .TSP.Reference formulaErrorTable = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formulaerrortable_);
    }

    // optional .TSP.Reference merge_region_map = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.merge_region_map_);
    }

    // optional .TSP.Reference customFormatTable = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.customformattable_);
    }

    // optional .TSP.Reference multipleChoiceListFormatTable = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multiplechoicelistformattable_);
    }

    // optional .TSP.Reference richTextPayloadTable = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.richtextpayloadtable_);
    }

    // optional .TSP.Reference conditionalstyletable = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditionalstyletable_);
    }

    // optional .TSP.Reference commentStorageTable = 19;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.commentstoragetable_);
    }

  }
  // optional uint32 storage_version = 14;
  if (cached_has_bits & 0x00040000u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_storage_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DataStore::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DataStore::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DataStore::GetClassData() const { return &_class_data_; }


void DataStore::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DataStore*>(&to_msg);
  auto& from = static_cast<const DataStore&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DataStore)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rowheaders()->::TST::HeaderStorage::MergeFrom(
          from._internal_rowheaders());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_columnheaders()->::TSP::Reference::MergeFrom(
          from._internal_columnheaders());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_tiles()->::TST::TileStorage::MergeFrom(
          from._internal_tiles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_stringtable()->::TSP::Reference::MergeFrom(
          from._internal_stringtable());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_styletable()->::TSP::Reference::MergeFrom(
          from._internal_styletable());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_formulatable()->::TSP::Reference::MergeFrom(
          from._internal_formulatable());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_rowtiletree()->::TST::TableRBTree::MergeFrom(
          from._internal_rowtiletree());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_columntiletree()->::TST::TableRBTree::MergeFrom(
          from._internal_columntiletree());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_formattable()->::TSP::Reference::MergeFrom(
          from._internal_formattable());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_formulaerrortable()->::TSP::Reference::MergeFrom(
          from._internal_formulaerrortable());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_merge_region_map()->::TSP::Reference::MergeFrom(
          from._internal_merge_region_map());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_customformattable()->::TSP::Reference::MergeFrom(
          from._internal_customformattable());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_multiplechoicelistformattable()->::TSP::Reference::MergeFrom(
          from._internal_multiplechoicelistformattable());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_richtextpayloadtable()->::TSP::Reference::MergeFrom(
          from._internal_richtextpayloadtable());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_conditionalstyletable()->::TSP::Reference::MergeFrom(
          from._internal_conditionalstyletable());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_commentstoragetable()->::TSP::Reference::MergeFrom(
          from._internal_commentstoragetable());
    }
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.nextrowstripid_ = from._impl_.nextrowstripid_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.nextcolumnstripid_ = from._impl_.nextcolumnstripid_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.storage_version_ = from._impl_.storage_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DataStore::CopyFrom(const DataStore& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DataStore)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataStore::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_rowheaders()) {
    if (!_impl_.rowheaders_->IsInitialized()) return false;
  }
  if (_internal_has_columnheaders()) {
    if (!_impl_.columnheaders_->IsInitialized()) return false;
  }
  if (_internal_has_tiles()) {
    if (!_impl_.tiles_->IsInitialized()) return false;
  }
  if (_internal_has_stringtable()) {
    if (!_impl_.stringtable_->IsInitialized()) return false;
  }
  if (_internal_has_styletable()) {
    if (!_impl_.styletable_->IsInitialized()) return false;
  }
  if (_internal_has_formulatable()) {
    if (!_impl_.formulatable_->IsInitialized()) return false;
  }
  if (_internal_has_rowtiletree()) {
    if (!_impl_.rowtiletree_->IsInitialized()) return false;
  }
  if (_internal_has_columntiletree()) {
    if (!_impl_.columntiletree_->IsInitialized()) return false;
  }
  if (_internal_has_formattable()) {
    if (!_impl_.formattable_->IsInitialized()) return false;
  }
  if (_internal_has_formulaerrortable()) {
    if (!_impl_.formulaerrortable_->IsInitialized()) return false;
  }
  if (_internal_has_merge_region_map()) {
    if (!_impl_.merge_region_map_->IsInitialized()) return false;
  }
  if (_internal_has_customformattable()) {
    if (!_impl_.customformattable_->IsInitialized()) return false;
  }
  if (_internal_has_multiplechoicelistformattable()) {
    if (!_impl_.multiplechoicelistformattable_->IsInitialized()) return false;
  }
  if (_internal_has_richtextpayloadtable()) {
    if (!_impl_.richtextpayloadtable_->IsInitialized()) return false;
  }
  if (_internal_has_conditionalstyletable()) {
    if (!_impl_.conditionalstyletable_->IsInitialized()) return false;
  }
  if (_internal_has_commentstoragetable()) {
    if (!_impl_.commentstoragetable_->IsInitialized()) return false;
  }
  return true;
}

void DataStore::InternalSwap(DataStore* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataStore, _impl_.storage_version_)
      + sizeof(DataStore::_impl_.storage_version_)
      - PROTOBUF_FIELD_OFFSET(DataStore, _impl_.rowheaders_)>(
          reinterpret_cast<char*>(&_impl_.rowheaders_),
          reinterpret_cast<char*>(&other->_impl_.rowheaders_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DataStore::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[17]);
}

// ===================================================================

class TableInfoArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableInfoArchive>()._impl_._has_bits_);
  static const ::TSD::DrawableArchive& super(const TableInfoArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& tablemodel(const TableInfoArchive* msg);
  static void set_has_tablemodel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& editingstate(const TableInfoArchive* msg);
  static void set_has_editingstate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSD::DrawableArchive&
TableInfoArchive::_Internal::super(const TableInfoArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TableInfoArchive::_Internal::tablemodel(const TableInfoArchive* msg) {
  return *msg->_impl_.tablemodel_;
}
const ::TSP::Reference&
TableInfoArchive::_Internal::editingstate(const TableInfoArchive* msg) {
  return *msg->_impl_.editingstate_;
}
void TableInfoArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TableInfoArchive::clear_tablemodel() {
  if (_impl_.tablemodel_ != nullptr) _impl_.tablemodel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableInfoArchive::clear_editingstate() {
  if (_impl_.editingstate_ != nullptr) _impl_.editingstate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TableInfoArchive::TableInfoArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableInfoArchive)
}
TableInfoArchive::TableInfoArchive(const TableInfoArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableInfoArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tablemodel_){nullptr}
    , decltype(_impl_.editingstate_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::DrawableArchive(*from._impl_.super_);
  }
  if (from._internal_has_tablemodel()) {
    _this->_impl_.tablemodel_ = new ::TSP::Reference(*from._impl_.tablemodel_);
  }
  if (from._internal_has_editingstate()) {
    _this->_impl_.editingstate_ = new ::TSP::Reference(*from._impl_.editingstate_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.TableInfoArchive)
}

inline void TableInfoArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tablemodel_){nullptr}
    , decltype(_impl_.editingstate_){nullptr}
  };
}

TableInfoArchive::~TableInfoArchive() {
  // @@protoc_insertion_point(destructor:TST.TableInfoArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableInfoArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.tablemodel_;
  if (this != internal_default_instance()) delete _impl_.editingstate_;
}

void TableInfoArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableInfoArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableInfoArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tablemodel_ != nullptr);
      _impl_.tablemodel_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.editingstate_ != nullptr);
      _impl_.editingstate_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableInfoArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.DrawableArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference tableModel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tablemodel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference editingState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_editingstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableInfoArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableInfoArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.DrawableArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference tableModel = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tablemodel(this),
        _Internal::tablemodel(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference editingState = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::editingstate(this),
        _Internal::editingstate(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableInfoArchive)
  return target;
}

size_t TableInfoArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableInfoArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSD.DrawableArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_tablemodel()) {
    // required .TSP.Reference tableModel = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tablemodel_);
  }

  return total_size;
}
size_t TableInfoArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableInfoArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSD.DrawableArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference tableModel = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tablemodel_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference editingState = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editingstate_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableInfoArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableInfoArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableInfoArchive::GetClassData() const { return &_class_data_; }


void TableInfoArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableInfoArchive*>(&to_msg);
  auto& from = static_cast<const TableInfoArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableInfoArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::DrawableArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tablemodel()->::TSP::Reference::MergeFrom(
          from._internal_tablemodel());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_editingstate()->::TSP::Reference::MergeFrom(
          from._internal_editingstate());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableInfoArchive::CopyFrom(const TableInfoArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableInfoArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableInfoArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_tablemodel()) {
    if (!_impl_.tablemodel_->IsInitialized()) return false;
  }
  if (_internal_has_editingstate()) {
    if (!_impl_.editingstate_->IsInitialized()) return false;
  }
  return true;
}

void TableInfoArchive::InternalSwap(TableInfoArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableInfoArchive, _impl_.editingstate_)
      + sizeof(TableInfoArchive::_impl_.editingstate_)
      - PROTOBUF_FIELD_OFFSET(TableInfoArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableInfoArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[18]);
}

// ===================================================================

class EditingStateArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EditingStateArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& editingstorage(const EditingStateArchive* msg);
  static void set_has_editingstorage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::Cell& editingcell(const EditingStateArchive* msg);
  static void set_has_editingcell(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::SelectionArchive& selection(const EditingStateArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellID& lasteditingcellid(const EditingStateArchive* msg);
  static void set_has_lasteditingcellid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellID& editingcellid(const EditingStateArchive* msg);
  static void set_has_editingcellid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& deprecated_setup_textundoredotransaction(const EditingStateArchive* msg);
  static void set_has_deprecated_setup_textundoredotransaction(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cell_was_edited_in_current_session(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TSP::Reference&
EditingStateArchive::_Internal::editingstorage(const EditingStateArchive* msg) {
  return *msg->_impl_.editingstorage_;
}
const ::TST::Cell&
EditingStateArchive::_Internal::editingcell(const EditingStateArchive* msg) {
  return *msg->_impl_.editingcell_;
}
const ::TST::SelectionArchive&
EditingStateArchive::_Internal::selection(const EditingStateArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellID&
EditingStateArchive::_Internal::lasteditingcellid(const EditingStateArchive* msg) {
  return *msg->_impl_.lasteditingcellid_;
}
const ::TST::CellID&
EditingStateArchive::_Internal::editingcellid(const EditingStateArchive* msg) {
  return *msg->_impl_.editingcellid_;
}
const ::TSWP::UndoTransaction&
EditingStateArchive::_Internal::deprecated_setup_textundoredotransaction(const EditingStateArchive* msg) {
  return *msg->_impl_.deprecated_setup_textundoredotransaction_;
}
void EditingStateArchive::clear_editingstorage() {
  if (_impl_.editingstorage_ != nullptr) _impl_.editingstorage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void EditingStateArchive::clear_deprecated_setup_textundoredotransaction() {
  if (_impl_.deprecated_setup_textundoredotransaction_ != nullptr) _impl_.deprecated_setup_textundoredotransaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
EditingStateArchive::EditingStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.EditingStateArchive)
}
EditingStateArchive::EditingStateArchive(const EditingStateArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EditingStateArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.editingstorage_){nullptr}
    , decltype(_impl_.editingcell_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.lasteditingcellid_){nullptr}
    , decltype(_impl_.editingcellid_){nullptr}
    , decltype(_impl_.deprecated_setup_textundoredotransaction_){nullptr}
    , decltype(_impl_.cell_was_edited_in_current_session_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_editingstorage()) {
    _this->_impl_.editingstorage_ = new ::TSP::Reference(*from._impl_.editingstorage_);
  }
  if (from._internal_has_editingcell()) {
    _this->_impl_.editingcell_ = new ::TST::Cell(*from._impl_.editingcell_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_lasteditingcellid()) {
    _this->_impl_.lasteditingcellid_ = new ::TST::CellID(*from._impl_.lasteditingcellid_);
  }
  if (from._internal_has_editingcellid()) {
    _this->_impl_.editingcellid_ = new ::TST::CellID(*from._impl_.editingcellid_);
  }
  if (from._internal_has_deprecated_setup_textundoredotransaction()) {
    _this->_impl_.deprecated_setup_textundoredotransaction_ = new ::TSWP::UndoTransaction(*from._impl_.deprecated_setup_textundoredotransaction_);
  }
  _this->_impl_.cell_was_edited_in_current_session_ = from._impl_.cell_was_edited_in_current_session_;
  // @@protoc_insertion_point(copy_constructor:TST.EditingStateArchive)
}

inline void EditingStateArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.editingstorage_){nullptr}
    , decltype(_impl_.editingcell_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.lasteditingcellid_){nullptr}
    , decltype(_impl_.editingcellid_){nullptr}
    , decltype(_impl_.deprecated_setup_textundoredotransaction_){nullptr}
    , decltype(_impl_.cell_was_edited_in_current_session_){false}
  };
}

EditingStateArchive::~EditingStateArchive() {
  // @@protoc_insertion_point(destructor:TST.EditingStateArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditingStateArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.editingstorage_;
  if (this != internal_default_instance()) delete _impl_.editingcell_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.lasteditingcellid_;
  if (this != internal_default_instance()) delete _impl_.editingcellid_;
  if (this != internal_default_instance()) delete _impl_.deprecated_setup_textundoredotransaction_;
}

void EditingStateArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EditingStateArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.EditingStateArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.editingstorage_ != nullptr);
      _impl_.editingstorage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.editingcell_ != nullptr);
      _impl_.editingcell_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.lasteditingcellid_ != nullptr);
      _impl_.lasteditingcellid_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.editingcellid_ != nullptr);
      _impl_.editingcellid_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.deprecated_setup_textundoredotransaction_ != nullptr);
      _impl_.deprecated_setup_textundoredotransaction_->Clear();
    }
  }
  _impl_.cell_was_edited_in_current_session_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EditingStateArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference editingStorage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_editingstorage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell editingCell = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_editingcell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID lasteditingcellid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lasteditingcellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID editingcellid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_editingcellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_deprecated_setup_textundoredotransaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cell_was_edited_in_current_session = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_cell_was_edited_in_current_session(&has_bits);
          _impl_.cell_was_edited_in_current_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditingStateArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.EditingStateArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference editingStorage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::editingstorage(this),
        _Internal::editingstorage(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell editingCell = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::editingcell(this),
        _Internal::editingcell(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive selection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellID lasteditingcellid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lasteditingcellid(this),
        _Internal::lasteditingcellid(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellID editingcellid = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::editingcellid(this),
        _Internal::editingcellid(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::deprecated_setup_textundoredotransaction(this),
        _Internal::deprecated_setup_textundoredotransaction(this).GetCachedSize(), target, stream);
  }

  // optional bool cell_was_edited_in_current_session = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_cell_was_edited_in_current_session(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.EditingStateArchive)
  return target;
}

size_t EditingStateArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.EditingStateArchive)
  size_t total_size = 0;

  // required .TST.Cell editingCell = 2;
  if (_internal_has_editingcell()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editingcell_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference editingStorage = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editingstorage_);
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional .TST.SelectionArchive selection = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selection_);
    }

    // optional .TST.CellID lasteditingcellid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lasteditingcellid_);
    }

    // optional .TST.CellID editingcellid = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.editingcellid_);
    }

    // optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.deprecated_setup_textundoredotransaction_);
    }

    // optional bool cell_was_edited_in_current_session = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EditingStateArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EditingStateArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EditingStateArchive::GetClassData() const { return &_class_data_; }


void EditingStateArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EditingStateArchive*>(&to_msg);
  auto& from = static_cast<const EditingStateArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.EditingStateArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_editingstorage()->::TSP::Reference::MergeFrom(
          from._internal_editingstorage());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_editingcell()->::TST::Cell::MergeFrom(
          from._internal_editingcell());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_lasteditingcellid()->::TST::CellID::MergeFrom(
          from._internal_lasteditingcellid());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_editingcellid()->::TST::CellID::MergeFrom(
          from._internal_editingcellid());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_deprecated_setup_textundoredotransaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_deprecated_setup_textundoredotransaction());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cell_was_edited_in_current_session_ = from._impl_.cell_was_edited_in_current_session_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EditingStateArchive::CopyFrom(const EditingStateArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.EditingStateArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditingStateArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_editingstorage()) {
    if (!_impl_.editingstorage_->IsInitialized()) return false;
  }
  if (_internal_has_editingcell()) {
    if (!_impl_.editingcell_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_lasteditingcellid()) {
    if (!_impl_.lasteditingcellid_->IsInitialized()) return false;
  }
  if (_internal_has_editingcellid()) {
    if (!_impl_.editingcellid_->IsInitialized()) return false;
  }
  if (_internal_has_deprecated_setup_textundoredotransaction()) {
    if (!_impl_.deprecated_setup_textundoredotransaction_->IsInitialized()) return false;
  }
  return true;
}

void EditingStateArchive::InternalSwap(EditingStateArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EditingStateArchive, _impl_.cell_was_edited_in_current_session_)
      + sizeof(EditingStateArchive::_impl_.cell_was_edited_in_current_session_)
      - PROTOBUF_FIELD_OFFSET(EditingStateArchive, _impl_.editingstorage_)>(
          reinterpret_cast<char*>(&_impl_.editingstorage_),
          reinterpret_cast<char*>(&other->_impl_.editingstorage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EditingStateArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[19]);
}

// ===================================================================

class WPTableInfoArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<WPTableInfoArchive>()._impl_._has_bits_);
  static const ::TST::TableInfoArchive& super(const WPTableInfoArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const WPTableInfoArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableInfoArchive&
WPTableInfoArchive::_Internal::super(const WPTableInfoArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
WPTableInfoArchive::_Internal::storage(const WPTableInfoArchive* msg) {
  return *msg->_impl_.storage_;
}
void WPTableInfoArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
WPTableInfoArchive::WPTableInfoArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.WPTableInfoArchive)
}
WPTableInfoArchive::WPTableInfoArchive(const WPTableInfoArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WPTableInfoArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableInfoArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.WPTableInfoArchive)
}

inline void WPTableInfoArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
  };
}

WPTableInfoArchive::~WPTableInfoArchive() {
  // @@protoc_insertion_point(destructor:TST.WPTableInfoArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WPTableInfoArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
}

void WPTableInfoArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WPTableInfoArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.WPTableInfoArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WPTableInfoArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableInfoArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WPTableInfoArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.WPTableInfoArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableInfoArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.WPTableInfoArchive)
  return target;
}

size_t WPTableInfoArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.WPTableInfoArchive)
  size_t total_size = 0;

  // required .TST.TableInfoArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference storage = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WPTableInfoArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WPTableInfoArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WPTableInfoArchive::GetClassData() const { return &_class_data_; }


void WPTableInfoArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WPTableInfoArchive*>(&to_msg);
  auto& from = static_cast<const WPTableInfoArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.WPTableInfoArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableInfoArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WPTableInfoArchive::CopyFrom(const WPTableInfoArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.WPTableInfoArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WPTableInfoArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  return true;
}

void WPTableInfoArchive::InternalSwap(WPTableInfoArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WPTableInfoArchive, _impl_.storage_)
      + sizeof(WPTableInfoArchive::_impl_.storage_)
      - PROTOBUF_FIELD_OFFSET(WPTableInfoArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WPTableInfoArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[20]);
}

// ===================================================================

class TableStyleNetworkArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableStyleNetworkArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& table_style(const TableStyleNetworkArchive* msg);
  static void set_has_table_style(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& body_text_style(const TableStyleNetworkArchive* msg);
  static void set_has_body_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& header_row_text_style(const TableStyleNetworkArchive* msg);
  static void set_has_header_row_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& header_column_text_style(const TableStyleNetworkArchive* msg);
  static void set_has_header_column_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& footer_row_text_style(const TableStyleNetworkArchive* msg);
  static void set_has_footer_row_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& body_cell_style(const TableStyleNetworkArchive* msg);
  static void set_has_body_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& header_row_style(const TableStyleNetworkArchive* msg);
  static void set_has_header_row_style(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& header_column_style(const TableStyleNetworkArchive* msg);
  static void set_has_header_column_style(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& footer_row_style(const TableStyleNetworkArchive* msg);
  static void set_has_footer_row_style(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& table_name_style(const TableStyleNetworkArchive* msg);
  static void set_has_table_name_style(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Reference& table_name_shape_style(const TableStyleNetworkArchive* msg);
  static void set_has_table_name_shape_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000001ff) ^ 0x000001ff) != 0;
  }
};

const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::table_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.table_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::body_text_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.body_text_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::header_row_text_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.header_row_text_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::header_column_text_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.header_column_text_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::footer_row_text_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.footer_row_text_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::body_cell_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.body_cell_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::header_row_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.header_row_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::header_column_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.header_column_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::footer_row_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.footer_row_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::table_name_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.table_name_style_;
}
const ::TSP::Reference&
TableStyleNetworkArchive::_Internal::table_name_shape_style(const TableStyleNetworkArchive* msg) {
  return *msg->_impl_.table_name_shape_style_;
}
void TableStyleNetworkArchive::clear_table_style() {
  if (_impl_.table_style_ != nullptr) _impl_.table_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void TableStyleNetworkArchive::clear_body_text_style() {
  if (_impl_.body_text_style_ != nullptr) _impl_.body_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TableStyleNetworkArchive::clear_header_row_text_style() {
  if (_impl_.header_row_text_style_ != nullptr) _impl_.header_row_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableStyleNetworkArchive::clear_header_column_text_style() {
  if (_impl_.header_column_text_style_ != nullptr) _impl_.header_column_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TableStyleNetworkArchive::clear_footer_row_text_style() {
  if (_impl_.footer_row_text_style_ != nullptr) _impl_.footer_row_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TableStyleNetworkArchive::clear_body_cell_style() {
  if (_impl_.body_cell_style_ != nullptr) _impl_.body_cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void TableStyleNetworkArchive::clear_header_row_style() {
  if (_impl_.header_row_style_ != nullptr) _impl_.header_row_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void TableStyleNetworkArchive::clear_header_column_style() {
  if (_impl_.header_column_style_ != nullptr) _impl_.header_column_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void TableStyleNetworkArchive::clear_footer_row_style() {
  if (_impl_.footer_row_style_ != nullptr) _impl_.footer_row_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void TableStyleNetworkArchive::clear_table_name_style() {
  if (_impl_.table_name_style_ != nullptr) _impl_.table_name_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void TableStyleNetworkArchive::clear_table_name_shape_style() {
  if (_impl_.table_name_shape_style_ != nullptr) _impl_.table_name_shape_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
TableStyleNetworkArchive::TableStyleNetworkArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableStyleNetworkArchive)
}
TableStyleNetworkArchive::TableStyleNetworkArchive(const TableStyleNetworkArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableStyleNetworkArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_text_style_){nullptr}
    , decltype(_impl_.header_row_text_style_){nullptr}
    , decltype(_impl_.header_column_text_style_){nullptr}
    , decltype(_impl_.footer_row_text_style_){nullptr}
    , decltype(_impl_.body_cell_style_){nullptr}
    , decltype(_impl_.header_row_style_){nullptr}
    , decltype(_impl_.header_column_style_){nullptr}
    , decltype(_impl_.footer_row_style_){nullptr}
    , decltype(_impl_.table_style_){nullptr}
    , decltype(_impl_.table_name_style_){nullptr}
    , decltype(_impl_.table_name_shape_style_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body_text_style()) {
    _this->_impl_.body_text_style_ = new ::TSP::Reference(*from._impl_.body_text_style_);
  }
  if (from._internal_has_header_row_text_style()) {
    _this->_impl_.header_row_text_style_ = new ::TSP::Reference(*from._impl_.header_row_text_style_);
  }
  if (from._internal_has_header_column_text_style()) {
    _this->_impl_.header_column_text_style_ = new ::TSP::Reference(*from._impl_.header_column_text_style_);
  }
  if (from._internal_has_footer_row_text_style()) {
    _this->_impl_.footer_row_text_style_ = new ::TSP::Reference(*from._impl_.footer_row_text_style_);
  }
  if (from._internal_has_body_cell_style()) {
    _this->_impl_.body_cell_style_ = new ::TSP::Reference(*from._impl_.body_cell_style_);
  }
  if (from._internal_has_header_row_style()) {
    _this->_impl_.header_row_style_ = new ::TSP::Reference(*from._impl_.header_row_style_);
  }
  if (from._internal_has_header_column_style()) {
    _this->_impl_.header_column_style_ = new ::TSP::Reference(*from._impl_.header_column_style_);
  }
  if (from._internal_has_footer_row_style()) {
    _this->_impl_.footer_row_style_ = new ::TSP::Reference(*from._impl_.footer_row_style_);
  }
  if (from._internal_has_table_style()) {
    _this->_impl_.table_style_ = new ::TSP::Reference(*from._impl_.table_style_);
  }
  if (from._internal_has_table_name_style()) {
    _this->_impl_.table_name_style_ = new ::TSP::Reference(*from._impl_.table_name_style_);
  }
  if (from._internal_has_table_name_shape_style()) {
    _this->_impl_.table_name_shape_style_ = new ::TSP::Reference(*from._impl_.table_name_shape_style_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TST.TableStyleNetworkArchive)
}

inline void TableStyleNetworkArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.body_text_style_){nullptr}
    , decltype(_impl_.header_row_text_style_){nullptr}
    , decltype(_impl_.header_column_text_style_){nullptr}
    , decltype(_impl_.footer_row_text_style_){nullptr}
    , decltype(_impl_.body_cell_style_){nullptr}
    , decltype(_impl_.header_row_style_){nullptr}
    , decltype(_impl_.header_column_style_){nullptr}
    , decltype(_impl_.footer_row_style_){nullptr}
    , decltype(_impl_.table_style_){nullptr}
    , decltype(_impl_.table_name_style_){nullptr}
    , decltype(_impl_.table_name_shape_style_){nullptr}
    , decltype(_impl_.preset_index_){0u}
  };
}

TableStyleNetworkArchive::~TableStyleNetworkArchive() {
  // @@protoc_insertion_point(destructor:TST.TableStyleNetworkArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableStyleNetworkArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.body_text_style_;
  if (this != internal_default_instance()) delete _impl_.header_row_text_style_;
  if (this != internal_default_instance()) delete _impl_.header_column_text_style_;
  if (this != internal_default_instance()) delete _impl_.footer_row_text_style_;
  if (this != internal_default_instance()) delete _impl_.body_cell_style_;
  if (this != internal_default_instance()) delete _impl_.header_row_style_;
  if (this != internal_default_instance()) delete _impl_.header_column_style_;
  if (this != internal_default_instance()) delete _impl_.footer_row_style_;
  if (this != internal_default_instance()) delete _impl_.table_style_;
  if (this != internal_default_instance()) delete _impl_.table_name_style_;
  if (this != internal_default_instance()) delete _impl_.table_name_shape_style_;
}

void TableStyleNetworkArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableStyleNetworkArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableStyleNetworkArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.body_text_style_ != nullptr);
      _impl_.body_text_style_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.header_row_text_style_ != nullptr);
      _impl_.header_row_text_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.header_column_text_style_ != nullptr);
      _impl_.header_column_text_style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.footer_row_text_style_ != nullptr);
      _impl_.footer_row_text_style_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.body_cell_style_ != nullptr);
      _impl_.body_cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.header_row_style_ != nullptr);
      _impl_.header_row_style_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.header_column_style_ != nullptr);
      _impl_.header_column_style_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.footer_row_style_ != nullptr);
      _impl_.footer_row_style_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.table_style_ != nullptr);
      _impl_.table_style_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.table_name_style_ != nullptr);
      _impl_.table_name_style_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.table_name_shape_style_ != nullptr);
      _impl_.table_name_shape_style_->Clear();
    }
  }
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableStyleNetworkArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference body_text_style = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_row_text_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_row_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_column_text_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_column_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference footer_row_text_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer_row_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference body_cell_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_row_style = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_row_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_column_style = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_column_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference footer_row_style = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer_row_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference table_style = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_name_style = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_name_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_name_shape_style = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_name_shape_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preset_index = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableStyleNetworkArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableStyleNetworkArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference body_text_style = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::body_text_style(this),
        _Internal::body_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_row_text_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::header_row_text_style(this),
        _Internal::header_row_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_column_text_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::header_column_text_style(this),
        _Internal::header_column_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference footer_row_text_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::footer_row_text_style(this),
        _Internal::footer_row_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference body_cell_style = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::body_cell_style(this),
        _Internal::body_cell_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_row_style = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::header_row_style(this),
        _Internal::header_row_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_column_style = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::header_column_style(this),
        _Internal::header_column_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference footer_row_style = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::footer_row_style(this),
        _Internal::footer_row_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference table_style = 9;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::table_style(this),
        _Internal::table_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_name_style = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::table_name_style(this),
        _Internal::table_name_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_name_shape_style = 11;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::table_name_shape_style(this),
        _Internal::table_name_shape_style(this).GetCachedSize(), target, stream);
  }

  // optional uint32 preset_index = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableStyleNetworkArchive)
  return target;
}

size_t TableStyleNetworkArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableStyleNetworkArchive)
  size_t total_size = 0;

  if (_internal_has_body_text_style()) {
    // required .TSP.Reference body_text_style = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_text_style_);
  }

  if (_internal_has_header_row_text_style()) {
    // required .TSP.Reference header_row_text_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_text_style_);
  }

  if (_internal_has_header_column_text_style()) {
    // required .TSP.Reference header_column_text_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_text_style_);
  }

  if (_internal_has_footer_row_text_style()) {
    // required .TSP.Reference footer_row_text_style = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_text_style_);
  }

  if (_internal_has_body_cell_style()) {
    // required .TSP.Reference body_cell_style = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_cell_style_);
  }

  if (_internal_has_header_row_style()) {
    // required .TSP.Reference header_row_style = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_style_);
  }

  if (_internal_has_header_column_style()) {
    // required .TSP.Reference header_column_style = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_style_);
  }

  if (_internal_has_footer_row_style()) {
    // required .TSP.Reference footer_row_style = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_style_);
  }

  if (_internal_has_table_style()) {
    // required .TSP.Reference table_style = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_style_);
  }

  return total_size;
}
size_t TableStyleNetworkArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableStyleNetworkArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000001ff) ^ 0x000001ff) == 0) {  // All required fields are present.
    // required .TSP.Reference body_text_style = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_text_style_);

    // required .TSP.Reference header_row_text_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_text_style_);

    // required .TSP.Reference header_column_text_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_text_style_);

    // required .TSP.Reference footer_row_text_style = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_text_style_);

    // required .TSP.Reference body_cell_style = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_cell_style_);

    // required .TSP.Reference header_row_style = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_style_);

    // required .TSP.Reference header_column_style = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_style_);

    // required .TSP.Reference footer_row_style = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_style_);

    // required .TSP.Reference table_style = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_style_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000e00u) {
    // optional .TSP.Reference table_name_style = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_name_style_);
    }

    // optional .TSP.Reference table_name_shape_style = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_name_shape_style_);
    }

    // optional uint32 preset_index = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableStyleNetworkArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableStyleNetworkArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableStyleNetworkArchive::GetClassData() const { return &_class_data_; }


void TableStyleNetworkArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableStyleNetworkArchive*>(&to_msg);
  auto& from = static_cast<const TableStyleNetworkArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableStyleNetworkArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_body_text_style()->::TSP::Reference::MergeFrom(
          from._internal_body_text_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_header_row_text_style()->::TSP::Reference::MergeFrom(
          from._internal_header_row_text_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_header_column_text_style()->::TSP::Reference::MergeFrom(
          from._internal_header_column_text_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_footer_row_text_style()->::TSP::Reference::MergeFrom(
          from._internal_footer_row_text_style());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_body_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_body_cell_style());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_header_row_style()->::TSP::Reference::MergeFrom(
          from._internal_header_row_style());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_header_column_style()->::TSP::Reference::MergeFrom(
          from._internal_header_column_style());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_footer_row_style()->::TSP::Reference::MergeFrom(
          from._internal_footer_row_style());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_table_style()->::TSP::Reference::MergeFrom(
          from._internal_table_style());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_table_name_style()->::TSP::Reference::MergeFrom(
          from._internal_table_name_style());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_table_name_shape_style()->::TSP::Reference::MergeFrom(
          from._internal_table_name_shape_style());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableStyleNetworkArchive::CopyFrom(const TableStyleNetworkArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableStyleNetworkArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableStyleNetworkArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_body_text_style()) {
    if (!_impl_.body_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_row_text_style()) {
    if (!_impl_.header_row_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_column_text_style()) {
    if (!_impl_.header_column_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_footer_row_text_style()) {
    if (!_impl_.footer_row_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_body_cell_style()) {
    if (!_impl_.body_cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_row_style()) {
    if (!_impl_.header_row_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_column_style()) {
    if (!_impl_.header_column_style_->IsInitialized()) return false;
  }
  if (_internal_has_footer_row_style()) {
    if (!_impl_.footer_row_style_->IsInitialized()) return false;
  }
  if (_internal_has_table_style()) {
    if (!_impl_.table_style_->IsInitialized()) return false;
  }
  if (_internal_has_table_name_style()) {
    if (!_impl_.table_name_style_->IsInitialized()) return false;
  }
  if (_internal_has_table_name_shape_style()) {
    if (!_impl_.table_name_shape_style_->IsInitialized()) return false;
  }
  return true;
}

void TableStyleNetworkArchive::InternalSwap(TableStyleNetworkArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableStyleNetworkArchive, _impl_.preset_index_)
      + sizeof(TableStyleNetworkArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(TableStyleNetworkArchive, _impl_.body_text_style_)>(
          reinterpret_cast<char*>(&_impl_.body_text_style_),
          reinterpret_cast<char*>(&other->_impl_.body_text_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableStyleNetworkArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[21]);
}

// ===================================================================

class TableModelArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableModelArchive>()._impl_._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_from_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& table_style(const TableModelArchive* msg);
  static void set_has_table_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& body_text_style(const TableModelArchive* msg);
  static void set_has_body_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Reference& header_row_text_style(const TableModelArchive* msg);
  static void set_has_header_row_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::Reference& header_column_text_style(const TableModelArchive* msg);
  static void set_has_header_column_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::TSP::Reference& footer_row_text_style(const TableModelArchive* msg);
  static void set_has_footer_row_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::TSP::Reference& body_cell_style(const TableModelArchive* msg);
  static void set_has_body_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& header_row_style(const TableModelArchive* msg);
  static void set_has_header_row_style(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& header_column_style(const TableModelArchive* msg);
  static void set_has_header_column_style(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& footer_row_style(const TableModelArchive* msg);
  static void set_has_footer_row_style(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::Reference& table_name_style(const TableModelArchive* msg);
  static void set_has_table_name_style(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::TSP::Reference& table_name_shape_style(const TableModelArchive* msg);
  static void set_has_table_name_shape_style(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::TST::DataStore& data_store(const TableModelArchive* msg);
  static void set_has_data_store(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& provider(const TableModelArchive* msg);
  static void set_has_provider(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_number_of_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_table_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_table_name_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_table_name_height(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_table_name_border_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_number_of_header_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_number_of_header_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_number_of_footer_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_header_rows_frozen(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_header_columns_frozen(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_number_of_hidden_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_number_of_hidden_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_number_of_user_hidden_rows(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_number_of_user_hidden_columns(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_number_of_filtered_rows(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_default_row_height(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_default_column_width(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static const ::TST::CellID& origin_offset(const TableModelArchive* msg);
  static void set_has_origin_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_repeating_header_rows_enabled(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_repeating_header_columns_enabled(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_style_apply_clears_all(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static const ::TSP::Reference& hidden_state_formula_owner_for_columns(const TableModelArchive* msg);
  static void set_has_hidden_state_formula_owner_for_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::TSP::Reference& hidden_state_formula_owner_for_rows(const TableModelArchive* msg);
  static void set_has_hidden_state_formula_owner_for_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::TSP::Reference& filter_set(const TableModelArchive* msg);
  static void set_has_filter_set(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::TSCE::CFUUIDArchive& conditional_style_formula_owner_id(const TableModelArchive* msg);
  static void set_has_conditional_style_formula_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return (((has_bits[0] & 0x18607bdb) ^ 0x18607bdb)
       | ((has_bits[1] & 0x00000004) ^ 0x00000004)) != 0;
  }
};

const ::TSP::Reference&
TableModelArchive::_Internal::table_style(const TableModelArchive* msg) {
  return *msg->_impl_.table_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::body_text_style(const TableModelArchive* msg) {
  return *msg->_impl_.body_text_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::header_row_text_style(const TableModelArchive* msg) {
  return *msg->_impl_.header_row_text_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::header_column_text_style(const TableModelArchive* msg) {
  return *msg->_impl_.header_column_text_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::footer_row_text_style(const TableModelArchive* msg) {
  return *msg->_impl_.footer_row_text_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::body_cell_style(const TableModelArchive* msg) {
  return *msg->_impl_.body_cell_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::header_row_style(const TableModelArchive* msg) {
  return *msg->_impl_.header_row_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::header_column_style(const TableModelArchive* msg) {
  return *msg->_impl_.header_column_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::footer_row_style(const TableModelArchive* msg) {
  return *msg->_impl_.footer_row_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::table_name_style(const TableModelArchive* msg) {
  return *msg->_impl_.table_name_style_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::table_name_shape_style(const TableModelArchive* msg) {
  return *msg->_impl_.table_name_shape_style_;
}
const ::TST::DataStore&
TableModelArchive::_Internal::data_store(const TableModelArchive* msg) {
  return *msg->_impl_.data_store_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::provider(const TableModelArchive* msg) {
  return *msg->_impl_.provider_;
}
const ::TST::CellID&
TableModelArchive::_Internal::origin_offset(const TableModelArchive* msg) {
  return *msg->_impl_.origin_offset_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::hidden_state_formula_owner_for_columns(const TableModelArchive* msg) {
  return *msg->_impl_.hidden_state_formula_owner_for_columns_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::hidden_state_formula_owner_for_rows(const TableModelArchive* msg) {
  return *msg->_impl_.hidden_state_formula_owner_for_rows_;
}
const ::TSP::Reference&
TableModelArchive::_Internal::filter_set(const TableModelArchive* msg) {
  return *msg->_impl_.filter_set_;
}
const ::TSCE::CFUUIDArchive&
TableModelArchive::_Internal::conditional_style_formula_owner_id(const TableModelArchive* msg) {
  return *msg->_impl_.conditional_style_formula_owner_id_;
}
void TableModelArchive::clear_table_style() {
  if (_impl_.table_style_ != nullptr) _impl_.table_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TableModelArchive::clear_body_text_style() {
  if (_impl_.body_text_style_ != nullptr) _impl_.body_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void TableModelArchive::clear_header_row_text_style() {
  if (_impl_.header_row_text_style_ != nullptr) _impl_.header_row_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void TableModelArchive::clear_header_column_text_style() {
  if (_impl_.header_column_text_style_ != nullptr) _impl_.header_column_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void TableModelArchive::clear_footer_row_text_style() {
  if (_impl_.footer_row_text_style_ != nullptr) _impl_.footer_row_text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
void TableModelArchive::clear_body_cell_style() {
  if (_impl_.body_cell_style_ != nullptr) _impl_.body_cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void TableModelArchive::clear_header_row_style() {
  if (_impl_.header_row_style_ != nullptr) _impl_.header_row_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void TableModelArchive::clear_header_column_style() {
  if (_impl_.header_column_style_ != nullptr) _impl_.header_column_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void TableModelArchive::clear_footer_row_style() {
  if (_impl_.footer_row_style_ != nullptr) _impl_.footer_row_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void TableModelArchive::clear_table_name_style() {
  if (_impl_.table_name_style_ != nullptr) _impl_.table_name_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
void TableModelArchive::clear_table_name_shape_style() {
  if (_impl_.table_name_shape_style_ != nullptr) _impl_.table_name_shape_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
void TableModelArchive::clear_provider() {
  if (_impl_.provider_ != nullptr) _impl_.provider_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void TableModelArchive::clear_hidden_state_formula_owner_for_columns() {
  if (_impl_.hidden_state_formula_owner_for_columns_ != nullptr) _impl_.hidden_state_formula_owner_for_columns_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
void TableModelArchive::clear_hidden_state_formula_owner_for_rows() {
  if (_impl_.hidden_state_formula_owner_for_rows_ != nullptr) _impl_.hidden_state_formula_owner_for_rows_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
void TableModelArchive::clear_filter_set() {
  if (_impl_.filter_set_ != nullptr) _impl_.filter_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
void TableModelArchive::clear_conditional_style_formula_owner_id() {
  if (_impl_.conditional_style_formula_owner_id_ != nullptr) _impl_.conditional_style_formula_owner_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
TableModelArchive::TableModelArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableModelArchive)
}
TableModelArchive::TableModelArchive(const TableModelArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableModelArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.table_id_){}
    , decltype(_impl_.table_name_){}
    , decltype(_impl_.from_table_id_){}
    , decltype(_impl_.table_style_){nullptr}
    , decltype(_impl_.data_store_){nullptr}
    , decltype(_impl_.provider_){nullptr}
    , decltype(_impl_.body_cell_style_){nullptr}
    , decltype(_impl_.header_row_style_){nullptr}
    , decltype(_impl_.header_column_style_){nullptr}
    , decltype(_impl_.footer_row_style_){nullptr}
    , decltype(_impl_.origin_offset_){nullptr}
    , decltype(_impl_.body_text_style_){nullptr}
    , decltype(_impl_.header_row_text_style_){nullptr}
    , decltype(_impl_.header_column_text_style_){nullptr}
    , decltype(_impl_.footer_row_text_style_){nullptr}
    , decltype(_impl_.table_name_style_){nullptr}
    , decltype(_impl_.hidden_state_formula_owner_for_columns_){nullptr}
    , decltype(_impl_.hidden_state_formula_owner_for_rows_){nullptr}
    , decltype(_impl_.table_name_shape_style_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.conditional_style_formula_owner_id_){nullptr}
    , decltype(_impl_.number_of_rows_){}
    , decltype(_impl_.number_of_columns_){}
    , decltype(_impl_.number_of_header_rows_){}
    , decltype(_impl_.number_of_header_columns_){}
    , decltype(_impl_.number_of_footer_rows_){}
    , decltype(_impl_.number_of_hidden_rows_){}
    , decltype(_impl_.default_row_height_){}
    , decltype(_impl_.default_column_width_){}
    , decltype(_impl_.number_of_hidden_columns_){}
    , decltype(_impl_.table_name_enabled_){}
    , decltype(_impl_.table_name_border_enabled_){}
    , decltype(_impl_.header_rows_frozen_){}
    , decltype(_impl_.header_columns_frozen_){}
    , decltype(_impl_.preset_index_){}
    , decltype(_impl_.repeating_header_rows_enabled_){}
    , decltype(_impl_.repeating_header_columns_enabled_){}
    , decltype(_impl_.style_apply_clears_all_){}
    , decltype(_impl_.table_name_height_){}
    , decltype(_impl_.number_of_filtered_rows_){}
    , decltype(_impl_.number_of_user_hidden_rows_){}
    , decltype(_impl_.number_of_user_hidden_columns_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.table_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_table_id()) {
    _this->_impl_.table_id_.Set(from._internal_table_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_table_name()) {
    _this->_impl_.table_name_.Set(from._internal_table_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.from_table_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_table_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_from_table_id()) {
    _this->_impl_.from_table_id_.Set(from._internal_from_table_id(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_table_style()) {
    _this->_impl_.table_style_ = new ::TSP::Reference(*from._impl_.table_style_);
  }
  if (from._internal_has_data_store()) {
    _this->_impl_.data_store_ = new ::TST::DataStore(*from._impl_.data_store_);
  }
  if (from._internal_has_provider()) {
    _this->_impl_.provider_ = new ::TSP::Reference(*from._impl_.provider_);
  }
  if (from._internal_has_body_cell_style()) {
    _this->_impl_.body_cell_style_ = new ::TSP::Reference(*from._impl_.body_cell_style_);
  }
  if (from._internal_has_header_row_style()) {
    _this->_impl_.header_row_style_ = new ::TSP::Reference(*from._impl_.header_row_style_);
  }
  if (from._internal_has_header_column_style()) {
    _this->_impl_.header_column_style_ = new ::TSP::Reference(*from._impl_.header_column_style_);
  }
  if (from._internal_has_footer_row_style()) {
    _this->_impl_.footer_row_style_ = new ::TSP::Reference(*from._impl_.footer_row_style_);
  }
  if (from._internal_has_origin_offset()) {
    _this->_impl_.origin_offset_ = new ::TST::CellID(*from._impl_.origin_offset_);
  }
  if (from._internal_has_body_text_style()) {
    _this->_impl_.body_text_style_ = new ::TSP::Reference(*from._impl_.body_text_style_);
  }
  if (from._internal_has_header_row_text_style()) {
    _this->_impl_.header_row_text_style_ = new ::TSP::Reference(*from._impl_.header_row_text_style_);
  }
  if (from._internal_has_header_column_text_style()) {
    _this->_impl_.header_column_text_style_ = new ::TSP::Reference(*from._impl_.header_column_text_style_);
  }
  if (from._internal_has_footer_row_text_style()) {
    _this->_impl_.footer_row_text_style_ = new ::TSP::Reference(*from._impl_.footer_row_text_style_);
  }
  if (from._internal_has_table_name_style()) {
    _this->_impl_.table_name_style_ = new ::TSP::Reference(*from._impl_.table_name_style_);
  }
  if (from._internal_has_hidden_state_formula_owner_for_columns()) {
    _this->_impl_.hidden_state_formula_owner_for_columns_ = new ::TSP::Reference(*from._impl_.hidden_state_formula_owner_for_columns_);
  }
  if (from._internal_has_hidden_state_formula_owner_for_rows()) {
    _this->_impl_.hidden_state_formula_owner_for_rows_ = new ::TSP::Reference(*from._impl_.hidden_state_formula_owner_for_rows_);
  }
  if (from._internal_has_table_name_shape_style()) {
    _this->_impl_.table_name_shape_style_ = new ::TSP::Reference(*from._impl_.table_name_shape_style_);
  }
  if (from._internal_has_filter_set()) {
    _this->_impl_.filter_set_ = new ::TSP::Reference(*from._impl_.filter_set_);
  }
  if (from._internal_has_conditional_style_formula_owner_id()) {
    _this->_impl_.conditional_style_formula_owner_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.conditional_style_formula_owner_id_);
  }
  ::memcpy(&_impl_.number_of_rows_, &from._impl_.number_of_rows_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_user_hidden_columns_) -
    reinterpret_cast<char*>(&_impl_.number_of_rows_)) + sizeof(_impl_.number_of_user_hidden_columns_));
  // @@protoc_insertion_point(copy_constructor:TST.TableModelArchive)
}

inline void TableModelArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.table_id_){}
    , decltype(_impl_.table_name_){}
    , decltype(_impl_.from_table_id_){}
    , decltype(_impl_.table_style_){nullptr}
    , decltype(_impl_.data_store_){nullptr}
    , decltype(_impl_.provider_){nullptr}
    , decltype(_impl_.body_cell_style_){nullptr}
    , decltype(_impl_.header_row_style_){nullptr}
    , decltype(_impl_.header_column_style_){nullptr}
    , decltype(_impl_.footer_row_style_){nullptr}
    , decltype(_impl_.origin_offset_){nullptr}
    , decltype(_impl_.body_text_style_){nullptr}
    , decltype(_impl_.header_row_text_style_){nullptr}
    , decltype(_impl_.header_column_text_style_){nullptr}
    , decltype(_impl_.footer_row_text_style_){nullptr}
    , decltype(_impl_.table_name_style_){nullptr}
    , decltype(_impl_.hidden_state_formula_owner_for_columns_){nullptr}
    , decltype(_impl_.hidden_state_formula_owner_for_rows_){nullptr}
    , decltype(_impl_.table_name_shape_style_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.conditional_style_formula_owner_id_){nullptr}
    , decltype(_impl_.number_of_rows_){0u}
    , decltype(_impl_.number_of_columns_){0u}
    , decltype(_impl_.number_of_header_rows_){0u}
    , decltype(_impl_.number_of_header_columns_){0u}
    , decltype(_impl_.number_of_footer_rows_){0u}
    , decltype(_impl_.number_of_hidden_rows_){0u}
    , decltype(_impl_.default_row_height_){0}
    , decltype(_impl_.default_column_width_){0}
    , decltype(_impl_.number_of_hidden_columns_){0u}
    , decltype(_impl_.table_name_enabled_){false}
    , decltype(_impl_.table_name_border_enabled_){false}
    , decltype(_impl_.header_rows_frozen_){false}
    , decltype(_impl_.header_columns_frozen_){false}
    , decltype(_impl_.preset_index_){0u}
    , decltype(_impl_.repeating_header_rows_enabled_){false}
    , decltype(_impl_.repeating_header_columns_enabled_){false}
    , decltype(_impl_.style_apply_clears_all_){false}
    , decltype(_impl_.table_name_height_){0}
    , decltype(_impl_.number_of_filtered_rows_){0u}
    , decltype(_impl_.number_of_user_hidden_rows_){0u}
    , decltype(_impl_.number_of_user_hidden_columns_){0u}
  };
  _impl_.table_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.from_table_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_table_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableModelArchive::~TableModelArchive() {
  // @@protoc_insertion_point(destructor:TST.TableModelArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableModelArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.table_id_.Destroy();
  _impl_.table_name_.Destroy();
  _impl_.from_table_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.table_style_;
  if (this != internal_default_instance()) delete _impl_.data_store_;
  if (this != internal_default_instance()) delete _impl_.provider_;
  if (this != internal_default_instance()) delete _impl_.body_cell_style_;
  if (this != internal_default_instance()) delete _impl_.header_row_style_;
  if (this != internal_default_instance()) delete _impl_.header_column_style_;
  if (this != internal_default_instance()) delete _impl_.footer_row_style_;
  if (this != internal_default_instance()) delete _impl_.origin_offset_;
  if (this != internal_default_instance()) delete _impl_.body_text_style_;
  if (this != internal_default_instance()) delete _impl_.header_row_text_style_;
  if (this != internal_default_instance()) delete _impl_.header_column_text_style_;
  if (this != internal_default_instance()) delete _impl_.footer_row_text_style_;
  if (this != internal_default_instance()) delete _impl_.table_name_style_;
  if (this != internal_default_instance()) delete _impl_.hidden_state_formula_owner_for_columns_;
  if (this != internal_default_instance()) delete _impl_.hidden_state_formula_owner_for_rows_;
  if (this != internal_default_instance()) delete _impl_.table_name_shape_style_;
  if (this != internal_default_instance()) delete _impl_.filter_set_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_formula_owner_id_;
}

void TableModelArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableModelArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableModelArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.table_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.table_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.from_table_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.table_style_ != nullptr);
      _impl_.table_style_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.data_store_ != nullptr);
      _impl_.data_store_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.provider_ != nullptr);
      _impl_.provider_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.body_cell_style_ != nullptr);
      _impl_.body_cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.header_row_style_ != nullptr);
      _impl_.header_row_style_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.header_column_style_ != nullptr);
      _impl_.header_column_style_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.footer_row_style_ != nullptr);
      _impl_.footer_row_style_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.origin_offset_ != nullptr);
      _impl_.origin_offset_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.body_text_style_ != nullptr);
      _impl_.body_text_style_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.header_row_text_style_ != nullptr);
      _impl_.header_row_text_style_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.header_column_text_style_ != nullptr);
      _impl_.header_column_text_style_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.footer_row_text_style_ != nullptr);
      _impl_.footer_row_text_style_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.table_name_style_ != nullptr);
      _impl_.table_name_style_->Clear();
    }
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.hidden_state_formula_owner_for_columns_ != nullptr);
      _impl_.hidden_state_formula_owner_for_columns_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.hidden_state_formula_owner_for_rows_ != nullptr);
      _impl_.hidden_state_formula_owner_for_rows_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(_impl_.table_name_shape_style_ != nullptr);
      _impl_.table_name_shape_style_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(_impl_.filter_set_ != nullptr);
      _impl_.filter_set_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(_impl_.conditional_style_formula_owner_id_ != nullptr);
      _impl_.conditional_style_formula_owner_id_->Clear();
    }
  }
  if (cached_has_bits & 0x00e00000u) {
    ::memset(&_impl_.number_of_rows_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_header_rows_) -
        reinterpret_cast<char*>(&_impl_.number_of_rows_)) + sizeof(_impl_.number_of_header_rows_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.number_of_header_columns_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.table_name_border_enabled_) -
        reinterpret_cast<char*>(&_impl_.number_of_header_columns_)) + sizeof(_impl_.table_name_border_enabled_));
  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.header_rows_frozen_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_filtered_rows_) -
        reinterpret_cast<char*>(&_impl_.header_rows_frozen_)) + sizeof(_impl_.number_of_filtered_rows_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.number_of_user_hidden_rows_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_user_hidden_columns_) -
        reinterpret_cast<char*>(&_impl_.number_of_user_hidden_rows_)) + sizeof(_impl_.number_of_user_hidden_columns_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableModelArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_table_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.TableModelArchive.table_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference table_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.DataStore data_store = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_store(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference provider = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_provider(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_of_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_number_of_rows(&_impl_._has_bits_);
          _impl_.number_of_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_of_columns = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_number_of_columns(&_impl_._has_bits_);
          _impl_.number_of_columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string table_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_table_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.TableModelArchive.table_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_header_rows = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_number_of_header_rows(&_impl_._has_bits_);
          _impl_.number_of_header_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_header_columns = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_number_of_header_columns(&_impl_._has_bits_);
          _impl_.number_of_header_columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_footer_rows = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_number_of_footer_rows(&_impl_._has_bits_);
          _impl_.number_of_footer_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool header_rows_frozen = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_header_rows_frozen(&_impl_._has_bits_);
          _impl_.header_rows_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool header_columns_frozen = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_header_columns_frozen(&_impl_._has_bits_);
          _impl_.header_columns_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_hidden_rows = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_number_of_hidden_rows(&_impl_._has_bits_);
          _impl_.number_of_hidden_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_hidden_columns = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_number_of_hidden_columns(&_impl_._has_bits_);
          _impl_.number_of_hidden_columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double default_row_height = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _Internal::set_has_default_row_height(&_impl_._has_bits_);
          _impl_.default_row_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double default_column_width = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _Internal::set_has_default_column_width(&_impl_._has_bits_);
          _impl_.default_column_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference body_cell_style = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_row_style = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_row_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_column_style = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_column_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference footer_row_style = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer_row_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool table_name_enabled = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_table_name_enabled(&_impl_._has_bits_);
          _impl_.table_name_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID origin_offset = 23 [deprecated = true];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin_offset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference body_text_style = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_body_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_row_text_style = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_row_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference header_column_text_style = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_column_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference footer_row_text_style = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer_row_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 preset_index = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_preset_index(&_impl_._has_bits_);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool repeating_header_rows_enabled = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_repeating_header_rows_enabled(&_impl_._has_bits_);
          _impl_.repeating_header_rows_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_name_style = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_name_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool style_apply_clears_all = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_style_apply_clears_all(&_impl_._has_bits_);
          _impl_.style_apply_clears_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool repeating_header_columns_enabled = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_repeating_header_columns_enabled(&_impl_._has_bits_);
          _impl_.repeating_header_columns_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double table_name_height = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_table_name_height(&_impl_._has_bits_);
          _impl_.table_name_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hidden_state_formula_owner_for_columns(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hidden_state_formula_owner_for_rows(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_name_shape_style = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_name_shape_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool table_name_border_enabled = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_table_name_border_enabled(&_impl_._has_bits_);
          _impl_.table_name_border_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference filter_set = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style_formula_owner_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_filtered_rows = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_number_of_filtered_rows(&_impl_._has_bits_);
          _impl_.number_of_filtered_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_user_hidden_rows = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_number_of_user_hidden_rows(&_impl_._has_bits_);
          _impl_.number_of_user_hidden_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 number_of_user_hidden_columns = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_number_of_user_hidden_columns(&_impl_._has_bits_);
          _impl_.number_of_user_hidden_columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string from_table_id = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_from_table_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.TableModelArchive.from_table_id");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableModelArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableModelArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_table_id().data(), static_cast<int>(this->_internal_table_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.TableModelArchive.table_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_table_id(), target);
  }

  // required .TSP.Reference table_style = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::table_style(this),
        _Internal::table_style(this).GetCachedSize(), target, stream);
  }

  // required .TST.DataStore data_store = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::data_store(this),
        _Internal::data_store(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference provider = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::provider(this),
        _Internal::provider(this).GetCachedSize(), target, stream);
  }

  // required uint32 number_of_rows = 6;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_number_of_rows(), target);
  }

  // required uint32 number_of_columns = 7;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_number_of_columns(), target);
  }

  // required string table_name = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_table_name().data(), static_cast<int>(this->_internal_table_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.TableModelArchive.table_name");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_table_name(), target);
  }

  // optional uint32 number_of_header_rows = 9;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_number_of_header_rows(), target);
  }

  // optional uint32 number_of_header_columns = 10;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_number_of_header_columns(), target);
  }

  // optional uint32 number_of_footer_rows = 11;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_number_of_footer_rows(), target);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool header_rows_frozen = 12;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_header_rows_frozen(), target);
  }

  // optional bool header_columns_frozen = 13;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_header_columns_frozen(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 number_of_hidden_rows = 14;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_number_of_hidden_rows(), target);
  }

  // optional uint32 number_of_hidden_columns = 15;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_number_of_hidden_columns(), target);
  }

  // required double default_row_height = 16;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_default_row_height(), target);
  }

  // required double default_column_width = 17;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_default_column_width(), target);
  }

  // required .TSP.Reference body_cell_style = 18;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::body_cell_style(this),
        _Internal::body_cell_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_row_style = 19;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::header_row_style(this),
        _Internal::header_row_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_column_style = 20;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::header_column_style(this),
        _Internal::header_column_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference footer_row_style = 21;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::footer_row_style(this),
        _Internal::footer_row_style(this).GetCachedSize(), target, stream);
  }

  // optional bool table_name_enabled = 22;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_table_name_enabled(), target);
  }

  // optional .TST.CellID origin_offset = 23 [deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::origin_offset(this),
        _Internal::origin_offset(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference body_text_style = 24;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::body_text_style(this),
        _Internal::body_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_row_text_style = 25;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::header_row_text_style(this),
        _Internal::header_row_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference header_column_text_style = 26;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::header_column_text_style(this),
        _Internal::header_column_text_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference footer_row_text_style = 27;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::footer_row_text_style(this),
        _Internal::footer_row_text_style(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // required uint32 preset_index = 28;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_preset_index(), target);
  }

  // optional bool repeating_header_rows_enabled = 29;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_repeating_header_rows_enabled(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference table_name_style = 30;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::table_name_style(this),
        _Internal::table_name_style(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional bool style_apply_clears_all = 31;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_style_apply_clears_all(), target);
  }

  // optional bool repeating_header_columns_enabled = 32;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(32, this->_internal_repeating_header_columns_enabled(), target);
  }

  // optional double table_name_height = 33;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_table_name_height(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(34, _Internal::hidden_state_formula_owner_for_columns(this),
        _Internal::hidden_state_formula_owner_for_columns(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(35, _Internal::hidden_state_formula_owner_for_rows(this),
        _Internal::hidden_state_formula_owner_for_rows(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_name_shape_style = 36;
  if (cached_has_bits & 0x00040000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::table_name_shape_style(this),
        _Internal::table_name_shape_style(this).GetCachedSize(), target, stream);
  }

  // optional bool table_name_border_enabled = 37;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_table_name_border_enabled(), target);
  }

  // optional .TSP.Reference filter_set = 38;
  if (cached_has_bits & 0x00080000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::filter_set(this),
        _Internal::filter_set(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
  if (cached_has_bits & 0x00100000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::conditional_style_formula_owner_id(this),
        _Internal::conditional_style_formula_owner_id(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[1];
  // optional uint32 number_of_filtered_rows = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(40, this->_internal_number_of_filtered_rows(), target);
  }

  // optional uint32 number_of_user_hidden_rows = 41;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(41, this->_internal_number_of_user_hidden_rows(), target);
  }

  // optional uint32 number_of_user_hidden_columns = 42;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(42, this->_internal_number_of_user_hidden_columns(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string from_table_id = 43;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_from_table_id().data(), static_cast<int>(this->_internal_from_table_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.TableModelArchive.from_table_id");
    target = stream->WriteStringMaybeAliased(
        43, this->_internal_from_table_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableModelArchive)
  return target;
}

size_t TableModelArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableModelArchive)
  size_t total_size = 0;

  if (_internal_has_table_id()) {
    // required string table_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_table_id());
  }

  if (_internal_has_table_name()) {
    // required string table_name = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_table_name());
  }

  if (_internal_has_table_style()) {
    // required .TSP.Reference table_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_style_);
  }

  if (_internal_has_data_store()) {
    // required .TST.DataStore data_store = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_store_);
  }

  if (_internal_has_body_cell_style()) {
    // required .TSP.Reference body_cell_style = 18;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_cell_style_);
  }

  if (_internal_has_header_row_style()) {
    // required .TSP.Reference header_row_style = 19;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_style_);
  }

  if (_internal_has_header_column_style()) {
    // required .TSP.Reference header_column_style = 20;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_style_);
  }

  if (_internal_has_footer_row_style()) {
    // required .TSP.Reference footer_row_style = 21;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_style_);
  }

  if (_internal_has_body_text_style()) {
    // required .TSP.Reference body_text_style = 24;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_text_style_);
  }

  if (_internal_has_header_row_text_style()) {
    // required .TSP.Reference header_row_text_style = 25;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_text_style_);
  }

  if (_internal_has_header_column_text_style()) {
    // required .TSP.Reference header_column_text_style = 26;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_text_style_);
  }

  if (_internal_has_footer_row_text_style()) {
    // required .TSP.Reference footer_row_text_style = 27;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_text_style_);
  }

  if (_internal_has_number_of_rows()) {
    // required uint32 number_of_rows = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_rows());
  }

  if (_internal_has_number_of_columns()) {
    // required uint32 number_of_columns = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_columns());
  }

  if (_internal_has_default_row_height()) {
    // required double default_row_height = 16;
    total_size += 2 + 8;
  }

  if (_internal_has_default_column_width()) {
    // required double default_column_width = 17;
    total_size += 2 + 8;
  }

  if (_internal_has_preset_index()) {
    // required uint32 preset_index = 28;
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_preset_index());
  }

  return total_size;
}
size_t TableModelArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableModelArchive)
  size_t total_size = 0;

  if ((((_impl_._has_bits_[0] & 0x18607bdb) ^ 0x18607bdb)
       | ((_impl_._has_bits_[1] & 0x00000004) ^ 0x00000004)) == 0) {  // All required fields are present.
    // required string table_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_table_id());

    // required string table_name = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_table_name());

    // required .TSP.Reference table_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_style_);

    // required .TST.DataStore data_store = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_store_);

    // required .TSP.Reference body_cell_style = 18;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_cell_style_);

    // required .TSP.Reference header_row_style = 19;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_style_);

    // required .TSP.Reference header_column_style = 20;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_style_);

    // required .TSP.Reference footer_row_style = 21;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_style_);

    // required .TSP.Reference body_text_style = 24;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_text_style_);

    // required .TSP.Reference header_row_text_style = 25;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_row_text_style_);

    // required .TSP.Reference header_column_text_style = 26;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_column_text_style_);

    // required .TSP.Reference footer_row_text_style = 27;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.footer_row_text_style_);

    // required uint32 number_of_rows = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_rows());

    // required uint32 number_of_columns = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_columns());

    // required double default_row_height = 16;
    total_size += 2 + 8;

    // required double default_column_width = 17;
    total_size += 2 + 8;

    // required uint32 preset_index = 28;
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_preset_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string from_table_id = 43;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from_table_id());
  }

  // optional .TSP.Reference provider = 5;
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.provider_);
  }

  // optional .TST.CellID origin_offset = 23 [deprecated = true];
  if (cached_has_bits & 0x00000400u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.origin_offset_);
  }

  // optional .TSP.Reference table_name_style = 30;
  if (cached_has_bits & 0x00008000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_name_style_);
  }

  if (cached_has_bits & 0x001f0000u) {
    // optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hidden_state_formula_owner_for_columns_);
    }

    // optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hidden_state_formula_owner_for_rows_);
    }

    // optional .TSP.Reference table_name_shape_style = 36;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_name_shape_style_);
    }

    // optional .TSP.Reference filter_set = 38;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filter_set_);
    }

    // optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_formula_owner_id_);
    }

  }
  // optional uint32 number_of_header_rows = 9;
  if (cached_has_bits & 0x00800000u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_header_rows());
  }

  if (cached_has_bits & 0x07000000u) {
    // optional uint32 number_of_header_columns = 10;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_header_columns());
    }

    // optional uint32 number_of_footer_rows = 11;
    if (cached_has_bits & 0x02000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_footer_rows());
    }

    // optional uint32 number_of_hidden_rows = 14;
    if (cached_has_bits & 0x04000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_hidden_rows());
    }

  }
  if (cached_has_bits & 0xe0000000u) {
    // optional uint32 number_of_hidden_columns = 15;
    if (cached_has_bits & 0x20000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_hidden_columns());
    }

    // optional bool table_name_enabled = 22;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 1;
    }

    // optional bool table_name_border_enabled = 37;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _impl_._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    // optional bool header_rows_frozen = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool header_columns_frozen = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x000000f8u) {
    // optional bool repeating_header_rows_enabled = 29;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 1;
    }

    // optional bool repeating_header_columns_enabled = 32;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool style_apply_clears_all = 31;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

    // optional double table_name_height = 33;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 8;
    }

    // optional uint32 number_of_filtered_rows = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_number_of_filtered_rows());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 number_of_user_hidden_rows = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_number_of_user_hidden_rows());
    }

    // optional uint32 number_of_user_hidden_columns = 42;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_number_of_user_hidden_columns());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableModelArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableModelArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableModelArchive::GetClassData() const { return &_class_data_; }


void TableModelArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableModelArchive*>(&to_msg);
  auto& from = static_cast<const TableModelArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableModelArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_table_id(from._internal_table_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_table_name(from._internal_table_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_from_table_id(from._internal_from_table_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_table_style()->::TSP::Reference::MergeFrom(
          from._internal_table_style());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_data_store()->::TST::DataStore::MergeFrom(
          from._internal_data_store());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_provider()->::TSP::Reference::MergeFrom(
          from._internal_provider());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_body_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_body_cell_style());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_header_row_style()->::TSP::Reference::MergeFrom(
          from._internal_header_row_style());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_header_column_style()->::TSP::Reference::MergeFrom(
          from._internal_header_column_style());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_footer_row_style()->::TSP::Reference::MergeFrom(
          from._internal_footer_row_style());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_origin_offset()->::TST::CellID::MergeFrom(
          from._internal_origin_offset());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_body_text_style()->::TSP::Reference::MergeFrom(
          from._internal_body_text_style());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_header_row_text_style()->::TSP::Reference::MergeFrom(
          from._internal_header_row_text_style());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_header_column_text_style()->::TSP::Reference::MergeFrom(
          from._internal_header_column_text_style());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_footer_row_text_style()->::TSP::Reference::MergeFrom(
          from._internal_footer_row_text_style());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_table_name_style()->::TSP::Reference::MergeFrom(
          from._internal_table_name_style());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_hidden_state_formula_owner_for_columns()->::TSP::Reference::MergeFrom(
          from._internal_hidden_state_formula_owner_for_columns());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_hidden_state_formula_owner_for_rows()->::TSP::Reference::MergeFrom(
          from._internal_hidden_state_formula_owner_for_rows());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_internal_mutable_table_name_shape_style()->::TSP::Reference::MergeFrom(
          from._internal_table_name_shape_style());
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_internal_mutable_filter_set()->::TSP::Reference::MergeFrom(
          from._internal_filter_set());
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_internal_mutable_conditional_style_formula_owner_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_conditional_style_formula_owner_id());
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.number_of_rows_ = from._impl_.number_of_rows_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.number_of_columns_ = from._impl_.number_of_columns_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.number_of_header_rows_ = from._impl_.number_of_header_rows_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.number_of_header_columns_ = from._impl_.number_of_header_columns_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.number_of_footer_rows_ = from._impl_.number_of_footer_rows_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.number_of_hidden_rows_ = from._impl_.number_of_hidden_rows_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.default_row_height_ = from._impl_.default_row_height_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.default_column_width_ = from._impl_.default_column_width_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.number_of_hidden_columns_ = from._impl_.number_of_hidden_columns_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.table_name_enabled_ = from._impl_.table_name_enabled_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.table_name_border_enabled_ = from._impl_.table_name_border_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._impl_._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.header_rows_frozen_ = from._impl_.header_rows_frozen_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.header_columns_frozen_ = from._impl_.header_columns_frozen_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.repeating_header_rows_enabled_ = from._impl_.repeating_header_rows_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.repeating_header_columns_enabled_ = from._impl_.repeating_header_columns_enabled_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.style_apply_clears_all_ = from._impl_.style_apply_clears_all_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.table_name_height_ = from._impl_.table_name_height_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.number_of_filtered_rows_ = from._impl_.number_of_filtered_rows_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.number_of_user_hidden_rows_ = from._impl_.number_of_user_hidden_rows_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.number_of_user_hidden_columns_ = from._impl_.number_of_user_hidden_columns_;
    }
    _this->_impl_._has_bits_[1] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableModelArchive::CopyFrom(const TableModelArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableModelArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableModelArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_table_style()) {
    if (!_impl_.table_style_->IsInitialized()) return false;
  }
  if (_internal_has_data_store()) {
    if (!_impl_.data_store_->IsInitialized()) return false;
  }
  if (_internal_has_provider()) {
    if (!_impl_.provider_->IsInitialized()) return false;
  }
  if (_internal_has_body_cell_style()) {
    if (!_impl_.body_cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_row_style()) {
    if (!_impl_.header_row_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_column_style()) {
    if (!_impl_.header_column_style_->IsInitialized()) return false;
  }
  if (_internal_has_footer_row_style()) {
    if (!_impl_.footer_row_style_->IsInitialized()) return false;
  }
  if (_internal_has_origin_offset()) {
    if (!_impl_.origin_offset_->IsInitialized()) return false;
  }
  if (_internal_has_body_text_style()) {
    if (!_impl_.body_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_row_text_style()) {
    if (!_impl_.header_row_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_header_column_text_style()) {
    if (!_impl_.header_column_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_footer_row_text_style()) {
    if (!_impl_.footer_row_text_style_->IsInitialized()) return false;
  }
  if (_internal_has_table_name_style()) {
    if (!_impl_.table_name_style_->IsInitialized()) return false;
  }
  if (_internal_has_hidden_state_formula_owner_for_columns()) {
    if (!_impl_.hidden_state_formula_owner_for_columns_->IsInitialized()) return false;
  }
  if (_internal_has_hidden_state_formula_owner_for_rows()) {
    if (!_impl_.hidden_state_formula_owner_for_rows_->IsInitialized()) return false;
  }
  if (_internal_has_table_name_shape_style()) {
    if (!_impl_.table_name_shape_style_->IsInitialized()) return false;
  }
  if (_internal_has_filter_set()) {
    if (!_impl_.filter_set_->IsInitialized()) return false;
  }
  return true;
}

void TableModelArchive::InternalSwap(TableModelArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.table_id_, lhs_arena,
      &other->_impl_.table_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.table_name_, lhs_arena,
      &other->_impl_.table_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_table_id_, lhs_arena,
      &other->_impl_.from_table_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableModelArchive, _impl_.number_of_user_hidden_columns_)
      + sizeof(TableModelArchive::_impl_.number_of_user_hidden_columns_)
      - PROTOBUF_FIELD_OFFSET(TableModelArchive, _impl_.table_style_)>(
          reinterpret_cast<char*>(&_impl_.table_style_),
          reinterpret_cast<char*>(&other->_impl_.table_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableModelArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[22]);
}

// ===================================================================

class DurationWrapperArchive::_Internal {
 public:
};

DurationWrapperArchive::DurationWrapperArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:TST.DurationWrapperArchive)
}
DurationWrapperArchive::DurationWrapperArchive(const DurationWrapperArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  DurationWrapperArchive* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.DurationWrapperArchive)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DurationWrapperArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DurationWrapperArchive::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata DurationWrapperArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[23]);
}

// ===================================================================

class Cell::_Internal {
 public:
  using HasBits = decltype(std::declval<Cell>()._impl_._has_bits_);
  static void set_has_valuetype(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_numbervalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_stringvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_boolvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::TSP::Reference& cell_style(const Cell* msg);
  static void set_has_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& text_style(const Cell* msg);
  static void set_has_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::FormulaArchive& formula(const Cell* msg);
  static void set_has_formula(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& formulaerror(const Cell* msg);
  static void set_has_formulaerror(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSK::FormatStructArchive& current_format(const Cell* msg);
  static void set_has_current_format(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSK::FormatStructArchive& number_format(const Cell* msg);
  static void set_has_number_format(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSK::FormatStructArchive& currency_format(const Cell* msg);
  static void set_has_currency_format(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSK::FormatStructArchive& duration_format(const Cell* msg);
  static void set_has_duration_format(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSK::FormatStructArchive& date_format(const Cell* msg);
  static void set_has_date_format(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSK::FormatStructArchive& control_format(const Cell* msg);
  static void set_has_control_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::TSK::FormatStructArchive& custom_format(const Cell* msg);
  static void set_has_custom_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSK::FormatStructArchive& base_format(const Cell* msg);
  static void set_has_base_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSK::FormatStructArchive& multiple_choice_list_format(const Cell* msg);
  static void set_has_multiple_choice_list_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_explicit_format_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::TSP::Reference& richtextpayload(const Cell* msg);
  static void set_has_richtextpayload(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::TSP::Reference& conditional_style(const Cell* msg);
  static void set_has_conditional_style(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::TSP::Reference& multiple_choice_list(const Cell* msg);
  static void set_has_multiple_choice_list(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::TSP::Reference& comment_storage(const Cell* msg);
  static void set_has_comment_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_conditional_style_applied_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00040000) ^ 0x00040000) != 0;
  }
};

const ::TSP::Reference&
Cell::_Internal::cell_style(const Cell* msg) {
  return *msg->_impl_.cell_style_;
}
const ::TSP::Reference&
Cell::_Internal::text_style(const Cell* msg) {
  return *msg->_impl_.text_style_;
}
const ::TSCE::FormulaArchive&
Cell::_Internal::formula(const Cell* msg) {
  return *msg->_impl_.formula_;
}
const ::TSP::Reference&
Cell::_Internal::formulaerror(const Cell* msg) {
  return *msg->_impl_.formulaerror_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::current_format(const Cell* msg) {
  return *msg->_impl_.current_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::number_format(const Cell* msg) {
  return *msg->_impl_.number_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::currency_format(const Cell* msg) {
  return *msg->_impl_.currency_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::duration_format(const Cell* msg) {
  return *msg->_impl_.duration_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::date_format(const Cell* msg) {
  return *msg->_impl_.date_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::control_format(const Cell* msg) {
  return *msg->_impl_.control_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::custom_format(const Cell* msg) {
  return *msg->_impl_.custom_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::base_format(const Cell* msg) {
  return *msg->_impl_.base_format_;
}
const ::TSK::FormatStructArchive&
Cell::_Internal::multiple_choice_list_format(const Cell* msg) {
  return *msg->_impl_.multiple_choice_list_format_;
}
const ::TSP::Reference&
Cell::_Internal::richtextpayload(const Cell* msg) {
  return *msg->_impl_.richtextpayload_;
}
const ::TSP::Reference&
Cell::_Internal::conditional_style(const Cell* msg) {
  return *msg->_impl_.conditional_style_;
}
const ::TSP::Reference&
Cell::_Internal::multiple_choice_list(const Cell* msg) {
  return *msg->_impl_.multiple_choice_list_;
}
const ::TSP::Reference&
Cell::_Internal::comment_storage(const Cell* msg) {
  return *msg->_impl_.comment_storage_;
}
void Cell::clear_cell_style() {
  if (_impl_.cell_style_ != nullptr) _impl_.cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void Cell::clear_text_style() {
  if (_impl_.text_style_ != nullptr) _impl_.text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void Cell::clear_formula() {
  if (_impl_.formula_ != nullptr) _impl_.formula_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void Cell::clear_formulaerror() {
  if (_impl_.formulaerror_ != nullptr) _impl_.formulaerror_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void Cell::clear_current_format() {
  if (_impl_.current_format_ != nullptr) _impl_.current_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void Cell::clear_number_format() {
  if (_impl_.number_format_ != nullptr) _impl_.number_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void Cell::clear_currency_format() {
  if (_impl_.currency_format_ != nullptr) _impl_.currency_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void Cell::clear_duration_format() {
  if (_impl_.duration_format_ != nullptr) _impl_.duration_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void Cell::clear_date_format() {
  if (_impl_.date_format_ != nullptr) _impl_.date_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
void Cell::clear_control_format() {
  if (_impl_.control_format_ != nullptr) _impl_.control_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
void Cell::clear_custom_format() {
  if (_impl_.custom_format_ != nullptr) _impl_.custom_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
void Cell::clear_base_format() {
  if (_impl_.base_format_ != nullptr) _impl_.base_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
void Cell::clear_multiple_choice_list_format() {
  if (_impl_.multiple_choice_list_format_ != nullptr) _impl_.multiple_choice_list_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
void Cell::clear_richtextpayload() {
  if (_impl_.richtextpayload_ != nullptr) _impl_.richtextpayload_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
void Cell::clear_conditional_style() {
  if (_impl_.conditional_style_ != nullptr) _impl_.conditional_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
void Cell::clear_multiple_choice_list() {
  if (_impl_.multiple_choice_list_ != nullptr) _impl_.multiple_choice_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
void Cell::clear_comment_storage() {
  if (_impl_.comment_storage_ != nullptr) _impl_.comment_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
Cell::Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.Cell)
}
Cell::Cell(const Cell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Cell* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stringvalue_){}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.current_format_){nullptr}
    , decltype(_impl_.formulaerror_){nullptr}
    , decltype(_impl_.number_format_){nullptr}
    , decltype(_impl_.currency_format_){nullptr}
    , decltype(_impl_.duration_format_){nullptr}
    , decltype(_impl_.date_format_){nullptr}
    , decltype(_impl_.control_format_){nullptr}
    , decltype(_impl_.custom_format_){nullptr}
    , decltype(_impl_.base_format_){nullptr}
    , decltype(_impl_.multiple_choice_list_format_){nullptr}
    , decltype(_impl_.richtextpayload_){nullptr}
    , decltype(_impl_.conditional_style_){nullptr}
    , decltype(_impl_.multiple_choice_list_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}
    , decltype(_impl_.valuetype_){}
    , decltype(_impl_.boolvalue_){}
    , decltype(_impl_.numbervalue_){}
    , decltype(_impl_.explicit_format_flags_){}
    , decltype(_impl_.conditional_style_applied_rule_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stringvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stringvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stringvalue()) {
    _this->_impl_.stringvalue_.Set(from._internal_stringvalue(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cell_style()) {
    _this->_impl_.cell_style_ = new ::TSP::Reference(*from._impl_.cell_style_);
  }
  if (from._internal_has_text_style()) {
    _this->_impl_.text_style_ = new ::TSP::Reference(*from._impl_.text_style_);
  }
  if (from._internal_has_formula()) {
    _this->_impl_.formula_ = new ::TSCE::FormulaArchive(*from._impl_.formula_);
  }
  if (from._internal_has_current_format()) {
    _this->_impl_.current_format_ = new ::TSK::FormatStructArchive(*from._impl_.current_format_);
  }
  if (from._internal_has_formulaerror()) {
    _this->_impl_.formulaerror_ = new ::TSP::Reference(*from._impl_.formulaerror_);
  }
  if (from._internal_has_number_format()) {
    _this->_impl_.number_format_ = new ::TSK::FormatStructArchive(*from._impl_.number_format_);
  }
  if (from._internal_has_currency_format()) {
    _this->_impl_.currency_format_ = new ::TSK::FormatStructArchive(*from._impl_.currency_format_);
  }
  if (from._internal_has_duration_format()) {
    _this->_impl_.duration_format_ = new ::TSK::FormatStructArchive(*from._impl_.duration_format_);
  }
  if (from._internal_has_date_format()) {
    _this->_impl_.date_format_ = new ::TSK::FormatStructArchive(*from._impl_.date_format_);
  }
  if (from._internal_has_control_format()) {
    _this->_impl_.control_format_ = new ::TSK::FormatStructArchive(*from._impl_.control_format_);
  }
  if (from._internal_has_custom_format()) {
    _this->_impl_.custom_format_ = new ::TSK::FormatStructArchive(*from._impl_.custom_format_);
  }
  if (from._internal_has_base_format()) {
    _this->_impl_.base_format_ = new ::TSK::FormatStructArchive(*from._impl_.base_format_);
  }
  if (from._internal_has_multiple_choice_list_format()) {
    _this->_impl_.multiple_choice_list_format_ = new ::TSK::FormatStructArchive(*from._impl_.multiple_choice_list_format_);
  }
  if (from._internal_has_richtextpayload()) {
    _this->_impl_.richtextpayload_ = new ::TSP::Reference(*from._impl_.richtextpayload_);
  }
  if (from._internal_has_conditional_style()) {
    _this->_impl_.conditional_style_ = new ::TSP::Reference(*from._impl_.conditional_style_);
  }
  if (from._internal_has_multiple_choice_list()) {
    _this->_impl_.multiple_choice_list_ = new ::TSP::Reference(*from._impl_.multiple_choice_list_);
  }
  if (from._internal_has_comment_storage()) {
    _this->_impl_.comment_storage_ = new ::TSP::Reference(*from._impl_.comment_storage_);
  }
  ::memcpy(&_impl_.valuetype_, &from._impl_.valuetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.conditional_style_applied_rule_) -
    reinterpret_cast<char*>(&_impl_.valuetype_)) + sizeof(_impl_.conditional_style_applied_rule_));
  // @@protoc_insertion_point(copy_constructor:TST.Cell)
}

inline void Cell::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stringvalue_){}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.current_format_){nullptr}
    , decltype(_impl_.formulaerror_){nullptr}
    , decltype(_impl_.number_format_){nullptr}
    , decltype(_impl_.currency_format_){nullptr}
    , decltype(_impl_.duration_format_){nullptr}
    , decltype(_impl_.date_format_){nullptr}
    , decltype(_impl_.control_format_){nullptr}
    , decltype(_impl_.custom_format_){nullptr}
    , decltype(_impl_.base_format_){nullptr}
    , decltype(_impl_.multiple_choice_list_format_){nullptr}
    , decltype(_impl_.richtextpayload_){nullptr}
    , decltype(_impl_.conditional_style_){nullptr}
    , decltype(_impl_.multiple_choice_list_){nullptr}
    , decltype(_impl_.comment_storage_){nullptr}
    , decltype(_impl_.valuetype_){0}
    , decltype(_impl_.boolvalue_){false}
    , decltype(_impl_.numbervalue_){0}
    , decltype(_impl_.explicit_format_flags_){0u}
    , decltype(_impl_.conditional_style_applied_rule_){0u}
  };
  _impl_.stringvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stringvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Cell::~Cell() {
  // @@protoc_insertion_point(destructor:TST.Cell)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Cell::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stringvalue_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cell_style_;
  if (this != internal_default_instance()) delete _impl_.text_style_;
  if (this != internal_default_instance()) delete _impl_.formula_;
  if (this != internal_default_instance()) delete _impl_.current_format_;
  if (this != internal_default_instance()) delete _impl_.formulaerror_;
  if (this != internal_default_instance()) delete _impl_.number_format_;
  if (this != internal_default_instance()) delete _impl_.currency_format_;
  if (this != internal_default_instance()) delete _impl_.duration_format_;
  if (this != internal_default_instance()) delete _impl_.date_format_;
  if (this != internal_default_instance()) delete _impl_.control_format_;
  if (this != internal_default_instance()) delete _impl_.custom_format_;
  if (this != internal_default_instance()) delete _impl_.base_format_;
  if (this != internal_default_instance()) delete _impl_.multiple_choice_list_format_;
  if (this != internal_default_instance()) delete _impl_.richtextpayload_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_;
  if (this != internal_default_instance()) delete _impl_.multiple_choice_list_;
  if (this != internal_default_instance()) delete _impl_.comment_storage_;
}

void Cell::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Cell::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.Cell)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stringvalue_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_style_ != nullptr);
      _impl_.cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.text_style_ != nullptr);
      _impl_.text_style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.formula_ != nullptr);
      _impl_.formula_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.current_format_ != nullptr);
      _impl_.current_format_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.formulaerror_ != nullptr);
      _impl_.formulaerror_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.number_format_ != nullptr);
      _impl_.number_format_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.currency_format_ != nullptr);
      _impl_.currency_format_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.duration_format_ != nullptr);
      _impl_.duration_format_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.date_format_ != nullptr);
      _impl_.date_format_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.control_format_ != nullptr);
      _impl_.control_format_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.custom_format_ != nullptr);
      _impl_.custom_format_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(_impl_.base_format_ != nullptr);
      _impl_.base_format_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(_impl_.multiple_choice_list_format_ != nullptr);
      _impl_.multiple_choice_list_format_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(_impl_.richtextpayload_ != nullptr);
      _impl_.richtextpayload_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(_impl_.conditional_style_ != nullptr);
      _impl_.conditional_style_->Clear();
    }
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(_impl_.multiple_choice_list_ != nullptr);
      _impl_.multiple_choice_list_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(_impl_.comment_storage_ != nullptr);
      _impl_.comment_storage_->Clear();
    }
  }
  if (cached_has_bits & 0x007c0000u) {
    ::memset(&_impl_.valuetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.conditional_style_applied_rule_) -
        reinterpret_cast<char*>(&_impl_.valuetype_)) + sizeof(_impl_.conditional_style_applied_rule_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cell::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellValueType valueType = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CellValueType_IsValid(val))) {
            _internal_set_valuetype(static_cast<::TST::CellValueType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference cell_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double numberValue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_numbervalue(&has_bits);
          _impl_.numbervalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional string stringValue = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_stringvalue();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.Cell.stringValue");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool boolValue = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_boolvalue(&has_bits);
          _impl_.boolvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.FormulaArchive formula = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive current_format = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_current_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formulaError = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_formulaerror(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive number_format = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_number_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive currency_format = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_currency_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive duration_format = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive date_format = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_date_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive control_format = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_control_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive custom_format = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive base_format = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_base_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiple_choice_list_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 explicit_format_flags = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_explicit_format_flags(&has_bits);
          _impl_.explicit_format_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference richTextPayload = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_richtextpayload(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference conditional_style = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference multiple_choice_list = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_multiple_choice_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference comment_storage = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_comment_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 conditional_style_applied_rule = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_conditional_style_applied_rule(&has_bits);
          _impl_.conditional_style_applied_rule_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Cell::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.Cell)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellValueType valueType = 2;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_valuetype(), target);
  }

  // optional .TSP.Reference cell_style = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cell_style(this),
        _Internal::cell_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_style = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::text_style(this),
        _Internal::text_style(this).GetCachedSize(), target, stream);
  }

  // optional double numberValue = 5;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_numbervalue(), target);
  }

  // optional string stringValue = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_stringvalue().data(), static_cast<int>(this->_internal_stringvalue().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.Cell.stringValue");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_stringvalue(), target);
  }

  // optional bool boolValue = 7;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_boolvalue(), target);
  }

  // optional .TSCE.FormulaArchive formula = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::formula(this),
        _Internal::formula(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive current_format = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::current_format(this),
        _Internal::current_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference formulaError = 10;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::formulaerror(this),
        _Internal::formulaerror(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive number_format = 11;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::number_format(this),
        _Internal::number_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive currency_format = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::currency_format(this),
        _Internal::currency_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive duration_format = 13;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::duration_format(this),
        _Internal::duration_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive date_format = 14;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::date_format(this),
        _Internal::date_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive control_format = 15;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::control_format(this),
        _Internal::control_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive custom_format = 16;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::custom_format(this),
        _Internal::custom_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive base_format = 17;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::base_format(this),
        _Internal::base_format(this).GetCachedSize(), target, stream);
  }

  // optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::multiple_choice_list_format(this),
        _Internal::multiple_choice_list_format(this).GetCachedSize(), target, stream);
  }

  // optional uint32 explicit_format_flags = 19;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_explicit_format_flags(), target);
  }

  // optional .TSP.Reference richTextPayload = 20;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::richtextpayload(this),
        _Internal::richtextpayload(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference conditional_style = 21;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::conditional_style(this),
        _Internal::conditional_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference multiple_choice_list = 22;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::multiple_choice_list(this),
        _Internal::multiple_choice_list(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference comment_storage = 23;
  if (cached_has_bits & 0x00020000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::comment_storage(this),
        _Internal::comment_storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 conditional_style_applied_rule = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_conditional_style_applied_rule(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.Cell)
  return target;
}

size_t Cell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.Cell)
  size_t total_size = 0;

  // required .TST.CellValueType valueType = 2;
  if (_internal_has_valuetype()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_valuetype());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string stringValue = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_stringvalue());
    }

    // optional .TSP.Reference cell_style = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cell_style_);
    }

    // optional .TSP.Reference text_style = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_style_);
    }

    // optional .TSCE.FormulaArchive formula = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formula_);
    }

    // optional .TSK.FormatStructArchive current_format = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.current_format_);
    }

    // optional .TSP.Reference formulaError = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formulaerror_);
    }

    // optional .TSK.FormatStructArchive number_format = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.number_format_);
    }

    // optional .TSK.FormatStructArchive currency_format = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.currency_format_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .TSK.FormatStructArchive duration_format = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.duration_format_);
    }

    // optional .TSK.FormatStructArchive date_format = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_format_);
    }

    // optional .TSK.FormatStructArchive control_format = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.control_format_);
    }

    // optional .TSK.FormatStructArchive custom_format = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.custom_format_);
    }

    // optional .TSK.FormatStructArchive base_format = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_format_);
    }

    // optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multiple_choice_list_format_);
    }

    // optional .TSP.Reference richTextPayload = 20;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.richtextpayload_);
    }

    // optional .TSP.Reference conditional_style = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_);
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional .TSP.Reference multiple_choice_list = 22;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multiple_choice_list_);
    }

    // optional .TSP.Reference comment_storage = 23;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.comment_storage_);
    }

  }
  if (cached_has_bits & 0x00780000u) {
    // optional bool boolValue = 7;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional double numberValue = 5;
    if (cached_has_bits & 0x00100000u) {
      total_size += 1 + 8;
    }

    // optional uint32 explicit_format_flags = 19;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_explicit_format_flags());
    }

    // optional uint32 conditional_style_applied_rule = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_conditional_style_applied_rule());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Cell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cell::GetClassData() const { return &_class_data_; }


void Cell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Cell*>(&to_msg);
  auto& from = static_cast<const Cell&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.Cell)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stringvalue(from._internal_stringvalue());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_cell_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_text_style()->::TSP::Reference::MergeFrom(
          from._internal_text_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_formula()->::TSCE::FormulaArchive::MergeFrom(
          from._internal_formula());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_current_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_current_format());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_formulaerror()->::TSP::Reference::MergeFrom(
          from._internal_formulaerror());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_number_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_number_format());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_currency_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_currency_format());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_duration_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_duration_format());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_date_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_date_format());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_control_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_control_format());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_custom_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_custom_format());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_mutable_base_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_base_format());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_mutable_multiple_choice_list_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_multiple_choice_list_format());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_mutable_richtextpayload()->::TSP::Reference::MergeFrom(
          from._internal_richtextpayload());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_conditional_style()->::TSP::Reference::MergeFrom(
          from._internal_conditional_style());
    }
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_internal_mutable_multiple_choice_list()->::TSP::Reference::MergeFrom(
          from._internal_multiple_choice_list());
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_internal_mutable_comment_storage()->::TSP::Reference::MergeFrom(
          from._internal_comment_storage());
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.valuetype_ = from._impl_.valuetype_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.boolvalue_ = from._impl_.boolvalue_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.numbervalue_ = from._impl_.numbervalue_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.explicit_format_flags_ = from._impl_.explicit_format_flags_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.conditional_style_applied_rule_ = from._impl_.conditional_style_applied_rule_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cell::CopyFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cell::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cell_style()) {
    if (!_impl_.cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_text_style()) {
    if (!_impl_.text_style_->IsInitialized()) return false;
  }
  if (_internal_has_formula()) {
    if (!_impl_.formula_->IsInitialized()) return false;
  }
  if (_internal_has_current_format()) {
    if (!_impl_.current_format_->IsInitialized()) return false;
  }
  if (_internal_has_formulaerror()) {
    if (!_impl_.formulaerror_->IsInitialized()) return false;
  }
  if (_internal_has_number_format()) {
    if (!_impl_.number_format_->IsInitialized()) return false;
  }
  if (_internal_has_currency_format()) {
    if (!_impl_.currency_format_->IsInitialized()) return false;
  }
  if (_internal_has_duration_format()) {
    if (!_impl_.duration_format_->IsInitialized()) return false;
  }
  if (_internal_has_date_format()) {
    if (!_impl_.date_format_->IsInitialized()) return false;
  }
  if (_internal_has_control_format()) {
    if (!_impl_.control_format_->IsInitialized()) return false;
  }
  if (_internal_has_custom_format()) {
    if (!_impl_.custom_format_->IsInitialized()) return false;
  }
  if (_internal_has_base_format()) {
    if (!_impl_.base_format_->IsInitialized()) return false;
  }
  if (_internal_has_multiple_choice_list_format()) {
    if (!_impl_.multiple_choice_list_format_->IsInitialized()) return false;
  }
  if (_internal_has_richtextpayload()) {
    if (!_impl_.richtextpayload_->IsInitialized()) return false;
  }
  if (_internal_has_conditional_style()) {
    if (!_impl_.conditional_style_->IsInitialized()) return false;
  }
  if (_internal_has_multiple_choice_list()) {
    if (!_impl_.multiple_choice_list_->IsInitialized()) return false;
  }
  if (_internal_has_comment_storage()) {
    if (!_impl_.comment_storage_->IsInitialized()) return false;
  }
  return true;
}

void Cell::InternalSwap(Cell* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stringvalue_, lhs_arena,
      &other->_impl_.stringvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cell, _impl_.conditional_style_applied_rule_)
      + sizeof(Cell::_impl_.conditional_style_applied_rule_)
      - PROTOBUF_FIELD_OFFSET(Cell, _impl_.cell_style_)>(
          reinterpret_cast<char*>(&_impl_.cell_style_),
          reinterpret_cast<char*>(&other->_impl_.cell_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cell::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[24]);
}

// ===================================================================

class MergeRegionMapArchive::_Internal {
 public:
};

MergeRegionMapArchive::MergeRegionMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.MergeRegionMapArchive)
}
MergeRegionMapArchive::MergeRegionMapArchive(const MergeRegionMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MergeRegionMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_range_){from._impl_.cell_range_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.MergeRegionMapArchive)
}

inline void MergeRegionMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_range_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MergeRegionMapArchive::~MergeRegionMapArchive() {
  // @@protoc_insertion_point(destructor:TST.MergeRegionMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MergeRegionMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cell_range_.~RepeatedPtrField();
}

void MergeRegionMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MergeRegionMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.MergeRegionMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cell_range_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MergeRegionMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TST.CellRange cell_range = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cell_range(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MergeRegionMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.MergeRegionMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TST.CellRange cell_range = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_range_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell_range(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.MergeRegionMapArchive)
  return target;
}

size_t MergeRegionMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.MergeRegionMapArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CellRange cell_range = 1;
  total_size += 1UL * this->_internal_cell_range_size();
  for (const auto& msg : this->_impl_.cell_range_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MergeRegionMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MergeRegionMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MergeRegionMapArchive::GetClassData() const { return &_class_data_; }


void MergeRegionMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MergeRegionMapArchive*>(&to_msg);
  auto& from = static_cast<const MergeRegionMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.MergeRegionMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cell_range_.MergeFrom(from._impl_.cell_range_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MergeRegionMapArchive::CopyFrom(const MergeRegionMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.MergeRegionMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeRegionMapArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cell_range_))
    return false;
  return true;
}

void MergeRegionMapArchive::InternalSwap(MergeRegionMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cell_range_.InternalSwap(&other->_impl_.cell_range_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MergeRegionMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[25]);
}

// ===================================================================

class CellMapArchive_CellMapEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CellMapArchive_CellMapEntry>()._impl_._has_bits_);
  static const ::TST::CellID& cellid(const CellMapArchive_CellMapEntry* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::Cell& cell(const CellMapArchive_CellMapEntry* msg);
  static void set_has_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CellID&
CellMapArchive_CellMapEntry::_Internal::cellid(const CellMapArchive_CellMapEntry* msg) {
  return *msg->_impl_.cellid_;
}
const ::TST::Cell&
CellMapArchive_CellMapEntry::_Internal::cell(const CellMapArchive_CellMapEntry* msg) {
  return *msg->_impl_.cell_;
}
CellMapArchive_CellMapEntry::CellMapArchive_CellMapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellMapArchive.CellMapEntry)
}
CellMapArchive_CellMapEntry::CellMapArchive_CellMapEntry(const CellMapArchive_CellMapEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellMapArchive_CellMapEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.cell_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  if (from._internal_has_cell()) {
    _this->_impl_.cell_ = new ::TST::Cell(*from._impl_.cell_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CellMapArchive.CellMapEntry)
}

inline void CellMapArchive_CellMapEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.cell_){nullptr}
  };
}

CellMapArchive_CellMapEntry::~CellMapArchive_CellMapEntry() {
  // @@protoc_insertion_point(destructor:TST.CellMapArchive.CellMapEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellMapArchive_CellMapEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellid_;
  if (this != internal_default_instance()) delete _impl_.cell_;
}

void CellMapArchive_CellMapEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellMapArchive_CellMapEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellMapArchive.CellMapEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
      _impl_.cellid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_ != nullptr);
      _impl_.cell_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellMapArchive_CellMapEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID cellID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.Cell cell = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellMapArchive_CellMapEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellMapArchive.CellMapEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID cellID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  // optional .TST.Cell cell = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cell(this),
        _Internal::cell(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellMapArchive.CellMapEntry)
  return target;
}

size_t CellMapArchive_CellMapEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellMapArchive.CellMapEntry)
  size_t total_size = 0;

  // required .TST.CellID cellID = 1;
  if (_internal_has_cellid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TST.Cell cell = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellMapArchive_CellMapEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellMapArchive_CellMapEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellMapArchive_CellMapEntry::GetClassData() const { return &_class_data_; }


void CellMapArchive_CellMapEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellMapArchive_CellMapEntry*>(&to_msg);
  auto& from = static_cast<const CellMapArchive_CellMapEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellMapArchive.CellMapEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell()->::TST::Cell::MergeFrom(
          from._internal_cell());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellMapArchive_CellMapEntry::CopyFrom(const CellMapArchive_CellMapEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellMapArchive.CellMapEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellMapArchive_CellMapEntry::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  if (_internal_has_cell()) {
    if (!_impl_.cell_->IsInitialized()) return false;
  }
  return true;
}

void CellMapArchive_CellMapEntry::InternalSwap(CellMapArchive_CellMapEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CellMapArchive_CellMapEntry, _impl_.cell_)
      + sizeof(CellMapArchive_CellMapEntry::_impl_.cell_)
      - PROTOBUF_FIELD_OFFSET(CellMapArchive_CellMapEntry, _impl_.cellid_)>(
          reinterpret_cast<char*>(&_impl_.cellid_),
          reinterpret_cast<char*>(&other->_impl_.cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CellMapArchive_CellMapEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[26]);
}

// ===================================================================

class CellMapArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CellMapArchive>()._impl_._has_bits_);
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_may_modify_formulas_in_cells(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_may_modify_values_referenced_by_formulas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_applies_to_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CellMapArchive::CellMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellMapArchive)
}
CellMapArchive::CellMapArchive(const CellMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellmapentry_){from._impl_.cellmapentry_}
    , decltype(_impl_.capacity_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.applies_to_hidden_){}
    , decltype(_impl_.may_modify_formulas_in_cells_){}
    , decltype(_impl_.may_modify_values_referenced_by_formulas_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.capacity_, &from._impl_.capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.may_modify_values_referenced_by_formulas_) -
    reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.may_modify_values_referenced_by_formulas_));
  // @@protoc_insertion_point(copy_constructor:TST.CellMapArchive)
}

inline void CellMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellmapentry_){arena}
    , decltype(_impl_.capacity_){0u}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.applies_to_hidden_){false}
    , decltype(_impl_.may_modify_formulas_in_cells_){true}
    , decltype(_impl_.may_modify_values_referenced_by_formulas_){true}
  };
}

CellMapArchive::~CellMapArchive() {
  // @@protoc_insertion_point(destructor:TST.CellMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cellmapentry_.~RepeatedPtrField();
}

void CellMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cellmapentry_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.applies_to_hidden_) -
        reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.applies_to_hidden_));
    _impl_.may_modify_formulas_in_cells_ = true;
    _impl_.may_modify_values_referenced_by_formulas_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_capacity(&has_bits);
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cellmapentry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool may_modify_formulas_in_cells = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_may_modify_formulas_in_cells(&has_bits);
          _impl_.may_modify_formulas_in_cells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_may_modify_values_referenced_by_formulas(&has_bits);
          _impl_.may_modify_values_referenced_by_formulas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool applies_to_hidden = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_applies_to_hidden(&has_bits);
          _impl_.applies_to_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 capacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_capacity(), target);
  }

  // required uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cellmapentry_size()); i < n; i++) {
    const auto& repfield = this->_internal_cellmapentry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool may_modify_formulas_in_cells = 4 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_may_modify_formulas_in_cells(), target);
  }

  // optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_may_modify_values_referenced_by_formulas(), target);
  }

  // optional bool applies_to_hidden = 6 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_applies_to_hidden(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellMapArchive)
  return target;
}

size_t CellMapArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CellMapArchive)
  size_t total_size = 0;

  if (_internal_has_capacity()) {
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());
  }

  if (_internal_has_count()) {
    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t CellMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellMapArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());

    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
  total_size += 1UL * this->_internal_cellmapentry_size();
  for (const auto& msg : this->_impl_.cellmapentry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional bool applies_to_hidden = 6 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool may_modify_formulas_in_cells = 4 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellMapArchive::GetClassData() const { return &_class_data_; }


void CellMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellMapArchive*>(&to_msg);
  auto& from = static_cast<const CellMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cellmapentry_.MergeFrom(from._impl_.cellmapentry_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.capacity_ = from._impl_.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.applies_to_hidden_ = from._impl_.applies_to_hidden_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.may_modify_formulas_in_cells_ = from._impl_.may_modify_formulas_in_cells_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.may_modify_values_referenced_by_formulas_ = from._impl_.may_modify_values_referenced_by_formulas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellMapArchive::CopyFrom(const CellMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellMapArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cellmapentry_))
    return false;
  return true;
}

void CellMapArchive::InternalSwap(CellMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cellmapentry_.InternalSwap(&other->_impl_.cellmapentry_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CellMapArchive, _impl_.applies_to_hidden_)
      + sizeof(CellMapArchive::_impl_.applies_to_hidden_)
      - PROTOBUF_FIELD_OFFSET(CellMapArchive, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
  swap(_impl_.may_modify_formulas_in_cells_, other->_impl_.may_modify_formulas_in_cells_);
  swap(_impl_.may_modify_values_referenced_by_formulas_, other->_impl_.may_modify_values_referenced_by_formulas_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CellMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[27]);
}

// ===================================================================

class DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleStyleMapArchive_DoubleStyleMapEntryArchive>()._impl_._has_bits_);
  static const ::TST::CellID& cell_id(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg);
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& old_style(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg);
  static void set_has_old_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& new_style(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg);
  static void set_has_new_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::CellID&
DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_Internal::cell_id(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg) {
  return *msg->_impl_.cell_id_;
}
const ::TSP::Reference&
DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_Internal::old_style(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg) {
  return *msg->_impl_.old_style_;
}
const ::TSP::Reference&
DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_Internal::new_style(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* msg) {
  return *msg->_impl_.new_style_;
}
void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_old_style() {
  if (_impl_.old_style_ != nullptr) _impl_.old_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_new_style() {
  if (_impl_.new_style_ != nullptr) _impl_.new_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
DoubleStyleMapArchive_DoubleStyleMapEntryArchive::DoubleStyleMapArchive_DoubleStyleMapEntryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
}
DoubleStyleMapArchive_DoubleStyleMapEntryArchive::DoubleStyleMapArchive_DoubleStyleMapEntryArchive(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoubleStyleMapArchive_DoubleStyleMapEntryArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_id_){nullptr}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cell_id()) {
    _this->_impl_.cell_id_ = new ::TST::CellID(*from._impl_.cell_id_);
  }
  if (from._internal_has_old_style()) {
    _this->_impl_.old_style_ = new ::TSP::Reference(*from._impl_.old_style_);
  }
  if (from._internal_has_new_style()) {
    _this->_impl_.new_style_ = new ::TSP::Reference(*from._impl_.new_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
}

inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_id_){nullptr}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}
  };
}

DoubleStyleMapArchive_DoubleStyleMapEntryArchive::~DoubleStyleMapArchive_DoubleStyleMapEntryArchive() {
  // @@protoc_insertion_point(destructor:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cell_id_;
  if (this != internal_default_instance()) delete _impl_.old_style_;
  if (this != internal_default_instance()) delete _impl_.new_style_;
}

void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cell_id_ != nullptr);
      _impl_.cell_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_style_ != nullptr);
      _impl_.old_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_style_ != nullptr);
      _impl_.new_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID cell_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference old_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference new_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID cell_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cell_id(this),
        _Internal::cell_id(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference old_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_style(this),
        _Internal::old_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference new_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_style(this),
        _Internal::new_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  return target;
}

size_t DoubleStyleMapArchive_DoubleStyleMapEntryArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  size_t total_size = 0;

  if (_internal_has_cell_id()) {
    // required .TST.CellID cell_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_id_);
  }

  if (_internal_has_old_style()) {
    // required .TSP.Reference old_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_);
  }

  if (_internal_has_new_style()) {
    // required .TSP.Reference new_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_);
  }

  return total_size;
}
size_t DoubleStyleMapArchive_DoubleStyleMapEntryArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.CellID cell_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_id_);

    // required .TSP.Reference old_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_);

    // required .TSP.Reference new_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoubleStyleMapArchive_DoubleStyleMapEntryArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleStyleMapArchive_DoubleStyleMapEntryArchive::GetClassData() const { return &_class_data_; }


void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoubleStyleMapArchive_DoubleStyleMapEntryArchive*>(&to_msg);
  auto& from = static_cast<const DoubleStyleMapArchive_DoubleStyleMapEntryArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cell_id()->::TST::CellID::MergeFrom(
          from._internal_cell_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_style()->::TSP::Reference::MergeFrom(
          from._internal_old_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_style()->::TSP::Reference::MergeFrom(
          from._internal_new_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::CopyFrom(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cell_id()) {
    if (!_impl_.cell_id_->IsInitialized()) return false;
  }
  if (_internal_has_old_style()) {
    if (!_impl_.old_style_->IsInitialized()) return false;
  }
  if (_internal_has_new_style()) {
    if (!_impl_.new_style_->IsInitialized()) return false;
  }
  return true;
}

void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::InternalSwap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_.new_style_)
      + sizeof(DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_impl_.new_style_)
      - PROTOBUF_FIELD_OFFSET(DoubleStyleMapArchive_DoubleStyleMapEntryArchive, _impl_.cell_id_)>(
          reinterpret_cast<char*>(&_impl_.cell_id_),
          reinterpret_cast<char*>(&other->_impl_.cell_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleStyleMapArchive_DoubleStyleMapEntryArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[28]);
}

// ===================================================================

class DoubleStyleMapArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleStyleMapArchive>()._impl_._has_bits_);
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

DoubleStyleMapArchive::DoubleStyleMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DoubleStyleMapArchive)
}
DoubleStyleMapArchive::DoubleStyleMapArchive(const DoubleStyleMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoubleStyleMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_map_entry_){from._impl_.cell_map_entry_}
    , decltype(_impl_.capacity_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.capacity_, &from._impl_.capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TST.DoubleStyleMapArchive)
}

inline void DoubleStyleMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_map_entry_){arena}
    , decltype(_impl_.capacity_){0u}
    , decltype(_impl_.count_){0u}
  };
}

DoubleStyleMapArchive::~DoubleStyleMapArchive() {
  // @@protoc_insertion_point(destructor:TST.DoubleStyleMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoubleStyleMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cell_map_entry_.~RepeatedPtrField();
}

void DoubleStyleMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleStyleMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DoubleStyleMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cell_map_entry_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleStyleMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_capacity(&has_bits);
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cell_map_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleStyleMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DoubleStyleMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 capacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_capacity(), target);
  }

  // required uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_map_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell_map_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DoubleStyleMapArchive)
  return target;
}

size_t DoubleStyleMapArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.DoubleStyleMapArchive)
  size_t total_size = 0;

  if (_internal_has_capacity()) {
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());
  }

  if (_internal_has_count()) {
    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t DoubleStyleMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DoubleStyleMapArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());

    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
  total_size += 1UL * this->_internal_cell_map_entry_size();
  for (const auto& msg : this->_impl_.cell_map_entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleStyleMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoubleStyleMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleStyleMapArchive::GetClassData() const { return &_class_data_; }


void DoubleStyleMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoubleStyleMapArchive*>(&to_msg);
  auto& from = static_cast<const DoubleStyleMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DoubleStyleMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cell_map_entry_.MergeFrom(from._impl_.cell_map_entry_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.capacity_ = from._impl_.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleStyleMapArchive::CopyFrom(const DoubleStyleMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DoubleStyleMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleStyleMapArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cell_map_entry_))
    return false;
  return true;
}

void DoubleStyleMapArchive::InternalSwap(DoubleStyleMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cell_map_entry_.InternalSwap(&other->_impl_.cell_map_entry_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleStyleMapArchive, _impl_.count_)
      + sizeof(DoubleStyleMapArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(DoubleStyleMapArchive, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleStyleMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[29]);
}

// ===================================================================

class StyleTableMapArchive_StyleTableMapEntryArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleTableMapArchive_StyleTableMapEntryArchive>()._impl_._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& old_style(const StyleTableMapArchive_StyleTableMapEntryArchive* msg);
  static void set_has_old_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& new_style(const StyleTableMapArchive_StyleTableMapEntryArchive* msg);
  static void set_has_new_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TSP::Reference&
StyleTableMapArchive_StyleTableMapEntryArchive::_Internal::old_style(const StyleTableMapArchive_StyleTableMapEntryArchive* msg) {
  return *msg->_impl_.old_style_;
}
const ::TSP::Reference&
StyleTableMapArchive_StyleTableMapEntryArchive::_Internal::new_style(const StyleTableMapArchive_StyleTableMapEntryArchive* msg) {
  return *msg->_impl_.new_style_;
}
void StyleTableMapArchive_StyleTableMapEntryArchive::clear_old_style() {
  if (_impl_.old_style_ != nullptr) _impl_.old_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StyleTableMapArchive_StyleTableMapEntryArchive::clear_new_style() {
  if (_impl_.new_style_ != nullptr) _impl_.new_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
StyleTableMapArchive_StyleTableMapEntryArchive::StyleTableMapArchive_StyleTableMapEntryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
}
StyleTableMapArchive_StyleTableMapEntryArchive::StyleTableMapArchive_StyleTableMapEntryArchive(const StyleTableMapArchive_StyleTableMapEntryArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleTableMapArchive_StyleTableMapEntryArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}
    , decltype(_impl_.key_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_old_style()) {
    _this->_impl_.old_style_ = new ::TSP::Reference(*from._impl_.old_style_);
  }
  if (from._internal_has_new_style()) {
    _this->_impl_.new_style_ = new ::TSP::Reference(*from._impl_.new_style_);
  }
  _this->_impl_.key_ = from._impl_.key_;
  // @@protoc_insertion_point(copy_constructor:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
}

inline void StyleTableMapArchive_StyleTableMapEntryArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}
    , decltype(_impl_.key_){0u}
  };
}

StyleTableMapArchive_StyleTableMapEntryArchive::~StyleTableMapArchive_StyleTableMapEntryArchive() {
  // @@protoc_insertion_point(destructor:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleTableMapArchive_StyleTableMapEntryArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.old_style_;
  if (this != internal_default_instance()) delete _impl_.new_style_;
}

void StyleTableMapArchive_StyleTableMapEntryArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleTableMapArchive_StyleTableMapEntryArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.old_style_ != nullptr);
      _impl_.old_style_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.new_style_ != nullptr);
      _impl_.new_style_->Clear();
    }
  }
  _impl_.key_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleTableMapArchive_StyleTableMapEntryArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference old_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference new_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleTableMapArchive_StyleTableMapEntryArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 key = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_key(), target);
  }

  // required .TSP.Reference old_style = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_style(this),
        _Internal::old_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference new_style = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_style(this),
        _Internal::new_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  return target;
}

size_t StyleTableMapArchive_StyleTableMapEntryArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  size_t total_size = 0;

  if (_internal_has_old_style()) {
    // required .TSP.Reference old_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_);
  }

  if (_internal_has_new_style()) {
    // required .TSP.Reference new_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_);
  }

  if (_internal_has_key()) {
    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());
  }

  return total_size;
}
size_t StyleTableMapArchive_StyleTableMapEntryArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TSP.Reference old_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_);

    // required .TSP.Reference new_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_);

    // required uint32 key = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_key());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleTableMapArchive_StyleTableMapEntryArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleTableMapArchive_StyleTableMapEntryArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleTableMapArchive_StyleTableMapEntryArchive::GetClassData() const { return &_class_data_; }


void StyleTableMapArchive_StyleTableMapEntryArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleTableMapArchive_StyleTableMapEntryArchive*>(&to_msg);
  auto& from = static_cast<const StyleTableMapArchive_StyleTableMapEntryArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_old_style()->::TSP::Reference::MergeFrom(
          from._internal_old_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_new_style()->::TSP::Reference::MergeFrom(
          from._internal_new_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleTableMapArchive_StyleTableMapEntryArchive::CopyFrom(const StyleTableMapArchive_StyleTableMapEntryArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleTableMapArchive_StyleTableMapEntryArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_old_style()) {
    if (!_impl_.old_style_->IsInitialized()) return false;
  }
  if (_internal_has_new_style()) {
    if (!_impl_.new_style_->IsInitialized()) return false;
  }
  return true;
}

void StyleTableMapArchive_StyleTableMapEntryArchive::InternalSwap(StyleTableMapArchive_StyleTableMapEntryArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleTableMapArchive_StyleTableMapEntryArchive, _impl_.key_)
      + sizeof(StyleTableMapArchive_StyleTableMapEntryArchive::_impl_.key_)
      - PROTOBUF_FIELD_OFFSET(StyleTableMapArchive_StyleTableMapEntryArchive, _impl_.old_style_)>(
          reinterpret_cast<char*>(&_impl_.old_style_),
          reinterpret_cast<char*>(&other->_impl_.old_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleTableMapArchive_StyleTableMapEntryArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[30]);
}

// ===================================================================

class StyleTableMapArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleTableMapArchive>()._impl_._has_bits_);
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

StyleTableMapArchive::StyleTableMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.StyleTableMapArchive)
}
StyleTableMapArchive::StyleTableMapArchive(const StyleTableMapArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleTableMapArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_entry_){from._impl_.map_entry_}
    , decltype(_impl_.capacity_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.capacity_, &from._impl_.capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TST.StyleTableMapArchive)
}

inline void StyleTableMapArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.map_entry_){arena}
    , decltype(_impl_.capacity_){0u}
    , decltype(_impl_.count_){0u}
  };
}

StyleTableMapArchive::~StyleTableMapArchive() {
  // @@protoc_insertion_point(destructor:TST.StyleTableMapArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleTableMapArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.map_entry_.~RepeatedPtrField();
}

void StyleTableMapArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleTableMapArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.StyleTableMapArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.map_entry_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.capacity_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleTableMapArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 capacity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_capacity(&has_bits);
          _impl_.capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_map_entry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleTableMapArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.StyleTableMapArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 capacity = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_capacity(), target);
  }

  // required uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_map_entry_size()); i < n; i++) {
    const auto& repfield = this->_internal_map_entry(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.StyleTableMapArchive)
  return target;
}

size_t StyleTableMapArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.StyleTableMapArchive)
  size_t total_size = 0;

  if (_internal_has_capacity()) {
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());
  }

  if (_internal_has_count()) {
    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t StyleTableMapArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.StyleTableMapArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 capacity = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_capacity());

    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
  total_size += 1UL * this->_internal_map_entry_size();
  for (const auto& msg : this->_impl_.map_entry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleTableMapArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleTableMapArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleTableMapArchive::GetClassData() const { return &_class_data_; }


void StyleTableMapArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleTableMapArchive*>(&to_msg);
  auto& from = static_cast<const StyleTableMapArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.StyleTableMapArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.map_entry_.MergeFrom(from._impl_.map_entry_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.capacity_ = from._impl_.capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleTableMapArchive::CopyFrom(const StyleTableMapArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.StyleTableMapArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleTableMapArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.map_entry_))
    return false;
  return true;
}

void StyleTableMapArchive::InternalSwap(StyleTableMapArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.map_entry_.InternalSwap(&other->_impl_.map_entry_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleTableMapArchive, _impl_.count_)
      + sizeof(StyleTableMapArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(StyleTableMapArchive, _impl_.capacity_)>(
          reinterpret_cast<char*>(&_impl_.capacity_),
          reinterpret_cast<char*>(&other->_impl_.capacity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleTableMapArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[31]);
}

// ===================================================================

class SelectionArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectionArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& tablemodel(const SelectionArchive* msg);
  static void set_has_tablemodel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_selection_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellID& anchor_cell(const SelectionArchive* msg);
  static void set_has_anchor_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellID& cursor_cell(const SelectionArchive* msg);
  static void set_has_cursor_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::TSP::Reference&
SelectionArchive::_Internal::tablemodel(const SelectionArchive* msg) {
  return *msg->_impl_.tablemodel_;
}
const ::TST::CellID&
SelectionArchive::_Internal::anchor_cell(const SelectionArchive* msg) {
  return *msg->_impl_.anchor_cell_;
}
const ::TST::CellID&
SelectionArchive::_Internal::cursor_cell(const SelectionArchive* msg) {
  return *msg->_impl_.cursor_cell_;
}
void SelectionArchive::clear_tablemodel() {
  if (_impl_.tablemodel_ != nullptr) _impl_.tablemodel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SelectionArchive::SelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.SelectionArchive)
}
SelectionArchive::SelectionArchive(const SelectionArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SelectionArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_ranges_){from._impl_.cell_ranges_}
    , decltype(_impl_.base_ranges_){from._impl_.base_ranges_}
    , decltype(_impl_.tablemodel_){nullptr}
    , decltype(_impl_.anchor_cell_){nullptr}
    , decltype(_impl_.cursor_cell_){nullptr}
    , decltype(_impl_.selection_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tablemodel()) {
    _this->_impl_.tablemodel_ = new ::TSP::Reference(*from._impl_.tablemodel_);
  }
  if (from._internal_has_anchor_cell()) {
    _this->_impl_.anchor_cell_ = new ::TST::CellID(*from._impl_.anchor_cell_);
  }
  if (from._internal_has_cursor_cell()) {
    _this->_impl_.cursor_cell_ = new ::TST::CellID(*from._impl_.cursor_cell_);
  }
  _this->_impl_.selection_type_ = from._impl_.selection_type_;
  // @@protoc_insertion_point(copy_constructor:TST.SelectionArchive)
}

inline void SelectionArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_ranges_){arena}
    , decltype(_impl_.base_ranges_){arena}
    , decltype(_impl_.tablemodel_){nullptr}
    , decltype(_impl_.anchor_cell_){nullptr}
    , decltype(_impl_.cursor_cell_){nullptr}
    , decltype(_impl_.selection_type_){0}
  };
}

SelectionArchive::~SelectionArchive() {
  // @@protoc_insertion_point(destructor:TST.SelectionArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectionArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cell_ranges_.~RepeatedPtrField();
  _impl_.base_ranges_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.tablemodel_;
  if (this != internal_default_instance()) delete _impl_.anchor_cell_;
  if (this != internal_default_instance()) delete _impl_.cursor_cell_;
}

void SelectionArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SelectionArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.SelectionArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cell_ranges_.Clear();
  _impl_.base_ranges_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.tablemodel_ != nullptr);
      _impl_.tablemodel_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.anchor_cell_ != nullptr);
      _impl_.anchor_cell_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cursor_cell_ != nullptr);
      _impl_.cursor_cell_->Clear();
    }
  }
  _impl_.selection_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectionArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference tableModel = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tablemodel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionTypeArchive selection_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::SelectionTypeArchive_IsValid(val))) {
            _internal_set_selection_type(static_cast<::TST::SelectionTypeArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID anchor_cell = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_anchor_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CellRange cell_ranges = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cell_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CellRange base_ranges = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_base_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID cursor_cell = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_cursor_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectionArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.SelectionArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference tableModel = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tablemodel(this),
        _Internal::tablemodel(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionTypeArchive selection_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_selection_type(), target);
  }

  // optional .TST.CellID anchor_cell = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::anchor_cell(this),
        _Internal::anchor_cell(this).GetCachedSize(), target, stream);
  }

  // repeated .TST.CellRange cell_ranges = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TST.CellRange base_ranges = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_base_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_base_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TST.CellID cursor_cell = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::cursor_cell(this),
        _Internal::cursor_cell(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.SelectionArchive)
  return target;
}

size_t SelectionArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.SelectionArchive)
  size_t total_size = 0;

  // required .TST.SelectionTypeArchive selection_type = 4;
  if (_internal_has_selection_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_selection_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CellRange cell_ranges = 6;
  total_size += 1UL * this->_internal_cell_ranges_size();
  for (const auto& msg : this->_impl_.cell_ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TST.CellRange base_ranges = 7;
  total_size += 1UL * this->_internal_base_ranges_size();
  for (const auto& msg : this->_impl_.base_ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSP.Reference tableModel = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tablemodel_);
    }

    // optional .TST.CellID anchor_cell = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.anchor_cell_);
    }

    // optional .TST.CellID cursor_cell = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cursor_cell_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectionArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SelectionArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectionArchive::GetClassData() const { return &_class_data_; }


void SelectionArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SelectionArchive*>(&to_msg);
  auto& from = static_cast<const SelectionArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.SelectionArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cell_ranges_.MergeFrom(from._impl_.cell_ranges_);
  _this->_impl_.base_ranges_.MergeFrom(from._impl_.base_ranges_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tablemodel()->::TSP::Reference::MergeFrom(
          from._internal_tablemodel());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_anchor_cell()->::TST::CellID::MergeFrom(
          from._internal_anchor_cell());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cursor_cell()->::TST::CellID::MergeFrom(
          from._internal_cursor_cell());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_type_ = from._impl_.selection_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectionArchive::CopyFrom(const SelectionArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.SelectionArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectionArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cell_ranges_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.base_ranges_))
    return false;
  if (_internal_has_tablemodel()) {
    if (!_impl_.tablemodel_->IsInitialized()) return false;
  }
  if (_internal_has_anchor_cell()) {
    if (!_impl_.anchor_cell_->IsInitialized()) return false;
  }
  if (_internal_has_cursor_cell()) {
    if (!_impl_.cursor_cell_->IsInitialized()) return false;
  }
  return true;
}

void SelectionArchive::InternalSwap(SelectionArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cell_ranges_.InternalSwap(&other->_impl_.cell_ranges_);
  _impl_.base_ranges_.InternalSwap(&other->_impl_.base_ranges_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectionArchive, _impl_.selection_type_)
      + sizeof(SelectionArchive::_impl_.selection_type_)
      - PROTOBUF_FIELD_OFFSET(SelectionArchive, _impl_.tablemodel_)>(
          reinterpret_cast<char*>(&_impl_.tablemodel_),
          reinterpret_cast<char*>(&other->_impl_.tablemodel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectionArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[32]);
}

// ===================================================================

class FilterRuleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FilterRuleArchive>()._impl_._has_bits_);
  static const ::TST::FormulaPredicateArchive& predicate(const FilterRuleArchive* msg);
  static void set_has_predicate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::FormulaPredicateArchive&
FilterRuleArchive::_Internal::predicate(const FilterRuleArchive* msg) {
  return *msg->_impl_.predicate_;
}
FilterRuleArchive::FilterRuleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FilterRuleArchive)
}
FilterRuleArchive::FilterRuleArchive(const FilterRuleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FilterRuleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predicate_){nullptr}
    , decltype(_impl_.disabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_predicate()) {
    _this->_impl_.predicate_ = new ::TST::FormulaPredicateArchive(*from._impl_.predicate_);
  }
  _this->_impl_.disabled_ = from._impl_.disabled_;
  // @@protoc_insertion_point(copy_constructor:TST.FilterRuleArchive)
}

inline void FilterRuleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predicate_){nullptr}
    , decltype(_impl_.disabled_){false}
  };
}

FilterRuleArchive::~FilterRuleArchive() {
  // @@protoc_insertion_point(destructor:TST.FilterRuleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilterRuleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.predicate_;
}

void FilterRuleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilterRuleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FilterRuleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.predicate_ != nullptr);
    _impl_.predicate_->Clear();
  }
  _impl_.disabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FilterRuleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.FormulaPredicateArchive predicate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_predicate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_disabled(&has_bits);
          _impl_.disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilterRuleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FilterRuleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.FormulaPredicateArchive predicate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::predicate(this),
        _Internal::predicate(this).GetCachedSize(), target, stream);
  }

  // optional bool disabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_disabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FilterRuleArchive)
  return target;
}

size_t FilterRuleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FilterRuleArchive)
  size_t total_size = 0;

  // required .TST.FormulaPredicateArchive predicate = 1;
  if (_internal_has_predicate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.predicate_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool disabled = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FilterRuleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FilterRuleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FilterRuleArchive::GetClassData() const { return &_class_data_; }


void FilterRuleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FilterRuleArchive*>(&to_msg);
  auto& from = static_cast<const FilterRuleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FilterRuleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_predicate()->::TST::FormulaPredicateArchive::MergeFrom(
          from._internal_predicate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.disabled_ = from._impl_.disabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FilterRuleArchive::CopyFrom(const FilterRuleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FilterRuleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterRuleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_predicate()) {
    if (!_impl_.predicate_->IsInitialized()) return false;
  }
  return true;
}

void FilterRuleArchive::InternalSwap(FilterRuleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FilterRuleArchive, _impl_.disabled_)
      + sizeof(FilterRuleArchive::_impl_.disabled_)
      - PROTOBUF_FIELD_OFFSET(FilterRuleArchive, _impl_.predicate_)>(
          reinterpret_cast<char*>(&_impl_.predicate_),
          reinterpret_cast<char*>(&other->_impl_.predicate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FilterRuleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[33]);
}

// ===================================================================

class TableStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const TableStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableStylePropertiesArchive& table_properties(const TableStyleArchive* msg);
  static void set_has_table_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
TableStyleArchive::_Internal::super(const TableStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::TableStylePropertiesArchive&
TableStyleArchive::_Internal::table_properties(const TableStyleArchive* msg) {
  return *msg->_impl_.table_properties_;
}
void TableStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TableStyleArchive::clear_table_properties() {
  if (_impl_.table_properties_ != nullptr) _impl_.table_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TableStyleArchive::TableStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableStyleArchive)
}
TableStyleArchive::TableStyleArchive(const TableStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.table_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_table_properties()) {
    _this->_impl_.table_properties_ = new ::TST::TableStylePropertiesArchive(*from._impl_.table_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TST.TableStyleArchive)
}

inline void TableStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.table_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

TableStyleArchive::~TableStyleArchive() {
  // @@protoc_insertion_point(destructor:TST.TableStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.table_properties_;
}

void TableStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.table_properties_ != nullptr);
      _impl_.table_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.TableStylePropertiesArchive table_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TST.TableStylePropertiesArchive table_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::table_properties(this),
        _Internal::table_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableStyleArchive)
  return target;
}

size_t TableStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TST.TableStylePropertiesArchive table_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableStyleArchive::GetClassData() const { return &_class_data_; }


void TableStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableStyleArchive*>(&to_msg);
  auto& from = static_cast<const TableStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_table_properties()->::TST::TableStylePropertiesArchive::MergeFrom(
          from._internal_table_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableStyleArchive::CopyFrom(const TableStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_table_properties()) {
    if (!_impl_.table_properties_->IsInitialized()) return false;
  }
  return true;
}

void TableStyleArchive::InternalSwap(TableStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableStyleArchive, _impl_.override_count_)
      + sizeof(TableStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(TableStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[34]);
}

// ===================================================================

class CellStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CellStyleArchive>()._impl_._has_bits_);
  static const ::TSS::StyleArchive& super(const CellStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_override_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellStylePropertiesArchive& cell_properties(const CellStyleArchive* msg);
  static void set_has_cell_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleArchive&
CellStyleArchive::_Internal::super(const CellStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellStylePropertiesArchive&
CellStyleArchive::_Internal::cell_properties(const CellStyleArchive* msg) {
  return *msg->_impl_.cell_properties_;
}
void CellStyleArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CellStyleArchive::clear_cell_properties() {
  if (_impl_.cell_properties_ != nullptr) _impl_.cell_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CellStyleArchive::CellStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellStyleArchive)
}
CellStyleArchive::CellStyleArchive(const CellStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cell_properties_){nullptr}
    , decltype(_impl_.override_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleArchive(*from._impl_.super_);
  }
  if (from._internal_has_cell_properties()) {
    _this->_impl_.cell_properties_ = new ::TST::CellStylePropertiesArchive(*from._impl_.cell_properties_);
  }
  _this->_impl_.override_count_ = from._impl_.override_count_;
  // @@protoc_insertion_point(copy_constructor:TST.CellStyleArchive)
}

inline void CellStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cell_properties_){nullptr}
    , decltype(_impl_.override_count_){0u}
  };
}

CellStyleArchive::~CellStyleArchive() {
  // @@protoc_insertion_point(destructor:TST.CellStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.cell_properties_;
}

void CellStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_properties_ != nullptr);
      _impl_.cell_properties_->Clear();
    }
  }
  _impl_.override_count_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_count = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_override_count(&has_bits);
          _impl_.override_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellStylePropertiesArchive cell_properties = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 override_count = 10 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_override_count(), target);
  }

  // optional .TST.CellStylePropertiesArchive cell_properties = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::cell_properties(this),
        _Internal::cell_properties(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellStyleArchive)
  return target;
}

size_t CellStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellStyleArchive)
  size_t total_size = 0;

  // required .TSS.StyleArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TST.CellStylePropertiesArchive cell_properties = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cell_properties_);
    }

    // optional uint32 override_count = 10 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_override_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellStyleArchive::GetClassData() const { return &_class_data_; }


void CellStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellStyleArchive*>(&to_msg);
  auto& from = static_cast<const CellStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::StyleArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell_properties()->::TST::CellStylePropertiesArchive::MergeFrom(
          from._internal_cell_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.override_count_ = from._impl_.override_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellStyleArchive::CopyFrom(const CellStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_cell_properties()) {
    if (!_impl_.cell_properties_->IsInitialized()) return false;
  }
  return true;
}

void CellStyleArchive::InternalSwap(CellStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CellStyleArchive, _impl_.override_count_)
      + sizeof(CellStyleArchive::_impl_.override_count_)
      - PROTOBUF_FIELD_OFFSET(CellStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CellStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[35]);
}

// ===================================================================

class FormulaPredicateArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormulaPredicateArchive>()._impl_._has_bits_);
  static const ::TSCE::FormulaArchive& formula(const FormulaPredicateArchive* msg);
  static void set_has_formula(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_predicate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_qualifier1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_qualifier2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_param_index1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_param_index2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_param_index0(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

const ::TSCE::FormulaArchive&
FormulaPredicateArchive::_Internal::formula(const FormulaPredicateArchive* msg) {
  return *msg->_impl_.formula_;
}
void FormulaPredicateArchive::clear_formula() {
  if (_impl_.formula_ != nullptr) _impl_.formula_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FormulaPredicateArchive::FormulaPredicateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FormulaPredicateArchive)
}
FormulaPredicateArchive::FormulaPredicateArchive(const FormulaPredicateArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormulaPredicateArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.predicate_type_){}
    , decltype(_impl_.qualifier1_){}
    , decltype(_impl_.qualifier2_){}
    , decltype(_impl_.param_index1_){}
    , decltype(_impl_.param_index2_){}
    , decltype(_impl_.param_index0_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_formula()) {
    _this->_impl_.formula_ = new ::TSCE::FormulaArchive(*from._impl_.formula_);
  }
  ::memcpy(&_impl_.predicate_type_, &from._impl_.predicate_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.param_index0_) -
    reinterpret_cast<char*>(&_impl_.predicate_type_)) + sizeof(_impl_.param_index0_));
  // @@protoc_insertion_point(copy_constructor:TST.FormulaPredicateArchive)
}

inline void FormulaPredicateArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.formula_){nullptr}
    , decltype(_impl_.predicate_type_){0}
    , decltype(_impl_.qualifier1_){0}
    , decltype(_impl_.qualifier2_){0}
    , decltype(_impl_.param_index1_){0}
    , decltype(_impl_.param_index2_){0}
    , decltype(_impl_.param_index0_){0}
  };
}

FormulaPredicateArchive::~FormulaPredicateArchive() {
  // @@protoc_insertion_point(destructor:TST.FormulaPredicateArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormulaPredicateArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.formula_;
}

void FormulaPredicateArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormulaPredicateArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FormulaPredicateArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.formula_ != nullptr);
    _impl_.formula_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.predicate_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.param_index0_) -
        reinterpret_cast<char*>(&_impl_.predicate_type_)) + sizeof(_impl_.param_index0_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormulaPredicateArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSCE.FormulaArchive formula = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FormulaPredicateArchive_FormulaPredicateType_IsValid(val))) {
            _internal_set_predicate_type(static_cast<::TST::FormulaPredicateArchive_FormulaPredicateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FormulaPredicateArchive_QualifierType_IsValid(val))) {
            _internal_set_qualifier1(static_cast<::TST::FormulaPredicateArchive_QualifierType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FormulaPredicateArchive_QualifierType_IsValid(val))) {
            _internal_set_qualifier2(static_cast<::TST::FormulaPredicateArchive_QualifierType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 param_index1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_param_index1(&has_bits);
          _impl_.param_index1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 param_index2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_param_index2(&has_bits);
          _impl_.param_index2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 param_index0 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_param_index0(&has_bits);
          _impl_.param_index0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormulaPredicateArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FormulaPredicateArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSCE.FormulaArchive formula = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::formula(this),
        _Internal::formula(this).GetCachedSize(), target, stream);
  }

  // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_predicate_type(), target);
  }

  // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_qualifier1(), target);
  }

  // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_qualifier2(), target);
  }

  // required int32 param_index1 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_param_index1(), target);
  }

  // required int32 param_index2 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_param_index2(), target);
  }

  // required int32 param_index0 = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_param_index0(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FormulaPredicateArchive)
  return target;
}

size_t FormulaPredicateArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.FormulaPredicateArchive)
  size_t total_size = 0;

  if (_internal_has_formula()) {
    // required .TSCE.FormulaArchive formula = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_);
  }

  if (_internal_has_predicate_type()) {
    // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_predicate_type());
  }

  if (_internal_has_qualifier1()) {
    // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_qualifier1());
  }

  if (_internal_has_qualifier2()) {
    // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_qualifier2());
  }

  if (_internal_has_param_index1()) {
    // required int32 param_index1 = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index1());
  }

  if (_internal_has_param_index2()) {
    // required int32 param_index2 = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index2());
  }

  if (_internal_has_param_index0()) {
    // required int32 param_index0 = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index0());
  }

  return total_size;
}
size_t FormulaPredicateArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FormulaPredicateArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required .TSCE.FormulaArchive formula = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_);

    // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_predicate_type());

    // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_qualifier1());

    // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_qualifier2());

    // required int32 param_index1 = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index1());

    // required int32 param_index2 = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index2());

    // required int32 param_index0 = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_param_index0());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormulaPredicateArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormulaPredicateArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormulaPredicateArchive::GetClassData() const { return &_class_data_; }


void FormulaPredicateArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormulaPredicateArchive*>(&to_msg);
  auto& from = static_cast<const FormulaPredicateArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FormulaPredicateArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_formula()->::TSCE::FormulaArchive::MergeFrom(
          from._internal_formula());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.predicate_type_ = from._impl_.predicate_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.qualifier1_ = from._impl_.qualifier1_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.qualifier2_ = from._impl_.qualifier2_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.param_index1_ = from._impl_.param_index1_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.param_index2_ = from._impl_.param_index2_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.param_index0_ = from._impl_.param_index0_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormulaPredicateArchive::CopyFrom(const FormulaPredicateArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FormulaPredicateArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormulaPredicateArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_formula()) {
    if (!_impl_.formula_->IsInitialized()) return false;
  }
  return true;
}

void FormulaPredicateArchive::InternalSwap(FormulaPredicateArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FormulaPredicateArchive, _impl_.param_index0_)
      + sizeof(FormulaPredicateArchive::_impl_.param_index0_)
      - PROTOBUF_FIELD_OFFSET(FormulaPredicateArchive, _impl_.formula_)>(
          reinterpret_cast<char*>(&_impl_.formula_),
          reinterpret_cast<char*>(&other->_impl_.formula_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FormulaPredicateArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[36]);
}

// ===================================================================

class ConditionalStyleSetArchive_ConditionalStyleRule::_Internal {
 public:
  using HasBits = decltype(std::declval<ConditionalStyleSetArchive_ConditionalStyleRule>()._impl_._has_bits_);
  static const ::TST::FormulaPredicateArchive& predicate(const ConditionalStyleSetArchive_ConditionalStyleRule* msg);
  static void set_has_predicate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& cell_style(const ConditionalStyleSetArchive_ConditionalStyleRule* msg);
  static void set_has_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& text_style(const ConditionalStyleSetArchive_ConditionalStyleRule* msg);
  static void set_has_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::FormulaPredicateArchive&
ConditionalStyleSetArchive_ConditionalStyleRule::_Internal::predicate(const ConditionalStyleSetArchive_ConditionalStyleRule* msg) {
  return *msg->_impl_.predicate_;
}
const ::TSP::Reference&
ConditionalStyleSetArchive_ConditionalStyleRule::_Internal::cell_style(const ConditionalStyleSetArchive_ConditionalStyleRule* msg) {
  return *msg->_impl_.cell_style_;
}
const ::TSP::Reference&
ConditionalStyleSetArchive_ConditionalStyleRule::_Internal::text_style(const ConditionalStyleSetArchive_ConditionalStyleRule* msg) {
  return *msg->_impl_.text_style_;
}
void ConditionalStyleSetArchive_ConditionalStyleRule::clear_cell_style() {
  if (_impl_.cell_style_ != nullptr) _impl_.cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ConditionalStyleSetArchive_ConditionalStyleRule::clear_text_style() {
  if (_impl_.text_style_ != nullptr) _impl_.text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ConditionalStyleSetArchive_ConditionalStyleRule::ConditionalStyleSetArchive_ConditionalStyleRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
}
ConditionalStyleSetArchive_ConditionalStyleRule::ConditionalStyleSetArchive_ConditionalStyleRule(const ConditionalStyleSetArchive_ConditionalStyleRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConditionalStyleSetArchive_ConditionalStyleRule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predicate_){nullptr}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_predicate()) {
    _this->_impl_.predicate_ = new ::TST::FormulaPredicateArchive(*from._impl_.predicate_);
  }
  if (from._internal_has_cell_style()) {
    _this->_impl_.cell_style_ = new ::TSP::Reference(*from._impl_.cell_style_);
  }
  if (from._internal_has_text_style()) {
    _this->_impl_.text_style_ = new ::TSP::Reference(*from._impl_.text_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
}

inline void ConditionalStyleSetArchive_ConditionalStyleRule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.predicate_){nullptr}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
  };
}

ConditionalStyleSetArchive_ConditionalStyleRule::~ConditionalStyleSetArchive_ConditionalStyleRule() {
  // @@protoc_insertion_point(destructor:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConditionalStyleSetArchive_ConditionalStyleRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.predicate_;
  if (this != internal_default_instance()) delete _impl_.cell_style_;
  if (this != internal_default_instance()) delete _impl_.text_style_;
}

void ConditionalStyleSetArchive_ConditionalStyleRule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConditionalStyleSetArchive_ConditionalStyleRule::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.predicate_ != nullptr);
      _impl_.predicate_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_style_ != nullptr);
      _impl_.cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.text_style_ != nullptr);
      _impl_.text_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConditionalStyleSetArchive_ConditionalStyleRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.FormulaPredicateArchive predicate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_predicate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference cell_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference text_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConditionalStyleSetArchive_ConditionalStyleRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.FormulaPredicateArchive predicate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::predicate(this),
        _Internal::predicate(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference cell_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cell_style(this),
        _Internal::cell_style(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference text_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::text_style(this),
        _Internal::text_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  return target;
}

size_t ConditionalStyleSetArchive_ConditionalStyleRule::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  size_t total_size = 0;

  if (_internal_has_predicate()) {
    // required .TST.FormulaPredicateArchive predicate = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.predicate_);
  }

  if (_internal_has_cell_style()) {
    // required .TSP.Reference cell_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_style_);
  }

  if (_internal_has_text_style()) {
    // required .TSP.Reference text_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.text_style_);
  }

  return total_size;
}
size_t ConditionalStyleSetArchive_ConditionalStyleRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.FormulaPredicateArchive predicate = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.predicate_);

    // required .TSP.Reference cell_style = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_style_);

    // required .TSP.Reference text_style = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.text_style_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConditionalStyleSetArchive_ConditionalStyleRule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConditionalStyleSetArchive_ConditionalStyleRule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConditionalStyleSetArchive_ConditionalStyleRule::GetClassData() const { return &_class_data_; }


void ConditionalStyleSetArchive_ConditionalStyleRule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConditionalStyleSetArchive_ConditionalStyleRule*>(&to_msg);
  auto& from = static_cast<const ConditionalStyleSetArchive_ConditionalStyleRule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_predicate()->::TST::FormulaPredicateArchive::MergeFrom(
          from._internal_predicate());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_cell_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_text_style()->::TSP::Reference::MergeFrom(
          from._internal_text_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConditionalStyleSetArchive_ConditionalStyleRule::CopyFrom(const ConditionalStyleSetArchive_ConditionalStyleRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalStyleSetArchive_ConditionalStyleRule::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_predicate()) {
    if (!_impl_.predicate_->IsInitialized()) return false;
  }
  if (_internal_has_cell_style()) {
    if (!_impl_.cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_text_style()) {
    if (!_impl_.text_style_->IsInitialized()) return false;
  }
  return true;
}

void ConditionalStyleSetArchive_ConditionalStyleRule::InternalSwap(ConditionalStyleSetArchive_ConditionalStyleRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConditionalStyleSetArchive_ConditionalStyleRule, _impl_.text_style_)
      + sizeof(ConditionalStyleSetArchive_ConditionalStyleRule::_impl_.text_style_)
      - PROTOBUF_FIELD_OFFSET(ConditionalStyleSetArchive_ConditionalStyleRule, _impl_.predicate_)>(
          reinterpret_cast<char*>(&_impl_.predicate_),
          reinterpret_cast<char*>(&other->_impl_.predicate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConditionalStyleSetArchive_ConditionalStyleRule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[37]);
}

// ===================================================================

class ConditionalStyleSetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ConditionalStyleSetArchive>()._impl_._has_bits_);
  static void set_has_rulecount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellID& cellid(const ConditionalStyleSetArchive* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TST::CellID&
ConditionalStyleSetArchive::_Internal::cellid(const ConditionalStyleSetArchive* msg) {
  return *msg->_impl_.cellid_;
}
ConditionalStyleSetArchive::ConditionalStyleSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ConditionalStyleSetArchive)
}
ConditionalStyleSetArchive::ConditionalStyleSetArchive(const ConditionalStyleSetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConditionalStyleSetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rules_){from._impl_.rules_}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.rulecount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  _this->_impl_.rulecount_ = from._impl_.rulecount_;
  // @@protoc_insertion_point(copy_constructor:TST.ConditionalStyleSetArchive)
}

inline void ConditionalStyleSetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rules_){arena}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.rulecount_){0u}
  };
}

ConditionalStyleSetArchive::~ConditionalStyleSetArchive() {
  // @@protoc_insertion_point(destructor:TST.ConditionalStyleSetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConditionalStyleSetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rules_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.cellid_;
}

void ConditionalStyleSetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConditionalStyleSetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ConditionalStyleSetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rules_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
    _impl_.cellid_->Clear();
  }
  _impl_.rulecount_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConditionalStyleSetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ruleCount = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rulecount(&has_bits);
          _impl_.rulecount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellID cellID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConditionalStyleSetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ConditionalStyleSetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ruleCount = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rulecount(), target);
  }

  // repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .TST.CellID cellID = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ConditionalStyleSetArchive)
  return target;
}

size_t ConditionalStyleSetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ConditionalStyleSetArchive)
  size_t total_size = 0;

  // required uint32 ruleCount = 1;
  if (_internal_has_rulecount()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rulecount());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
  total_size += 1UL * this->_internal_rules_size();
  for (const auto& msg : this->_impl_.rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TST.CellID cellID = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConditionalStyleSetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConditionalStyleSetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConditionalStyleSetArchive::GetClassData() const { return &_class_data_; }


void ConditionalStyleSetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConditionalStyleSetArchive*>(&to_msg);
  auto& from = static_cast<const ConditionalStyleSetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ConditionalStyleSetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rules_.MergeFrom(from._impl_.rules_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rulecount_ = from._impl_.rulecount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConditionalStyleSetArchive::CopyFrom(const ConditionalStyleSetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ConditionalStyleSetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalStyleSetArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.rules_))
    return false;
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  return true;
}

void ConditionalStyleSetArchive::InternalSwap(ConditionalStyleSetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rules_.InternalSwap(&other->_impl_.rules_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConditionalStyleSetArchive, _impl_.rulecount_)
      + sizeof(ConditionalStyleSetArchive::_impl_.rulecount_)
      - PROTOBUF_FIELD_OFFSET(ConditionalStyleSetArchive, _impl_.cellid_)>(
          reinterpret_cast<char*>(&_impl_.cellid_),
          reinterpret_cast<char*>(&other->_impl_.cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConditionalStyleSetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[38]);
}

// ===================================================================

class FilterSetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FilterSetArchive>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_needs_formula_rewrite_for_import(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FilterSetArchive::FilterSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FilterSetArchive)
}
FilterSetArchive::FilterSetArchive(const FilterSetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FilterSetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filter_rules_){from._impl_.filter_rules_}
    , decltype(_impl_.filter_offsets_){from._impl_.filter_offsets_}
    , decltype(_impl_.filter_enabled_){from._impl_.filter_enabled_}
    , decltype(_impl_.type_){}
    , decltype(_impl_.needs_formula_rewrite_for_import_){}
    , decltype(_impl_.is_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_enabled_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.FilterSetArchive)
}

inline void FilterSetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filter_rules_){arena}
    , decltype(_impl_.filter_offsets_){arena}
    , decltype(_impl_.filter_enabled_){arena}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.needs_formula_rewrite_for_import_){false}
    , decltype(_impl_.is_enabled_){true}
  };
}

FilterSetArchive::~FilterSetArchive() {
  // @@protoc_insertion_point(destructor:TST.FilterSetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilterSetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filter_rules_.~RepeatedPtrField();
  _impl_.filter_offsets_.~RepeatedField();
  _impl_.filter_enabled_.~RepeatedField();
}

void FilterSetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilterSetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FilterSetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filter_rules_.Clear();
  _impl_.filter_offsets_.Clear();
  _impl_.filter_enabled_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.needs_formula_rewrite_for_import_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.needs_formula_rewrite_for_import_));
    _impl_.is_enabled_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FilterSetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FilterSetArchive_FilterSetType_IsValid(val))) {
            _internal_set_type(static_cast<::TST::FilterSetArchive_FilterSetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_enabled(&has_bits);
          _impl_.is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.FilterRuleArchive filter_rules = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_filter_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_formula_rewrite_for_import = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_needs_formula_rewrite_for_import(&has_bits);
          _impl_.needs_formula_rewrite_for_import_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 filter_offsets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_filter_offsets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_filter_offsets(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool filter_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_filter_enabled(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_filter_enabled(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilterSetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FilterSetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional bool is_enabled = 2 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_enabled(), target);
  }

  // repeated .TST.FilterRuleArchive filter_rules = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_filter_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_filter_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool needs_formula_rewrite_for_import = 4 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_needs_formula_rewrite_for_import(), target);
  }

  // repeated uint32 filter_offsets = 5;
  for (int i = 0, n = this->_internal_filter_offsets_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_filter_offsets(i), target);
  }

  // repeated bool filter_enabled = 6;
  for (int i = 0, n = this->_internal_filter_enabled_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_filter_enabled(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FilterSetArchive)
  return target;
}

size_t FilterSetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FilterSetArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.FilterRuleArchive filter_rules = 3;
  total_size += 1UL * this->_internal_filter_rules_size();
  for (const auto& msg : this->_impl_.filter_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 filter_offsets = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.filter_offsets_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_filter_offsets_size());
    total_size += data_size;
  }

  // repeated bool filter_enabled = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_filter_enabled_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_filter_enabled_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool needs_formula_rewrite_for_import = 4 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_enabled = 2 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FilterSetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FilterSetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FilterSetArchive::GetClassData() const { return &_class_data_; }


void FilterSetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FilterSetArchive*>(&to_msg);
  auto& from = static_cast<const FilterSetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FilterSetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.filter_rules_.MergeFrom(from._impl_.filter_rules_);
  _this->_impl_.filter_offsets_.MergeFrom(from._impl_.filter_offsets_);
  _this->_impl_.filter_enabled_.MergeFrom(from._impl_.filter_enabled_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.needs_formula_rewrite_for_import_ = from._impl_.needs_formula_rewrite_for_import_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.is_enabled_ = from._impl_.is_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FilterSetArchive::CopyFrom(const FilterSetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FilterSetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterSetArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.filter_rules_))
    return false;
  return true;
}

void FilterSetArchive::InternalSwap(FilterSetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.filter_rules_.InternalSwap(&other->_impl_.filter_rules_);
  _impl_.filter_offsets_.InternalSwap(&other->_impl_.filter_offsets_);
  _impl_.filter_enabled_.InternalSwap(&other->_impl_.filter_enabled_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FilterSetArchive, _impl_.needs_formula_rewrite_for_import_)
      + sizeof(FilterSetArchive::_impl_.needs_formula_rewrite_for_import_)
      - PROTOBUF_FIELD_OFFSET(FilterSetArchive, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
  swap(_impl_.is_enabled_, other->_impl_.is_enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FilterSetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[39]);
}

// ===================================================================

class TokenAttachmentArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TokenAttachmentArchive>()._impl_._has_bits_);
  static const ::TSWP::UIGraphicalAttachment& super(const TokenAttachmentArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& expressionnode(const TokenAttachmentArchive* msg);
  static void set_has_expressionnode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::UIGraphicalAttachment&
TokenAttachmentArchive::_Internal::super(const TokenAttachmentArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TokenAttachmentArchive::_Internal::expressionnode(const TokenAttachmentArchive* msg) {
  return *msg->_impl_.expressionnode_;
}
void TokenAttachmentArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TokenAttachmentArchive::clear_expressionnode() {
  if (_impl_.expressionnode_ != nullptr) _impl_.expressionnode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TokenAttachmentArchive::TokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TokenAttachmentArchive)
}
TokenAttachmentArchive::TokenAttachmentArchive(const TokenAttachmentArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TokenAttachmentArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.expressionnode_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::UIGraphicalAttachment(*from._impl_.super_);
  }
  if (from._internal_has_expressionnode()) {
    _this->_impl_.expressionnode_ = new ::TSP::Reference(*from._impl_.expressionnode_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.TokenAttachmentArchive)
}

inline void TokenAttachmentArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.expressionnode_){nullptr}
  };
}

TokenAttachmentArchive::~TokenAttachmentArchive() {
  // @@protoc_insertion_point(destructor:TST.TokenAttachmentArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TokenAttachmentArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.expressionnode_;
}

void TokenAttachmentArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TokenAttachmentArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.expressionnode_ != nullptr);
      _impl_.expressionnode_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TokenAttachmentArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.UIGraphicalAttachment super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference expressionNode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expressionnode(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TokenAttachmentArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.UIGraphicalAttachment super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference expressionNode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::expressionnode(this),
        _Internal::expressionnode(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TokenAttachmentArchive)
  return target;
}

size_t TokenAttachmentArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TokenAttachmentArchive)
  size_t total_size = 0;

  // required .TSWP.UIGraphicalAttachment super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference expressionNode = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expressionnode_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TokenAttachmentArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TokenAttachmentArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TokenAttachmentArchive::GetClassData() const { return &_class_data_; }


void TokenAttachmentArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TokenAttachmentArchive*>(&to_msg);
  auto& from = static_cast<const TokenAttachmentArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TokenAttachmentArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::UIGraphicalAttachment::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_expressionnode()->::TSP::Reference::MergeFrom(
          from._internal_expressionnode());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TokenAttachmentArchive::CopyFrom(const TokenAttachmentArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TokenAttachmentArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenAttachmentArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_expressionnode()) {
    if (!_impl_.expressionnode_->IsInitialized()) return false;
  }
  return true;
}

void TokenAttachmentArchive::InternalSwap(TokenAttachmentArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TokenAttachmentArchive, _impl_.expressionnode_)
      + sizeof(TokenAttachmentArchive::_impl_.expressionnode_)
      - PROTOBUF_FIELD_OFFSET(TokenAttachmentArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TokenAttachmentArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[40]);
}

// ===================================================================

class FormulaArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormulaArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& expressiontree(const FormulaArchive* msg);
  static void set_has_expressiontree(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
FormulaArchive::_Internal::expressiontree(const FormulaArchive* msg) {
  return *msg->_impl_.expressiontree_;
}
void FormulaArchive::clear_expressiontree() {
  if (_impl_.expressiontree_ != nullptr) _impl_.expressiontree_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FormulaArchive::FormulaArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FormulaArchive)
}
FormulaArchive::FormulaArchive(const FormulaArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormulaArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.expressiontree_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expressiontree()) {
    _this->_impl_.expressiontree_ = new ::TSP::Reference(*from._impl_.expressiontree_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.FormulaArchive)
}

inline void FormulaArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.expressiontree_){nullptr}
  };
}

FormulaArchive::~FormulaArchive() {
  // @@protoc_insertion_point(destructor:TST.FormulaArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormulaArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.expressiontree_;
}

void FormulaArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormulaArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FormulaArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.expressiontree_ != nullptr);
    _impl_.expressiontree_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormulaArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference expressionTree = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_expressiontree(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormulaArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FormulaArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference expressionTree = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::expressiontree(this),
        _Internal::expressiontree(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FormulaArchive)
  return target;
}

size_t FormulaArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FormulaArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference expressionTree = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expressiontree_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormulaArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormulaArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormulaArchive::GetClassData() const { return &_class_data_; }


void FormulaArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormulaArchive*>(&to_msg);
  auto& from = static_cast<const FormulaArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FormulaArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_expressiontree()) {
    _this->_internal_mutable_expressiontree()->::TSP::Reference::MergeFrom(
        from._internal_expressiontree());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormulaArchive::CopyFrom(const FormulaArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FormulaArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormulaArchive::IsInitialized() const {
  if (_internal_has_expressiontree()) {
    if (!_impl_.expressiontree_->IsInitialized()) return false;
  }
  return true;
}

void FormulaArchive::InternalSwap(FormulaArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.expressiontree_, other->_impl_.expressiontree_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FormulaArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[41]);
}

// ===================================================================

class ExpressionNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ExpressionNodeArchive>()._impl_._has_bits_);
  static void set_has_first_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

void ExpressionNodeArchive::clear_children() {
  _impl_.children_.Clear();
}
ExpressionNodeArchive::ExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ExpressionNodeArchive)
}
ExpressionNodeArchive::ExpressionNodeArchive(const ExpressionNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ExpressionNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.first_index_){}
    , decltype(_impl_.last_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.first_index_, &from._impl_.first_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_index_) -
    reinterpret_cast<char*>(&_impl_.first_index_)) + sizeof(_impl_.last_index_));
  // @@protoc_insertion_point(copy_constructor:TST.ExpressionNodeArchive)
}

inline void ExpressionNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.first_index_){uint64_t{0u}}
    , decltype(_impl_.last_index_){uint64_t{0u}}
  };
}

ExpressionNodeArchive::~ExpressionNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.ExpressionNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpressionNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.children_.~RepeatedPtrField();
}

void ExpressionNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExpressionNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ExpressionNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.children_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.first_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_index_) -
        reinterpret_cast<char*>(&_impl_.first_index_)) + sizeof(_impl_.last_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExpressionNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TSP.Reference children = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 first_index = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_first_index(&has_bits);
          _impl_.first_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 last_index = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_last_index(&has_bits);
          _impl_.last_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpressionNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ExpressionNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 first_index = 2 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_first_index(), target);
  }

  // optional uint64 last_index = 3 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_last_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ExpressionNodeArchive)
  return target;
}

size_t ExpressionNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ExpressionNodeArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference children = 1;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 first_index = 2 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_first_index());
    }

    // optional uint64 last_index = 3 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_last_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExpressionNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ExpressionNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExpressionNodeArchive::GetClassData() const { return &_class_data_; }


void ExpressionNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ExpressionNodeArchive*>(&to_msg);
  auto& from = static_cast<const ExpressionNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ExpressionNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.first_index_ = from._impl_.first_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.last_index_ = from._impl_.last_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExpressionNodeArchive::CopyFrom(const ExpressionNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ExpressionNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpressionNodeArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.children_))
    return false;
  return true;
}

void ExpressionNodeArchive::InternalSwap(ExpressionNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExpressionNodeArchive, _impl_.last_index_)
      + sizeof(ExpressionNodeArchive::_impl_.last_index_)
      - PROTOBUF_FIELD_OFFSET(ExpressionNodeArchive, _impl_.first_index_)>(
          reinterpret_cast<char*>(&_impl_.first_index_),
          reinterpret_cast<char*>(&other->_impl_.first_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExpressionNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[42]);
}

// ===================================================================

class BooleanNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<BooleanNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const BooleanNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
BooleanNodeArchive::_Internal::super(const BooleanNodeArchive* msg) {
  return *msg->_impl_.super_;
}
BooleanNodeArchive::BooleanNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.BooleanNodeArchive)
}
BooleanNodeArchive::BooleanNodeArchive(const BooleanNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BooleanNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:TST.BooleanNodeArchive)
}

inline void BooleanNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.value_){false}
  };
}

BooleanNodeArchive::~BooleanNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.BooleanNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void BooleanNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BooleanNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.BooleanNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.value_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BooleanNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BooleanNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.BooleanNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.BooleanNodeArchive)
  return target;
}

size_t BooleanNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.BooleanNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_value()) {
    // required bool value = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t BooleanNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.BooleanNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool value = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BooleanNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BooleanNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BooleanNodeArchive::GetClassData() const { return &_class_data_; }


void BooleanNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BooleanNodeArchive*>(&to_msg);
  auto& from = static_cast<const BooleanNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.BooleanNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.value_ = from._impl_.value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BooleanNodeArchive::CopyFrom(const BooleanNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.BooleanNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void BooleanNodeArchive::InternalSwap(BooleanNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BooleanNodeArchive, _impl_.value_)
      + sizeof(BooleanNodeArchive::_impl_.value_)
      - PROTOBUF_FIELD_OFFSET(BooleanNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BooleanNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[43]);
}

// ===================================================================

class NumberNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<NumberNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const NumberNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
NumberNodeArchive::_Internal::super(const NumberNodeArchive* msg) {
  return *msg->_impl_.super_;
}
NumberNodeArchive::NumberNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.NumberNodeArchive)
}
NumberNodeArchive::NumberNodeArchive(const NumberNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NumberNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  _this->_impl_.number_ = from._impl_.number_;
  // @@protoc_insertion_point(copy_constructor:TST.NumberNodeArchive)
}

inline void NumberNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.number_){0}
  };
}

NumberNodeArchive::~NumberNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.NumberNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NumberNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void NumberNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NumberNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.NumberNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.number_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NumberNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_number(&has_bits);
          _impl_.number_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NumberNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.NumberNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.NumberNodeArchive)
  return target;
}

size_t NumberNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.NumberNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_number()) {
    // required double number = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t NumberNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.NumberNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double number = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NumberNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NumberNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NumberNodeArchive::GetClassData() const { return &_class_data_; }


void NumberNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NumberNodeArchive*>(&to_msg);
  auto& from = static_cast<const NumberNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.NumberNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.number_ = from._impl_.number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NumberNodeArchive::CopyFrom(const NumberNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.NumberNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NumberNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void NumberNodeArchive::InternalSwap(NumberNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NumberNodeArchive, _impl_.number_)
      + sizeof(NumberNodeArchive::_impl_.number_)
      - PROTOBUF_FIELD_OFFSET(NumberNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata NumberNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[44]);
}

// ===================================================================

class StringNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StringNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const StringNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
StringNodeArchive::_Internal::super(const StringNodeArchive* msg) {
  return *msg->_impl_.super_;
}
StringNodeArchive::StringNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.StringNodeArchive)
}
StringNodeArchive::StringNodeArchive(const StringNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StringNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.StringNodeArchive)
}

inline void StringNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StringNodeArchive::~StringNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.StringNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StringNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.StringNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.StringNodeArchive.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.StringNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.StringNodeArchive.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.StringNodeArchive)
  return target;
}

size_t StringNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.StringNodeArchive)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t StringNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.StringNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StringNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringNodeArchive::GetClassData() const { return &_class_data_; }


void StringNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StringNodeArchive*>(&to_msg);
  auto& from = static_cast<const StringNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.StringNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringNodeArchive::CopyFrom(const StringNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.StringNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StringNodeArchive::InternalSwap(StringNodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[45]);
}

// ===================================================================

class IdentifierNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<IdentifierNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const IdentifierNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
IdentifierNodeArchive::_Internal::super(const IdentifierNodeArchive* msg) {
  return *msg->_impl_.super_;
}
IdentifierNodeArchive::IdentifierNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.IdentifierNodeArchive)
}
IdentifierNodeArchive::IdentifierNodeArchive(const IdentifierNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IdentifierNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    _this->_impl_.identifier_.Set(from._internal_identifier(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.IdentifierNodeArchive)
}

inline void IdentifierNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.identifier_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IdentifierNodeArchive::~IdentifierNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.IdentifierNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IdentifierNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.identifier_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void IdentifierNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IdentifierNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.IdentifierNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IdentifierNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.IdentifierNodeArchive.identifier");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IdentifierNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.IdentifierNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional string identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_identifier().data(), static_cast<int>(this->_internal_identifier().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.IdentifierNodeArchive.identifier");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.IdentifierNodeArchive)
  return target;
}

size_t IdentifierNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.IdentifierNodeArchive)
  size_t total_size = 0;

  // required .TST.ExpressionNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string identifier = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_identifier());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IdentifierNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IdentifierNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IdentifierNodeArchive::GetClassData() const { return &_class_data_; }


void IdentifierNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IdentifierNodeArchive*>(&to_msg);
  auto& from = static_cast<const IdentifierNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.IdentifierNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IdentifierNodeArchive::CopyFrom(const IdentifierNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.IdentifierNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdentifierNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void IdentifierNodeArchive::InternalSwap(IdentifierNodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.identifier_, lhs_arena,
      &other->_impl_.identifier_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IdentifierNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[46]);
}

// ===================================================================

class ArrayNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ArrayNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const ArrayNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
ArrayNodeArchive::_Internal::super(const ArrayNodeArchive* msg) {
  return *msg->_impl_.super_;
}
ArrayNodeArchive::ArrayNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ArrayNodeArchive)
}
ArrayNodeArchive::ArrayNodeArchive(const ArrayNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArrayNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.columns_){}
    , decltype(_impl_.rows_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.columns_, &from._impl_.columns_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rows_) -
    reinterpret_cast<char*>(&_impl_.columns_)) + sizeof(_impl_.rows_));
  // @@protoc_insertion_point(copy_constructor:TST.ArrayNodeArchive)
}

inline void ArrayNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.columns_){0u}
    , decltype(_impl_.rows_){0u}
  };
}

ArrayNodeArchive::~ArrayNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.ArrayNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArrayNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ArrayNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArrayNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ArrayNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.columns_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rows_) -
        reinterpret_cast<char*>(&_impl_.columns_)) + sizeof(_impl_.rows_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArrayNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 columns = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_columns(&has_bits);
          _impl_.columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rows(&has_bits);
          _impl_.rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArrayNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ArrayNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 columns = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_columns(), target);
  }

  // optional uint32 rows = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rows(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ArrayNodeArchive)
  return target;
}

size_t ArrayNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ArrayNodeArchive)
  size_t total_size = 0;

  // required .TST.ExpressionNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 columns = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_columns());
    }

    // optional uint32 rows = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rows());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArrayNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArrayNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArrayNodeArchive::GetClassData() const { return &_class_data_; }


void ArrayNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArrayNodeArchive*>(&to_msg);
  auto& from = static_cast<const ArrayNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ArrayNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.columns_ = from._impl_.columns_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rows_ = from._impl_.rows_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArrayNodeArchive::CopyFrom(const ArrayNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ArrayNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArrayNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ArrayNodeArchive::InternalSwap(ArrayNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArrayNodeArchive, _impl_.rows_)
      + sizeof(ArrayNodeArchive::_impl_.rows_)
      - PROTOBUF_FIELD_OFFSET(ArrayNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArrayNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[47]);
}

// ===================================================================

class ListNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ListNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const ListNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
ListNodeArchive::_Internal::super(const ListNodeArchive* msg) {
  return *msg->_impl_.super_;
}
ListNodeArchive::ListNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ListNodeArchive)
}
ListNodeArchive::ListNodeArchive(const ListNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.ListNodeArchive)
}

inline void ListNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ListNodeArchive::~ListNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.ListNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ListNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ListNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ListNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ListNodeArchive)
  return target;
}

size_t ListNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ListNodeArchive)
  size_t total_size = 0;

  // required .TST.ExpressionNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListNodeArchive::GetClassData() const { return &_class_data_; }


void ListNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListNodeArchive*>(&to_msg);
  auto& from = static_cast<const ListNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ListNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListNodeArchive::CopyFrom(const ListNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ListNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ListNodeArchive::InternalSwap(ListNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[48]);
}

// ===================================================================

class OperatorNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<OperatorNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const OperatorNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_operatorchar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
OperatorNodeArchive::_Internal::super(const OperatorNodeArchive* msg) {
  return *msg->_impl_.super_;
}
OperatorNodeArchive::OperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.OperatorNodeArchive)
}
OperatorNodeArchive::OperatorNodeArchive(const OperatorNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OperatorNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.operatorchar_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  _this->_impl_.operatorchar_ = from._impl_.operatorchar_;
  // @@protoc_insertion_point(copy_constructor:TST.OperatorNodeArchive)
}

inline void OperatorNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.operatorchar_){0u}
  };
}

OperatorNodeArchive::~OperatorNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.OperatorNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OperatorNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void OperatorNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OperatorNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.OperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.operatorchar_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OperatorNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 operatorChar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_operatorchar(&has_bits);
          _impl_.operatorchar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OperatorNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.OperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 operatorChar = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_operatorchar(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.OperatorNodeArchive)
  return target;
}

size_t OperatorNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.OperatorNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_operatorchar()) {
    // required uint32 operatorChar = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_operatorchar());
  }

  return total_size;
}
size_t OperatorNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.OperatorNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 operatorChar = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_operatorchar());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OperatorNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OperatorNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OperatorNodeArchive::GetClassData() const { return &_class_data_; }


void OperatorNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OperatorNodeArchive*>(&to_msg);
  auto& from = static_cast<const OperatorNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.OperatorNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.operatorchar_ = from._impl_.operatorchar_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OperatorNodeArchive::CopyFrom(const OperatorNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.OperatorNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperatorNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void OperatorNodeArchive::InternalSwap(OperatorNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OperatorNodeArchive, _impl_.operatorchar_)
      + sizeof(OperatorNodeArchive::_impl_.operatorchar_)
      - PROTOBUF_FIELD_OFFSET(OperatorNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OperatorNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[49]);
}

// ===================================================================

class PostfixOperatorNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PostfixOperatorNodeArchive>()._impl_._has_bits_);
  static const ::TST::OperatorNodeArchive& super(const PostfixOperatorNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::OperatorNodeArchive&
PostfixOperatorNodeArchive::_Internal::super(const PostfixOperatorNodeArchive* msg) {
  return *msg->_impl_.super_;
}
PostfixOperatorNodeArchive::PostfixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.PostfixOperatorNodeArchive)
}
PostfixOperatorNodeArchive::PostfixOperatorNodeArchive(const PostfixOperatorNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PostfixOperatorNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::OperatorNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.PostfixOperatorNodeArchive)
}

inline void PostfixOperatorNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

PostfixOperatorNodeArchive::~PostfixOperatorNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.PostfixOperatorNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PostfixOperatorNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void PostfixOperatorNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PostfixOperatorNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.PostfixOperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PostfixOperatorNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.OperatorNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PostfixOperatorNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.PostfixOperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.OperatorNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.PostfixOperatorNodeArchive)
  return target;
}

size_t PostfixOperatorNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.PostfixOperatorNodeArchive)
  size_t total_size = 0;

  // required .TST.OperatorNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PostfixOperatorNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PostfixOperatorNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PostfixOperatorNodeArchive::GetClassData() const { return &_class_data_; }


void PostfixOperatorNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PostfixOperatorNodeArchive*>(&to_msg);
  auto& from = static_cast<const PostfixOperatorNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.PostfixOperatorNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::OperatorNodeArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PostfixOperatorNodeArchive::CopyFrom(const PostfixOperatorNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.PostfixOperatorNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PostfixOperatorNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void PostfixOperatorNodeArchive::InternalSwap(PostfixOperatorNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PostfixOperatorNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[50]);
}

// ===================================================================

class PrefixOperatorNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<PrefixOperatorNodeArchive>()._impl_._has_bits_);
  static const ::TST::OperatorNodeArchive& super(const PrefixOperatorNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::OperatorNodeArchive&
PrefixOperatorNodeArchive::_Internal::super(const PrefixOperatorNodeArchive* msg) {
  return *msg->_impl_.super_;
}
PrefixOperatorNodeArchive::PrefixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.PrefixOperatorNodeArchive)
}
PrefixOperatorNodeArchive::PrefixOperatorNodeArchive(const PrefixOperatorNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrefixOperatorNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::OperatorNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.PrefixOperatorNodeArchive)
}

inline void PrefixOperatorNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

PrefixOperatorNodeArchive::~PrefixOperatorNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.PrefixOperatorNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrefixOperatorNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void PrefixOperatorNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrefixOperatorNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.PrefixOperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrefixOperatorNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.OperatorNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrefixOperatorNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.PrefixOperatorNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.OperatorNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.PrefixOperatorNodeArchive)
  return target;
}

size_t PrefixOperatorNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.PrefixOperatorNodeArchive)
  size_t total_size = 0;

  // required .TST.OperatorNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrefixOperatorNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrefixOperatorNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrefixOperatorNodeArchive::GetClassData() const { return &_class_data_; }


void PrefixOperatorNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrefixOperatorNodeArchive*>(&to_msg);
  auto& from = static_cast<const PrefixOperatorNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.PrefixOperatorNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::OperatorNodeArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrefixOperatorNodeArchive::CopyFrom(const PrefixOperatorNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.PrefixOperatorNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrefixOperatorNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void PrefixOperatorNodeArchive::InternalSwap(PrefixOperatorNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrefixOperatorNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[51]);
}

// ===================================================================

class FunctionNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FunctionNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const FunctionNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_functionindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_invalidfunctionname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
FunctionNodeArchive::_Internal::super(const FunctionNodeArchive* msg) {
  return *msg->_impl_.super_;
}
FunctionNodeArchive::FunctionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FunctionNodeArchive)
}
FunctionNodeArchive::FunctionNodeArchive(const FunctionNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FunctionNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidfunctionname_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.functionindex_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.invalidfunctionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidfunctionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invalidfunctionname()) {
    _this->_impl_.invalidfunctionname_.Set(from._internal_invalidfunctionname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  _this->_impl_.functionindex_ = from._impl_.functionindex_;
  // @@protoc_insertion_point(copy_constructor:TST.FunctionNodeArchive)
}

inline void FunctionNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.invalidfunctionname_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.functionindex_){0u}
  };
  _impl_.invalidfunctionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidfunctionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FunctionNodeArchive::~FunctionNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.FunctionNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FunctionNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.invalidfunctionname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void FunctionNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FunctionNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FunctionNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.invalidfunctionname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.functionindex_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 functionIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_functionindex(&has_bits);
          _impl_.functionindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string invalidFunctionName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_invalidfunctionname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.FunctionNodeArchive.invalidFunctionName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FunctionNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FunctionNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 functionIndex = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_functionindex(), target);
  }

  // optional string invalidFunctionName = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_invalidfunctionname().data(), static_cast<int>(this->_internal_invalidfunctionname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.FunctionNodeArchive.invalidFunctionName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_invalidfunctionname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FunctionNodeArchive)
  return target;
}

size_t FunctionNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.FunctionNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_functionindex()) {
    // required uint32 functionIndex = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_functionindex());
  }

  return total_size;
}
size_t FunctionNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FunctionNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 functionIndex = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_functionindex());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string invalidFunctionName = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_invalidfunctionname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FunctionNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FunctionNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FunctionNodeArchive::GetClassData() const { return &_class_data_; }


void FunctionNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FunctionNodeArchive*>(&to_msg);
  auto& from = static_cast<const FunctionNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FunctionNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_invalidfunctionname(from._internal_invalidfunctionname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.functionindex_ = from._impl_.functionindex_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FunctionNodeArchive::CopyFrom(const FunctionNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FunctionNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void FunctionNodeArchive::InternalSwap(FunctionNodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.invalidfunctionname_, lhs_arena,
      &other->_impl_.invalidfunctionname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FunctionNodeArchive, _impl_.functionindex_)
      + sizeof(FunctionNodeArchive::_impl_.functionindex_)
      - PROTOBUF_FIELD_OFFSET(FunctionNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[52]);
}

// ===================================================================

class FunctionEndNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FunctionEndNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const FunctionEndNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
FunctionEndNodeArchive::_Internal::super(const FunctionEndNodeArchive* msg) {
  return *msg->_impl_.super_;
}
FunctionEndNodeArchive::FunctionEndNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FunctionEndNodeArchive)
}
FunctionEndNodeArchive::FunctionEndNodeArchive(const FunctionEndNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FunctionEndNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.FunctionEndNodeArchive)
}

inline void FunctionEndNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

FunctionEndNodeArchive::~FunctionEndNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.FunctionEndNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FunctionEndNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void FunctionEndNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FunctionEndNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FunctionEndNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FunctionEndNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FunctionEndNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FunctionEndNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FunctionEndNodeArchive)
  return target;
}

size_t FunctionEndNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FunctionEndNodeArchive)
  size_t total_size = 0;

  // required .TST.ExpressionNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FunctionEndNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FunctionEndNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FunctionEndNodeArchive::GetClassData() const { return &_class_data_; }


void FunctionEndNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FunctionEndNodeArchive*>(&to_msg);
  auto& from = static_cast<const FunctionEndNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FunctionEndNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FunctionEndNodeArchive::CopyFrom(const FunctionEndNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FunctionEndNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionEndNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void FunctionEndNodeArchive::InternalSwap(FunctionEndNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FunctionEndNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[53]);
}

// ===================================================================

class DateNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DateNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const DateNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
DateNodeArchive::_Internal::super(const DateNodeArchive* msg) {
  return *msg->_impl_.super_;
}
DateNodeArchive::DateNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DateNodeArchive)
}
DateNodeArchive::DateNodeArchive(const DateNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DateNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_format()) {
    _this->_impl_.format_.Set(from._internal_format(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.DateNodeArchive)
}

inline void DateNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DateNodeArchive::~DateNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.DateNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  _impl_.format_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DateNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DateNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DateNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.format_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DateNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.DateNodeArchive.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.DateNodeArchive.format");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DateNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.DateNodeArchive.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional string format = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_format().data(), static_cast<int>(this->_internal_format().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.DateNodeArchive.format");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DateNodeArchive)
  return target;
}

size_t DateNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.DateNodeArchive)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t DateNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DateNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string format = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_format());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DateNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DateNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DateNodeArchive::GetClassData() const { return &_class_data_; }


void DateNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DateNodeArchive*>(&to_msg);
  auto& from = static_cast<const DateNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DateNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_format(from._internal_format());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DateNodeArchive::CopyFrom(const DateNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DateNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DateNodeArchive::InternalSwap(DateNodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.format_, lhs_arena,
      &other->_impl_.format_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DateNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[54]);
}

// ===================================================================

class ReferenceNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReferenceNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const ReferenceNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::RangeReferenceArchive& rangereference(const ReferenceNodeArchive* msg);
  static void set_has_rangereference(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stickybits(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hosttableid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
ReferenceNodeArchive::_Internal::super(const ReferenceNodeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::RangeReferenceArchive&
ReferenceNodeArchive::_Internal::rangereference(const ReferenceNodeArchive* msg) {
  return *msg->_impl_.rangereference_;
}
void ReferenceNodeArchive::clear_rangereference() {
  if (_impl_.rangereference_ != nullptr) _impl_.rangereference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ReferenceNodeArchive::ReferenceNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ReferenceNodeArchive)
}
ReferenceNodeArchive::ReferenceNodeArchive(const ReferenceNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReferenceNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hosttableid_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.rangereference_){nullptr}
    , decltype(_impl_.stickybits_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hosttableid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hosttableid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hosttableid()) {
    _this->_impl_.hosttableid_.Set(from._internal_hosttableid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  if (from._internal_has_rangereference()) {
    _this->_impl_.rangereference_ = new ::TSCE::RangeReferenceArchive(*from._impl_.rangereference_);
  }
  _this->_impl_.stickybits_ = from._impl_.stickybits_;
  // @@protoc_insertion_point(copy_constructor:TST.ReferenceNodeArchive)
}

inline void ReferenceNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hosttableid_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.rangereference_){nullptr}
    , decltype(_impl_.stickybits_){0u}
  };
  _impl_.hosttableid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hosttableid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReferenceNodeArchive::~ReferenceNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.ReferenceNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReferenceNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hosttableid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.rangereference_;
}

void ReferenceNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReferenceNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ReferenceNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hosttableid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.rangereference_ != nullptr);
      _impl_.rangereference_->Clear();
    }
  }
  _impl_.stickybits_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReferenceNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.RangeReferenceArchive rangeReference = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rangereference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 stickyBits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_stickybits(&has_bits);
          _impl_.stickybits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hostTableID = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hosttableid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.ReferenceNodeArchive.hostTableID");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReferenceNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ReferenceNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.RangeReferenceArchive rangeReference = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rangereference(this),
        _Internal::rangereference(this).GetCachedSize(), target, stream);
  }

  // required uint32 stickyBits = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_stickybits(), target);
  }

  // optional string hostTableID = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hosttableid().data(), static_cast<int>(this->_internal_hosttableid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.ReferenceNodeArchive.hostTableID");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hosttableid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ReferenceNodeArchive)
  return target;
}

size_t ReferenceNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.ReferenceNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_rangereference()) {
    // required .TSCE.RangeReferenceArchive rangeReference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rangereference_);
  }

  if (_internal_has_stickybits()) {
    // required uint32 stickyBits = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stickybits());
  }

  return total_size;
}
size_t ReferenceNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ReferenceNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.RangeReferenceArchive rangeReference = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rangereference_);

    // required uint32 stickyBits = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_stickybits());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string hostTableID = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hosttableid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReferenceNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReferenceNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReferenceNodeArchive::GetClassData() const { return &_class_data_; }


void ReferenceNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReferenceNodeArchive*>(&to_msg);
  auto& from = static_cast<const ReferenceNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ReferenceNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hosttableid(from._internal_hosttableid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_rangereference()->::TSCE::RangeReferenceArchive::MergeFrom(
          from._internal_rangereference());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.stickybits_ = from._impl_.stickybits_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReferenceNodeArchive::CopyFrom(const ReferenceNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ReferenceNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReferenceNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_rangereference()) {
    if (!_impl_.rangereference_->IsInitialized()) return false;
  }
  return true;
}

void ReferenceNodeArchive::InternalSwap(ReferenceNodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hosttableid_, lhs_arena,
      &other->_impl_.hosttableid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReferenceNodeArchive, _impl_.stickybits_)
      + sizeof(ReferenceNodeArchive::_impl_.stickybits_)
      - PROTOBUF_FIELD_OFFSET(ReferenceNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReferenceNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[55]);
}

// ===================================================================

class DurationNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DurationNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const DurationNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timeinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_smallest(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_largest(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
DurationNodeArchive::_Internal::super(const DurationNodeArchive* msg) {
  return *msg->_impl_.super_;
}
DurationNodeArchive::DurationNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DurationNodeArchive)
}
DurationNodeArchive::DurationNodeArchive(const DurationNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DurationNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.timeinterval_){}
    , decltype(_impl_.smallest_){}
    , decltype(_impl_.largest_){}
    , decltype(_impl_.style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.timeinterval_, &from._impl_.timeinterval_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.style_) -
    reinterpret_cast<char*>(&_impl_.timeinterval_)) + sizeof(_impl_.style_));
  // @@protoc_insertion_point(copy_constructor:TST.DurationNodeArchive)
}

inline void DurationNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.timeinterval_){0}
    , decltype(_impl_.smallest_){0u}
    , decltype(_impl_.largest_){0u}
    , decltype(_impl_.style_){0u}
  };
}

DurationNodeArchive::~DurationNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.DurationNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DurationNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DurationNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DurationNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DurationNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.timeinterval_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.style_) -
        reinterpret_cast<char*>(&_impl_.timeinterval_)) + sizeof(_impl_.style_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DurationNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double timeinterval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_timeinterval(&has_bits);
          _impl_.timeinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 smallest = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_smallest(&has_bits);
          _impl_.smallest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 largest = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_largest(&has_bits);
          _impl_.largest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_style(&has_bits);
          _impl_.style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DurationNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DurationNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double timeinterval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_timeinterval(), target);
  }

  // required uint32 smallest = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_smallest(), target);
  }

  // required uint32 largest = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_largest(), target);
  }

  // required uint32 style = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DurationNodeArchive)
  return target;
}

size_t DurationNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.DurationNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_timeinterval()) {
    // required double timeinterval = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_smallest()) {
    // required uint32 smallest = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_smallest());
  }

  if (_internal_has_largest()) {
    // required uint32 largest = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_largest());
  }

  if (_internal_has_style()) {
    // required uint32 style = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_style());
  }

  return total_size;
}
size_t DurationNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DurationNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double timeinterval = 2;
    total_size += 1 + 8;

    // required uint32 smallest = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_smallest());

    // required uint32 largest = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_largest());

    // required uint32 style = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_style());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DurationNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DurationNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DurationNodeArchive::GetClassData() const { return &_class_data_; }


void DurationNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DurationNodeArchive*>(&to_msg);
  auto& from = static_cast<const DurationNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DurationNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timeinterval_ = from._impl_.timeinterval_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.smallest_ = from._impl_.smallest_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.largest_ = from._impl_.largest_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.style_ = from._impl_.style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DurationNodeArchive::CopyFrom(const DurationNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DurationNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DurationNodeArchive::InternalSwap(DurationNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DurationNodeArchive, _impl_.style_)
      + sizeof(DurationNodeArchive::_impl_.style_)
      - PROTOBUF_FIELD_OFFSET(DurationNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DurationNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[56]);
}

// ===================================================================

class ArgumentPlaceholderNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ArgumentPlaceholderNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const ArgumentPlaceholderNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_functionindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_argumentindex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
ArgumentPlaceholderNodeArchive::_Internal::super(const ArgumentPlaceholderNodeArchive* msg) {
  return *msg->_impl_.super_;
}
ArgumentPlaceholderNodeArchive::ArgumentPlaceholderNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.ArgumentPlaceholderNodeArchive)
}
ArgumentPlaceholderNodeArchive::ArgumentPlaceholderNodeArchive(const ArgumentPlaceholderNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ArgumentPlaceholderNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.functionindex_){}
    , decltype(_impl_.argumentindex_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.functionindex_, &from._impl_.functionindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mode_) -
    reinterpret_cast<char*>(&_impl_.functionindex_)) + sizeof(_impl_.mode_));
  // @@protoc_insertion_point(copy_constructor:TST.ArgumentPlaceholderNodeArchive)
}

inline void ArgumentPlaceholderNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.functionindex_){0u}
    , decltype(_impl_.argumentindex_){0u}
    , decltype(_impl_.mode_){0u}
  };
}

ArgumentPlaceholderNodeArchive::~ArgumentPlaceholderNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.ArgumentPlaceholderNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ArgumentPlaceholderNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ArgumentPlaceholderNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ArgumentPlaceholderNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.ArgumentPlaceholderNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.functionindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.mode_) -
        reinterpret_cast<char*>(&_impl_.functionindex_)) + sizeof(_impl_.mode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ArgumentPlaceholderNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 functionIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_functionindex(&has_bits);
          _impl_.functionindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 argumentIndex = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_argumentindex(&has_bits);
          _impl_.argumentindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 mode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ArgumentPlaceholderNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.ArgumentPlaceholderNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 functionIndex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_functionindex(), target);
  }

  // required uint32 argumentIndex = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_argumentindex(), target);
  }

  // optional uint32 mode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.ArgumentPlaceholderNodeArchive)
  return target;
}

size_t ArgumentPlaceholderNodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.ArgumentPlaceholderNodeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_functionindex()) {
    // required uint32 functionIndex = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_functionindex());
  }

  if (_internal_has_argumentindex()) {
    // required uint32 argumentIndex = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argumentindex());
  }

  return total_size;
}
size_t ArgumentPlaceholderNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.ArgumentPlaceholderNodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.ExpressionNodeArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 functionIndex = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_functionindex());

    // required uint32 argumentIndex = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_argumentindex());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 mode = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ArgumentPlaceholderNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ArgumentPlaceholderNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ArgumentPlaceholderNodeArchive::GetClassData() const { return &_class_data_; }


void ArgumentPlaceholderNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ArgumentPlaceholderNodeArchive*>(&to_msg);
  auto& from = static_cast<const ArgumentPlaceholderNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.ArgumentPlaceholderNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.functionindex_ = from._impl_.functionindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.argumentindex_ = from._impl_.argumentindex_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ArgumentPlaceholderNodeArchive::CopyFrom(const ArgumentPlaceholderNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.ArgumentPlaceholderNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArgumentPlaceholderNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ArgumentPlaceholderNodeArchive::InternalSwap(ArgumentPlaceholderNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ArgumentPlaceholderNodeArchive, _impl_.mode_)
      + sizeof(ArgumentPlaceholderNodeArchive::_impl_.mode_)
      - PROTOBUF_FIELD_OFFSET(ArgumentPlaceholderNodeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ArgumentPlaceholderNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[57]);
}

// ===================================================================

class EmptyExpressionNodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<EmptyExpressionNodeArchive>()._impl_._has_bits_);
  static const ::TST::ExpressionNodeArchive& super(const EmptyExpressionNodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::ExpressionNodeArchive&
EmptyExpressionNodeArchive::_Internal::super(const EmptyExpressionNodeArchive* msg) {
  return *msg->_impl_.super_;
}
EmptyExpressionNodeArchive::EmptyExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.EmptyExpressionNodeArchive)
}
EmptyExpressionNodeArchive::EmptyExpressionNodeArchive(const EmptyExpressionNodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EmptyExpressionNodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::ExpressionNodeArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.EmptyExpressionNodeArchive)
}

inline void EmptyExpressionNodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

EmptyExpressionNodeArchive::~EmptyExpressionNodeArchive() {
  // @@protoc_insertion_point(destructor:TST.EmptyExpressionNodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EmptyExpressionNodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void EmptyExpressionNodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EmptyExpressionNodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.EmptyExpressionNodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EmptyExpressionNodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.ExpressionNodeArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EmptyExpressionNodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.EmptyExpressionNodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.ExpressionNodeArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.EmptyExpressionNodeArchive)
  return target;
}

size_t EmptyExpressionNodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.EmptyExpressionNodeArchive)
  size_t total_size = 0;

  // required .TST.ExpressionNodeArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EmptyExpressionNodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EmptyExpressionNodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EmptyExpressionNodeArchive::GetClassData() const { return &_class_data_; }


void EmptyExpressionNodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EmptyExpressionNodeArchive*>(&to_msg);
  auto& from = static_cast<const EmptyExpressionNodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.EmptyExpressionNodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::ExpressionNodeArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EmptyExpressionNodeArchive::CopyFrom(const EmptyExpressionNodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.EmptyExpressionNodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmptyExpressionNodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void EmptyExpressionNodeArchive::InternalSwap(EmptyExpressionNodeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EmptyExpressionNodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[58]);
}

// ===================================================================

class LayoutHintArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<LayoutHintArchive>()._impl_._has_bits_);
  static void set_has_isvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TST::CellRange& cellrange(const LayoutHintArchive* msg);
  static void set_has_cellrange(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellID& hintid(const LayoutHintArchive* msg);
  static void set_has_hintid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Size& maximumsize(const LayoutHintArchive* msg);
  static void set_has_maximumsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_partitionposition(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_horizontal(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Size& effectivesize(const LayoutHintArchive* msg);
  static void set_has_effectivesize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_partitioningpass(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000077) ^ 0x00000077) != 0;
  }
};

const ::TST::CellRange&
LayoutHintArchive::_Internal::cellrange(const LayoutHintArchive* msg) {
  return *msg->_impl_.cellrange_;
}
const ::TST::CellID&
LayoutHintArchive::_Internal::hintid(const LayoutHintArchive* msg) {
  return *msg->_impl_.hintid_;
}
const ::TSP::Size&
LayoutHintArchive::_Internal::maximumsize(const LayoutHintArchive* msg) {
  return *msg->_impl_.maximumsize_;
}
const ::TSP::Size&
LayoutHintArchive::_Internal::effectivesize(const LayoutHintArchive* msg) {
  return *msg->_impl_.effectivesize_;
}
void LayoutHintArchive::clear_maximumsize() {
  if (_impl_.maximumsize_ != nullptr) _impl_.maximumsize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void LayoutHintArchive::clear_effectivesize() {
  if (_impl_.effectivesize_ != nullptr) _impl_.effectivesize_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
LayoutHintArchive::LayoutHintArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.LayoutHintArchive)
}
LayoutHintArchive::LayoutHintArchive(const LayoutHintArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LayoutHintArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellrange_){nullptr}
    , decltype(_impl_.hintid_){nullptr}
    , decltype(_impl_.maximumsize_){nullptr}
    , decltype(_impl_.effectivesize_){nullptr}
    , decltype(_impl_.isvalid_){}
    , decltype(_impl_.horizontal_){}
    , decltype(_impl_.partitionposition_){}
    , decltype(_impl_.partitioningpass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellrange()) {
    _this->_impl_.cellrange_ = new ::TST::CellRange(*from._impl_.cellrange_);
  }
  if (from._internal_has_hintid()) {
    _this->_impl_.hintid_ = new ::TST::CellID(*from._impl_.hintid_);
  }
  if (from._internal_has_maximumsize()) {
    _this->_impl_.maximumsize_ = new ::TSP::Size(*from._impl_.maximumsize_);
  }
  if (from._internal_has_effectivesize()) {
    _this->_impl_.effectivesize_ = new ::TSP::Size(*from._impl_.effectivesize_);
  }
  ::memcpy(&_impl_.isvalid_, &from._impl_.isvalid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.partitioningpass_) -
    reinterpret_cast<char*>(&_impl_.isvalid_)) + sizeof(_impl_.partitioningpass_));
  // @@protoc_insertion_point(copy_constructor:TST.LayoutHintArchive)
}

inline void LayoutHintArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellrange_){nullptr}
    , decltype(_impl_.hintid_){nullptr}
    , decltype(_impl_.maximumsize_){nullptr}
    , decltype(_impl_.effectivesize_){nullptr}
    , decltype(_impl_.isvalid_){false}
    , decltype(_impl_.horizontal_){false}
    , decltype(_impl_.partitionposition_){0u}
    , decltype(_impl_.partitioningpass_){0u}
  };
}

LayoutHintArchive::~LayoutHintArchive() {
  // @@protoc_insertion_point(destructor:TST.LayoutHintArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LayoutHintArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellrange_;
  if (this != internal_default_instance()) delete _impl_.hintid_;
  if (this != internal_default_instance()) delete _impl_.maximumsize_;
  if (this != internal_default_instance()) delete _impl_.effectivesize_;
}

void LayoutHintArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LayoutHintArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.LayoutHintArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellrange_ != nullptr);
      _impl_.cellrange_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.hintid_ != nullptr);
      _impl_.hintid_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.maximumsize_ != nullptr);
      _impl_.maximumsize_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.effectivesize_ != nullptr);
      _impl_.effectivesize_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.isvalid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.partitioningpass_) -
        reinterpret_cast<char*>(&_impl_.isvalid_)) + sizeof(_impl_.partitioningpass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LayoutHintArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool isValid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_isvalid(&has_bits);
          _impl_.isvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellRange cellRange = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellID hintID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hintid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Size maximumSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_maximumsize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 partitionPosition = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_partitionposition(&has_bits);
          _impl_.partitionposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool horizontal = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_horizontal(&has_bits);
          _impl_.horizontal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Size effectiveSize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_effectivesize(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 partitioningPass = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_partitioningpass(&has_bits);
          _impl_.partitioningpass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LayoutHintArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.LayoutHintArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool isValid = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_isvalid(), target);
  }

  // required .TST.CellRange cellRange = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cellrange(this),
        _Internal::cellrange(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellID hintID = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::hintid(this),
        _Internal::hintid(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Size maximumSize = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::maximumsize(this),
        _Internal::maximumsize(this).GetCachedSize(), target, stream);
  }

  // required uint32 partitionPosition = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_partitionposition(), target);
  }

  // required bool horizontal = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_horizontal(), target);
  }

  // optional .TSP.Size effectiveSize = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::effectivesize(this),
        _Internal::effectivesize(this).GetCachedSize(), target, stream);
  }

  // optional uint32 partitioningPass = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_partitioningpass(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.LayoutHintArchive)
  return target;
}

size_t LayoutHintArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.LayoutHintArchive)
  size_t total_size = 0;

  if (_internal_has_cellrange()) {
    // required .TST.CellRange cellRange = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellrange_);
  }

  if (_internal_has_hintid()) {
    // required .TST.CellID hintID = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.hintid_);
  }

  if (_internal_has_maximumsize()) {
    // required .TSP.Size maximumSize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.maximumsize_);
  }

  if (_internal_has_isvalid()) {
    // required bool isValid = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_horizontal()) {
    // required bool horizontal = 6;
    total_size += 1 + 1;
  }

  if (_internal_has_partitionposition()) {
    // required uint32 partitionPosition = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partitionposition());
  }

  return total_size;
}
size_t LayoutHintArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.LayoutHintArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000077) ^ 0x00000077) == 0) {  // All required fields are present.
    // required .TST.CellRange cellRange = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellrange_);

    // required .TST.CellID hintID = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.hintid_);

    // required .TSP.Size maximumSize = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.maximumsize_);

    // required bool isValid = 1;
    total_size += 1 + 1;

    // required bool horizontal = 6;
    total_size += 1 + 1;

    // required uint32 partitionPosition = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partitionposition());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Size effectiveSize = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.effectivesize_);
  }

  // optional uint32 partitioningPass = 8;
  if (cached_has_bits & 0x00000080u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_partitioningpass());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LayoutHintArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LayoutHintArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LayoutHintArchive::GetClassData() const { return &_class_data_; }


void LayoutHintArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LayoutHintArchive*>(&to_msg);
  auto& from = static_cast<const LayoutHintArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.LayoutHintArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellrange()->::TST::CellRange::MergeFrom(
          from._internal_cellrange());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_hintid()->::TST::CellID::MergeFrom(
          from._internal_hintid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_maximumsize()->::TSP::Size::MergeFrom(
          from._internal_maximumsize());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_effectivesize()->::TSP::Size::MergeFrom(
          from._internal_effectivesize());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.isvalid_ = from._impl_.isvalid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.horizontal_ = from._impl_.horizontal_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.partitionposition_ = from._impl_.partitionposition_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.partitioningpass_ = from._impl_.partitioningpass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LayoutHintArchive::CopyFrom(const LayoutHintArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.LayoutHintArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayoutHintArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellrange()) {
    if (!_impl_.cellrange_->IsInitialized()) return false;
  }
  if (_internal_has_hintid()) {
    if (!_impl_.hintid_->IsInitialized()) return false;
  }
  if (_internal_has_maximumsize()) {
    if (!_impl_.maximumsize_->IsInitialized()) return false;
  }
  if (_internal_has_effectivesize()) {
    if (!_impl_.effectivesize_->IsInitialized()) return false;
  }
  return true;
}

void LayoutHintArchive::InternalSwap(LayoutHintArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayoutHintArchive, _impl_.partitioningpass_)
      + sizeof(LayoutHintArchive::_impl_.partitioningpass_)
      - PROTOBUF_FIELD_OFFSET(LayoutHintArchive, _impl_.cellrange_)>(
          reinterpret_cast<char*>(&_impl_.cellrange_),
          reinterpret_cast<char*>(&other->_impl_.cellrange_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LayoutHintArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[59]);
}

// ===================================================================

class CompletionTokenAttachmentArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CompletionTokenAttachmentArchive>()._impl_._has_bits_);
  static const ::TST::TokenAttachmentArchive& super(const CompletionTokenAttachmentArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_completiontext(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_caretposition(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_prefixstart(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::TST::TokenAttachmentArchive&
CompletionTokenAttachmentArchive::_Internal::super(const CompletionTokenAttachmentArchive* msg) {
  return *msg->_impl_.super_;
}
CompletionTokenAttachmentArchive::CompletionTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CompletionTokenAttachmentArchive)
}
CompletionTokenAttachmentArchive::CompletionTokenAttachmentArchive(const CompletionTokenAttachmentArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CompletionTokenAttachmentArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.completiontext_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.caretposition_){}
    , decltype(_impl_.prefixstart_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.completiontext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.completiontext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_completiontext()) {
    _this->_impl_.completiontext_.Set(from._internal_completiontext(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TokenAttachmentArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.caretposition_, &from._impl_.caretposition_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prefixstart_) -
    reinterpret_cast<char*>(&_impl_.caretposition_)) + sizeof(_impl_.prefixstart_));
  // @@protoc_insertion_point(copy_constructor:TST.CompletionTokenAttachmentArchive)
}

inline void CompletionTokenAttachmentArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.completiontext_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.caretposition_){0u}
    , decltype(_impl_.prefixstart_){0u}
  };
  _impl_.completiontext_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.completiontext_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CompletionTokenAttachmentArchive::~CompletionTokenAttachmentArchive() {
  // @@protoc_insertion_point(destructor:TST.CompletionTokenAttachmentArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CompletionTokenAttachmentArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.completiontext_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CompletionTokenAttachmentArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CompletionTokenAttachmentArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CompletionTokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.completiontext_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.caretposition_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.prefixstart_) -
        reinterpret_cast<char*>(&_impl_.caretposition_)) + sizeof(_impl_.prefixstart_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompletionTokenAttachmentArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TokenAttachmentArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string completionText = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_completiontext();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CompletionTokenAttachmentArchive.completionText");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 caretPosition = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_caretposition(&has_bits);
          _impl_.caretposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 prefixStart = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prefixstart(&has_bits);
          _impl_.prefixstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CompletionTokenAttachmentArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CompletionTokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TokenAttachmentArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional string completionText = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_completiontext().data(), static_cast<int>(this->_internal_completiontext().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CompletionTokenAttachmentArchive.completionText");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_completiontext(), target);
  }

  // optional uint32 caretPosition = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_caretposition(), target);
  }

  // optional uint32 prefixStart = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_prefixstart(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CompletionTokenAttachmentArchive)
  return target;
}

size_t CompletionTokenAttachmentArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CompletionTokenAttachmentArchive)
  size_t total_size = 0;

  // required .TST.TokenAttachmentArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string completionText = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_completiontext());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional uint32 caretPosition = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_caretposition());
    }

    // optional uint32 prefixStart = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_prefixstart());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompletionTokenAttachmentArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CompletionTokenAttachmentArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompletionTokenAttachmentArchive::GetClassData() const { return &_class_data_; }


void CompletionTokenAttachmentArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CompletionTokenAttachmentArchive*>(&to_msg);
  auto& from = static_cast<const CompletionTokenAttachmentArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CompletionTokenAttachmentArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_completiontext(from._internal_completiontext());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::TokenAttachmentArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.caretposition_ = from._impl_.caretposition_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prefixstart_ = from._impl_.prefixstart_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompletionTokenAttachmentArchive::CopyFrom(const CompletionTokenAttachmentArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CompletionTokenAttachmentArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompletionTokenAttachmentArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CompletionTokenAttachmentArchive::InternalSwap(CompletionTokenAttachmentArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.completiontext_, lhs_arena,
      &other->_impl_.completiontext_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompletionTokenAttachmentArchive, _impl_.prefixstart_)
      + sizeof(CompletionTokenAttachmentArchive::_impl_.prefixstart_)
      - PROTOBUF_FIELD_OFFSET(CompletionTokenAttachmentArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CompletionTokenAttachmentArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[60]);
}

// ===================================================================

class HiddenStateFormulaOwnerArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<HiddenStateFormulaOwnerArchive>()._impl_._has_bits_);
  static const ::TSCE::CFUUIDArchive& owner_id(const HiddenStateFormulaOwnerArchive* msg);
  static void set_has_owner_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needs_to_update_filter_set_for_import(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSCE::CFUUIDArchive&
HiddenStateFormulaOwnerArchive::_Internal::owner_id(const HiddenStateFormulaOwnerArchive* msg) {
  return *msg->_impl_.owner_id_;
}
void HiddenStateFormulaOwnerArchive::clear_owner_id() {
  if (_impl_.owner_id_ != nullptr) _impl_.owner_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void HiddenStateFormulaOwnerArchive::clear_threshold_value() {
  _impl_.threshold_value_.Clear();
}
HiddenStateFormulaOwnerArchive::HiddenStateFormulaOwnerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.HiddenStateFormulaOwnerArchive)
}
HiddenStateFormulaOwnerArchive::HiddenStateFormulaOwnerArchive(const HiddenStateFormulaOwnerArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HiddenStateFormulaOwnerArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threshold_value_){from._impl_.threshold_value_}
    , decltype(_impl_.owner_id_){nullptr}
    , decltype(_impl_.needs_to_update_filter_set_for_import_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner_id()) {
    _this->_impl_.owner_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.owner_id_);
  }
  _this->_impl_.needs_to_update_filter_set_for_import_ = from._impl_.needs_to_update_filter_set_for_import_;
  // @@protoc_insertion_point(copy_constructor:TST.HiddenStateFormulaOwnerArchive)
}

inline void HiddenStateFormulaOwnerArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.threshold_value_){arena}
    , decltype(_impl_.owner_id_){nullptr}
    , decltype(_impl_.needs_to_update_filter_set_for_import_){false}
  };
}

HiddenStateFormulaOwnerArchive::~HiddenStateFormulaOwnerArchive() {
  // @@protoc_insertion_point(destructor:TST.HiddenStateFormulaOwnerArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HiddenStateFormulaOwnerArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.threshold_value_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.owner_id_;
}

void HiddenStateFormulaOwnerArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HiddenStateFormulaOwnerArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.HiddenStateFormulaOwnerArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.threshold_value_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.owner_id_ != nullptr);
    _impl_.owner_id_->Clear();
  }
  _impl_.needs_to_update_filter_set_for_import_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HiddenStateFormulaOwnerArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSCE.CFUUIDArchive owner_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSCE.CellValueArchive threshold_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threshold_value(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_to_update_filter_set_for_import = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_needs_to_update_filter_set_for_import(&has_bits);
          _impl_.needs_to_update_filter_set_for_import_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HiddenStateFormulaOwnerArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.HiddenStateFormulaOwnerArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSCE.CFUUIDArchive owner_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::owner_id(this),
        _Internal::owner_id(this).GetCachedSize(), target, stream);
  }

  // repeated .TSCE.CellValueArchive threshold_value = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threshold_value_size()); i < n; i++) {
    const auto& repfield = this->_internal_threshold_value(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool needs_to_update_filter_set_for_import = 3 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_needs_to_update_filter_set_for_import(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.HiddenStateFormulaOwnerArchive)
  return target;
}

size_t HiddenStateFormulaOwnerArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.HiddenStateFormulaOwnerArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSCE.CellValueArchive threshold_value = 2;
  total_size += 1UL * this->_internal_threshold_value_size();
  for (const auto& msg : this->_impl_.threshold_value_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSCE.CFUUIDArchive owner_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_id_);
    }

    // optional bool needs_to_update_filter_set_for_import = 3 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HiddenStateFormulaOwnerArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HiddenStateFormulaOwnerArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HiddenStateFormulaOwnerArchive::GetClassData() const { return &_class_data_; }


void HiddenStateFormulaOwnerArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HiddenStateFormulaOwnerArchive*>(&to_msg);
  auto& from = static_cast<const HiddenStateFormulaOwnerArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.HiddenStateFormulaOwnerArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.threshold_value_.MergeFrom(from._impl_.threshold_value_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_owner_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.needs_to_update_filter_set_for_import_ = from._impl_.needs_to_update_filter_set_for_import_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HiddenStateFormulaOwnerArchive::CopyFrom(const HiddenStateFormulaOwnerArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.HiddenStateFormulaOwnerArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HiddenStateFormulaOwnerArchive::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.threshold_value_))
    return false;
  return true;
}

void HiddenStateFormulaOwnerArchive::InternalSwap(HiddenStateFormulaOwnerArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.threshold_value_.InternalSwap(&other->_impl_.threshold_value_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HiddenStateFormulaOwnerArchive, _impl_.needs_to_update_filter_set_for_import_)
      + sizeof(HiddenStateFormulaOwnerArchive::_impl_.needs_to_update_filter_set_for_import_)
      - PROTOBUF_FIELD_OFFSET(HiddenStateFormulaOwnerArchive, _impl_.owner_id_)>(
          reinterpret_cast<char*>(&_impl_.owner_id_),
          reinterpret_cast<char*>(&other->_impl_.owner_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HiddenStateFormulaOwnerArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[61]);
}

// ===================================================================

class RichTextPayloadArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RichTextPayloadArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& storage(const RichTextPayloadArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Range& range(const RichTextPayloadArchive* msg);
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellID& cellid(const RichTextPayloadArchive* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::TSP::Reference&
RichTextPayloadArchive::_Internal::storage(const RichTextPayloadArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSP::Range&
RichTextPayloadArchive::_Internal::range(const RichTextPayloadArchive* msg) {
  return *msg->_impl_.range_;
}
const ::TST::CellID&
RichTextPayloadArchive::_Internal::cellid(const RichTextPayloadArchive* msg) {
  return *msg->_impl_.cellid_;
}
void RichTextPayloadArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RichTextPayloadArchive::clear_range() {
  if (_impl_.range_ != nullptr) _impl_.range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
RichTextPayloadArchive::RichTextPayloadArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.RichTextPayloadArchive)
}
RichTextPayloadArchive::RichTextPayloadArchive(const RichTextPayloadArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RichTextPayloadArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.range_){nullptr}
    , decltype(_impl_.cellid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_range()) {
    _this->_impl_.range_ = new ::TSP::Range(*from._impl_.range_);
  }
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.RichTextPayloadArchive)
}

inline void RichTextPayloadArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.range_){nullptr}
    , decltype(_impl_.cellid_){nullptr}
  };
}

RichTextPayloadArchive::~RichTextPayloadArchive() {
  // @@protoc_insertion_point(destructor:TST.RichTextPayloadArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RichTextPayloadArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.range_;
  if (this != internal_default_instance()) delete _impl_.cellid_;
}

void RichTextPayloadArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RichTextPayloadArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.RichTextPayloadArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.range_ != nullptr);
      _impl_.range_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
      _impl_.cellid_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RichTextPayloadArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference storage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Range range = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellID cellid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RichTextPayloadArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.RichTextPayloadArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference storage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Range range = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::range(this),
        _Internal::range(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellID cellid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.RichTextPayloadArchive)
  return target;
}

size_t RichTextPayloadArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.RichTextPayloadArchive)
  size_t total_size = 0;

  if (_internal_has_storage()) {
    // required .TSP.Reference storage = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_);
  }

  if (_internal_has_cellid()) {
    // required .TST.CellID cellid = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }

  return total_size;
}
size_t RichTextPayloadArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.RichTextPayloadArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .TSP.Reference storage = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_);

    // required .TST.CellID cellid = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Range range = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.range_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RichTextPayloadArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RichTextPayloadArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RichTextPayloadArchive::GetClassData() const { return &_class_data_; }


void RichTextPayloadArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RichTextPayloadArchive*>(&to_msg);
  auto& from = static_cast<const RichTextPayloadArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.RichTextPayloadArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_range()->::TSP::Range::MergeFrom(
          from._internal_range());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RichTextPayloadArchive::CopyFrom(const RichTextPayloadArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.RichTextPayloadArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RichTextPayloadArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_range()) {
    if (!_impl_.range_->IsInitialized()) return false;
  }
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  return true;
}

void RichTextPayloadArchive::InternalSwap(RichTextPayloadArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RichTextPayloadArchive, _impl_.cellid_)
      + sizeof(RichTextPayloadArchive::_impl_.cellid_)
      - PROTOBUF_FIELD_OFFSET(RichTextPayloadArchive, _impl_.storage_)>(
          reinterpret_cast<char*>(&_impl_.storage_),
          reinterpret_cast<char*>(&other->_impl_.storage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RichTextPayloadArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[62]);
}

// ===================================================================

class FormulaEqualsTokenAttachmentArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormulaEqualsTokenAttachmentArchive>()._impl_._has_bits_);
  static const ::TSWP::UIGraphicalAttachment& super(const FormulaEqualsTokenAttachmentArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSWP::UIGraphicalAttachment&
FormulaEqualsTokenAttachmentArchive::_Internal::super(const FormulaEqualsTokenAttachmentArchive* msg) {
  return *msg->_impl_.super_;
}
void FormulaEqualsTokenAttachmentArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FormulaEqualsTokenAttachmentArchive::FormulaEqualsTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FormulaEqualsTokenAttachmentArchive)
}
FormulaEqualsTokenAttachmentArchive::FormulaEqualsTokenAttachmentArchive(const FormulaEqualsTokenAttachmentArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormulaEqualsTokenAttachmentArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::UIGraphicalAttachment(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.FormulaEqualsTokenAttachmentArchive)
}

inline void FormulaEqualsTokenAttachmentArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

FormulaEqualsTokenAttachmentArchive::~FormulaEqualsTokenAttachmentArchive() {
  // @@protoc_insertion_point(destructor:TST.FormulaEqualsTokenAttachmentArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormulaEqualsTokenAttachmentArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void FormulaEqualsTokenAttachmentArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormulaEqualsTokenAttachmentArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FormulaEqualsTokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormulaEqualsTokenAttachmentArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSWP.UIGraphicalAttachment super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormulaEqualsTokenAttachmentArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FormulaEqualsTokenAttachmentArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSWP.UIGraphicalAttachment super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FormulaEqualsTokenAttachmentArchive)
  return target;
}

size_t FormulaEqualsTokenAttachmentArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FormulaEqualsTokenAttachmentArchive)
  size_t total_size = 0;

  // required .TSWP.UIGraphicalAttachment super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormulaEqualsTokenAttachmentArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormulaEqualsTokenAttachmentArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormulaEqualsTokenAttachmentArchive::GetClassData() const { return &_class_data_; }


void FormulaEqualsTokenAttachmentArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormulaEqualsTokenAttachmentArchive*>(&to_msg);
  auto& from = static_cast<const FormulaEqualsTokenAttachmentArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FormulaEqualsTokenAttachmentArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSWP::UIGraphicalAttachment::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormulaEqualsTokenAttachmentArchive::CopyFrom(const FormulaEqualsTokenAttachmentArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FormulaEqualsTokenAttachmentArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormulaEqualsTokenAttachmentArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FormulaEqualsTokenAttachmentArchive::InternalSwap(FormulaEqualsTokenAttachmentArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FormulaEqualsTokenAttachmentArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[63]);
}

// ===================================================================

class CellRegion::_Internal {
 public:
};

CellRegion::CellRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CellRegion)
}
CellRegion::CellRegion(const CellRegion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CellRegion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_ranges_){from._impl_.cell_ranges_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TST.CellRegion)
}

inline void CellRegion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cell_ranges_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CellRegion::~CellRegion() {
  // @@protoc_insertion_point(destructor:TST.CellRegion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CellRegion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cell_ranges_.~RepeatedPtrField();
}

void CellRegion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CellRegion::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CellRegion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cell_ranges_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CellRegion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .TST.CellRange cell_ranges = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cell_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CellRegion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CellRegion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TST.CellRange cell_ranges = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CellRegion)
  return target;
}

size_t CellRegion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CellRegion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CellRange cell_ranges = 1;
  total_size += 1UL * this->_internal_cell_ranges_size();
  for (const auto& msg : this->_impl_.cell_ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CellRegion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CellRegion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CellRegion::GetClassData() const { return &_class_data_; }


void CellRegion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CellRegion*>(&to_msg);
  auto& from = static_cast<const CellRegion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CellRegion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cell_ranges_.MergeFrom(from._impl_.cell_ranges_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CellRegion::CopyFrom(const CellRegion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CellRegion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CellRegion::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cell_ranges_))
    return false;
  return true;
}

void CellRegion::InternalSwap(CellRegion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cell_ranges_.InternalSwap(&other->_impl_.cell_ranges_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CellRegion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTArchives_2eproto_getter, &descriptor_table_TSTArchives_2eproto_once,
      file_level_metadata_TSTArchives_2eproto[64]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TST
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TST::CellID*
Arena::CreateMaybeMessage< ::TST::CellID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellID >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableSize*
Arena::CreateMaybeMessage< ::TST::TableSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableSize >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CellRange*
Arena::CreateMaybeMessage< ::TST::CellRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellRange >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableSelection*
Arena::CreateMaybeMessage< ::TST::TableSelection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableSelection >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TileRowInfo*
Arena::CreateMaybeMessage< ::TST::TileRowInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TileRowInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::Tile*
Arena::CreateMaybeMessage< ::TST::Tile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::Tile >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TileStorage_Tile*
Arena::CreateMaybeMessage< ::TST::TileStorage_Tile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TileStorage_Tile >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TileStorage*
Arena::CreateMaybeMessage< ::TST::TileStorage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TileStorage >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::PopUpMenuModel_CellValue*
Arena::CreateMaybeMessage< ::TST::PopUpMenuModel_CellValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::PopUpMenuModel_CellValue >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::PopUpMenuModel*
Arena::CreateMaybeMessage< ::TST::PopUpMenuModel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::PopUpMenuModel >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableDataList_ListEntry*
Arena::CreateMaybeMessage< ::TST::TableDataList_ListEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableDataList_ListEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableDataList*
Arena::CreateMaybeMessage< ::TST::TableDataList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableDataList >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableRBTree_Node*
Arena::CreateMaybeMessage< ::TST::TableRBTree_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableRBTree_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableRBTree*
Arena::CreateMaybeMessage< ::TST::TableRBTree >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableRBTree >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::HeaderStorageBucket_Header*
Arena::CreateMaybeMessage< ::TST::HeaderStorageBucket_Header >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::HeaderStorageBucket_Header >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::HeaderStorageBucket*
Arena::CreateMaybeMessage< ::TST::HeaderStorageBucket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::HeaderStorageBucket >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::HeaderStorage*
Arena::CreateMaybeMessage< ::TST::HeaderStorage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::HeaderStorage >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DataStore*
Arena::CreateMaybeMessage< ::TST::DataStore >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DataStore >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableInfoArchive*
Arena::CreateMaybeMessage< ::TST::TableInfoArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableInfoArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::EditingStateArchive*
Arena::CreateMaybeMessage< ::TST::EditingStateArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::EditingStateArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::WPTableInfoArchive*
Arena::CreateMaybeMessage< ::TST::WPTableInfoArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::WPTableInfoArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableStyleNetworkArchive*
Arena::CreateMaybeMessage< ::TST::TableStyleNetworkArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableStyleNetworkArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableModelArchive*
Arena::CreateMaybeMessage< ::TST::TableModelArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableModelArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DurationWrapperArchive*
Arena::CreateMaybeMessage< ::TST::DurationWrapperArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DurationWrapperArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::Cell*
Arena::CreateMaybeMessage< ::TST::Cell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::Cell >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::MergeRegionMapArchive*
Arena::CreateMaybeMessage< ::TST::MergeRegionMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::MergeRegionMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CellMapArchive_CellMapEntry*
Arena::CreateMaybeMessage< ::TST::CellMapArchive_CellMapEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellMapArchive_CellMapEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CellMapArchive*
Arena::CreateMaybeMessage< ::TST::CellMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive*
Arena::CreateMaybeMessage< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DoubleStyleMapArchive*
Arena::CreateMaybeMessage< ::TST::DoubleStyleMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DoubleStyleMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::StyleTableMapArchive_StyleTableMapEntryArchive*
Arena::CreateMaybeMessage< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::StyleTableMapArchive*
Arena::CreateMaybeMessage< ::TST::StyleTableMapArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::StyleTableMapArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::SelectionArchive*
Arena::CreateMaybeMessage< ::TST::SelectionArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::SelectionArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FilterRuleArchive*
Arena::CreateMaybeMessage< ::TST::FilterRuleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FilterRuleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableStyleArchive*
Arena::CreateMaybeMessage< ::TST::TableStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CellStyleArchive*
Arena::CreateMaybeMessage< ::TST::CellStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FormulaPredicateArchive*
Arena::CreateMaybeMessage< ::TST::FormulaPredicateArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FormulaPredicateArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ConditionalStyleSetArchive_ConditionalStyleRule*
Arena::CreateMaybeMessage< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ConditionalStyleSetArchive*
Arena::CreateMaybeMessage< ::TST::ConditionalStyleSetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ConditionalStyleSetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FilterSetArchive*
Arena::CreateMaybeMessage< ::TST::FilterSetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FilterSetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TokenAttachmentArchive*
Arena::CreateMaybeMessage< ::TST::TokenAttachmentArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TokenAttachmentArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FormulaArchive*
Arena::CreateMaybeMessage< ::TST::FormulaArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FormulaArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ExpressionNodeArchive*
Arena::CreateMaybeMessage< ::TST::ExpressionNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ExpressionNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::BooleanNodeArchive*
Arena::CreateMaybeMessage< ::TST::BooleanNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::BooleanNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::NumberNodeArchive*
Arena::CreateMaybeMessage< ::TST::NumberNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::NumberNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::StringNodeArchive*
Arena::CreateMaybeMessage< ::TST::StringNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::StringNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::IdentifierNodeArchive*
Arena::CreateMaybeMessage< ::TST::IdentifierNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::IdentifierNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ArrayNodeArchive*
Arena::CreateMaybeMessage< ::TST::ArrayNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ArrayNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ListNodeArchive*
Arena::CreateMaybeMessage< ::TST::ListNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ListNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::OperatorNodeArchive*
Arena::CreateMaybeMessage< ::TST::OperatorNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::OperatorNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::PostfixOperatorNodeArchive*
Arena::CreateMaybeMessage< ::TST::PostfixOperatorNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::PostfixOperatorNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::PrefixOperatorNodeArchive*
Arena::CreateMaybeMessage< ::TST::PrefixOperatorNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::PrefixOperatorNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FunctionNodeArchive*
Arena::CreateMaybeMessage< ::TST::FunctionNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FunctionNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FunctionEndNodeArchive*
Arena::CreateMaybeMessage< ::TST::FunctionEndNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FunctionEndNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DateNodeArchive*
Arena::CreateMaybeMessage< ::TST::DateNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DateNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ReferenceNodeArchive*
Arena::CreateMaybeMessage< ::TST::ReferenceNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ReferenceNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DurationNodeArchive*
Arena::CreateMaybeMessage< ::TST::DurationNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DurationNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::ArgumentPlaceholderNodeArchive*
Arena::CreateMaybeMessage< ::TST::ArgumentPlaceholderNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::ArgumentPlaceholderNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::EmptyExpressionNodeArchive*
Arena::CreateMaybeMessage< ::TST::EmptyExpressionNodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::EmptyExpressionNodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::LayoutHintArchive*
Arena::CreateMaybeMessage< ::TST::LayoutHintArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::LayoutHintArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CompletionTokenAttachmentArchive*
Arena::CreateMaybeMessage< ::TST::CompletionTokenAttachmentArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CompletionTokenAttachmentArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::HiddenStateFormulaOwnerArchive*
Arena::CreateMaybeMessage< ::TST::HiddenStateFormulaOwnerArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::HiddenStateFormulaOwnerArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::RichTextPayloadArchive*
Arena::CreateMaybeMessage< ::TST::RichTextPayloadArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::RichTextPayloadArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FormulaEqualsTokenAttachmentArchive*
Arena::CreateMaybeMessage< ::TST::FormulaEqualsTokenAttachmentArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FormulaEqualsTokenAttachmentArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CellRegion*
Arena::CreateMaybeMessage< ::TST::CellRegion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CellRegion >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
