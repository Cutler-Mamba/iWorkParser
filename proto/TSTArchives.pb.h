// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSTArchives.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TSTArchives_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TSTArchives_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "TSPMessages.pb.h"
#include "TSDArchives.pb.h"
#include "TSKArchives.pb.h"
#include "TSSArchives.pb.h"
#include "TSCEArchives.pb.h"
#include "TSWPArchives.pb.h"
#include "TSTStylePropertyArchiving.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TSTArchives_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TSTArchives_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TSTArchives_2eproto;
namespace TST {
class ArgumentPlaceholderNodeArchive;
struct ArgumentPlaceholderNodeArchiveDefaultTypeInternal;
extern ArgumentPlaceholderNodeArchiveDefaultTypeInternal _ArgumentPlaceholderNodeArchive_default_instance_;
class ArrayNodeArchive;
struct ArrayNodeArchiveDefaultTypeInternal;
extern ArrayNodeArchiveDefaultTypeInternal _ArrayNodeArchive_default_instance_;
class BooleanNodeArchive;
struct BooleanNodeArchiveDefaultTypeInternal;
extern BooleanNodeArchiveDefaultTypeInternal _BooleanNodeArchive_default_instance_;
class Cell;
struct CellDefaultTypeInternal;
extern CellDefaultTypeInternal _Cell_default_instance_;
class CellID;
struct CellIDDefaultTypeInternal;
extern CellIDDefaultTypeInternal _CellID_default_instance_;
class CellMapArchive;
struct CellMapArchiveDefaultTypeInternal;
extern CellMapArchiveDefaultTypeInternal _CellMapArchive_default_instance_;
class CellMapArchive_CellMapEntry;
struct CellMapArchive_CellMapEntryDefaultTypeInternal;
extern CellMapArchive_CellMapEntryDefaultTypeInternal _CellMapArchive_CellMapEntry_default_instance_;
class CellRange;
struct CellRangeDefaultTypeInternal;
extern CellRangeDefaultTypeInternal _CellRange_default_instance_;
class CellRegion;
struct CellRegionDefaultTypeInternal;
extern CellRegionDefaultTypeInternal _CellRegion_default_instance_;
class CellStyleArchive;
struct CellStyleArchiveDefaultTypeInternal;
extern CellStyleArchiveDefaultTypeInternal _CellStyleArchive_default_instance_;
class CompletionTokenAttachmentArchive;
struct CompletionTokenAttachmentArchiveDefaultTypeInternal;
extern CompletionTokenAttachmentArchiveDefaultTypeInternal _CompletionTokenAttachmentArchive_default_instance_;
class ConditionalStyleSetArchive;
struct ConditionalStyleSetArchiveDefaultTypeInternal;
extern ConditionalStyleSetArchiveDefaultTypeInternal _ConditionalStyleSetArchive_default_instance_;
class ConditionalStyleSetArchive_ConditionalStyleRule;
struct ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal;
extern ConditionalStyleSetArchive_ConditionalStyleRuleDefaultTypeInternal _ConditionalStyleSetArchive_ConditionalStyleRule_default_instance_;
class DataStore;
struct DataStoreDefaultTypeInternal;
extern DataStoreDefaultTypeInternal _DataStore_default_instance_;
class DateNodeArchive;
struct DateNodeArchiveDefaultTypeInternal;
extern DateNodeArchiveDefaultTypeInternal _DateNodeArchive_default_instance_;
class DoubleStyleMapArchive;
struct DoubleStyleMapArchiveDefaultTypeInternal;
extern DoubleStyleMapArchiveDefaultTypeInternal _DoubleStyleMapArchive_default_instance_;
class DoubleStyleMapArchive_DoubleStyleMapEntryArchive;
struct DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal;
extern DoubleStyleMapArchive_DoubleStyleMapEntryArchiveDefaultTypeInternal _DoubleStyleMapArchive_DoubleStyleMapEntryArchive_default_instance_;
class DurationNodeArchive;
struct DurationNodeArchiveDefaultTypeInternal;
extern DurationNodeArchiveDefaultTypeInternal _DurationNodeArchive_default_instance_;
class DurationWrapperArchive;
struct DurationWrapperArchiveDefaultTypeInternal;
extern DurationWrapperArchiveDefaultTypeInternal _DurationWrapperArchive_default_instance_;
class EditingStateArchive;
struct EditingStateArchiveDefaultTypeInternal;
extern EditingStateArchiveDefaultTypeInternal _EditingStateArchive_default_instance_;
class EmptyExpressionNodeArchive;
struct EmptyExpressionNodeArchiveDefaultTypeInternal;
extern EmptyExpressionNodeArchiveDefaultTypeInternal _EmptyExpressionNodeArchive_default_instance_;
class ExpressionNodeArchive;
struct ExpressionNodeArchiveDefaultTypeInternal;
extern ExpressionNodeArchiveDefaultTypeInternal _ExpressionNodeArchive_default_instance_;
class FilterRuleArchive;
struct FilterRuleArchiveDefaultTypeInternal;
extern FilterRuleArchiveDefaultTypeInternal _FilterRuleArchive_default_instance_;
class FilterSetArchive;
struct FilterSetArchiveDefaultTypeInternal;
extern FilterSetArchiveDefaultTypeInternal _FilterSetArchive_default_instance_;
class FormulaArchive;
struct FormulaArchiveDefaultTypeInternal;
extern FormulaArchiveDefaultTypeInternal _FormulaArchive_default_instance_;
class FormulaEqualsTokenAttachmentArchive;
struct FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal;
extern FormulaEqualsTokenAttachmentArchiveDefaultTypeInternal _FormulaEqualsTokenAttachmentArchive_default_instance_;
class FormulaPredicateArchive;
struct FormulaPredicateArchiveDefaultTypeInternal;
extern FormulaPredicateArchiveDefaultTypeInternal _FormulaPredicateArchive_default_instance_;
class FunctionEndNodeArchive;
struct FunctionEndNodeArchiveDefaultTypeInternal;
extern FunctionEndNodeArchiveDefaultTypeInternal _FunctionEndNodeArchive_default_instance_;
class FunctionNodeArchive;
struct FunctionNodeArchiveDefaultTypeInternal;
extern FunctionNodeArchiveDefaultTypeInternal _FunctionNodeArchive_default_instance_;
class HeaderStorage;
struct HeaderStorageDefaultTypeInternal;
extern HeaderStorageDefaultTypeInternal _HeaderStorage_default_instance_;
class HeaderStorageBucket;
struct HeaderStorageBucketDefaultTypeInternal;
extern HeaderStorageBucketDefaultTypeInternal _HeaderStorageBucket_default_instance_;
class HeaderStorageBucket_Header;
struct HeaderStorageBucket_HeaderDefaultTypeInternal;
extern HeaderStorageBucket_HeaderDefaultTypeInternal _HeaderStorageBucket_Header_default_instance_;
class HiddenStateFormulaOwnerArchive;
struct HiddenStateFormulaOwnerArchiveDefaultTypeInternal;
extern HiddenStateFormulaOwnerArchiveDefaultTypeInternal _HiddenStateFormulaOwnerArchive_default_instance_;
class IdentifierNodeArchive;
struct IdentifierNodeArchiveDefaultTypeInternal;
extern IdentifierNodeArchiveDefaultTypeInternal _IdentifierNodeArchive_default_instance_;
class LayoutHintArchive;
struct LayoutHintArchiveDefaultTypeInternal;
extern LayoutHintArchiveDefaultTypeInternal _LayoutHintArchive_default_instance_;
class ListNodeArchive;
struct ListNodeArchiveDefaultTypeInternal;
extern ListNodeArchiveDefaultTypeInternal _ListNodeArchive_default_instance_;
class MergeRegionMapArchive;
struct MergeRegionMapArchiveDefaultTypeInternal;
extern MergeRegionMapArchiveDefaultTypeInternal _MergeRegionMapArchive_default_instance_;
class NumberNodeArchive;
struct NumberNodeArchiveDefaultTypeInternal;
extern NumberNodeArchiveDefaultTypeInternal _NumberNodeArchive_default_instance_;
class OperatorNodeArchive;
struct OperatorNodeArchiveDefaultTypeInternal;
extern OperatorNodeArchiveDefaultTypeInternal _OperatorNodeArchive_default_instance_;
class PopUpMenuModel;
struct PopUpMenuModelDefaultTypeInternal;
extern PopUpMenuModelDefaultTypeInternal _PopUpMenuModel_default_instance_;
class PopUpMenuModel_CellValue;
struct PopUpMenuModel_CellValueDefaultTypeInternal;
extern PopUpMenuModel_CellValueDefaultTypeInternal _PopUpMenuModel_CellValue_default_instance_;
class PostfixOperatorNodeArchive;
struct PostfixOperatorNodeArchiveDefaultTypeInternal;
extern PostfixOperatorNodeArchiveDefaultTypeInternal _PostfixOperatorNodeArchive_default_instance_;
class PrefixOperatorNodeArchive;
struct PrefixOperatorNodeArchiveDefaultTypeInternal;
extern PrefixOperatorNodeArchiveDefaultTypeInternal _PrefixOperatorNodeArchive_default_instance_;
class ReferenceNodeArchive;
struct ReferenceNodeArchiveDefaultTypeInternal;
extern ReferenceNodeArchiveDefaultTypeInternal _ReferenceNodeArchive_default_instance_;
class RichTextPayloadArchive;
struct RichTextPayloadArchiveDefaultTypeInternal;
extern RichTextPayloadArchiveDefaultTypeInternal _RichTextPayloadArchive_default_instance_;
class SelectionArchive;
struct SelectionArchiveDefaultTypeInternal;
extern SelectionArchiveDefaultTypeInternal _SelectionArchive_default_instance_;
class StringNodeArchive;
struct StringNodeArchiveDefaultTypeInternal;
extern StringNodeArchiveDefaultTypeInternal _StringNodeArchive_default_instance_;
class StyleTableMapArchive;
struct StyleTableMapArchiveDefaultTypeInternal;
extern StyleTableMapArchiveDefaultTypeInternal _StyleTableMapArchive_default_instance_;
class StyleTableMapArchive_StyleTableMapEntryArchive;
struct StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal;
extern StyleTableMapArchive_StyleTableMapEntryArchiveDefaultTypeInternal _StyleTableMapArchive_StyleTableMapEntryArchive_default_instance_;
class TableDataList;
struct TableDataListDefaultTypeInternal;
extern TableDataListDefaultTypeInternal _TableDataList_default_instance_;
class TableDataList_ListEntry;
struct TableDataList_ListEntryDefaultTypeInternal;
extern TableDataList_ListEntryDefaultTypeInternal _TableDataList_ListEntry_default_instance_;
class TableInfoArchive;
struct TableInfoArchiveDefaultTypeInternal;
extern TableInfoArchiveDefaultTypeInternal _TableInfoArchive_default_instance_;
class TableModelArchive;
struct TableModelArchiveDefaultTypeInternal;
extern TableModelArchiveDefaultTypeInternal _TableModelArchive_default_instance_;
class TableRBTree;
struct TableRBTreeDefaultTypeInternal;
extern TableRBTreeDefaultTypeInternal _TableRBTree_default_instance_;
class TableRBTree_Node;
struct TableRBTree_NodeDefaultTypeInternal;
extern TableRBTree_NodeDefaultTypeInternal _TableRBTree_Node_default_instance_;
class TableSelection;
struct TableSelectionDefaultTypeInternal;
extern TableSelectionDefaultTypeInternal _TableSelection_default_instance_;
class TableSize;
struct TableSizeDefaultTypeInternal;
extern TableSizeDefaultTypeInternal _TableSize_default_instance_;
class TableStyleArchive;
struct TableStyleArchiveDefaultTypeInternal;
extern TableStyleArchiveDefaultTypeInternal _TableStyleArchive_default_instance_;
class TableStyleNetworkArchive;
struct TableStyleNetworkArchiveDefaultTypeInternal;
extern TableStyleNetworkArchiveDefaultTypeInternal _TableStyleNetworkArchive_default_instance_;
class Tile;
struct TileDefaultTypeInternal;
extern TileDefaultTypeInternal _Tile_default_instance_;
class TileRowInfo;
struct TileRowInfoDefaultTypeInternal;
extern TileRowInfoDefaultTypeInternal _TileRowInfo_default_instance_;
class TileStorage;
struct TileStorageDefaultTypeInternal;
extern TileStorageDefaultTypeInternal _TileStorage_default_instance_;
class TileStorage_Tile;
struct TileStorage_TileDefaultTypeInternal;
extern TileStorage_TileDefaultTypeInternal _TileStorage_Tile_default_instance_;
class TokenAttachmentArchive;
struct TokenAttachmentArchiveDefaultTypeInternal;
extern TokenAttachmentArchiveDefaultTypeInternal _TokenAttachmentArchive_default_instance_;
class WPTableInfoArchive;
struct WPTableInfoArchiveDefaultTypeInternal;
extern WPTableInfoArchiveDefaultTypeInternal _WPTableInfoArchive_default_instance_;
}  // namespace TST
PROTOBUF_NAMESPACE_OPEN
template<> ::TST::ArgumentPlaceholderNodeArchive* Arena::CreateMaybeMessage<::TST::ArgumentPlaceholderNodeArchive>(Arena*);
template<> ::TST::ArrayNodeArchive* Arena::CreateMaybeMessage<::TST::ArrayNodeArchive>(Arena*);
template<> ::TST::BooleanNodeArchive* Arena::CreateMaybeMessage<::TST::BooleanNodeArchive>(Arena*);
template<> ::TST::Cell* Arena::CreateMaybeMessage<::TST::Cell>(Arena*);
template<> ::TST::CellID* Arena::CreateMaybeMessage<::TST::CellID>(Arena*);
template<> ::TST::CellMapArchive* Arena::CreateMaybeMessage<::TST::CellMapArchive>(Arena*);
template<> ::TST::CellMapArchive_CellMapEntry* Arena::CreateMaybeMessage<::TST::CellMapArchive_CellMapEntry>(Arena*);
template<> ::TST::CellRange* Arena::CreateMaybeMessage<::TST::CellRange>(Arena*);
template<> ::TST::CellRegion* Arena::CreateMaybeMessage<::TST::CellRegion>(Arena*);
template<> ::TST::CellStyleArchive* Arena::CreateMaybeMessage<::TST::CellStyleArchive>(Arena*);
template<> ::TST::CompletionTokenAttachmentArchive* Arena::CreateMaybeMessage<::TST::CompletionTokenAttachmentArchive>(Arena*);
template<> ::TST::ConditionalStyleSetArchive* Arena::CreateMaybeMessage<::TST::ConditionalStyleSetArchive>(Arena*);
template<> ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* Arena::CreateMaybeMessage<::TST::ConditionalStyleSetArchive_ConditionalStyleRule>(Arena*);
template<> ::TST::DataStore* Arena::CreateMaybeMessage<::TST::DataStore>(Arena*);
template<> ::TST::DateNodeArchive* Arena::CreateMaybeMessage<::TST::DateNodeArchive>(Arena*);
template<> ::TST::DoubleStyleMapArchive* Arena::CreateMaybeMessage<::TST::DoubleStyleMapArchive>(Arena*);
template<> ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* Arena::CreateMaybeMessage<::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive>(Arena*);
template<> ::TST::DurationNodeArchive* Arena::CreateMaybeMessage<::TST::DurationNodeArchive>(Arena*);
template<> ::TST::DurationWrapperArchive* Arena::CreateMaybeMessage<::TST::DurationWrapperArchive>(Arena*);
template<> ::TST::EditingStateArchive* Arena::CreateMaybeMessage<::TST::EditingStateArchive>(Arena*);
template<> ::TST::EmptyExpressionNodeArchive* Arena::CreateMaybeMessage<::TST::EmptyExpressionNodeArchive>(Arena*);
template<> ::TST::ExpressionNodeArchive* Arena::CreateMaybeMessage<::TST::ExpressionNodeArchive>(Arena*);
template<> ::TST::FilterRuleArchive* Arena::CreateMaybeMessage<::TST::FilterRuleArchive>(Arena*);
template<> ::TST::FilterSetArchive* Arena::CreateMaybeMessage<::TST::FilterSetArchive>(Arena*);
template<> ::TST::FormulaArchive* Arena::CreateMaybeMessage<::TST::FormulaArchive>(Arena*);
template<> ::TST::FormulaEqualsTokenAttachmentArchive* Arena::CreateMaybeMessage<::TST::FormulaEqualsTokenAttachmentArchive>(Arena*);
template<> ::TST::FormulaPredicateArchive* Arena::CreateMaybeMessage<::TST::FormulaPredicateArchive>(Arena*);
template<> ::TST::FunctionEndNodeArchive* Arena::CreateMaybeMessage<::TST::FunctionEndNodeArchive>(Arena*);
template<> ::TST::FunctionNodeArchive* Arena::CreateMaybeMessage<::TST::FunctionNodeArchive>(Arena*);
template<> ::TST::HeaderStorage* Arena::CreateMaybeMessage<::TST::HeaderStorage>(Arena*);
template<> ::TST::HeaderStorageBucket* Arena::CreateMaybeMessage<::TST::HeaderStorageBucket>(Arena*);
template<> ::TST::HeaderStorageBucket_Header* Arena::CreateMaybeMessage<::TST::HeaderStorageBucket_Header>(Arena*);
template<> ::TST::HiddenStateFormulaOwnerArchive* Arena::CreateMaybeMessage<::TST::HiddenStateFormulaOwnerArchive>(Arena*);
template<> ::TST::IdentifierNodeArchive* Arena::CreateMaybeMessage<::TST::IdentifierNodeArchive>(Arena*);
template<> ::TST::LayoutHintArchive* Arena::CreateMaybeMessage<::TST::LayoutHintArchive>(Arena*);
template<> ::TST::ListNodeArchive* Arena::CreateMaybeMessage<::TST::ListNodeArchive>(Arena*);
template<> ::TST::MergeRegionMapArchive* Arena::CreateMaybeMessage<::TST::MergeRegionMapArchive>(Arena*);
template<> ::TST::NumberNodeArchive* Arena::CreateMaybeMessage<::TST::NumberNodeArchive>(Arena*);
template<> ::TST::OperatorNodeArchive* Arena::CreateMaybeMessage<::TST::OperatorNodeArchive>(Arena*);
template<> ::TST::PopUpMenuModel* Arena::CreateMaybeMessage<::TST::PopUpMenuModel>(Arena*);
template<> ::TST::PopUpMenuModel_CellValue* Arena::CreateMaybeMessage<::TST::PopUpMenuModel_CellValue>(Arena*);
template<> ::TST::PostfixOperatorNodeArchive* Arena::CreateMaybeMessage<::TST::PostfixOperatorNodeArchive>(Arena*);
template<> ::TST::PrefixOperatorNodeArchive* Arena::CreateMaybeMessage<::TST::PrefixOperatorNodeArchive>(Arena*);
template<> ::TST::ReferenceNodeArchive* Arena::CreateMaybeMessage<::TST::ReferenceNodeArchive>(Arena*);
template<> ::TST::RichTextPayloadArchive* Arena::CreateMaybeMessage<::TST::RichTextPayloadArchive>(Arena*);
template<> ::TST::SelectionArchive* Arena::CreateMaybeMessage<::TST::SelectionArchive>(Arena*);
template<> ::TST::StringNodeArchive* Arena::CreateMaybeMessage<::TST::StringNodeArchive>(Arena*);
template<> ::TST::StyleTableMapArchive* Arena::CreateMaybeMessage<::TST::StyleTableMapArchive>(Arena*);
template<> ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* Arena::CreateMaybeMessage<::TST::StyleTableMapArchive_StyleTableMapEntryArchive>(Arena*);
template<> ::TST::TableDataList* Arena::CreateMaybeMessage<::TST::TableDataList>(Arena*);
template<> ::TST::TableDataList_ListEntry* Arena::CreateMaybeMessage<::TST::TableDataList_ListEntry>(Arena*);
template<> ::TST::TableInfoArchive* Arena::CreateMaybeMessage<::TST::TableInfoArchive>(Arena*);
template<> ::TST::TableModelArchive* Arena::CreateMaybeMessage<::TST::TableModelArchive>(Arena*);
template<> ::TST::TableRBTree* Arena::CreateMaybeMessage<::TST::TableRBTree>(Arena*);
template<> ::TST::TableRBTree_Node* Arena::CreateMaybeMessage<::TST::TableRBTree_Node>(Arena*);
template<> ::TST::TableSelection* Arena::CreateMaybeMessage<::TST::TableSelection>(Arena*);
template<> ::TST::TableSize* Arena::CreateMaybeMessage<::TST::TableSize>(Arena*);
template<> ::TST::TableStyleArchive* Arena::CreateMaybeMessage<::TST::TableStyleArchive>(Arena*);
template<> ::TST::TableStyleNetworkArchive* Arena::CreateMaybeMessage<::TST::TableStyleNetworkArchive>(Arena*);
template<> ::TST::Tile* Arena::CreateMaybeMessage<::TST::Tile>(Arena*);
template<> ::TST::TileRowInfo* Arena::CreateMaybeMessage<::TST::TileRowInfo>(Arena*);
template<> ::TST::TileStorage* Arena::CreateMaybeMessage<::TST::TileStorage>(Arena*);
template<> ::TST::TileStorage_Tile* Arena::CreateMaybeMessage<::TST::TileStorage_Tile>(Arena*);
template<> ::TST::TokenAttachmentArchive* Arena::CreateMaybeMessage<::TST::TokenAttachmentArchive>(Arena*);
template<> ::TST::WPTableInfoArchive* Arena::CreateMaybeMessage<::TST::WPTableInfoArchive>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TST {

enum PopUpMenuModel_CellValueType : int {
  PopUpMenuModel_CellValueType_NIL_TYPE = 1,
  PopUpMenuModel_CellValueType_BOOLEAN_TYPE = 2,
  PopUpMenuModel_CellValueType_DATE_TYPE = 3,
  PopUpMenuModel_CellValueType_NUMBER_TYPE = 4,
  PopUpMenuModel_CellValueType_STRING_TYPE = 5
};
bool PopUpMenuModel_CellValueType_IsValid(int value);
constexpr PopUpMenuModel_CellValueType PopUpMenuModel_CellValueType_CellValueType_MIN = PopUpMenuModel_CellValueType_NIL_TYPE;
constexpr PopUpMenuModel_CellValueType PopUpMenuModel_CellValueType_CellValueType_MAX = PopUpMenuModel_CellValueType_STRING_TYPE;
constexpr int PopUpMenuModel_CellValueType_CellValueType_ARRAYSIZE = PopUpMenuModel_CellValueType_CellValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PopUpMenuModel_CellValueType_descriptor();
template<typename T>
inline const std::string& PopUpMenuModel_CellValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PopUpMenuModel_CellValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PopUpMenuModel_CellValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PopUpMenuModel_CellValueType_descriptor(), enum_t_value);
}
inline bool PopUpMenuModel_CellValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PopUpMenuModel_CellValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PopUpMenuModel_CellValueType>(
    PopUpMenuModel_CellValueType_descriptor(), name, value);
}
enum TableDataList_ListType : int {
  TableDataList_ListType_STRING = 1,
  TableDataList_ListType_FORMAT = 2,
  TableDataList_ListType_FORMULA = 3,
  TableDataList_ListType_STYLE = 4,
  TableDataList_ListType_FORMULA_ERROR = 5,
  TableDataList_ListType_CUSTOM_FORMAT = 6,
  TableDataList_ListType_MULTIPLE_CHOICE_LIST_FORMAT = 7,
  TableDataList_ListType_RICH_TEXT_PAYLOAD = 8,
  TableDataList_ListType_CONDITIONAL_STYLE = 9,
  TableDataList_ListType_COMMENT_STORAGE = 10
};
bool TableDataList_ListType_IsValid(int value);
constexpr TableDataList_ListType TableDataList_ListType_ListType_MIN = TableDataList_ListType_STRING;
constexpr TableDataList_ListType TableDataList_ListType_ListType_MAX = TableDataList_ListType_COMMENT_STORAGE;
constexpr int TableDataList_ListType_ListType_ARRAYSIZE = TableDataList_ListType_ListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TableDataList_ListType_descriptor();
template<typename T>
inline const std::string& TableDataList_ListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TableDataList_ListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TableDataList_ListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TableDataList_ListType_descriptor(), enum_t_value);
}
inline bool TableDataList_ListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TableDataList_ListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TableDataList_ListType>(
    TableDataList_ListType_descriptor(), name, value);
}
enum FormulaPredicateArchive_FormulaPredicateType : int {
  FormulaPredicateArchive_FormulaPredicateType_PredNone = 0,
  FormulaPredicateArchive_FormulaPredicateType_TextStartsWith = 1,
  FormulaPredicateArchive_FormulaPredicateType_TextEndsWith = 2,
  FormulaPredicateArchive_FormulaPredicateType_TextContains = 3,
  FormulaPredicateArchive_FormulaPredicateType_TextDoesNotContain = 4,
  FormulaPredicateArchive_FormulaPredicateType_ValueEqual = 5,
  FormulaPredicateArchive_FormulaPredicateType_ValueNotEqual = 6,
  FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThan = 7,
  FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThanOrEqual = 8,
  FormulaPredicateArchive_FormulaPredicateType_ValueLessThan = 9,
  FormulaPredicateArchive_FormulaPredicateType_ValueLessThanOrEqual = 10,
  FormulaPredicateArchive_FormulaPredicateType_ValueAboveAverage = 11,
  FormulaPredicateArchive_FormulaPredicateType_ValueBelowAverage = 12,
  FormulaPredicateArchive_FormulaPredicateType_ValueBetween = 13,
  FormulaPredicateArchive_FormulaPredicateType_Formula = 14,
  FormulaPredicateArchive_FormulaPredicateType_Duplicates = 15,
  FormulaPredicateArchive_FormulaPredicateType_Uniques = 16,
  FormulaPredicateArchive_FormulaPredicateType_DateIsToday = 17,
  FormulaPredicateArchive_FormulaPredicateType_DateIsYesterday = 18,
  FormulaPredicateArchive_FormulaPredicateType_DateIsTomorrow = 19,
  FormulaPredicateArchive_FormulaPredicateType_DateIsTheDate = 20,
  FormulaPredicateArchive_FormulaPredicateType_DateBeforeTheDate = 21,
  FormulaPredicateArchive_FormulaPredicateType_DateAfterTheDate = 22,
  FormulaPredicateArchive_FormulaPredicateType_DateIsInTheRange = 23,
  FormulaPredicateArchive_FormulaPredicateType_DateInTheNext = 24,
  FormulaPredicateArchive_FormulaPredicateType_DateInTheLast = 25,
  FormulaPredicateArchive_FormulaPredicateType_DateIsExactly = 26,
  FormulaPredicateArchive_FormulaPredicateType_DateBeforeRelative = 27,
  FormulaPredicateArchive_FormulaPredicateType_DateAfterRelative = 28,
  FormulaPredicateArchive_FormulaPredicateType_DateBetweenRelative = 29,
  FormulaPredicateArchive_FormulaPredicateType_ValueTop = 30,
  FormulaPredicateArchive_FormulaPredicateType_ValueBottom = 31,
  FormulaPredicateArchive_FormulaPredicateType_ValueNotBetween = 32,
  FormulaPredicateArchive_FormulaPredicateType_DateInThis = 33,
  FormulaPredicateArchive_FormulaPredicateType_IsBlank = 34,
  FormulaPredicateArchive_FormulaPredicateType_IsNotBlank = 35,
  FormulaPredicateArchive_FormulaPredicateType_TextIs = 36,
  FormulaPredicateArchive_FormulaPredicateType_TextIsNot = 37,
  FormulaPredicateArchive_FormulaPredicateType_DurationEqual = 38,
  FormulaPredicateArchive_FormulaPredicateType_DurationNotEqual = 39,
  FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThan = 40,
  FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThanOrEqual = 41,
  FormulaPredicateArchive_FormulaPredicateType_DurationLessThan = 42,
  FormulaPredicateArchive_FormulaPredicateType_DurationLessThanOrEqual = 43,
  FormulaPredicateArchive_FormulaPredicateType_DurationBetween = 44,
  FormulaPredicateArchive_FormulaPredicateType_DurationNotBetween = 45,
  FormulaPredicateArchive_FormulaPredicateType_DurationAboveAverage = 46,
  FormulaPredicateArchive_FormulaPredicateType_DurationBelowAverage = 47,
  FormulaPredicateArchive_FormulaPredicateType_DurationTop = 48,
  FormulaPredicateArchive_FormulaPredicateType_DurationBottom = 49
};
bool FormulaPredicateArchive_FormulaPredicateType_IsValid(int value);
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MIN = FormulaPredicateArchive_FormulaPredicateType_PredNone;
constexpr FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX = FormulaPredicateArchive_FormulaPredicateType_DurationBottom;
constexpr int FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_ARRAYSIZE = FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FormulaPredicateArchive_FormulaPredicateType_descriptor();
template<typename T>
inline const std::string& FormulaPredicateArchive_FormulaPredicateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FormulaPredicateArchive_FormulaPredicateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FormulaPredicateArchive_FormulaPredicateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FormulaPredicateArchive_FormulaPredicateType_descriptor(), enum_t_value);
}
inline bool FormulaPredicateArchive_FormulaPredicateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormulaPredicateArchive_FormulaPredicateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FormulaPredicateArchive_FormulaPredicateType>(
    FormulaPredicateArchive_FormulaPredicateType_descriptor(), name, value);
}
enum FormulaPredicateArchive_QualifierType : int {
  FormulaPredicateArchive_QualifierType_QualNone = 0,
  FormulaPredicateArchive_QualifierType_Days = 2,
  FormulaPredicateArchive_QualifierType_Weeks = 3,
  FormulaPredicateArchive_QualifierType_Months = 4,
  FormulaPredicateArchive_QualifierType_Years = 5,
  FormulaPredicateArchive_QualifierType_Ago = 6,
  FormulaPredicateArchive_QualifierType_FromNow = 7,
  FormulaPredicateArchive_QualifierType_Quarters = 8,
  FormulaPredicateArchive_QualifierType_Percent = 9,
  FormulaPredicateArchive_QualifierType_Values = 10
};
bool FormulaPredicateArchive_QualifierType_IsValid(int value);
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive_QualifierType_QualifierType_MIN = FormulaPredicateArchive_QualifierType_QualNone;
constexpr FormulaPredicateArchive_QualifierType FormulaPredicateArchive_QualifierType_QualifierType_MAX = FormulaPredicateArchive_QualifierType_Values;
constexpr int FormulaPredicateArchive_QualifierType_QualifierType_ARRAYSIZE = FormulaPredicateArchive_QualifierType_QualifierType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FormulaPredicateArchive_QualifierType_descriptor();
template<typename T>
inline const std::string& FormulaPredicateArchive_QualifierType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FormulaPredicateArchive_QualifierType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FormulaPredicateArchive_QualifierType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FormulaPredicateArchive_QualifierType_descriptor(), enum_t_value);
}
inline bool FormulaPredicateArchive_QualifierType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormulaPredicateArchive_QualifierType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FormulaPredicateArchive_QualifierType>(
    FormulaPredicateArchive_QualifierType_descriptor(), name, value);
}
enum FilterSetArchive_FilterSetType : int {
  FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll = 0,
  FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny = 1
};
bool FilterSetArchive_FilterSetType_IsValid(int value);
constexpr FilterSetArchive_FilterSetType FilterSetArchive_FilterSetType_FilterSetType_MIN = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll;
constexpr FilterSetArchive_FilterSetType FilterSetArchive_FilterSetType_FilterSetType_MAX = FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny;
constexpr int FilterSetArchive_FilterSetType_FilterSetType_ARRAYSIZE = FilterSetArchive_FilterSetType_FilterSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterSetArchive_FilterSetType_descriptor();
template<typename T>
inline const std::string& FilterSetArchive_FilterSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterSetArchive_FilterSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterSetArchive_FilterSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterSetArchive_FilterSetType_descriptor(), enum_t_value);
}
inline bool FilterSetArchive_FilterSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterSetArchive_FilterSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterSetArchive_FilterSetType>(
    FilterSetArchive_FilterSetType_descriptor(), name, value);
}
enum CellType : int {
  genericCellType = 0,
  spanCellType = 1,
  numberCellType = 2,
  textCellType = 3,
  formulaCellType = 4,
  dateCellType = 5,
  boolCellType = 6,
  durationCellType = 7,
  formulaErrorCellType = 8,
  automaticCellType = 9
};
bool CellType_IsValid(int value);
constexpr CellType CellType_MIN = genericCellType;
constexpr CellType CellType_MAX = automaticCellType;
constexpr int CellType_ARRAYSIZE = CellType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CellType_descriptor();
template<typename T>
inline const std::string& CellType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CellType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CellType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CellType_descriptor(), enum_t_value);
}
inline bool CellType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CellType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CellType>(
    CellType_descriptor(), name, value);
}
enum CellValueType : int {
  emptyCellValueType = 0,
  numberCellValueType = 1,
  stringCellValueType = 2,
  providedCellValueType = 3,
  dateCellValueType = 4,
  boolCellValueType = 5,
  durationCellValueType = 6,
  errorCellValueType = 7,
  richTextCellType = 8
};
bool CellValueType_IsValid(int value);
constexpr CellValueType CellValueType_MIN = emptyCellValueType;
constexpr CellValueType CellValueType_MAX = richTextCellType;
constexpr int CellValueType_ARRAYSIZE = CellValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CellValueType_descriptor();
template<typename T>
inline const std::string& CellValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CellValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CellValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CellValueType_descriptor(), enum_t_value);
}
inline bool CellValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CellValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CellValueType>(
    CellValueType_descriptor(), name, value);
}
enum SelectionTypeArchive : int {
  cellSelectionType = 0,
  rowSelectionType = 1,
  columnSelectionType = 2,
  cellEditingSelectionType = 3,
  tableNameSelectionType = 4,
  tableSelectionType = 5
};
bool SelectionTypeArchive_IsValid(int value);
constexpr SelectionTypeArchive SelectionTypeArchive_MIN = cellSelectionType;
constexpr SelectionTypeArchive SelectionTypeArchive_MAX = tableSelectionType;
constexpr int SelectionTypeArchive_ARRAYSIZE = SelectionTypeArchive_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelectionTypeArchive_descriptor();
template<typename T>
inline const std::string& SelectionTypeArchive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelectionTypeArchive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelectionTypeArchive_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelectionTypeArchive_descriptor(), enum_t_value);
}
inline bool SelectionTypeArchive_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelectionTypeArchive* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelectionTypeArchive>(
    SelectionTypeArchive_descriptor(), name, value);
}
enum FillDirectionArchive : int {
  kTSTFillDownArchive = 1,
  kTSTFillUpArchive = 2,
  kTSTFillRightArchive = 3,
  kTSTFillLeftArchive = 4
};
bool FillDirectionArchive_IsValid(int value);
constexpr FillDirectionArchive FillDirectionArchive_MIN = kTSTFillDownArchive;
constexpr FillDirectionArchive FillDirectionArchive_MAX = kTSTFillLeftArchive;
constexpr int FillDirectionArchive_ARRAYSIZE = FillDirectionArchive_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FillDirectionArchive_descriptor();
template<typename T>
inline const std::string& FillDirectionArchive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FillDirectionArchive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FillDirectionArchive_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FillDirectionArchive_descriptor(), enum_t_value);
}
inline bool FillDirectionArchive_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FillDirectionArchive* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FillDirectionArchive>(
    FillDirectionArchive_descriptor(), name, value);
}
enum MergeActionArchive : int {
  mergeActionMerge = 0,
  mergeActionUnmerge = 1
};
bool MergeActionArchive_IsValid(int value);
constexpr MergeActionArchive MergeActionArchive_MIN = mergeActionMerge;
constexpr MergeActionArchive MergeActionArchive_MAX = mergeActionUnmerge;
constexpr int MergeActionArchive_ARRAYSIZE = MergeActionArchive_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MergeActionArchive_descriptor();
template<typename T>
inline const std::string& MergeActionArchive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MergeActionArchive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MergeActionArchive_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MergeActionArchive_descriptor(), enum_t_value);
}
inline bool MergeActionArchive_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MergeActionArchive* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MergeActionArchive>(
    MergeActionArchive_descriptor(), name, value);
}
enum HideShowActionArchive : int {
  hideShowActionHide = 0,
  hideShowActionShow = 1
};
bool HideShowActionArchive_IsValid(int value);
constexpr HideShowActionArchive HideShowActionArchive_MIN = hideShowActionHide;
constexpr HideShowActionArchive HideShowActionArchive_MAX = hideShowActionShow;
constexpr int HideShowActionArchive_ARRAYSIZE = HideShowActionArchive_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HideShowActionArchive_descriptor();
template<typename T>
inline const std::string& HideShowActionArchive_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HideShowActionArchive>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HideShowActionArchive_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HideShowActionArchive_descriptor(), enum_t_value);
}
inline bool HideShowActionArchive_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HideShowActionArchive* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HideShowActionArchive>(
    HideShowActionArchive_descriptor(), name, value);
}
// ===================================================================

class CellID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellID) */ {
 public:
  inline CellID() : CellID(nullptr) {}
  ~CellID() override;
  explicit PROTOBUF_CONSTEXPR CellID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellID(const CellID& from);
  CellID(CellID&& from) noexcept
    : CellID() {
    *this = ::std::move(from);
  }

  inline CellID& operator=(const CellID& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellID& operator=(CellID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellID& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellID* internal_default_instance() {
    return reinterpret_cast<const CellID*>(
               &_CellID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CellID& a, CellID& b) {
    a.Swap(&b);
  }
  inline void Swap(CellID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellID& from) {
    CellID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellID";
  }
  protected:
  explicit CellID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackedDataFieldNumber = 1,
  };
  // required fixed32 packedData = 1;
  bool has_packeddata() const;
  private:
  bool _internal_has_packeddata() const;
  public:
  void clear_packeddata();
  uint32_t packeddata() const;
  void set_packeddata(uint32_t value);
  private:
  uint32_t _internal_packeddata() const;
  void _internal_set_packeddata(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.CellID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t packeddata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableSize final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableSize) */ {
 public:
  inline TableSize() : TableSize(nullptr) {}
  ~TableSize() override;
  explicit PROTOBUF_CONSTEXPR TableSize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableSize(const TableSize& from);
  TableSize(TableSize&& from) noexcept
    : TableSize() {
    *this = ::std::move(from);
  }

  inline TableSize& operator=(const TableSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableSize& operator=(TableSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableSize* internal_default_instance() {
    return reinterpret_cast<const TableSize*>(
               &_TableSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TableSize& a, TableSize& b) {
    a.Swap(&b);
  }
  inline void Swap(TableSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableSize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableSize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableSize>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableSize& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableSize& from) {
    TableSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableSize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableSize";
  }
  protected:
  explicit TableSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackedDataFieldNumber = 1,
  };
  // required fixed32 packedData = 1;
  bool has_packeddata() const;
  private:
  bool _internal_has_packeddata() const;
  public:
  void clear_packeddata();
  uint32_t packeddata() const;
  void set_packeddata(uint32_t value);
  private:
  uint32_t _internal_packeddata() const;
  void _internal_set_packeddata(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableSize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t packeddata_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CellRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellRange) */ {
 public:
  inline CellRange() : CellRange(nullptr) {}
  ~CellRange() override;
  explicit PROTOBUF_CONSTEXPR CellRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellRange(const CellRange& from);
  CellRange(CellRange&& from) noexcept
    : CellRange() {
    *this = ::std::move(from);
  }

  inline CellRange& operator=(const CellRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellRange& operator=(CellRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellRange* internal_default_instance() {
    return reinterpret_cast<const CellRange*>(
               &_CellRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CellRange& a, CellRange& b) {
    a.Swap(&b);
  }
  inline void Swap(CellRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellRange& from) {
    CellRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellRange";
  }
  protected:
  explicit CellRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required .TST.CellID origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::TST::CellID& origin() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_origin();
  ::TST::CellID* mutable_origin();
  void set_allocated_origin(::TST::CellID* origin);
  private:
  const ::TST::CellID& _internal_origin() const;
  ::TST::CellID* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::TST::CellID* origin);
  ::TST::CellID* unsafe_arena_release_origin();

  // required .TST.TableSize size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::TST::TableSize& size() const;
  PROTOBUF_NODISCARD ::TST::TableSize* release_size();
  ::TST::TableSize* mutable_size();
  void set_allocated_size(::TST::TableSize* size);
  private:
  const ::TST::TableSize& _internal_size() const;
  ::TST::TableSize* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::TST::TableSize* size);
  ::TST::TableSize* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:TST.CellRange)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::CellID* origin_;
    ::TST::TableSize* size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableSelection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableSelection) */ {
 public:
  inline TableSelection() : TableSelection(nullptr) {}
  ~TableSelection() override;
  explicit PROTOBUF_CONSTEXPR TableSelection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableSelection(const TableSelection& from);
  TableSelection(TableSelection&& from) noexcept
    : TableSelection() {
    *this = ::std::move(from);
  }

  inline TableSelection& operator=(const TableSelection& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableSelection& operator=(TableSelection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableSelection& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableSelection* internal_default_instance() {
    return reinterpret_cast<const TableSelection*>(
               &_TableSelection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TableSelection& a, TableSelection& b) {
    a.Swap(&b);
  }
  inline void Swap(TableSelection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableSelection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableSelection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableSelection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableSelection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableSelection& from) {
    TableSelection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableSelection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableSelection";
  }
  protected:
  explicit TableSelection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellRangeFieldNumber = 1,
    kExtendedCellRangeFieldNumber = 2,
    kExtendedCellRangeValidFieldNumber = 3,
    kSelectionTypeFieldNumber = 4,
  };
  // required .TST.CellRange cellRange = 1;
  bool has_cellrange() const;
  private:
  bool _internal_has_cellrange() const;
  public:
  void clear_cellrange();
  const ::TST::CellRange& cellrange() const;
  PROTOBUF_NODISCARD ::TST::CellRange* release_cellrange();
  ::TST::CellRange* mutable_cellrange();
  void set_allocated_cellrange(::TST::CellRange* cellrange);
  private:
  const ::TST::CellRange& _internal_cellrange() const;
  ::TST::CellRange* _internal_mutable_cellrange();
  public:
  void unsafe_arena_set_allocated_cellrange(
      ::TST::CellRange* cellrange);
  ::TST::CellRange* unsafe_arena_release_cellrange();

  // required .TST.CellRange extendedCellRange = 2;
  bool has_extendedcellrange() const;
  private:
  bool _internal_has_extendedcellrange() const;
  public:
  void clear_extendedcellrange();
  const ::TST::CellRange& extendedcellrange() const;
  PROTOBUF_NODISCARD ::TST::CellRange* release_extendedcellrange();
  ::TST::CellRange* mutable_extendedcellrange();
  void set_allocated_extendedcellrange(::TST::CellRange* extendedcellrange);
  private:
  const ::TST::CellRange& _internal_extendedcellrange() const;
  ::TST::CellRange* _internal_mutable_extendedcellrange();
  public:
  void unsafe_arena_set_allocated_extendedcellrange(
      ::TST::CellRange* extendedcellrange);
  ::TST::CellRange* unsafe_arena_release_extendedcellrange();

  // required bool extendedCellRangeValid = 3;
  bool has_extendedcellrangevalid() const;
  private:
  bool _internal_has_extendedcellrangevalid() const;
  public:
  void clear_extendedcellrangevalid();
  bool extendedcellrangevalid() const;
  void set_extendedcellrangevalid(bool value);
  private:
  bool _internal_extendedcellrangevalid() const;
  void _internal_set_extendedcellrangevalid(bool value);
  public:

  // required .TST.SelectionTypeArchive selection_type = 4;
  bool has_selection_type() const;
  private:
  bool _internal_has_selection_type() const;
  public:
  void clear_selection_type();
  ::TST::SelectionTypeArchive selection_type() const;
  void set_selection_type(::TST::SelectionTypeArchive value);
  private:
  ::TST::SelectionTypeArchive _internal_selection_type() const;
  void _internal_set_selection_type(::TST::SelectionTypeArchive value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableSelection)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::CellRange* cellrange_;
    ::TST::CellRange* extendedcellrange_;
    bool extendedcellrangevalid_;
    int selection_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TileRowInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TileRowInfo) */ {
 public:
  inline TileRowInfo() : TileRowInfo(nullptr) {}
  ~TileRowInfo() override;
  explicit PROTOBUF_CONSTEXPR TileRowInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TileRowInfo(const TileRowInfo& from);
  TileRowInfo(TileRowInfo&& from) noexcept
    : TileRowInfo() {
    *this = ::std::move(from);
  }

  inline TileRowInfo& operator=(const TileRowInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileRowInfo& operator=(TileRowInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TileRowInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TileRowInfo* internal_default_instance() {
    return reinterpret_cast<const TileRowInfo*>(
               &_TileRowInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TileRowInfo& a, TileRowInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TileRowInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileRowInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TileRowInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TileRowInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TileRowInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TileRowInfo& from) {
    TileRowInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileRowInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TileRowInfo";
  }
  protected:
  explicit TileRowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellStorageBufferFieldNumber = 3,
    kCellOffsetsFieldNumber = 4,
    kTileRowIndexFieldNumber = 1,
    kCellCountFieldNumber = 2,
    kStorageVersionFieldNumber = 5,
  };
  // required bytes cellStorageBuffer = 3;
  bool has_cellstoragebuffer() const;
  private:
  bool _internal_has_cellstoragebuffer() const;
  public:
  void clear_cellstoragebuffer();
  const std::string& cellstoragebuffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cellstoragebuffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cellstoragebuffer();
  PROTOBUF_NODISCARD std::string* release_cellstoragebuffer();
  void set_allocated_cellstoragebuffer(std::string* cellstoragebuffer);
  private:
  const std::string& _internal_cellstoragebuffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cellstoragebuffer(const std::string& value);
  std::string* _internal_mutable_cellstoragebuffer();
  public:

  // required bytes cellOffsets = 4;
  bool has_celloffsets() const;
  private:
  bool _internal_has_celloffsets() const;
  public:
  void clear_celloffsets();
  const std::string& celloffsets() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_celloffsets(ArgT0&& arg0, ArgT... args);
  std::string* mutable_celloffsets();
  PROTOBUF_NODISCARD std::string* release_celloffsets();
  void set_allocated_celloffsets(std::string* celloffsets);
  private:
  const std::string& _internal_celloffsets() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_celloffsets(const std::string& value);
  std::string* _internal_mutable_celloffsets();
  public:

  // required uint32 tileRowIndex = 1;
  bool has_tilerowindex() const;
  private:
  bool _internal_has_tilerowindex() const;
  public:
  void clear_tilerowindex();
  uint32_t tilerowindex() const;
  void set_tilerowindex(uint32_t value);
  private:
  uint32_t _internal_tilerowindex() const;
  void _internal_set_tilerowindex(uint32_t value);
  public:

  // required uint32 cellCount = 2;
  bool has_cellcount() const;
  private:
  bool _internal_has_cellcount() const;
  public:
  void clear_cellcount();
  uint32_t cellcount() const;
  void set_cellcount(uint32_t value);
  private:
  uint32_t _internal_cellcount() const;
  void _internal_set_cellcount(uint32_t value);
  public:

  // optional uint32 storage_version = 5;
  bool has_storage_version() const;
  private:
  bool _internal_has_storage_version() const;
  public:
  void clear_storage_version();
  uint32_t storage_version() const;
  void set_storage_version(uint32_t value);
  private:
  uint32_t _internal_storage_version() const;
  void _internal_set_storage_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TileRowInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cellstoragebuffer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr celloffsets_;
    uint32_t tilerowindex_;
    uint32_t cellcount_;
    uint32_t storage_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.Tile) */ {
 public:
  inline Tile() : Tile(nullptr) {}
  ~Tile() override;
  explicit PROTOBUF_CONSTEXPR Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tile(const Tile& from);
  Tile(Tile&& from) noexcept
    : Tile() {
    *this = ::std::move(from);
  }

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tile& operator=(Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tile* internal_default_instance() {
    return reinterpret_cast<const Tile*>(
               &_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Tile& a, Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(Tile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tile& from) {
    Tile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.Tile";
  }
  protected:
  explicit Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowInfosFieldNumber = 5,
    kMaxColumnFieldNumber = 1,
    kMaxRowFieldNumber = 2,
    kNumCellsFieldNumber = 3,
    kNumrowsFieldNumber = 4,
    kStorageVersionFieldNumber = 6,
  };
  // repeated .TST.TileRowInfo rowInfos = 5;
  int rowinfos_size() const;
  private:
  int _internal_rowinfos_size() const;
  public:
  void clear_rowinfos();
  ::TST::TileRowInfo* mutable_rowinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileRowInfo >*
      mutable_rowinfos();
  private:
  const ::TST::TileRowInfo& _internal_rowinfos(int index) const;
  ::TST::TileRowInfo* _internal_add_rowinfos();
  public:
  const ::TST::TileRowInfo& rowinfos(int index) const;
  ::TST::TileRowInfo* add_rowinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileRowInfo >&
      rowinfos() const;

  // required uint32 maxColumn = 1;
  bool has_maxcolumn() const;
  private:
  bool _internal_has_maxcolumn() const;
  public:
  void clear_maxcolumn();
  uint32_t maxcolumn() const;
  void set_maxcolumn(uint32_t value);
  private:
  uint32_t _internal_maxcolumn() const;
  void _internal_set_maxcolumn(uint32_t value);
  public:

  // required uint32 maxRow = 2;
  bool has_maxrow() const;
  private:
  bool _internal_has_maxrow() const;
  public:
  void clear_maxrow();
  uint32_t maxrow() const;
  void set_maxrow(uint32_t value);
  private:
  uint32_t _internal_maxrow() const;
  void _internal_set_maxrow(uint32_t value);
  public:

  // required uint32 numCells = 3;
  bool has_numcells() const;
  private:
  bool _internal_has_numcells() const;
  public:
  void clear_numcells();
  uint32_t numcells() const;
  void set_numcells(uint32_t value);
  private:
  uint32_t _internal_numcells() const;
  void _internal_set_numcells(uint32_t value);
  public:

  // required uint32 numrows = 4;
  bool has_numrows() const;
  private:
  bool _internal_has_numrows() const;
  public:
  void clear_numrows();
  uint32_t numrows() const;
  void set_numrows(uint32_t value);
  private:
  uint32_t _internal_numrows() const;
  void _internal_set_numrows(uint32_t value);
  public:

  // optional uint32 storage_version = 6;
  bool has_storage_version() const;
  private:
  bool _internal_has_storage_version() const;
  public:
  void clear_storage_version();
  uint32_t storage_version() const;
  void set_storage_version(uint32_t value);
  private:
  uint32_t _internal_storage_version() const;
  void _internal_set_storage_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.Tile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileRowInfo > rowinfos_;
    uint32_t maxcolumn_;
    uint32_t maxrow_;
    uint32_t numcells_;
    uint32_t numrows_;
    uint32_t storage_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TileStorage_Tile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TileStorage.Tile) */ {
 public:
  inline TileStorage_Tile() : TileStorage_Tile(nullptr) {}
  ~TileStorage_Tile() override;
  explicit PROTOBUF_CONSTEXPR TileStorage_Tile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TileStorage_Tile(const TileStorage_Tile& from);
  TileStorage_Tile(TileStorage_Tile&& from) noexcept
    : TileStorage_Tile() {
    *this = ::std::move(from);
  }

  inline TileStorage_Tile& operator=(const TileStorage_Tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileStorage_Tile& operator=(TileStorage_Tile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TileStorage_Tile& default_instance() {
    return *internal_default_instance();
  }
  static inline const TileStorage_Tile* internal_default_instance() {
    return reinterpret_cast<const TileStorage_Tile*>(
               &_TileStorage_Tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TileStorage_Tile& a, TileStorage_Tile& b) {
    a.Swap(&b);
  }
  inline void Swap(TileStorage_Tile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileStorage_Tile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TileStorage_Tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TileStorage_Tile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TileStorage_Tile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TileStorage_Tile& from) {
    TileStorage_Tile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileStorage_Tile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TileStorage.Tile";
  }
  protected:
  explicit TileStorage_Tile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTileFieldNumber = 2,
    kTileidFieldNumber = 1,
  };
  // required .TSP.Reference tile = 2;
  bool has_tile() const;
  private:
  bool _internal_has_tile() const;
  public:
  void clear_tile();
  const ::TSP::Reference& tile() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_tile();
  ::TSP::Reference* mutable_tile();
  void set_allocated_tile(::TSP::Reference* tile);
  private:
  const ::TSP::Reference& _internal_tile() const;
  ::TSP::Reference* _internal_mutable_tile();
  public:
  void unsafe_arena_set_allocated_tile(
      ::TSP::Reference* tile);
  ::TSP::Reference* unsafe_arena_release_tile();

  // required uint32 tileid = 1;
  bool has_tileid() const;
  private:
  bool _internal_has_tileid() const;
  public:
  void clear_tileid();
  uint32_t tileid() const;
  void set_tileid(uint32_t value);
  private:
  uint32_t _internal_tileid() const;
  void _internal_set_tileid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TileStorage.Tile)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* tile_;
    uint32_t tileid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TileStorage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TileStorage) */ {
 public:
  inline TileStorage() : TileStorage(nullptr) {}
  ~TileStorage() override;
  explicit PROTOBUF_CONSTEXPR TileStorage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TileStorage(const TileStorage& from);
  TileStorage(TileStorage&& from) noexcept
    : TileStorage() {
    *this = ::std::move(from);
  }

  inline TileStorage& operator=(const TileStorage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileStorage& operator=(TileStorage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TileStorage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TileStorage* internal_default_instance() {
    return reinterpret_cast<const TileStorage*>(
               &_TileStorage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TileStorage& a, TileStorage& b) {
    a.Swap(&b);
  }
  inline void Swap(TileStorage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileStorage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TileStorage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TileStorage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TileStorage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TileStorage& from) {
    TileStorage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileStorage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TileStorage";
  }
  protected:
  explicit TileStorage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TileStorage_Tile Tile;

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .TST.TileStorage.Tile tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::TST::TileStorage_Tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileStorage_Tile >*
      mutable_tiles();
  private:
  const ::TST::TileStorage_Tile& _internal_tiles(int index) const;
  ::TST::TileStorage_Tile* _internal_add_tiles();
  public:
  const ::TST::TileStorage_Tile& tiles(int index) const;
  ::TST::TileStorage_Tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileStorage_Tile >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:TST.TileStorage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileStorage_Tile > tiles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class PopUpMenuModel_CellValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.PopUpMenuModel.CellValue) */ {
 public:
  inline PopUpMenuModel_CellValue() : PopUpMenuModel_CellValue(nullptr) {}
  ~PopUpMenuModel_CellValue() override;
  explicit PROTOBUF_CONSTEXPR PopUpMenuModel_CellValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PopUpMenuModel_CellValue(const PopUpMenuModel_CellValue& from);
  PopUpMenuModel_CellValue(PopUpMenuModel_CellValue&& from) noexcept
    : PopUpMenuModel_CellValue() {
    *this = ::std::move(from);
  }

  inline PopUpMenuModel_CellValue& operator=(const PopUpMenuModel_CellValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline PopUpMenuModel_CellValue& operator=(PopUpMenuModel_CellValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PopUpMenuModel_CellValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const PopUpMenuModel_CellValue* internal_default_instance() {
    return reinterpret_cast<const PopUpMenuModel_CellValue*>(
               &_PopUpMenuModel_CellValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PopUpMenuModel_CellValue& a, PopUpMenuModel_CellValue& b) {
    a.Swap(&b);
  }
  inline void Swap(PopUpMenuModel_CellValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PopUpMenuModel_CellValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PopUpMenuModel_CellValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PopUpMenuModel_CellValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PopUpMenuModel_CellValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PopUpMenuModel_CellValue& from) {
    PopUpMenuModel_CellValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PopUpMenuModel_CellValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.PopUpMenuModel.CellValue";
  }
  protected:
  explicit PopUpMenuModel_CellValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBooleanValueFieldNumber = 2,
    kDateValueFieldNumber = 3,
    kNumberValueFieldNumber = 4,
    kStringValueFieldNumber = 5,
    kCellValueTypeFieldNumber = 1,
  };
  // optional .TSCE.BooleanCellValueArchive boolean_value = 2;
  bool has_boolean_value() const;
  private:
  bool _internal_has_boolean_value() const;
  public:
  void clear_boolean_value();
  const ::TSCE::BooleanCellValueArchive& boolean_value() const;
  PROTOBUF_NODISCARD ::TSCE::BooleanCellValueArchive* release_boolean_value();
  ::TSCE::BooleanCellValueArchive* mutable_boolean_value();
  void set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value);
  private:
  const ::TSCE::BooleanCellValueArchive& _internal_boolean_value() const;
  ::TSCE::BooleanCellValueArchive* _internal_mutable_boolean_value();
  public:
  void unsafe_arena_set_allocated_boolean_value(
      ::TSCE::BooleanCellValueArchive* boolean_value);
  ::TSCE::BooleanCellValueArchive* unsafe_arena_release_boolean_value();

  // optional .TSCE.DateCellValueArchive date_value = 3;
  bool has_date_value() const;
  private:
  bool _internal_has_date_value() const;
  public:
  void clear_date_value();
  const ::TSCE::DateCellValueArchive& date_value() const;
  PROTOBUF_NODISCARD ::TSCE::DateCellValueArchive* release_date_value();
  ::TSCE::DateCellValueArchive* mutable_date_value();
  void set_allocated_date_value(::TSCE::DateCellValueArchive* date_value);
  private:
  const ::TSCE::DateCellValueArchive& _internal_date_value() const;
  ::TSCE::DateCellValueArchive* _internal_mutable_date_value();
  public:
  void unsafe_arena_set_allocated_date_value(
      ::TSCE::DateCellValueArchive* date_value);
  ::TSCE::DateCellValueArchive* unsafe_arena_release_date_value();

  // optional .TSCE.NumberCellValueArchive number_value = 4;
  bool has_number_value() const;
  private:
  bool _internal_has_number_value() const;
  public:
  void clear_number_value();
  const ::TSCE::NumberCellValueArchive& number_value() const;
  PROTOBUF_NODISCARD ::TSCE::NumberCellValueArchive* release_number_value();
  ::TSCE::NumberCellValueArchive* mutable_number_value();
  void set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value);
  private:
  const ::TSCE::NumberCellValueArchive& _internal_number_value() const;
  ::TSCE::NumberCellValueArchive* _internal_mutable_number_value();
  public:
  void unsafe_arena_set_allocated_number_value(
      ::TSCE::NumberCellValueArchive* number_value);
  ::TSCE::NumberCellValueArchive* unsafe_arena_release_number_value();

  // optional .TSCE.StringCellValueArchive string_value = 5;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const ::TSCE::StringCellValueArchive& string_value() const;
  PROTOBUF_NODISCARD ::TSCE::StringCellValueArchive* release_string_value();
  ::TSCE::StringCellValueArchive* mutable_string_value();
  void set_allocated_string_value(::TSCE::StringCellValueArchive* string_value);
  private:
  const ::TSCE::StringCellValueArchive& _internal_string_value() const;
  ::TSCE::StringCellValueArchive* _internal_mutable_string_value();
  public:
  void unsafe_arena_set_allocated_string_value(
      ::TSCE::StringCellValueArchive* string_value);
  ::TSCE::StringCellValueArchive* unsafe_arena_release_string_value();

  // required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
  bool has_cell_value_type() const;
  private:
  bool _internal_has_cell_value_type() const;
  public:
  void clear_cell_value_type();
  ::TST::PopUpMenuModel_CellValueType cell_value_type() const;
  void set_cell_value_type(::TST::PopUpMenuModel_CellValueType value);
  private:
  ::TST::PopUpMenuModel_CellValueType _internal_cell_value_type() const;
  void _internal_set_cell_value_type(::TST::PopUpMenuModel_CellValueType value);
  public:

  // @@protoc_insertion_point(class_scope:TST.PopUpMenuModel.CellValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSCE::BooleanCellValueArchive* boolean_value_;
    ::TSCE::DateCellValueArchive* date_value_;
    ::TSCE::NumberCellValueArchive* number_value_;
    ::TSCE::StringCellValueArchive* string_value_;
    int cell_value_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class PopUpMenuModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.PopUpMenuModel) */ {
 public:
  inline PopUpMenuModel() : PopUpMenuModel(nullptr) {}
  ~PopUpMenuModel() override;
  explicit PROTOBUF_CONSTEXPR PopUpMenuModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PopUpMenuModel(const PopUpMenuModel& from);
  PopUpMenuModel(PopUpMenuModel&& from) noexcept
    : PopUpMenuModel() {
    *this = ::std::move(from);
  }

  inline PopUpMenuModel& operator=(const PopUpMenuModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PopUpMenuModel& operator=(PopUpMenuModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PopUpMenuModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PopUpMenuModel* internal_default_instance() {
    return reinterpret_cast<const PopUpMenuModel*>(
               &_PopUpMenuModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PopUpMenuModel& a, PopUpMenuModel& b) {
    a.Swap(&b);
  }
  inline void Swap(PopUpMenuModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PopUpMenuModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PopUpMenuModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PopUpMenuModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PopUpMenuModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PopUpMenuModel& from) {
    PopUpMenuModel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PopUpMenuModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.PopUpMenuModel";
  }
  protected:
  explicit PopUpMenuModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PopUpMenuModel_CellValue CellValue;

  typedef PopUpMenuModel_CellValueType CellValueType;
  static constexpr CellValueType NIL_TYPE =
    PopUpMenuModel_CellValueType_NIL_TYPE;
  static constexpr CellValueType BOOLEAN_TYPE =
    PopUpMenuModel_CellValueType_BOOLEAN_TYPE;
  static constexpr CellValueType DATE_TYPE =
    PopUpMenuModel_CellValueType_DATE_TYPE;
  static constexpr CellValueType NUMBER_TYPE =
    PopUpMenuModel_CellValueType_NUMBER_TYPE;
  static constexpr CellValueType STRING_TYPE =
    PopUpMenuModel_CellValueType_STRING_TYPE;
  static inline bool CellValueType_IsValid(int value) {
    return PopUpMenuModel_CellValueType_IsValid(value);
  }
  static constexpr CellValueType CellValueType_MIN =
    PopUpMenuModel_CellValueType_CellValueType_MIN;
  static constexpr CellValueType CellValueType_MAX =
    PopUpMenuModel_CellValueType_CellValueType_MAX;
  static constexpr int CellValueType_ARRAYSIZE =
    PopUpMenuModel_CellValueType_CellValueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CellValueType_descriptor() {
    return PopUpMenuModel_CellValueType_descriptor();
  }
  template<typename T>
  static inline const std::string& CellValueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CellValueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CellValueType_Name.");
    return PopUpMenuModel_CellValueType_Name(enum_t_value);
  }
  static inline bool CellValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CellValueType* value) {
    return PopUpMenuModel_CellValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kTsceItemFieldNumber = 2,
  };
  // repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
  PROTOBUF_DEPRECATED int item_size() const;
  private:
  int _internal_item_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_item();
  PROTOBUF_DEPRECATED ::TST::PopUpMenuModel_CellValue* mutable_item(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >*
      mutable_item();
  private:
  const ::TST::PopUpMenuModel_CellValue& _internal_item(int index) const;
  ::TST::PopUpMenuModel_CellValue* _internal_add_item();
  public:
  PROTOBUF_DEPRECATED const ::TST::PopUpMenuModel_CellValue& item(int index) const;
  PROTOBUF_DEPRECATED ::TST::PopUpMenuModel_CellValue* add_item();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >&
      item() const;

  // repeated .TSCE.CellValueArchive tsce_item = 2;
  int tsce_item_size() const;
  private:
  int _internal_tsce_item_size() const;
  public:
  void clear_tsce_item();
  ::TSCE::CellValueArchive* mutable_tsce_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >*
      mutable_tsce_item();
  private:
  const ::TSCE::CellValueArchive& _internal_tsce_item(int index) const;
  ::TSCE::CellValueArchive* _internal_add_tsce_item();
  public:
  const ::TSCE::CellValueArchive& tsce_item(int index) const;
  ::TSCE::CellValueArchive* add_tsce_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >&
      tsce_item() const;

  // @@protoc_insertion_point(class_scope:TST.PopUpMenuModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue > item_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive > tsce_item_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableDataList_ListEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableDataList.ListEntry) */ {
 public:
  inline TableDataList_ListEntry() : TableDataList_ListEntry(nullptr) {}
  ~TableDataList_ListEntry() override;
  explicit PROTOBUF_CONSTEXPR TableDataList_ListEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableDataList_ListEntry(const TableDataList_ListEntry& from);
  TableDataList_ListEntry(TableDataList_ListEntry&& from) noexcept
    : TableDataList_ListEntry() {
    *this = ::std::move(from);
  }

  inline TableDataList_ListEntry& operator=(const TableDataList_ListEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableDataList_ListEntry& operator=(TableDataList_ListEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableDataList_ListEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableDataList_ListEntry* internal_default_instance() {
    return reinterpret_cast<const TableDataList_ListEntry*>(
               &_TableDataList_ListEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TableDataList_ListEntry& a, TableDataList_ListEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(TableDataList_ListEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableDataList_ListEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableDataList_ListEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableDataList_ListEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableDataList_ListEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableDataList_ListEntry& from) {
    TableDataList_ListEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableDataList_ListEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableDataList.ListEntry";
  }
  protected:
  explicit TableDataList_ListEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringFieldNumber = 3,
    kReferenceFieldNumber = 4,
    kFormulaFieldNumber = 5,
    kFormatFieldNumber = 6,
    kRegionFieldNumber = 7,
    kCustomFormatFieldNumber = 8,
    kRichTextPayloadFieldNumber = 9,
    kCommentStorageFieldNumber = 10,
    kKeyFieldNumber = 1,
    kRefcountFieldNumber = 2,
  };
  // optional string string = 3;
  bool has_string() const;
  private:
  bool _internal_has_string() const;
  public:
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // optional .TSP.Reference reference = 4;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::TSP::Reference& reference() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_reference();
  ::TSP::Reference* mutable_reference();
  void set_allocated_reference(::TSP::Reference* reference);
  private:
  const ::TSP::Reference& _internal_reference() const;
  ::TSP::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::TSP::Reference* reference);
  ::TSP::Reference* unsafe_arena_release_reference();

  // optional .TSCE.FormulaArchive formula = 5;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;
  public:
  void clear_formula();
  const ::TSCE::FormulaArchive& formula() const;
  PROTOBUF_NODISCARD ::TSCE::FormulaArchive* release_formula();
  ::TSCE::FormulaArchive* mutable_formula();
  void set_allocated_formula(::TSCE::FormulaArchive* formula);
  private:
  const ::TSCE::FormulaArchive& _internal_formula() const;
  ::TSCE::FormulaArchive* _internal_mutable_formula();
  public:
  void unsafe_arena_set_allocated_formula(
      ::TSCE::FormulaArchive* formula);
  ::TSCE::FormulaArchive* unsafe_arena_release_formula();

  // optional .TSK.FormatStructArchive format = 6;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const ::TSK::FormatStructArchive& format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_format();
  ::TSK::FormatStructArchive* mutable_format();
  void set_allocated_format(::TSK::FormatStructArchive* format);
  private:
  const ::TSK::FormatStructArchive& _internal_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_format();
  public:
  void unsafe_arena_set_allocated_format(
      ::TSK::FormatStructArchive* format);
  ::TSK::FormatStructArchive* unsafe_arena_release_format();

  // optional .TST.CellRange region = 7;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::TST::CellRange& region() const;
  PROTOBUF_NODISCARD ::TST::CellRange* release_region();
  ::TST::CellRange* mutable_region();
  void set_allocated_region(::TST::CellRange* region);
  private:
  const ::TST::CellRange& _internal_region() const;
  ::TST::CellRange* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::TST::CellRange* region);
  ::TST::CellRange* unsafe_arena_release_region();

  // optional .TSK.CustomFormatArchive custom_format = 8;
  bool has_custom_format() const;
  private:
  bool _internal_has_custom_format() const;
  public:
  void clear_custom_format();
  const ::TSK::CustomFormatArchive& custom_format() const;
  PROTOBUF_NODISCARD ::TSK::CustomFormatArchive* release_custom_format();
  ::TSK::CustomFormatArchive* mutable_custom_format();
  void set_allocated_custom_format(::TSK::CustomFormatArchive* custom_format);
  private:
  const ::TSK::CustomFormatArchive& _internal_custom_format() const;
  ::TSK::CustomFormatArchive* _internal_mutable_custom_format();
  public:
  void unsafe_arena_set_allocated_custom_format(
      ::TSK::CustomFormatArchive* custom_format);
  ::TSK::CustomFormatArchive* unsafe_arena_release_custom_format();

  // optional .TSP.Reference richTextPayload = 9;
  bool has_richtextpayload() const;
  private:
  bool _internal_has_richtextpayload() const;
  public:
  void clear_richtextpayload();
  const ::TSP::Reference& richtextpayload() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_richtextpayload();
  ::TSP::Reference* mutable_richtextpayload();
  void set_allocated_richtextpayload(::TSP::Reference* richtextpayload);
  private:
  const ::TSP::Reference& _internal_richtextpayload() const;
  ::TSP::Reference* _internal_mutable_richtextpayload();
  public:
  void unsafe_arena_set_allocated_richtextpayload(
      ::TSP::Reference* richtextpayload);
  ::TSP::Reference* unsafe_arena_release_richtextpayload();

  // optional .TSP.Reference comment_storage = 10;
  bool has_comment_storage() const;
  private:
  bool _internal_has_comment_storage() const;
  public:
  void clear_comment_storage();
  const ::TSP::Reference& comment_storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_comment_storage();
  ::TSP::Reference* mutable_comment_storage();
  void set_allocated_comment_storage(::TSP::Reference* comment_storage);
  private:
  const ::TSP::Reference& _internal_comment_storage() const;
  ::TSP::Reference* _internal_mutable_comment_storage();
  public:
  void unsafe_arena_set_allocated_comment_storage(
      ::TSP::Reference* comment_storage);
  ::TSP::Reference* unsafe_arena_release_comment_storage();

  // required uint32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  uint32_t key() const;
  void set_key(uint32_t value);
  private:
  uint32_t _internal_key() const;
  void _internal_set_key(uint32_t value);
  public:

  // required uint32 refcount = 2;
  bool has_refcount() const;
  private:
  bool _internal_has_refcount() const;
  public:
  void clear_refcount();
  uint32_t refcount() const;
  void set_refcount(uint32_t value);
  private:
  uint32_t _internal_refcount() const;
  void _internal_set_refcount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableDataList.ListEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    ::TSP::Reference* reference_;
    ::TSCE::FormulaArchive* formula_;
    ::TSK::FormatStructArchive* format_;
    ::TST::CellRange* region_;
    ::TSK::CustomFormatArchive* custom_format_;
    ::TSP::Reference* richtextpayload_;
    ::TSP::Reference* comment_storage_;
    uint32_t key_;
    uint32_t refcount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableDataList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableDataList) */ {
 public:
  inline TableDataList() : TableDataList(nullptr) {}
  ~TableDataList() override;
  explicit PROTOBUF_CONSTEXPR TableDataList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableDataList(const TableDataList& from);
  TableDataList(TableDataList&& from) noexcept
    : TableDataList() {
    *this = ::std::move(from);
  }

  inline TableDataList& operator=(const TableDataList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableDataList& operator=(TableDataList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableDataList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableDataList* internal_default_instance() {
    return reinterpret_cast<const TableDataList*>(
               &_TableDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TableDataList& a, TableDataList& b) {
    a.Swap(&b);
  }
  inline void Swap(TableDataList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableDataList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableDataList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableDataList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableDataList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableDataList& from) {
    TableDataList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableDataList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableDataList";
  }
  protected:
  explicit TableDataList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TableDataList_ListEntry ListEntry;

  typedef TableDataList_ListType ListType;
  static constexpr ListType STRING =
    TableDataList_ListType_STRING;
  static constexpr ListType FORMAT =
    TableDataList_ListType_FORMAT;
  static constexpr ListType FORMULA =
    TableDataList_ListType_FORMULA;
  static constexpr ListType STYLE =
    TableDataList_ListType_STYLE;
  static constexpr ListType FORMULA_ERROR =
    TableDataList_ListType_FORMULA_ERROR;
  static constexpr ListType CUSTOM_FORMAT =
    TableDataList_ListType_CUSTOM_FORMAT;
  static constexpr ListType MULTIPLE_CHOICE_LIST_FORMAT =
    TableDataList_ListType_MULTIPLE_CHOICE_LIST_FORMAT;
  static constexpr ListType RICH_TEXT_PAYLOAD =
    TableDataList_ListType_RICH_TEXT_PAYLOAD;
  static constexpr ListType CONDITIONAL_STYLE =
    TableDataList_ListType_CONDITIONAL_STYLE;
  static constexpr ListType COMMENT_STORAGE =
    TableDataList_ListType_COMMENT_STORAGE;
  static inline bool ListType_IsValid(int value) {
    return TableDataList_ListType_IsValid(value);
  }
  static constexpr ListType ListType_MIN =
    TableDataList_ListType_ListType_MIN;
  static constexpr ListType ListType_MAX =
    TableDataList_ListType_ListType_MAX;
  static constexpr int ListType_ARRAYSIZE =
    TableDataList_ListType_ListType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ListType_descriptor() {
    return TableDataList_ListType_descriptor();
  }
  template<typename T>
  static inline const std::string& ListType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ListType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ListType_Name.");
    return TableDataList_ListType_Name(enum_t_value);
  }
  static inline bool ListType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ListType* value) {
    return TableDataList_ListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kNextListIDFieldNumber = 2,
    kListTypeFieldNumber = 1,
  };
  // repeated .TST.TableDataList.ListEntry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::TST::TableDataList_ListEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableDataList_ListEntry >*
      mutable_entries();
  private:
  const ::TST::TableDataList_ListEntry& _internal_entries(int index) const;
  ::TST::TableDataList_ListEntry* _internal_add_entries();
  public:
  const ::TST::TableDataList_ListEntry& entries(int index) const;
  ::TST::TableDataList_ListEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableDataList_ListEntry >&
      entries() const;

  // required uint32 nextListID = 2;
  bool has_nextlistid() const;
  private:
  bool _internal_has_nextlistid() const;
  public:
  void clear_nextlistid();
  uint32_t nextlistid() const;
  void set_nextlistid(uint32_t value);
  private:
  uint32_t _internal_nextlistid() const;
  void _internal_set_nextlistid(uint32_t value);
  public:

  // required .TST.TableDataList.ListType listType = 1;
  bool has_listtype() const;
  private:
  bool _internal_has_listtype() const;
  public:
  void clear_listtype();
  ::TST::TableDataList_ListType listtype() const;
  void set_listtype(::TST::TableDataList_ListType value);
  private:
  ::TST::TableDataList_ListType _internal_listtype() const;
  void _internal_set_listtype(::TST::TableDataList_ListType value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableDataList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableDataList_ListEntry > entries_;
    uint32_t nextlistid_;
    int listtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableRBTree_Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableRBTree.Node) */ {
 public:
  inline TableRBTree_Node() : TableRBTree_Node(nullptr) {}
  ~TableRBTree_Node() override;
  explicit PROTOBUF_CONSTEXPR TableRBTree_Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRBTree_Node(const TableRBTree_Node& from);
  TableRBTree_Node(TableRBTree_Node&& from) noexcept
    : TableRBTree_Node() {
    *this = ::std::move(from);
  }

  inline TableRBTree_Node& operator=(const TableRBTree_Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRBTree_Node& operator=(TableRBTree_Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRBTree_Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRBTree_Node* internal_default_instance() {
    return reinterpret_cast<const TableRBTree_Node*>(
               &_TableRBTree_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TableRBTree_Node& a, TableRBTree_Node& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRBTree_Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRBTree_Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRBTree_Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRBTree_Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRBTree_Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRBTree_Node& from) {
    TableRBTree_Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRBTree_Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableRBTree.Node";
  }
  protected:
  explicit TableRBTree_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required uint32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  uint32_t key() const;
  void set_key(uint32_t value);
  private:
  uint32_t _internal_key() const;
  void _internal_set_key(uint32_t value);
  public:

  // required uint32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableRBTree.Node)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t key_;
    uint32_t value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableRBTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableRBTree) */ {
 public:
  inline TableRBTree() : TableRBTree(nullptr) {}
  ~TableRBTree() override;
  explicit PROTOBUF_CONSTEXPR TableRBTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableRBTree(const TableRBTree& from);
  TableRBTree(TableRBTree&& from) noexcept
    : TableRBTree() {
    *this = ::std::move(from);
  }

  inline TableRBTree& operator=(const TableRBTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableRBTree& operator=(TableRBTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableRBTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableRBTree* internal_default_instance() {
    return reinterpret_cast<const TableRBTree*>(
               &_TableRBTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TableRBTree& a, TableRBTree& b) {
    a.Swap(&b);
  }
  inline void Swap(TableRBTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableRBTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableRBTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableRBTree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableRBTree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableRBTree& from) {
    TableRBTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableRBTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableRBTree";
  }
  protected:
  explicit TableRBTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TableRBTree_Node Node;

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .TST.TableRBTree.Node nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::TST::TableRBTree_Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableRBTree_Node >*
      mutable_nodes();
  private:
  const ::TST::TableRBTree_Node& _internal_nodes(int index) const;
  ::TST::TableRBTree_Node* _internal_add_nodes();
  public:
  const ::TST::TableRBTree_Node& nodes(int index) const;
  ::TST::TableRBTree_Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableRBTree_Node >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:TST.TableRBTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableRBTree_Node > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class HeaderStorageBucket_Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.HeaderStorageBucket.Header) */ {
 public:
  inline HeaderStorageBucket_Header() : HeaderStorageBucket_Header(nullptr) {}
  ~HeaderStorageBucket_Header() override;
  explicit PROTOBUF_CONSTEXPR HeaderStorageBucket_Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeaderStorageBucket_Header(const HeaderStorageBucket_Header& from);
  HeaderStorageBucket_Header(HeaderStorageBucket_Header&& from) noexcept
    : HeaderStorageBucket_Header() {
    *this = ::std::move(from);
  }

  inline HeaderStorageBucket_Header& operator=(const HeaderStorageBucket_Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderStorageBucket_Header& operator=(HeaderStorageBucket_Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeaderStorageBucket_Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeaderStorageBucket_Header* internal_default_instance() {
    return reinterpret_cast<const HeaderStorageBucket_Header*>(
               &_HeaderStorageBucket_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HeaderStorageBucket_Header& a, HeaderStorageBucket_Header& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderStorageBucket_Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeaderStorageBucket_Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeaderStorageBucket_Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeaderStorageBucket_Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeaderStorageBucket_Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeaderStorageBucket_Header& from) {
    HeaderStorageBucket_Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderStorageBucket_Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.HeaderStorageBucket.Header";
  }
  protected:
  explicit HeaderStorageBucket_Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellStyleFieldNumber = 5,
    kTextStyleFieldNumber = 6,
    kIndexFieldNumber = 1,
    kSizeFieldNumber = 2,
    kHidingStateFieldNumber = 3,
    kNumberOfCellsFieldNumber = 4,
  };
  // optional .TSP.Reference cell_style = 5;
  bool has_cell_style() const;
  private:
  bool _internal_has_cell_style() const;
  public:
  void clear_cell_style();
  const ::TSP::Reference& cell_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_cell_style();
  ::TSP::Reference* mutable_cell_style();
  void set_allocated_cell_style(::TSP::Reference* cell_style);
  private:
  const ::TSP::Reference& _internal_cell_style() const;
  ::TSP::Reference* _internal_mutable_cell_style();
  public:
  void unsafe_arena_set_allocated_cell_style(
      ::TSP::Reference* cell_style);
  ::TSP::Reference* unsafe_arena_release_cell_style();

  // optional .TSP.Reference text_style = 6;
  bool has_text_style() const;
  private:
  bool _internal_has_text_style() const;
  public:
  void clear_text_style();
  const ::TSP::Reference& text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_text_style();
  ::TSP::Reference* mutable_text_style();
  void set_allocated_text_style(::TSP::Reference* text_style);
  private:
  const ::TSP::Reference& _internal_text_style() const;
  ::TSP::Reference* _internal_mutable_text_style();
  public:
  void unsafe_arena_set_allocated_text_style(
      ::TSP::Reference* text_style);
  ::TSP::Reference* unsafe_arena_release_text_style();

  // required uint32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // required float size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // required uint32 hidingState = 3;
  bool has_hidingstate() const;
  private:
  bool _internal_has_hidingstate() const;
  public:
  void clear_hidingstate();
  uint32_t hidingstate() const;
  void set_hidingstate(uint32_t value);
  private:
  uint32_t _internal_hidingstate() const;
  void _internal_set_hidingstate(uint32_t value);
  public:

  // required uint32 numberOfCells = 4;
  bool has_numberofcells() const;
  private:
  bool _internal_has_numberofcells() const;
  public:
  void clear_numberofcells();
  uint32_t numberofcells() const;
  void set_numberofcells(uint32_t value);
  private:
  uint32_t _internal_numberofcells() const;
  void _internal_set_numberofcells(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.HeaderStorageBucket.Header)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* cell_style_;
    ::TSP::Reference* text_style_;
    uint32_t index_;
    float size_;
    uint32_t hidingstate_;
    uint32_t numberofcells_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class HeaderStorageBucket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.HeaderStorageBucket) */ {
 public:
  inline HeaderStorageBucket() : HeaderStorageBucket(nullptr) {}
  ~HeaderStorageBucket() override;
  explicit PROTOBUF_CONSTEXPR HeaderStorageBucket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeaderStorageBucket(const HeaderStorageBucket& from);
  HeaderStorageBucket(HeaderStorageBucket&& from) noexcept
    : HeaderStorageBucket() {
    *this = ::std::move(from);
  }

  inline HeaderStorageBucket& operator=(const HeaderStorageBucket& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderStorageBucket& operator=(HeaderStorageBucket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeaderStorageBucket& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeaderStorageBucket* internal_default_instance() {
    return reinterpret_cast<const HeaderStorageBucket*>(
               &_HeaderStorageBucket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HeaderStorageBucket& a, HeaderStorageBucket& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderStorageBucket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeaderStorageBucket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeaderStorageBucket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeaderStorageBucket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeaderStorageBucket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeaderStorageBucket& from) {
    HeaderStorageBucket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderStorageBucket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.HeaderStorageBucket";
  }
  protected:
  explicit HeaderStorageBucket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HeaderStorageBucket_Header Header;

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 2,
    kBucketHashFunctionFieldNumber = 1,
  };
  // repeated .TST.HeaderStorageBucket.Header headers = 2;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  ::TST::HeaderStorageBucket_Header* mutable_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >*
      mutable_headers();
  private:
  const ::TST::HeaderStorageBucket_Header& _internal_headers(int index) const;
  ::TST::HeaderStorageBucket_Header* _internal_add_headers();
  public:
  const ::TST::HeaderStorageBucket_Header& headers(int index) const;
  ::TST::HeaderStorageBucket_Header* add_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >&
      headers() const;

  // required uint32 bucketHashFunction = 1;
  bool has_buckethashfunction() const;
  private:
  bool _internal_has_buckethashfunction() const;
  public:
  void clear_buckethashfunction();
  uint32_t buckethashfunction() const;
  void set_buckethashfunction(uint32_t value);
  private:
  uint32_t _internal_buckethashfunction() const;
  void _internal_set_buckethashfunction(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.HeaderStorageBucket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::HeaderStorageBucket_Header > headers_;
    uint32_t buckethashfunction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class HeaderStorage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.HeaderStorage) */ {
 public:
  inline HeaderStorage() : HeaderStorage(nullptr) {}
  ~HeaderStorage() override;
  explicit PROTOBUF_CONSTEXPR HeaderStorage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeaderStorage(const HeaderStorage& from);
  HeaderStorage(HeaderStorage&& from) noexcept
    : HeaderStorage() {
    *this = ::std::move(from);
  }

  inline HeaderStorage& operator=(const HeaderStorage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeaderStorage& operator=(HeaderStorage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeaderStorage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeaderStorage* internal_default_instance() {
    return reinterpret_cast<const HeaderStorage*>(
               &_HeaderStorage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HeaderStorage& a, HeaderStorage& b) {
    a.Swap(&b);
  }
  inline void Swap(HeaderStorage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeaderStorage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeaderStorage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeaderStorage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeaderStorage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeaderStorage& from) {
    HeaderStorage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeaderStorage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.HeaderStorage";
  }
  protected:
  explicit HeaderStorage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketsFieldNumber = 2,
    kBucketHashFunctionFieldNumber = 1,
  };
  // repeated .TSP.Reference buckets = 2;
  int buckets_size() const;
  private:
  int _internal_buckets_size() const;
  public:
  void clear_buckets();
  ::TSP::Reference* mutable_buckets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_buckets();
  private:
  const ::TSP::Reference& _internal_buckets(int index) const;
  ::TSP::Reference* _internal_add_buckets();
  public:
  const ::TSP::Reference& buckets(int index) const;
  ::TSP::Reference* add_buckets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      buckets() const;

  // required uint32 bucketHashFunction = 1;
  bool has_buckethashfunction() const;
  private:
  bool _internal_has_buckethashfunction() const;
  public:
  void clear_buckethashfunction();
  uint32_t buckethashfunction() const;
  void set_buckethashfunction(uint32_t value);
  private:
  uint32_t _internal_buckethashfunction() const;
  void _internal_set_buckethashfunction(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.HeaderStorage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > buckets_;
    uint32_t buckethashfunction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DataStore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.DataStore) */ {
 public:
  inline DataStore() : DataStore(nullptr) {}
  ~DataStore() override;
  explicit PROTOBUF_CONSTEXPR DataStore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataStore(const DataStore& from);
  DataStore(DataStore&& from) noexcept
    : DataStore() {
    *this = ::std::move(from);
  }

  inline DataStore& operator=(const DataStore& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStore& operator=(DataStore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStore& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataStore* internal_default_instance() {
    return reinterpret_cast<const DataStore*>(
               &_DataStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DataStore& a, DataStore& b) {
    a.Swap(&b);
  }
  inline void Swap(DataStore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataStore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataStore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataStore& from) {
    DataStore::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataStore* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DataStore";
  }
  protected:
  explicit DataStore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowHeadersFieldNumber = 1,
    kColumnHeadersFieldNumber = 2,
    kTilesFieldNumber = 3,
    kStringTableFieldNumber = 4,
    kStyleTableFieldNumber = 5,
    kFormulaTableFieldNumber = 6,
    kRowTileTreeFieldNumber = 9,
    kColumnTileTreeFieldNumber = 10,
    kFormatTableFieldNumber = 11,
    kFormulaErrorTableFieldNumber = 12,
    kMergeRegionMapFieldNumber = 13,
    kCustomFormatTableFieldNumber = 15,
    kMultipleChoiceListFormatTableFieldNumber = 16,
    kRichTextPayloadTableFieldNumber = 17,
    kConditionalstyletableFieldNumber = 18,
    kCommentStorageTableFieldNumber = 19,
    kNextRowStripIDFieldNumber = 7,
    kNextColumnStripIDFieldNumber = 8,
    kStorageVersionFieldNumber = 14,
  };
  // required .TST.HeaderStorage rowHeaders = 1;
  bool has_rowheaders() const;
  private:
  bool _internal_has_rowheaders() const;
  public:
  void clear_rowheaders();
  const ::TST::HeaderStorage& rowheaders() const;
  PROTOBUF_NODISCARD ::TST::HeaderStorage* release_rowheaders();
  ::TST::HeaderStorage* mutable_rowheaders();
  void set_allocated_rowheaders(::TST::HeaderStorage* rowheaders);
  private:
  const ::TST::HeaderStorage& _internal_rowheaders() const;
  ::TST::HeaderStorage* _internal_mutable_rowheaders();
  public:
  void unsafe_arena_set_allocated_rowheaders(
      ::TST::HeaderStorage* rowheaders);
  ::TST::HeaderStorage* unsafe_arena_release_rowheaders();

  // required .TSP.Reference columnHeaders = 2;
  bool has_columnheaders() const;
  private:
  bool _internal_has_columnheaders() const;
  public:
  void clear_columnheaders();
  const ::TSP::Reference& columnheaders() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_columnheaders();
  ::TSP::Reference* mutable_columnheaders();
  void set_allocated_columnheaders(::TSP::Reference* columnheaders);
  private:
  const ::TSP::Reference& _internal_columnheaders() const;
  ::TSP::Reference* _internal_mutable_columnheaders();
  public:
  void unsafe_arena_set_allocated_columnheaders(
      ::TSP::Reference* columnheaders);
  ::TSP::Reference* unsafe_arena_release_columnheaders();

  // required .TST.TileStorage tiles = 3;
  bool has_tiles() const;
  private:
  bool _internal_has_tiles() const;
  public:
  void clear_tiles();
  const ::TST::TileStorage& tiles() const;
  PROTOBUF_NODISCARD ::TST::TileStorage* release_tiles();
  ::TST::TileStorage* mutable_tiles();
  void set_allocated_tiles(::TST::TileStorage* tiles);
  private:
  const ::TST::TileStorage& _internal_tiles() const;
  ::TST::TileStorage* _internal_mutable_tiles();
  public:
  void unsafe_arena_set_allocated_tiles(
      ::TST::TileStorage* tiles);
  ::TST::TileStorage* unsafe_arena_release_tiles();

  // required .TSP.Reference stringTable = 4;
  bool has_stringtable() const;
  private:
  bool _internal_has_stringtable() const;
  public:
  void clear_stringtable();
  const ::TSP::Reference& stringtable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_stringtable();
  ::TSP::Reference* mutable_stringtable();
  void set_allocated_stringtable(::TSP::Reference* stringtable);
  private:
  const ::TSP::Reference& _internal_stringtable() const;
  ::TSP::Reference* _internal_mutable_stringtable();
  public:
  void unsafe_arena_set_allocated_stringtable(
      ::TSP::Reference* stringtable);
  ::TSP::Reference* unsafe_arena_release_stringtable();

  // required .TSP.Reference styleTable = 5;
  bool has_styletable() const;
  private:
  bool _internal_has_styletable() const;
  public:
  void clear_styletable();
  const ::TSP::Reference& styletable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_styletable();
  ::TSP::Reference* mutable_styletable();
  void set_allocated_styletable(::TSP::Reference* styletable);
  private:
  const ::TSP::Reference& _internal_styletable() const;
  ::TSP::Reference* _internal_mutable_styletable();
  public:
  void unsafe_arena_set_allocated_styletable(
      ::TSP::Reference* styletable);
  ::TSP::Reference* unsafe_arena_release_styletable();

  // required .TSP.Reference formulaTable = 6;
  bool has_formulatable() const;
  private:
  bool _internal_has_formulatable() const;
  public:
  void clear_formulatable();
  const ::TSP::Reference& formulatable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_formulatable();
  ::TSP::Reference* mutable_formulatable();
  void set_allocated_formulatable(::TSP::Reference* formulatable);
  private:
  const ::TSP::Reference& _internal_formulatable() const;
  ::TSP::Reference* _internal_mutable_formulatable();
  public:
  void unsafe_arena_set_allocated_formulatable(
      ::TSP::Reference* formulatable);
  ::TSP::Reference* unsafe_arena_release_formulatable();

  // required .TST.TableRBTree rowTileTree = 9;
  bool has_rowtiletree() const;
  private:
  bool _internal_has_rowtiletree() const;
  public:
  void clear_rowtiletree();
  const ::TST::TableRBTree& rowtiletree() const;
  PROTOBUF_NODISCARD ::TST::TableRBTree* release_rowtiletree();
  ::TST::TableRBTree* mutable_rowtiletree();
  void set_allocated_rowtiletree(::TST::TableRBTree* rowtiletree);
  private:
  const ::TST::TableRBTree& _internal_rowtiletree() const;
  ::TST::TableRBTree* _internal_mutable_rowtiletree();
  public:
  void unsafe_arena_set_allocated_rowtiletree(
      ::TST::TableRBTree* rowtiletree);
  ::TST::TableRBTree* unsafe_arena_release_rowtiletree();

  // required .TST.TableRBTree columnTileTree = 10;
  bool has_columntiletree() const;
  private:
  bool _internal_has_columntiletree() const;
  public:
  void clear_columntiletree();
  const ::TST::TableRBTree& columntiletree() const;
  PROTOBUF_NODISCARD ::TST::TableRBTree* release_columntiletree();
  ::TST::TableRBTree* mutable_columntiletree();
  void set_allocated_columntiletree(::TST::TableRBTree* columntiletree);
  private:
  const ::TST::TableRBTree& _internal_columntiletree() const;
  ::TST::TableRBTree* _internal_mutable_columntiletree();
  public:
  void unsafe_arena_set_allocated_columntiletree(
      ::TST::TableRBTree* columntiletree);
  ::TST::TableRBTree* unsafe_arena_release_columntiletree();

  // required .TSP.Reference formatTable = 11;
  bool has_formattable() const;
  private:
  bool _internal_has_formattable() const;
  public:
  void clear_formattable();
  const ::TSP::Reference& formattable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_formattable();
  ::TSP::Reference* mutable_formattable();
  void set_allocated_formattable(::TSP::Reference* formattable);
  private:
  const ::TSP::Reference& _internal_formattable() const;
  ::TSP::Reference* _internal_mutable_formattable();
  public:
  void unsafe_arena_set_allocated_formattable(
      ::TSP::Reference* formattable);
  ::TSP::Reference* unsafe_arena_release_formattable();

  // optional .TSP.Reference formulaErrorTable = 12;
  bool has_formulaerrortable() const;
  private:
  bool _internal_has_formulaerrortable() const;
  public:
  void clear_formulaerrortable();
  const ::TSP::Reference& formulaerrortable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_formulaerrortable();
  ::TSP::Reference* mutable_formulaerrortable();
  void set_allocated_formulaerrortable(::TSP::Reference* formulaerrortable);
  private:
  const ::TSP::Reference& _internal_formulaerrortable() const;
  ::TSP::Reference* _internal_mutable_formulaerrortable();
  public:
  void unsafe_arena_set_allocated_formulaerrortable(
      ::TSP::Reference* formulaerrortable);
  ::TSP::Reference* unsafe_arena_release_formulaerrortable();

  // optional .TSP.Reference merge_region_map = 13;
  bool has_merge_region_map() const;
  private:
  bool _internal_has_merge_region_map() const;
  public:
  void clear_merge_region_map();
  const ::TSP::Reference& merge_region_map() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_merge_region_map();
  ::TSP::Reference* mutable_merge_region_map();
  void set_allocated_merge_region_map(::TSP::Reference* merge_region_map);
  private:
  const ::TSP::Reference& _internal_merge_region_map() const;
  ::TSP::Reference* _internal_mutable_merge_region_map();
  public:
  void unsafe_arena_set_allocated_merge_region_map(
      ::TSP::Reference* merge_region_map);
  ::TSP::Reference* unsafe_arena_release_merge_region_map();

  // optional .TSP.Reference customFormatTable = 15;
  bool has_customformattable() const;
  private:
  bool _internal_has_customformattable() const;
  public:
  void clear_customformattable();
  const ::TSP::Reference& customformattable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_customformattable();
  ::TSP::Reference* mutable_customformattable();
  void set_allocated_customformattable(::TSP::Reference* customformattable);
  private:
  const ::TSP::Reference& _internal_customformattable() const;
  ::TSP::Reference* _internal_mutable_customformattable();
  public:
  void unsafe_arena_set_allocated_customformattable(
      ::TSP::Reference* customformattable);
  ::TSP::Reference* unsafe_arena_release_customformattable();

  // optional .TSP.Reference multipleChoiceListFormatTable = 16;
  bool has_multiplechoicelistformattable() const;
  private:
  bool _internal_has_multiplechoicelistformattable() const;
  public:
  void clear_multiplechoicelistformattable();
  const ::TSP::Reference& multiplechoicelistformattable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_multiplechoicelistformattable();
  ::TSP::Reference* mutable_multiplechoicelistformattable();
  void set_allocated_multiplechoicelistformattable(::TSP::Reference* multiplechoicelistformattable);
  private:
  const ::TSP::Reference& _internal_multiplechoicelistformattable() const;
  ::TSP::Reference* _internal_mutable_multiplechoicelistformattable();
  public:
  void unsafe_arena_set_allocated_multiplechoicelistformattable(
      ::TSP::Reference* multiplechoicelistformattable);
  ::TSP::Reference* unsafe_arena_release_multiplechoicelistformattable();

  // optional .TSP.Reference richTextPayloadTable = 17;
  bool has_richtextpayloadtable() const;
  private:
  bool _internal_has_richtextpayloadtable() const;
  public:
  void clear_richtextpayloadtable();
  const ::TSP::Reference& richtextpayloadtable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_richtextpayloadtable();
  ::TSP::Reference* mutable_richtextpayloadtable();
  void set_allocated_richtextpayloadtable(::TSP::Reference* richtextpayloadtable);
  private:
  const ::TSP::Reference& _internal_richtextpayloadtable() const;
  ::TSP::Reference* _internal_mutable_richtextpayloadtable();
  public:
  void unsafe_arena_set_allocated_richtextpayloadtable(
      ::TSP::Reference* richtextpayloadtable);
  ::TSP::Reference* unsafe_arena_release_richtextpayloadtable();

  // optional .TSP.Reference conditionalstyletable = 18;
  bool has_conditionalstyletable() const;
  private:
  bool _internal_has_conditionalstyletable() const;
  public:
  void clear_conditionalstyletable();
  const ::TSP::Reference& conditionalstyletable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_conditionalstyletable();
  ::TSP::Reference* mutable_conditionalstyletable();
  void set_allocated_conditionalstyletable(::TSP::Reference* conditionalstyletable);
  private:
  const ::TSP::Reference& _internal_conditionalstyletable() const;
  ::TSP::Reference* _internal_mutable_conditionalstyletable();
  public:
  void unsafe_arena_set_allocated_conditionalstyletable(
      ::TSP::Reference* conditionalstyletable);
  ::TSP::Reference* unsafe_arena_release_conditionalstyletable();

  // optional .TSP.Reference commentStorageTable = 19;
  bool has_commentstoragetable() const;
  private:
  bool _internal_has_commentstoragetable() const;
  public:
  void clear_commentstoragetable();
  const ::TSP::Reference& commentstoragetable() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_commentstoragetable();
  ::TSP::Reference* mutable_commentstoragetable();
  void set_allocated_commentstoragetable(::TSP::Reference* commentstoragetable);
  private:
  const ::TSP::Reference& _internal_commentstoragetable() const;
  ::TSP::Reference* _internal_mutable_commentstoragetable();
  public:
  void unsafe_arena_set_allocated_commentstoragetable(
      ::TSP::Reference* commentstoragetable);
  ::TSP::Reference* unsafe_arena_release_commentstoragetable();

  // required uint32 nextRowStripID = 7;
  bool has_nextrowstripid() const;
  private:
  bool _internal_has_nextrowstripid() const;
  public:
  void clear_nextrowstripid();
  uint32_t nextrowstripid() const;
  void set_nextrowstripid(uint32_t value);
  private:
  uint32_t _internal_nextrowstripid() const;
  void _internal_set_nextrowstripid(uint32_t value);
  public:

  // required uint32 nextColumnStripID = 8;
  bool has_nextcolumnstripid() const;
  private:
  bool _internal_has_nextcolumnstripid() const;
  public:
  void clear_nextcolumnstripid();
  uint32_t nextcolumnstripid() const;
  void set_nextcolumnstripid(uint32_t value);
  private:
  uint32_t _internal_nextcolumnstripid() const;
  void _internal_set_nextcolumnstripid(uint32_t value);
  public:

  // optional uint32 storage_version = 14;
  bool has_storage_version() const;
  private:
  bool _internal_has_storage_version() const;
  public:
  void clear_storage_version();
  uint32_t storage_version() const;
  void set_storage_version(uint32_t value);
  private:
  uint32_t _internal_storage_version() const;
  void _internal_set_storage_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.DataStore)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::HeaderStorage* rowheaders_;
    ::TSP::Reference* columnheaders_;
    ::TST::TileStorage* tiles_;
    ::TSP::Reference* stringtable_;
    ::TSP::Reference* styletable_;
    ::TSP::Reference* formulatable_;
    ::TST::TableRBTree* rowtiletree_;
    ::TST::TableRBTree* columntiletree_;
    ::TSP::Reference* formattable_;
    ::TSP::Reference* formulaerrortable_;
    ::TSP::Reference* merge_region_map_;
    ::TSP::Reference* customformattable_;
    ::TSP::Reference* multiplechoicelistformattable_;
    ::TSP::Reference* richtextpayloadtable_;
    ::TSP::Reference* conditionalstyletable_;
    ::TSP::Reference* commentstoragetable_;
    uint32_t nextrowstripid_;
    uint32_t nextcolumnstripid_;
    uint32_t storage_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableInfoArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableInfoArchive) */ {
 public:
  inline TableInfoArchive() : TableInfoArchive(nullptr) {}
  ~TableInfoArchive() override;
  explicit PROTOBUF_CONSTEXPR TableInfoArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableInfoArchive(const TableInfoArchive& from);
  TableInfoArchive(TableInfoArchive&& from) noexcept
    : TableInfoArchive() {
    *this = ::std::move(from);
  }

  inline TableInfoArchive& operator=(const TableInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableInfoArchive& operator=(TableInfoArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableInfoArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableInfoArchive* internal_default_instance() {
    return reinterpret_cast<const TableInfoArchive*>(
               &_TableInfoArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TableInfoArchive& a, TableInfoArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TableInfoArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableInfoArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableInfoArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableInfoArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableInfoArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableInfoArchive& from) {
    TableInfoArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableInfoArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableInfoArchive";
  }
  protected:
  explicit TableInfoArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTableModelFieldNumber = 2,
    kEditingStateFieldNumber = 3,
  };
  // required .TSD.DrawableArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSD::DrawableArchive& super() const;
  PROTOBUF_NODISCARD ::TSD::DrawableArchive* release_super();
  ::TSD::DrawableArchive* mutable_super();
  void set_allocated_super(::TSD::DrawableArchive* super);
  private:
  const ::TSD::DrawableArchive& _internal_super() const;
  ::TSD::DrawableArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSD::DrawableArchive* super);
  ::TSD::DrawableArchive* unsafe_arena_release_super();

  // required .TSP.Reference tableModel = 2;
  bool has_tablemodel() const;
  private:
  bool _internal_has_tablemodel() const;
  public:
  void clear_tablemodel();
  const ::TSP::Reference& tablemodel() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_tablemodel();
  ::TSP::Reference* mutable_tablemodel();
  void set_allocated_tablemodel(::TSP::Reference* tablemodel);
  private:
  const ::TSP::Reference& _internal_tablemodel() const;
  ::TSP::Reference* _internal_mutable_tablemodel();
  public:
  void unsafe_arena_set_allocated_tablemodel(
      ::TSP::Reference* tablemodel);
  ::TSP::Reference* unsafe_arena_release_tablemodel();

  // optional .TSP.Reference editingState = 3;
  bool has_editingstate() const;
  private:
  bool _internal_has_editingstate() const;
  public:
  void clear_editingstate();
  const ::TSP::Reference& editingstate() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_editingstate();
  ::TSP::Reference* mutable_editingstate();
  void set_allocated_editingstate(::TSP::Reference* editingstate);
  private:
  const ::TSP::Reference& _internal_editingstate() const;
  ::TSP::Reference* _internal_mutable_editingstate();
  public:
  void unsafe_arena_set_allocated_editingstate(
      ::TSP::Reference* editingstate);
  ::TSP::Reference* unsafe_arena_release_editingstate();

  // @@protoc_insertion_point(class_scope:TST.TableInfoArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSD::DrawableArchive* super_;
    ::TSP::Reference* tablemodel_;
    ::TSP::Reference* editingstate_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class EditingStateArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.EditingStateArchive) */ {
 public:
  inline EditingStateArchive() : EditingStateArchive(nullptr) {}
  ~EditingStateArchive() override;
  explicit PROTOBUF_CONSTEXPR EditingStateArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditingStateArchive(const EditingStateArchive& from);
  EditingStateArchive(EditingStateArchive&& from) noexcept
    : EditingStateArchive() {
    *this = ::std::move(from);
  }

  inline EditingStateArchive& operator=(const EditingStateArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditingStateArchive& operator=(EditingStateArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditingStateArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditingStateArchive* internal_default_instance() {
    return reinterpret_cast<const EditingStateArchive*>(
               &_EditingStateArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EditingStateArchive& a, EditingStateArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EditingStateArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditingStateArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditingStateArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditingStateArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditingStateArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditingStateArchive& from) {
    EditingStateArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditingStateArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.EditingStateArchive";
  }
  protected:
  explicit EditingStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEditingStorageFieldNumber = 1,
    kEditingCellFieldNumber = 2,
    kSelectionFieldNumber = 3,
    kLasteditingcellidFieldNumber = 4,
    kEditingcellidFieldNumber = 5,
    kDeprecatedSetupTextUndoRedoTransactionFieldNumber = 6,
    kCellWasEditedInCurrentSessionFieldNumber = 7,
  };
  // optional .TSP.Reference editingStorage = 1;
  bool has_editingstorage() const;
  private:
  bool _internal_has_editingstorage() const;
  public:
  void clear_editingstorage();
  const ::TSP::Reference& editingstorage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_editingstorage();
  ::TSP::Reference* mutable_editingstorage();
  void set_allocated_editingstorage(::TSP::Reference* editingstorage);
  private:
  const ::TSP::Reference& _internal_editingstorage() const;
  ::TSP::Reference* _internal_mutable_editingstorage();
  public:
  void unsafe_arena_set_allocated_editingstorage(
      ::TSP::Reference* editingstorage);
  ::TSP::Reference* unsafe_arena_release_editingstorage();

  // required .TST.Cell editingCell = 2;
  bool has_editingcell() const;
  private:
  bool _internal_has_editingcell() const;
  public:
  void clear_editingcell();
  const ::TST::Cell& editingcell() const;
  PROTOBUF_NODISCARD ::TST::Cell* release_editingcell();
  ::TST::Cell* mutable_editingcell();
  void set_allocated_editingcell(::TST::Cell* editingcell);
  private:
  const ::TST::Cell& _internal_editingcell() const;
  ::TST::Cell* _internal_mutable_editingcell();
  public:
  void unsafe_arena_set_allocated_editingcell(
      ::TST::Cell* editingcell);
  ::TST::Cell* unsafe_arena_release_editingcell();

  // optional .TST.SelectionArchive selection = 3;
  bool has_selection() const;
  private:
  bool _internal_has_selection() const;
  public:
  void clear_selection();
  const ::TST::SelectionArchive& selection() const;
  PROTOBUF_NODISCARD ::TST::SelectionArchive* release_selection();
  ::TST::SelectionArchive* mutable_selection();
  void set_allocated_selection(::TST::SelectionArchive* selection);
  private:
  const ::TST::SelectionArchive& _internal_selection() const;
  ::TST::SelectionArchive* _internal_mutable_selection();
  public:
  void unsafe_arena_set_allocated_selection(
      ::TST::SelectionArchive* selection);
  ::TST::SelectionArchive* unsafe_arena_release_selection();

  // optional .TST.CellID lasteditingcellid = 4;
  bool has_lasteditingcellid() const;
  private:
  bool _internal_has_lasteditingcellid() const;
  public:
  void clear_lasteditingcellid();
  const ::TST::CellID& lasteditingcellid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_lasteditingcellid();
  ::TST::CellID* mutable_lasteditingcellid();
  void set_allocated_lasteditingcellid(::TST::CellID* lasteditingcellid);
  private:
  const ::TST::CellID& _internal_lasteditingcellid() const;
  ::TST::CellID* _internal_mutable_lasteditingcellid();
  public:
  void unsafe_arena_set_allocated_lasteditingcellid(
      ::TST::CellID* lasteditingcellid);
  ::TST::CellID* unsafe_arena_release_lasteditingcellid();

  // optional .TST.CellID editingcellid = 5;
  bool has_editingcellid() const;
  private:
  bool _internal_has_editingcellid() const;
  public:
  void clear_editingcellid();
  const ::TST::CellID& editingcellid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_editingcellid();
  ::TST::CellID* mutable_editingcellid();
  void set_allocated_editingcellid(::TST::CellID* editingcellid);
  private:
  const ::TST::CellID& _internal_editingcellid() const;
  ::TST::CellID* _internal_mutable_editingcellid();
  public:
  void unsafe_arena_set_allocated_editingcellid(
      ::TST::CellID* editingcellid);
  ::TST::CellID* unsafe_arena_release_editingcellid();

  // optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
  bool has_deprecated_setup_textundoredotransaction() const;
  private:
  bool _internal_has_deprecated_setup_textundoredotransaction() const;
  public:
  void clear_deprecated_setup_textundoredotransaction();
  const ::TSWP::UndoTransaction& deprecated_setup_textundoredotransaction() const;
  PROTOBUF_NODISCARD ::TSWP::UndoTransaction* release_deprecated_setup_textundoredotransaction();
  ::TSWP::UndoTransaction* mutable_deprecated_setup_textundoredotransaction();
  void set_allocated_deprecated_setup_textundoredotransaction(::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction);
  private:
  const ::TSWP::UndoTransaction& _internal_deprecated_setup_textundoredotransaction() const;
  ::TSWP::UndoTransaction* _internal_mutable_deprecated_setup_textundoredotransaction();
  public:
  void unsafe_arena_set_allocated_deprecated_setup_textundoredotransaction(
      ::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction);
  ::TSWP::UndoTransaction* unsafe_arena_release_deprecated_setup_textundoredotransaction();

  // optional bool cell_was_edited_in_current_session = 7;
  bool has_cell_was_edited_in_current_session() const;
  private:
  bool _internal_has_cell_was_edited_in_current_session() const;
  public:
  void clear_cell_was_edited_in_current_session();
  bool cell_was_edited_in_current_session() const;
  void set_cell_was_edited_in_current_session(bool value);
  private:
  bool _internal_cell_was_edited_in_current_session() const;
  void _internal_set_cell_was_edited_in_current_session(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.EditingStateArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* editingstorage_;
    ::TST::Cell* editingcell_;
    ::TST::SelectionArchive* selection_;
    ::TST::CellID* lasteditingcellid_;
    ::TST::CellID* editingcellid_;
    ::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction_;
    bool cell_was_edited_in_current_session_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class WPTableInfoArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.WPTableInfoArchive) */ {
 public:
  inline WPTableInfoArchive() : WPTableInfoArchive(nullptr) {}
  ~WPTableInfoArchive() override;
  explicit PROTOBUF_CONSTEXPR WPTableInfoArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WPTableInfoArchive(const WPTableInfoArchive& from);
  WPTableInfoArchive(WPTableInfoArchive&& from) noexcept
    : WPTableInfoArchive() {
    *this = ::std::move(from);
  }

  inline WPTableInfoArchive& operator=(const WPTableInfoArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline WPTableInfoArchive& operator=(WPTableInfoArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WPTableInfoArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const WPTableInfoArchive* internal_default_instance() {
    return reinterpret_cast<const WPTableInfoArchive*>(
               &_WPTableInfoArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WPTableInfoArchive& a, WPTableInfoArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(WPTableInfoArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WPTableInfoArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WPTableInfoArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WPTableInfoArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WPTableInfoArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WPTableInfoArchive& from) {
    WPTableInfoArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WPTableInfoArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.WPTableInfoArchive";
  }
  protected:
  explicit WPTableInfoArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kStorageFieldNumber = 2,
  };
  // required .TST.TableInfoArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::TableInfoArchive& super() const;
  PROTOBUF_NODISCARD ::TST::TableInfoArchive* release_super();
  ::TST::TableInfoArchive* mutable_super();
  void set_allocated_super(::TST::TableInfoArchive* super);
  private:
  const ::TST::TableInfoArchive& _internal_super() const;
  ::TST::TableInfoArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::TableInfoArchive* super);
  ::TST::TableInfoArchive* unsafe_arena_release_super();

  // optional .TSP.Reference storage = 2;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // @@protoc_insertion_point(class_scope:TST.WPTableInfoArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::TableInfoArchive* super_;
    ::TSP::Reference* storage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableStyleNetworkArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableStyleNetworkArchive) */ {
 public:
  inline TableStyleNetworkArchive() : TableStyleNetworkArchive(nullptr) {}
  ~TableStyleNetworkArchive() override;
  explicit PROTOBUF_CONSTEXPR TableStyleNetworkArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableStyleNetworkArchive(const TableStyleNetworkArchive& from);
  TableStyleNetworkArchive(TableStyleNetworkArchive&& from) noexcept
    : TableStyleNetworkArchive() {
    *this = ::std::move(from);
  }

  inline TableStyleNetworkArchive& operator=(const TableStyleNetworkArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableStyleNetworkArchive& operator=(TableStyleNetworkArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableStyleNetworkArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableStyleNetworkArchive* internal_default_instance() {
    return reinterpret_cast<const TableStyleNetworkArchive*>(
               &_TableStyleNetworkArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TableStyleNetworkArchive& a, TableStyleNetworkArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TableStyleNetworkArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableStyleNetworkArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableStyleNetworkArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableStyleNetworkArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableStyleNetworkArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableStyleNetworkArchive& from) {
    TableStyleNetworkArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableStyleNetworkArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableStyleNetworkArchive";
  }
  protected:
  explicit TableStyleNetworkArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBodyTextStyleFieldNumber = 1,
    kHeaderRowTextStyleFieldNumber = 2,
    kHeaderColumnTextStyleFieldNumber = 3,
    kFooterRowTextStyleFieldNumber = 4,
    kBodyCellStyleFieldNumber = 5,
    kHeaderRowStyleFieldNumber = 6,
    kHeaderColumnStyleFieldNumber = 7,
    kFooterRowStyleFieldNumber = 8,
    kTableStyleFieldNumber = 9,
    kTableNameStyleFieldNumber = 10,
    kTableNameShapeStyleFieldNumber = 11,
    kPresetIndexFieldNumber = 12,
  };
  // required .TSP.Reference body_text_style = 1;
  bool has_body_text_style() const;
  private:
  bool _internal_has_body_text_style() const;
  public:
  void clear_body_text_style();
  const ::TSP::Reference& body_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_body_text_style();
  ::TSP::Reference* mutable_body_text_style();
  void set_allocated_body_text_style(::TSP::Reference* body_text_style);
  private:
  const ::TSP::Reference& _internal_body_text_style() const;
  ::TSP::Reference* _internal_mutable_body_text_style();
  public:
  void unsafe_arena_set_allocated_body_text_style(
      ::TSP::Reference* body_text_style);
  ::TSP::Reference* unsafe_arena_release_body_text_style();

  // required .TSP.Reference header_row_text_style = 2;
  bool has_header_row_text_style() const;
  private:
  bool _internal_has_header_row_text_style() const;
  public:
  void clear_header_row_text_style();
  const ::TSP::Reference& header_row_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_row_text_style();
  ::TSP::Reference* mutable_header_row_text_style();
  void set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style);
  private:
  const ::TSP::Reference& _internal_header_row_text_style() const;
  ::TSP::Reference* _internal_mutable_header_row_text_style();
  public:
  void unsafe_arena_set_allocated_header_row_text_style(
      ::TSP::Reference* header_row_text_style);
  ::TSP::Reference* unsafe_arena_release_header_row_text_style();

  // required .TSP.Reference header_column_text_style = 3;
  bool has_header_column_text_style() const;
  private:
  bool _internal_has_header_column_text_style() const;
  public:
  void clear_header_column_text_style();
  const ::TSP::Reference& header_column_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_column_text_style();
  ::TSP::Reference* mutable_header_column_text_style();
  void set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style);
  private:
  const ::TSP::Reference& _internal_header_column_text_style() const;
  ::TSP::Reference* _internal_mutable_header_column_text_style();
  public:
  void unsafe_arena_set_allocated_header_column_text_style(
      ::TSP::Reference* header_column_text_style);
  ::TSP::Reference* unsafe_arena_release_header_column_text_style();

  // required .TSP.Reference footer_row_text_style = 4;
  bool has_footer_row_text_style() const;
  private:
  bool _internal_has_footer_row_text_style() const;
  public:
  void clear_footer_row_text_style();
  const ::TSP::Reference& footer_row_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_footer_row_text_style();
  ::TSP::Reference* mutable_footer_row_text_style();
  void set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style);
  private:
  const ::TSP::Reference& _internal_footer_row_text_style() const;
  ::TSP::Reference* _internal_mutable_footer_row_text_style();
  public:
  void unsafe_arena_set_allocated_footer_row_text_style(
      ::TSP::Reference* footer_row_text_style);
  ::TSP::Reference* unsafe_arena_release_footer_row_text_style();

  // required .TSP.Reference body_cell_style = 5;
  bool has_body_cell_style() const;
  private:
  bool _internal_has_body_cell_style() const;
  public:
  void clear_body_cell_style();
  const ::TSP::Reference& body_cell_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_body_cell_style();
  ::TSP::Reference* mutable_body_cell_style();
  void set_allocated_body_cell_style(::TSP::Reference* body_cell_style);
  private:
  const ::TSP::Reference& _internal_body_cell_style() const;
  ::TSP::Reference* _internal_mutable_body_cell_style();
  public:
  void unsafe_arena_set_allocated_body_cell_style(
      ::TSP::Reference* body_cell_style);
  ::TSP::Reference* unsafe_arena_release_body_cell_style();

  // required .TSP.Reference header_row_style = 6;
  bool has_header_row_style() const;
  private:
  bool _internal_has_header_row_style() const;
  public:
  void clear_header_row_style();
  const ::TSP::Reference& header_row_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_row_style();
  ::TSP::Reference* mutable_header_row_style();
  void set_allocated_header_row_style(::TSP::Reference* header_row_style);
  private:
  const ::TSP::Reference& _internal_header_row_style() const;
  ::TSP::Reference* _internal_mutable_header_row_style();
  public:
  void unsafe_arena_set_allocated_header_row_style(
      ::TSP::Reference* header_row_style);
  ::TSP::Reference* unsafe_arena_release_header_row_style();

  // required .TSP.Reference header_column_style = 7;
  bool has_header_column_style() const;
  private:
  bool _internal_has_header_column_style() const;
  public:
  void clear_header_column_style();
  const ::TSP::Reference& header_column_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_column_style();
  ::TSP::Reference* mutable_header_column_style();
  void set_allocated_header_column_style(::TSP::Reference* header_column_style);
  private:
  const ::TSP::Reference& _internal_header_column_style() const;
  ::TSP::Reference* _internal_mutable_header_column_style();
  public:
  void unsafe_arena_set_allocated_header_column_style(
      ::TSP::Reference* header_column_style);
  ::TSP::Reference* unsafe_arena_release_header_column_style();

  // required .TSP.Reference footer_row_style = 8;
  bool has_footer_row_style() const;
  private:
  bool _internal_has_footer_row_style() const;
  public:
  void clear_footer_row_style();
  const ::TSP::Reference& footer_row_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_footer_row_style();
  ::TSP::Reference* mutable_footer_row_style();
  void set_allocated_footer_row_style(::TSP::Reference* footer_row_style);
  private:
  const ::TSP::Reference& _internal_footer_row_style() const;
  ::TSP::Reference* _internal_mutable_footer_row_style();
  public:
  void unsafe_arena_set_allocated_footer_row_style(
      ::TSP::Reference* footer_row_style);
  ::TSP::Reference* unsafe_arena_release_footer_row_style();

  // required .TSP.Reference table_style = 9;
  bool has_table_style() const;
  private:
  bool _internal_has_table_style() const;
  public:
  void clear_table_style();
  const ::TSP::Reference& table_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_style();
  ::TSP::Reference* mutable_table_style();
  void set_allocated_table_style(::TSP::Reference* table_style);
  private:
  const ::TSP::Reference& _internal_table_style() const;
  ::TSP::Reference* _internal_mutable_table_style();
  public:
  void unsafe_arena_set_allocated_table_style(
      ::TSP::Reference* table_style);
  ::TSP::Reference* unsafe_arena_release_table_style();

  // optional .TSP.Reference table_name_style = 10;
  bool has_table_name_style() const;
  private:
  bool _internal_has_table_name_style() const;
  public:
  void clear_table_name_style();
  const ::TSP::Reference& table_name_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_name_style();
  ::TSP::Reference* mutable_table_name_style();
  void set_allocated_table_name_style(::TSP::Reference* table_name_style);
  private:
  const ::TSP::Reference& _internal_table_name_style() const;
  ::TSP::Reference* _internal_mutable_table_name_style();
  public:
  void unsafe_arena_set_allocated_table_name_style(
      ::TSP::Reference* table_name_style);
  ::TSP::Reference* unsafe_arena_release_table_name_style();

  // optional .TSP.Reference table_name_shape_style = 11;
  bool has_table_name_shape_style() const;
  private:
  bool _internal_has_table_name_shape_style() const;
  public:
  void clear_table_name_shape_style();
  const ::TSP::Reference& table_name_shape_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_name_shape_style();
  ::TSP::Reference* mutable_table_name_shape_style();
  void set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style);
  private:
  const ::TSP::Reference& _internal_table_name_shape_style() const;
  ::TSP::Reference* _internal_mutable_table_name_shape_style();
  public:
  void unsafe_arena_set_allocated_table_name_shape_style(
      ::TSP::Reference* table_name_shape_style);
  ::TSP::Reference* unsafe_arena_release_table_name_shape_style();

  // optional uint32 preset_index = 12;
  bool has_preset_index() const;
  private:
  bool _internal_has_preset_index() const;
  public:
  void clear_preset_index();
  uint32_t preset_index() const;
  void set_preset_index(uint32_t value);
  private:
  uint32_t _internal_preset_index() const;
  void _internal_set_preset_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableStyleNetworkArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* body_text_style_;
    ::TSP::Reference* header_row_text_style_;
    ::TSP::Reference* header_column_text_style_;
    ::TSP::Reference* footer_row_text_style_;
    ::TSP::Reference* body_cell_style_;
    ::TSP::Reference* header_row_style_;
    ::TSP::Reference* header_column_style_;
    ::TSP::Reference* footer_row_style_;
    ::TSP::Reference* table_style_;
    ::TSP::Reference* table_name_style_;
    ::TSP::Reference* table_name_shape_style_;
    uint32_t preset_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableModelArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableModelArchive) */ {
 public:
  inline TableModelArchive() : TableModelArchive(nullptr) {}
  ~TableModelArchive() override;
  explicit PROTOBUF_CONSTEXPR TableModelArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableModelArchive(const TableModelArchive& from);
  TableModelArchive(TableModelArchive&& from) noexcept
    : TableModelArchive() {
    *this = ::std::move(from);
  }

  inline TableModelArchive& operator=(const TableModelArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableModelArchive& operator=(TableModelArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableModelArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableModelArchive* internal_default_instance() {
    return reinterpret_cast<const TableModelArchive*>(
               &_TableModelArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TableModelArchive& a, TableModelArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TableModelArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableModelArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableModelArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableModelArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableModelArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableModelArchive& from) {
    TableModelArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableModelArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableModelArchive";
  }
  protected:
  explicit TableModelArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kTableNameFieldNumber = 8,
    kFromTableIdFieldNumber = 43,
    kTableStyleFieldNumber = 3,
    kDataStoreFieldNumber = 4,
    kProviderFieldNumber = 5,
    kBodyCellStyleFieldNumber = 18,
    kHeaderRowStyleFieldNumber = 19,
    kHeaderColumnStyleFieldNumber = 20,
    kFooterRowStyleFieldNumber = 21,
    kOriginOffsetFieldNumber = 23,
    kBodyTextStyleFieldNumber = 24,
    kHeaderRowTextStyleFieldNumber = 25,
    kHeaderColumnTextStyleFieldNumber = 26,
    kFooterRowTextStyleFieldNumber = 27,
    kTableNameStyleFieldNumber = 30,
    kHiddenStateFormulaOwnerForColumnsFieldNumber = 34,
    kHiddenStateFormulaOwnerForRowsFieldNumber = 35,
    kTableNameShapeStyleFieldNumber = 36,
    kFilterSetFieldNumber = 38,
    kConditionalStyleFormulaOwnerIdFieldNumber = 39,
    kNumberOfRowsFieldNumber = 6,
    kNumberOfColumnsFieldNumber = 7,
    kNumberOfHeaderRowsFieldNumber = 9,
    kNumberOfHeaderColumnsFieldNumber = 10,
    kNumberOfFooterRowsFieldNumber = 11,
    kNumberOfHiddenRowsFieldNumber = 14,
    kDefaultRowHeightFieldNumber = 16,
    kDefaultColumnWidthFieldNumber = 17,
    kNumberOfHiddenColumnsFieldNumber = 15,
    kTableNameEnabledFieldNumber = 22,
    kTableNameBorderEnabledFieldNumber = 37,
    kHeaderRowsFrozenFieldNumber = 12,
    kHeaderColumnsFrozenFieldNumber = 13,
    kPresetIndexFieldNumber = 28,
    kRepeatingHeaderRowsEnabledFieldNumber = 29,
    kRepeatingHeaderColumnsEnabledFieldNumber = 32,
    kStyleApplyClearsAllFieldNumber = 31,
    kTableNameHeightFieldNumber = 33,
    kNumberOfFilteredRowsFieldNumber = 40,
    kNumberOfUserHiddenRowsFieldNumber = 41,
    kNumberOfUserHiddenColumnsFieldNumber = 42,
  };
  // required string table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const std::string& table_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_id();
  PROTOBUF_NODISCARD std::string* release_table_id();
  void set_allocated_table_id(std::string* table_id);
  private:
  const std::string& _internal_table_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_id(const std::string& value);
  std::string* _internal_mutable_table_id();
  public:

  // required string table_name = 8;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string from_table_id = 43;
  bool has_from_table_id() const;
  private:
  bool _internal_has_from_table_id() const;
  public:
  void clear_from_table_id();
  const std::string& from_table_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_table_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_table_id();
  PROTOBUF_NODISCARD std::string* release_from_table_id();
  void set_allocated_from_table_id(std::string* from_table_id);
  private:
  const std::string& _internal_from_table_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_table_id(const std::string& value);
  std::string* _internal_mutable_from_table_id();
  public:

  // required .TSP.Reference table_style = 3;
  bool has_table_style() const;
  private:
  bool _internal_has_table_style() const;
  public:
  void clear_table_style();
  const ::TSP::Reference& table_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_style();
  ::TSP::Reference* mutable_table_style();
  void set_allocated_table_style(::TSP::Reference* table_style);
  private:
  const ::TSP::Reference& _internal_table_style() const;
  ::TSP::Reference* _internal_mutable_table_style();
  public:
  void unsafe_arena_set_allocated_table_style(
      ::TSP::Reference* table_style);
  ::TSP::Reference* unsafe_arena_release_table_style();

  // required .TST.DataStore data_store = 4;
  bool has_data_store() const;
  private:
  bool _internal_has_data_store() const;
  public:
  void clear_data_store();
  const ::TST::DataStore& data_store() const;
  PROTOBUF_NODISCARD ::TST::DataStore* release_data_store();
  ::TST::DataStore* mutable_data_store();
  void set_allocated_data_store(::TST::DataStore* data_store);
  private:
  const ::TST::DataStore& _internal_data_store() const;
  ::TST::DataStore* _internal_mutable_data_store();
  public:
  void unsafe_arena_set_allocated_data_store(
      ::TST::DataStore* data_store);
  ::TST::DataStore* unsafe_arena_release_data_store();

  // optional .TSP.Reference provider = 5;
  bool has_provider() const;
  private:
  bool _internal_has_provider() const;
  public:
  void clear_provider();
  const ::TSP::Reference& provider() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_provider();
  ::TSP::Reference* mutable_provider();
  void set_allocated_provider(::TSP::Reference* provider);
  private:
  const ::TSP::Reference& _internal_provider() const;
  ::TSP::Reference* _internal_mutable_provider();
  public:
  void unsafe_arena_set_allocated_provider(
      ::TSP::Reference* provider);
  ::TSP::Reference* unsafe_arena_release_provider();

  // required .TSP.Reference body_cell_style = 18;
  bool has_body_cell_style() const;
  private:
  bool _internal_has_body_cell_style() const;
  public:
  void clear_body_cell_style();
  const ::TSP::Reference& body_cell_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_body_cell_style();
  ::TSP::Reference* mutable_body_cell_style();
  void set_allocated_body_cell_style(::TSP::Reference* body_cell_style);
  private:
  const ::TSP::Reference& _internal_body_cell_style() const;
  ::TSP::Reference* _internal_mutable_body_cell_style();
  public:
  void unsafe_arena_set_allocated_body_cell_style(
      ::TSP::Reference* body_cell_style);
  ::TSP::Reference* unsafe_arena_release_body_cell_style();

  // required .TSP.Reference header_row_style = 19;
  bool has_header_row_style() const;
  private:
  bool _internal_has_header_row_style() const;
  public:
  void clear_header_row_style();
  const ::TSP::Reference& header_row_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_row_style();
  ::TSP::Reference* mutable_header_row_style();
  void set_allocated_header_row_style(::TSP::Reference* header_row_style);
  private:
  const ::TSP::Reference& _internal_header_row_style() const;
  ::TSP::Reference* _internal_mutable_header_row_style();
  public:
  void unsafe_arena_set_allocated_header_row_style(
      ::TSP::Reference* header_row_style);
  ::TSP::Reference* unsafe_arena_release_header_row_style();

  // required .TSP.Reference header_column_style = 20;
  bool has_header_column_style() const;
  private:
  bool _internal_has_header_column_style() const;
  public:
  void clear_header_column_style();
  const ::TSP::Reference& header_column_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_column_style();
  ::TSP::Reference* mutable_header_column_style();
  void set_allocated_header_column_style(::TSP::Reference* header_column_style);
  private:
  const ::TSP::Reference& _internal_header_column_style() const;
  ::TSP::Reference* _internal_mutable_header_column_style();
  public:
  void unsafe_arena_set_allocated_header_column_style(
      ::TSP::Reference* header_column_style);
  ::TSP::Reference* unsafe_arena_release_header_column_style();

  // required .TSP.Reference footer_row_style = 21;
  bool has_footer_row_style() const;
  private:
  bool _internal_has_footer_row_style() const;
  public:
  void clear_footer_row_style();
  const ::TSP::Reference& footer_row_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_footer_row_style();
  ::TSP::Reference* mutable_footer_row_style();
  void set_allocated_footer_row_style(::TSP::Reference* footer_row_style);
  private:
  const ::TSP::Reference& _internal_footer_row_style() const;
  ::TSP::Reference* _internal_mutable_footer_row_style();
  public:
  void unsafe_arena_set_allocated_footer_row_style(
      ::TSP::Reference* footer_row_style);
  ::TSP::Reference* unsafe_arena_release_footer_row_style();

  // optional .TST.CellID origin_offset = 23 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_origin_offset() const;
  private:
  bool _internal_has_origin_offset() const;
  public:
  PROTOBUF_DEPRECATED void clear_origin_offset();
  PROTOBUF_DEPRECATED const ::TST::CellID& origin_offset() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::TST::CellID* release_origin_offset();
  PROTOBUF_DEPRECATED ::TST::CellID* mutable_origin_offset();
  PROTOBUF_DEPRECATED void set_allocated_origin_offset(::TST::CellID* origin_offset);
  private:
  const ::TST::CellID& _internal_origin_offset() const;
  ::TST::CellID* _internal_mutable_origin_offset();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_origin_offset(
      ::TST::CellID* origin_offset);
  PROTOBUF_DEPRECATED ::TST::CellID* unsafe_arena_release_origin_offset();

  // required .TSP.Reference body_text_style = 24;
  bool has_body_text_style() const;
  private:
  bool _internal_has_body_text_style() const;
  public:
  void clear_body_text_style();
  const ::TSP::Reference& body_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_body_text_style();
  ::TSP::Reference* mutable_body_text_style();
  void set_allocated_body_text_style(::TSP::Reference* body_text_style);
  private:
  const ::TSP::Reference& _internal_body_text_style() const;
  ::TSP::Reference* _internal_mutable_body_text_style();
  public:
  void unsafe_arena_set_allocated_body_text_style(
      ::TSP::Reference* body_text_style);
  ::TSP::Reference* unsafe_arena_release_body_text_style();

  // required .TSP.Reference header_row_text_style = 25;
  bool has_header_row_text_style() const;
  private:
  bool _internal_has_header_row_text_style() const;
  public:
  void clear_header_row_text_style();
  const ::TSP::Reference& header_row_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_row_text_style();
  ::TSP::Reference* mutable_header_row_text_style();
  void set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style);
  private:
  const ::TSP::Reference& _internal_header_row_text_style() const;
  ::TSP::Reference* _internal_mutable_header_row_text_style();
  public:
  void unsafe_arena_set_allocated_header_row_text_style(
      ::TSP::Reference* header_row_text_style);
  ::TSP::Reference* unsafe_arena_release_header_row_text_style();

  // required .TSP.Reference header_column_text_style = 26;
  bool has_header_column_text_style() const;
  private:
  bool _internal_has_header_column_text_style() const;
  public:
  void clear_header_column_text_style();
  const ::TSP::Reference& header_column_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_header_column_text_style();
  ::TSP::Reference* mutable_header_column_text_style();
  void set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style);
  private:
  const ::TSP::Reference& _internal_header_column_text_style() const;
  ::TSP::Reference* _internal_mutable_header_column_text_style();
  public:
  void unsafe_arena_set_allocated_header_column_text_style(
      ::TSP::Reference* header_column_text_style);
  ::TSP::Reference* unsafe_arena_release_header_column_text_style();

  // required .TSP.Reference footer_row_text_style = 27;
  bool has_footer_row_text_style() const;
  private:
  bool _internal_has_footer_row_text_style() const;
  public:
  void clear_footer_row_text_style();
  const ::TSP::Reference& footer_row_text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_footer_row_text_style();
  ::TSP::Reference* mutable_footer_row_text_style();
  void set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style);
  private:
  const ::TSP::Reference& _internal_footer_row_text_style() const;
  ::TSP::Reference* _internal_mutable_footer_row_text_style();
  public:
  void unsafe_arena_set_allocated_footer_row_text_style(
      ::TSP::Reference* footer_row_text_style);
  ::TSP::Reference* unsafe_arena_release_footer_row_text_style();

  // optional .TSP.Reference table_name_style = 30;
  bool has_table_name_style() const;
  private:
  bool _internal_has_table_name_style() const;
  public:
  void clear_table_name_style();
  const ::TSP::Reference& table_name_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_name_style();
  ::TSP::Reference* mutable_table_name_style();
  void set_allocated_table_name_style(::TSP::Reference* table_name_style);
  private:
  const ::TSP::Reference& _internal_table_name_style() const;
  ::TSP::Reference* _internal_mutable_table_name_style();
  public:
  void unsafe_arena_set_allocated_table_name_style(
      ::TSP::Reference* table_name_style);
  ::TSP::Reference* unsafe_arena_release_table_name_style();

  // optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
  bool has_hidden_state_formula_owner_for_columns() const;
  private:
  bool _internal_has_hidden_state_formula_owner_for_columns() const;
  public:
  void clear_hidden_state_formula_owner_for_columns();
  const ::TSP::Reference& hidden_state_formula_owner_for_columns() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_hidden_state_formula_owner_for_columns();
  ::TSP::Reference* mutable_hidden_state_formula_owner_for_columns();
  void set_allocated_hidden_state_formula_owner_for_columns(::TSP::Reference* hidden_state_formula_owner_for_columns);
  private:
  const ::TSP::Reference& _internal_hidden_state_formula_owner_for_columns() const;
  ::TSP::Reference* _internal_mutable_hidden_state_formula_owner_for_columns();
  public:
  void unsafe_arena_set_allocated_hidden_state_formula_owner_for_columns(
      ::TSP::Reference* hidden_state_formula_owner_for_columns);
  ::TSP::Reference* unsafe_arena_release_hidden_state_formula_owner_for_columns();

  // optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
  bool has_hidden_state_formula_owner_for_rows() const;
  private:
  bool _internal_has_hidden_state_formula_owner_for_rows() const;
  public:
  void clear_hidden_state_formula_owner_for_rows();
  const ::TSP::Reference& hidden_state_formula_owner_for_rows() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_hidden_state_formula_owner_for_rows();
  ::TSP::Reference* mutable_hidden_state_formula_owner_for_rows();
  void set_allocated_hidden_state_formula_owner_for_rows(::TSP::Reference* hidden_state_formula_owner_for_rows);
  private:
  const ::TSP::Reference& _internal_hidden_state_formula_owner_for_rows() const;
  ::TSP::Reference* _internal_mutable_hidden_state_formula_owner_for_rows();
  public:
  void unsafe_arena_set_allocated_hidden_state_formula_owner_for_rows(
      ::TSP::Reference* hidden_state_formula_owner_for_rows);
  ::TSP::Reference* unsafe_arena_release_hidden_state_formula_owner_for_rows();

  // optional .TSP.Reference table_name_shape_style = 36;
  bool has_table_name_shape_style() const;
  private:
  bool _internal_has_table_name_shape_style() const;
  public:
  void clear_table_name_shape_style();
  const ::TSP::Reference& table_name_shape_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_table_name_shape_style();
  ::TSP::Reference* mutable_table_name_shape_style();
  void set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style);
  private:
  const ::TSP::Reference& _internal_table_name_shape_style() const;
  ::TSP::Reference* _internal_mutable_table_name_shape_style();
  public:
  void unsafe_arena_set_allocated_table_name_shape_style(
      ::TSP::Reference* table_name_shape_style);
  ::TSP::Reference* unsafe_arena_release_table_name_shape_style();

  // optional .TSP.Reference filter_set = 38;
  bool has_filter_set() const;
  private:
  bool _internal_has_filter_set() const;
  public:
  void clear_filter_set();
  const ::TSP::Reference& filter_set() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_filter_set();
  ::TSP::Reference* mutable_filter_set();
  void set_allocated_filter_set(::TSP::Reference* filter_set);
  private:
  const ::TSP::Reference& _internal_filter_set() const;
  ::TSP::Reference* _internal_mutable_filter_set();
  public:
  void unsafe_arena_set_allocated_filter_set(
      ::TSP::Reference* filter_set);
  ::TSP::Reference* unsafe_arena_release_filter_set();

  // optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
  bool has_conditional_style_formula_owner_id() const;
  private:
  bool _internal_has_conditional_style_formula_owner_id() const;
  public:
  void clear_conditional_style_formula_owner_id();
  const ::TSCE::CFUUIDArchive& conditional_style_formula_owner_id() const;
  PROTOBUF_NODISCARD ::TSCE::CFUUIDArchive* release_conditional_style_formula_owner_id();
  ::TSCE::CFUUIDArchive* mutable_conditional_style_formula_owner_id();
  void set_allocated_conditional_style_formula_owner_id(::TSCE::CFUUIDArchive* conditional_style_formula_owner_id);
  private:
  const ::TSCE::CFUUIDArchive& _internal_conditional_style_formula_owner_id() const;
  ::TSCE::CFUUIDArchive* _internal_mutable_conditional_style_formula_owner_id();
  public:
  void unsafe_arena_set_allocated_conditional_style_formula_owner_id(
      ::TSCE::CFUUIDArchive* conditional_style_formula_owner_id);
  ::TSCE::CFUUIDArchive* unsafe_arena_release_conditional_style_formula_owner_id();

  // required uint32 number_of_rows = 6;
  bool has_number_of_rows() const;
  private:
  bool _internal_has_number_of_rows() const;
  public:
  void clear_number_of_rows();
  uint32_t number_of_rows() const;
  void set_number_of_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_rows() const;
  void _internal_set_number_of_rows(uint32_t value);
  public:

  // required uint32 number_of_columns = 7;
  bool has_number_of_columns() const;
  private:
  bool _internal_has_number_of_columns() const;
  public:
  void clear_number_of_columns();
  uint32_t number_of_columns() const;
  void set_number_of_columns(uint32_t value);
  private:
  uint32_t _internal_number_of_columns() const;
  void _internal_set_number_of_columns(uint32_t value);
  public:

  // optional uint32 number_of_header_rows = 9;
  bool has_number_of_header_rows() const;
  private:
  bool _internal_has_number_of_header_rows() const;
  public:
  void clear_number_of_header_rows();
  uint32_t number_of_header_rows() const;
  void set_number_of_header_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_header_rows() const;
  void _internal_set_number_of_header_rows(uint32_t value);
  public:

  // optional uint32 number_of_header_columns = 10;
  bool has_number_of_header_columns() const;
  private:
  bool _internal_has_number_of_header_columns() const;
  public:
  void clear_number_of_header_columns();
  uint32_t number_of_header_columns() const;
  void set_number_of_header_columns(uint32_t value);
  private:
  uint32_t _internal_number_of_header_columns() const;
  void _internal_set_number_of_header_columns(uint32_t value);
  public:

  // optional uint32 number_of_footer_rows = 11;
  bool has_number_of_footer_rows() const;
  private:
  bool _internal_has_number_of_footer_rows() const;
  public:
  void clear_number_of_footer_rows();
  uint32_t number_of_footer_rows() const;
  void set_number_of_footer_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_footer_rows() const;
  void _internal_set_number_of_footer_rows(uint32_t value);
  public:

  // optional uint32 number_of_hidden_rows = 14;
  bool has_number_of_hidden_rows() const;
  private:
  bool _internal_has_number_of_hidden_rows() const;
  public:
  void clear_number_of_hidden_rows();
  uint32_t number_of_hidden_rows() const;
  void set_number_of_hidden_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_hidden_rows() const;
  void _internal_set_number_of_hidden_rows(uint32_t value);
  public:

  // required double default_row_height = 16;
  bool has_default_row_height() const;
  private:
  bool _internal_has_default_row_height() const;
  public:
  void clear_default_row_height();
  double default_row_height() const;
  void set_default_row_height(double value);
  private:
  double _internal_default_row_height() const;
  void _internal_set_default_row_height(double value);
  public:

  // required double default_column_width = 17;
  bool has_default_column_width() const;
  private:
  bool _internal_has_default_column_width() const;
  public:
  void clear_default_column_width();
  double default_column_width() const;
  void set_default_column_width(double value);
  private:
  double _internal_default_column_width() const;
  void _internal_set_default_column_width(double value);
  public:

  // optional uint32 number_of_hidden_columns = 15;
  bool has_number_of_hidden_columns() const;
  private:
  bool _internal_has_number_of_hidden_columns() const;
  public:
  void clear_number_of_hidden_columns();
  uint32_t number_of_hidden_columns() const;
  void set_number_of_hidden_columns(uint32_t value);
  private:
  uint32_t _internal_number_of_hidden_columns() const;
  void _internal_set_number_of_hidden_columns(uint32_t value);
  public:

  // optional bool table_name_enabled = 22;
  bool has_table_name_enabled() const;
  private:
  bool _internal_has_table_name_enabled() const;
  public:
  void clear_table_name_enabled();
  bool table_name_enabled() const;
  void set_table_name_enabled(bool value);
  private:
  bool _internal_table_name_enabled() const;
  void _internal_set_table_name_enabled(bool value);
  public:

  // optional bool table_name_border_enabled = 37;
  bool has_table_name_border_enabled() const;
  private:
  bool _internal_has_table_name_border_enabled() const;
  public:
  void clear_table_name_border_enabled();
  bool table_name_border_enabled() const;
  void set_table_name_border_enabled(bool value);
  private:
  bool _internal_table_name_border_enabled() const;
  void _internal_set_table_name_border_enabled(bool value);
  public:

  // optional bool header_rows_frozen = 12;
  bool has_header_rows_frozen() const;
  private:
  bool _internal_has_header_rows_frozen() const;
  public:
  void clear_header_rows_frozen();
  bool header_rows_frozen() const;
  void set_header_rows_frozen(bool value);
  private:
  bool _internal_header_rows_frozen() const;
  void _internal_set_header_rows_frozen(bool value);
  public:

  // optional bool header_columns_frozen = 13;
  bool has_header_columns_frozen() const;
  private:
  bool _internal_has_header_columns_frozen() const;
  public:
  void clear_header_columns_frozen();
  bool header_columns_frozen() const;
  void set_header_columns_frozen(bool value);
  private:
  bool _internal_header_columns_frozen() const;
  void _internal_set_header_columns_frozen(bool value);
  public:

  // required uint32 preset_index = 28;
  bool has_preset_index() const;
  private:
  bool _internal_has_preset_index() const;
  public:
  void clear_preset_index();
  uint32_t preset_index() const;
  void set_preset_index(uint32_t value);
  private:
  uint32_t _internal_preset_index() const;
  void _internal_set_preset_index(uint32_t value);
  public:

  // optional bool repeating_header_rows_enabled = 29;
  bool has_repeating_header_rows_enabled() const;
  private:
  bool _internal_has_repeating_header_rows_enabled() const;
  public:
  void clear_repeating_header_rows_enabled();
  bool repeating_header_rows_enabled() const;
  void set_repeating_header_rows_enabled(bool value);
  private:
  bool _internal_repeating_header_rows_enabled() const;
  void _internal_set_repeating_header_rows_enabled(bool value);
  public:

  // optional bool repeating_header_columns_enabled = 32;
  bool has_repeating_header_columns_enabled() const;
  private:
  bool _internal_has_repeating_header_columns_enabled() const;
  public:
  void clear_repeating_header_columns_enabled();
  bool repeating_header_columns_enabled() const;
  void set_repeating_header_columns_enabled(bool value);
  private:
  bool _internal_repeating_header_columns_enabled() const;
  void _internal_set_repeating_header_columns_enabled(bool value);
  public:

  // optional bool style_apply_clears_all = 31;
  bool has_style_apply_clears_all() const;
  private:
  bool _internal_has_style_apply_clears_all() const;
  public:
  void clear_style_apply_clears_all();
  bool style_apply_clears_all() const;
  void set_style_apply_clears_all(bool value);
  private:
  bool _internal_style_apply_clears_all() const;
  void _internal_set_style_apply_clears_all(bool value);
  public:

  // optional double table_name_height = 33;
  bool has_table_name_height() const;
  private:
  bool _internal_has_table_name_height() const;
  public:
  void clear_table_name_height();
  double table_name_height() const;
  void set_table_name_height(double value);
  private:
  double _internal_table_name_height() const;
  void _internal_set_table_name_height(double value);
  public:

  // optional uint32 number_of_filtered_rows = 40;
  bool has_number_of_filtered_rows() const;
  private:
  bool _internal_has_number_of_filtered_rows() const;
  public:
  void clear_number_of_filtered_rows();
  uint32_t number_of_filtered_rows() const;
  void set_number_of_filtered_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_filtered_rows() const;
  void _internal_set_number_of_filtered_rows(uint32_t value);
  public:

  // optional uint32 number_of_user_hidden_rows = 41;
  bool has_number_of_user_hidden_rows() const;
  private:
  bool _internal_has_number_of_user_hidden_rows() const;
  public:
  void clear_number_of_user_hidden_rows();
  uint32_t number_of_user_hidden_rows() const;
  void set_number_of_user_hidden_rows(uint32_t value);
  private:
  uint32_t _internal_number_of_user_hidden_rows() const;
  void _internal_set_number_of_user_hidden_rows(uint32_t value);
  public:

  // optional uint32 number_of_user_hidden_columns = 42;
  bool has_number_of_user_hidden_columns() const;
  private:
  bool _internal_has_number_of_user_hidden_columns() const;
  public:
  void clear_number_of_user_hidden_columns();
  uint32_t number_of_user_hidden_columns() const;
  void set_number_of_user_hidden_columns(uint32_t value);
  private:
  uint32_t _internal_number_of_user_hidden_columns() const;
  void _internal_set_number_of_user_hidden_columns(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableModelArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_table_id_;
    ::TSP::Reference* table_style_;
    ::TST::DataStore* data_store_;
    ::TSP::Reference* provider_;
    ::TSP::Reference* body_cell_style_;
    ::TSP::Reference* header_row_style_;
    ::TSP::Reference* header_column_style_;
    ::TSP::Reference* footer_row_style_;
    ::TST::CellID* origin_offset_;
    ::TSP::Reference* body_text_style_;
    ::TSP::Reference* header_row_text_style_;
    ::TSP::Reference* header_column_text_style_;
    ::TSP::Reference* footer_row_text_style_;
    ::TSP::Reference* table_name_style_;
    ::TSP::Reference* hidden_state_formula_owner_for_columns_;
    ::TSP::Reference* hidden_state_formula_owner_for_rows_;
    ::TSP::Reference* table_name_shape_style_;
    ::TSP::Reference* filter_set_;
    ::TSCE::CFUUIDArchive* conditional_style_formula_owner_id_;
    uint32_t number_of_rows_;
    uint32_t number_of_columns_;
    uint32_t number_of_header_rows_;
    uint32_t number_of_header_columns_;
    uint32_t number_of_footer_rows_;
    uint32_t number_of_hidden_rows_;
    double default_row_height_;
    double default_column_width_;
    uint32_t number_of_hidden_columns_;
    bool table_name_enabled_;
    bool table_name_border_enabled_;
    bool header_rows_frozen_;
    bool header_columns_frozen_;
    uint32_t preset_index_;
    bool repeating_header_rows_enabled_;
    bool repeating_header_columns_enabled_;
    bool style_apply_clears_all_;
    double table_name_height_;
    uint32_t number_of_filtered_rows_;
    uint32_t number_of_user_hidden_rows_;
    uint32_t number_of_user_hidden_columns_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DurationWrapperArchive final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:TST.DurationWrapperArchive) */ {
 public:
  inline DurationWrapperArchive() : DurationWrapperArchive(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DurationWrapperArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DurationWrapperArchive(const DurationWrapperArchive& from);
  DurationWrapperArchive(DurationWrapperArchive&& from) noexcept
    : DurationWrapperArchive() {
    *this = ::std::move(from);
  }

  inline DurationWrapperArchive& operator=(const DurationWrapperArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DurationWrapperArchive& operator=(DurationWrapperArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DurationWrapperArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DurationWrapperArchive* internal_default_instance() {
    return reinterpret_cast<const DurationWrapperArchive*>(
               &_DurationWrapperArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DurationWrapperArchive& a, DurationWrapperArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DurationWrapperArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DurationWrapperArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DurationWrapperArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DurationWrapperArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DurationWrapperArchive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DurationWrapperArchive& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DurationWrapperArchive";
  }
  protected:
  explicit DurationWrapperArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TST.DurationWrapperArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class Cell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.Cell) */ {
 public:
  inline Cell() : Cell(nullptr) {}
  ~Cell() override;
  explicit PROTOBUF_CONSTEXPR Cell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cell(const Cell& from);
  Cell(Cell&& from) noexcept
    : Cell() {
    *this = ::std::move(from);
  }

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cell& operator=(Cell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cell* internal_default_instance() {
    return reinterpret_cast<const Cell*>(
               &_Cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Cell& a, Cell& b) {
    a.Swap(&b);
  }
  inline void Swap(Cell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cell& from) {
    Cell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.Cell";
  }
  protected:
  explicit Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 6,
    kCellStyleFieldNumber = 3,
    kTextStyleFieldNumber = 4,
    kFormulaFieldNumber = 8,
    kCurrentFormatFieldNumber = 9,
    kFormulaErrorFieldNumber = 10,
    kNumberFormatFieldNumber = 11,
    kCurrencyFormatFieldNumber = 12,
    kDurationFormatFieldNumber = 13,
    kDateFormatFieldNumber = 14,
    kControlFormatFieldNumber = 15,
    kCustomFormatFieldNumber = 16,
    kBaseFormatFieldNumber = 17,
    kMultipleChoiceListFormatFieldNumber = 18,
    kRichTextPayloadFieldNumber = 20,
    kConditionalStyleFieldNumber = 21,
    kMultipleChoiceListFieldNumber = 22,
    kCommentStorageFieldNumber = 23,
    kValueTypeFieldNumber = 2,
    kBoolValueFieldNumber = 7,
    kNumberValueFieldNumber = 5,
    kExplicitFormatFlagsFieldNumber = 19,
    kConditionalStyleAppliedRuleFieldNumber = 24,
  };
  // optional string stringValue = 6;
  bool has_stringvalue() const;
  private:
  bool _internal_has_stringvalue() const;
  public:
  void clear_stringvalue();
  const std::string& stringvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringvalue();
  PROTOBUF_NODISCARD std::string* release_stringvalue();
  void set_allocated_stringvalue(std::string* stringvalue);
  private:
  const std::string& _internal_stringvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringvalue(const std::string& value);
  std::string* _internal_mutable_stringvalue();
  public:

  // optional .TSP.Reference cell_style = 3;
  bool has_cell_style() const;
  private:
  bool _internal_has_cell_style() const;
  public:
  void clear_cell_style();
  const ::TSP::Reference& cell_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_cell_style();
  ::TSP::Reference* mutable_cell_style();
  void set_allocated_cell_style(::TSP::Reference* cell_style);
  private:
  const ::TSP::Reference& _internal_cell_style() const;
  ::TSP::Reference* _internal_mutable_cell_style();
  public:
  void unsafe_arena_set_allocated_cell_style(
      ::TSP::Reference* cell_style);
  ::TSP::Reference* unsafe_arena_release_cell_style();

  // optional .TSP.Reference text_style = 4;
  bool has_text_style() const;
  private:
  bool _internal_has_text_style() const;
  public:
  void clear_text_style();
  const ::TSP::Reference& text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_text_style();
  ::TSP::Reference* mutable_text_style();
  void set_allocated_text_style(::TSP::Reference* text_style);
  private:
  const ::TSP::Reference& _internal_text_style() const;
  ::TSP::Reference* _internal_mutable_text_style();
  public:
  void unsafe_arena_set_allocated_text_style(
      ::TSP::Reference* text_style);
  ::TSP::Reference* unsafe_arena_release_text_style();

  // optional .TSCE.FormulaArchive formula = 8;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;
  public:
  void clear_formula();
  const ::TSCE::FormulaArchive& formula() const;
  PROTOBUF_NODISCARD ::TSCE::FormulaArchive* release_formula();
  ::TSCE::FormulaArchive* mutable_formula();
  void set_allocated_formula(::TSCE::FormulaArchive* formula);
  private:
  const ::TSCE::FormulaArchive& _internal_formula() const;
  ::TSCE::FormulaArchive* _internal_mutable_formula();
  public:
  void unsafe_arena_set_allocated_formula(
      ::TSCE::FormulaArchive* formula);
  ::TSCE::FormulaArchive* unsafe_arena_release_formula();

  // optional .TSK.FormatStructArchive current_format = 9;
  bool has_current_format() const;
  private:
  bool _internal_has_current_format() const;
  public:
  void clear_current_format();
  const ::TSK::FormatStructArchive& current_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_current_format();
  ::TSK::FormatStructArchive* mutable_current_format();
  void set_allocated_current_format(::TSK::FormatStructArchive* current_format);
  private:
  const ::TSK::FormatStructArchive& _internal_current_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_current_format();
  public:
  void unsafe_arena_set_allocated_current_format(
      ::TSK::FormatStructArchive* current_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_current_format();

  // optional .TSP.Reference formulaError = 10;
  bool has_formulaerror() const;
  private:
  bool _internal_has_formulaerror() const;
  public:
  void clear_formulaerror();
  const ::TSP::Reference& formulaerror() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_formulaerror();
  ::TSP::Reference* mutable_formulaerror();
  void set_allocated_formulaerror(::TSP::Reference* formulaerror);
  private:
  const ::TSP::Reference& _internal_formulaerror() const;
  ::TSP::Reference* _internal_mutable_formulaerror();
  public:
  void unsafe_arena_set_allocated_formulaerror(
      ::TSP::Reference* formulaerror);
  ::TSP::Reference* unsafe_arena_release_formulaerror();

  // optional .TSK.FormatStructArchive number_format = 11;
  bool has_number_format() const;
  private:
  bool _internal_has_number_format() const;
  public:
  void clear_number_format();
  const ::TSK::FormatStructArchive& number_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_number_format();
  ::TSK::FormatStructArchive* mutable_number_format();
  void set_allocated_number_format(::TSK::FormatStructArchive* number_format);
  private:
  const ::TSK::FormatStructArchive& _internal_number_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_number_format();
  public:
  void unsafe_arena_set_allocated_number_format(
      ::TSK::FormatStructArchive* number_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_number_format();

  // optional .TSK.FormatStructArchive currency_format = 12;
  bool has_currency_format() const;
  private:
  bool _internal_has_currency_format() const;
  public:
  void clear_currency_format();
  const ::TSK::FormatStructArchive& currency_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_currency_format();
  ::TSK::FormatStructArchive* mutable_currency_format();
  void set_allocated_currency_format(::TSK::FormatStructArchive* currency_format);
  private:
  const ::TSK::FormatStructArchive& _internal_currency_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_currency_format();
  public:
  void unsafe_arena_set_allocated_currency_format(
      ::TSK::FormatStructArchive* currency_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_currency_format();

  // optional .TSK.FormatStructArchive duration_format = 13;
  bool has_duration_format() const;
  private:
  bool _internal_has_duration_format() const;
  public:
  void clear_duration_format();
  const ::TSK::FormatStructArchive& duration_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_duration_format();
  ::TSK::FormatStructArchive* mutable_duration_format();
  void set_allocated_duration_format(::TSK::FormatStructArchive* duration_format);
  private:
  const ::TSK::FormatStructArchive& _internal_duration_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_duration_format();
  public:
  void unsafe_arena_set_allocated_duration_format(
      ::TSK::FormatStructArchive* duration_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_duration_format();

  // optional .TSK.FormatStructArchive date_format = 14;
  bool has_date_format() const;
  private:
  bool _internal_has_date_format() const;
  public:
  void clear_date_format();
  const ::TSK::FormatStructArchive& date_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_date_format();
  ::TSK::FormatStructArchive* mutable_date_format();
  void set_allocated_date_format(::TSK::FormatStructArchive* date_format);
  private:
  const ::TSK::FormatStructArchive& _internal_date_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_date_format();
  public:
  void unsafe_arena_set_allocated_date_format(
      ::TSK::FormatStructArchive* date_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_date_format();

  // optional .TSK.FormatStructArchive control_format = 15;
  bool has_control_format() const;
  private:
  bool _internal_has_control_format() const;
  public:
  void clear_control_format();
  const ::TSK::FormatStructArchive& control_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_control_format();
  ::TSK::FormatStructArchive* mutable_control_format();
  void set_allocated_control_format(::TSK::FormatStructArchive* control_format);
  private:
  const ::TSK::FormatStructArchive& _internal_control_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_control_format();
  public:
  void unsafe_arena_set_allocated_control_format(
      ::TSK::FormatStructArchive* control_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_control_format();

  // optional .TSK.FormatStructArchive custom_format = 16;
  bool has_custom_format() const;
  private:
  bool _internal_has_custom_format() const;
  public:
  void clear_custom_format();
  const ::TSK::FormatStructArchive& custom_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_custom_format();
  ::TSK::FormatStructArchive* mutable_custom_format();
  void set_allocated_custom_format(::TSK::FormatStructArchive* custom_format);
  private:
  const ::TSK::FormatStructArchive& _internal_custom_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_custom_format();
  public:
  void unsafe_arena_set_allocated_custom_format(
      ::TSK::FormatStructArchive* custom_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_custom_format();

  // optional .TSK.FormatStructArchive base_format = 17;
  bool has_base_format() const;
  private:
  bool _internal_has_base_format() const;
  public:
  void clear_base_format();
  const ::TSK::FormatStructArchive& base_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_base_format();
  ::TSK::FormatStructArchive* mutable_base_format();
  void set_allocated_base_format(::TSK::FormatStructArchive* base_format);
  private:
  const ::TSK::FormatStructArchive& _internal_base_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_base_format();
  public:
  void unsafe_arena_set_allocated_base_format(
      ::TSK::FormatStructArchive* base_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_base_format();

  // optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
  bool has_multiple_choice_list_format() const;
  private:
  bool _internal_has_multiple_choice_list_format() const;
  public:
  void clear_multiple_choice_list_format();
  const ::TSK::FormatStructArchive& multiple_choice_list_format() const;
  PROTOBUF_NODISCARD ::TSK::FormatStructArchive* release_multiple_choice_list_format();
  ::TSK::FormatStructArchive* mutable_multiple_choice_list_format();
  void set_allocated_multiple_choice_list_format(::TSK::FormatStructArchive* multiple_choice_list_format);
  private:
  const ::TSK::FormatStructArchive& _internal_multiple_choice_list_format() const;
  ::TSK::FormatStructArchive* _internal_mutable_multiple_choice_list_format();
  public:
  void unsafe_arena_set_allocated_multiple_choice_list_format(
      ::TSK::FormatStructArchive* multiple_choice_list_format);
  ::TSK::FormatStructArchive* unsafe_arena_release_multiple_choice_list_format();

  // optional .TSP.Reference richTextPayload = 20;
  bool has_richtextpayload() const;
  private:
  bool _internal_has_richtextpayload() const;
  public:
  void clear_richtextpayload();
  const ::TSP::Reference& richtextpayload() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_richtextpayload();
  ::TSP::Reference* mutable_richtextpayload();
  void set_allocated_richtextpayload(::TSP::Reference* richtextpayload);
  private:
  const ::TSP::Reference& _internal_richtextpayload() const;
  ::TSP::Reference* _internal_mutable_richtextpayload();
  public:
  void unsafe_arena_set_allocated_richtextpayload(
      ::TSP::Reference* richtextpayload);
  ::TSP::Reference* unsafe_arena_release_richtextpayload();

  // optional .TSP.Reference conditional_style = 21;
  bool has_conditional_style() const;
  private:
  bool _internal_has_conditional_style() const;
  public:
  void clear_conditional_style();
  const ::TSP::Reference& conditional_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_conditional_style();
  ::TSP::Reference* mutable_conditional_style();
  void set_allocated_conditional_style(::TSP::Reference* conditional_style);
  private:
  const ::TSP::Reference& _internal_conditional_style() const;
  ::TSP::Reference* _internal_mutable_conditional_style();
  public:
  void unsafe_arena_set_allocated_conditional_style(
      ::TSP::Reference* conditional_style);
  ::TSP::Reference* unsafe_arena_release_conditional_style();

  // optional .TSP.Reference multiple_choice_list = 22;
  bool has_multiple_choice_list() const;
  private:
  bool _internal_has_multiple_choice_list() const;
  public:
  void clear_multiple_choice_list();
  const ::TSP::Reference& multiple_choice_list() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_multiple_choice_list();
  ::TSP::Reference* mutable_multiple_choice_list();
  void set_allocated_multiple_choice_list(::TSP::Reference* multiple_choice_list);
  private:
  const ::TSP::Reference& _internal_multiple_choice_list() const;
  ::TSP::Reference* _internal_mutable_multiple_choice_list();
  public:
  void unsafe_arena_set_allocated_multiple_choice_list(
      ::TSP::Reference* multiple_choice_list);
  ::TSP::Reference* unsafe_arena_release_multiple_choice_list();

  // optional .TSP.Reference comment_storage = 23;
  bool has_comment_storage() const;
  private:
  bool _internal_has_comment_storage() const;
  public:
  void clear_comment_storage();
  const ::TSP::Reference& comment_storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_comment_storage();
  ::TSP::Reference* mutable_comment_storage();
  void set_allocated_comment_storage(::TSP::Reference* comment_storage);
  private:
  const ::TSP::Reference& _internal_comment_storage() const;
  ::TSP::Reference* _internal_mutable_comment_storage();
  public:
  void unsafe_arena_set_allocated_comment_storage(
      ::TSP::Reference* comment_storage);
  ::TSP::Reference* unsafe_arena_release_comment_storage();

  // required .TST.CellValueType valueType = 2;
  bool has_valuetype() const;
  private:
  bool _internal_has_valuetype() const;
  public:
  void clear_valuetype();
  ::TST::CellValueType valuetype() const;
  void set_valuetype(::TST::CellValueType value);
  private:
  ::TST::CellValueType _internal_valuetype() const;
  void _internal_set_valuetype(::TST::CellValueType value);
  public:

  // optional bool boolValue = 7;
  bool has_boolvalue() const;
  private:
  bool _internal_has_boolvalue() const;
  public:
  void clear_boolvalue();
  bool boolvalue() const;
  void set_boolvalue(bool value);
  private:
  bool _internal_boolvalue() const;
  void _internal_set_boolvalue(bool value);
  public:

  // optional double numberValue = 5;
  bool has_numbervalue() const;
  private:
  bool _internal_has_numbervalue() const;
  public:
  void clear_numbervalue();
  double numbervalue() const;
  void set_numbervalue(double value);
  private:
  double _internal_numbervalue() const;
  void _internal_set_numbervalue(double value);
  public:

  // optional uint32 explicit_format_flags = 19;
  bool has_explicit_format_flags() const;
  private:
  bool _internal_has_explicit_format_flags() const;
  public:
  void clear_explicit_format_flags();
  uint32_t explicit_format_flags() const;
  void set_explicit_format_flags(uint32_t value);
  private:
  uint32_t _internal_explicit_format_flags() const;
  void _internal_set_explicit_format_flags(uint32_t value);
  public:

  // optional uint32 conditional_style_applied_rule = 24;
  bool has_conditional_style_applied_rule() const;
  private:
  bool _internal_has_conditional_style_applied_rule() const;
  public:
  void clear_conditional_style_applied_rule();
  uint32_t conditional_style_applied_rule() const;
  void set_conditional_style_applied_rule(uint32_t value);
  private:
  uint32_t _internal_conditional_style_applied_rule() const;
  void _internal_set_conditional_style_applied_rule(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.Cell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringvalue_;
    ::TSP::Reference* cell_style_;
    ::TSP::Reference* text_style_;
    ::TSCE::FormulaArchive* formula_;
    ::TSK::FormatStructArchive* current_format_;
    ::TSP::Reference* formulaerror_;
    ::TSK::FormatStructArchive* number_format_;
    ::TSK::FormatStructArchive* currency_format_;
    ::TSK::FormatStructArchive* duration_format_;
    ::TSK::FormatStructArchive* date_format_;
    ::TSK::FormatStructArchive* control_format_;
    ::TSK::FormatStructArchive* custom_format_;
    ::TSK::FormatStructArchive* base_format_;
    ::TSK::FormatStructArchive* multiple_choice_list_format_;
    ::TSP::Reference* richtextpayload_;
    ::TSP::Reference* conditional_style_;
    ::TSP::Reference* multiple_choice_list_;
    ::TSP::Reference* comment_storage_;
    int valuetype_;
    bool boolvalue_;
    double numbervalue_;
    uint32_t explicit_format_flags_;
    uint32_t conditional_style_applied_rule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class MergeRegionMapArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.MergeRegionMapArchive) */ {
 public:
  inline MergeRegionMapArchive() : MergeRegionMapArchive(nullptr) {}
  ~MergeRegionMapArchive() override;
  explicit PROTOBUF_CONSTEXPR MergeRegionMapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeRegionMapArchive(const MergeRegionMapArchive& from);
  MergeRegionMapArchive(MergeRegionMapArchive&& from) noexcept
    : MergeRegionMapArchive() {
    *this = ::std::move(from);
  }

  inline MergeRegionMapArchive& operator=(const MergeRegionMapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeRegionMapArchive& operator=(MergeRegionMapArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeRegionMapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeRegionMapArchive* internal_default_instance() {
    return reinterpret_cast<const MergeRegionMapArchive*>(
               &_MergeRegionMapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MergeRegionMapArchive& a, MergeRegionMapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeRegionMapArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeRegionMapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeRegionMapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeRegionMapArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MergeRegionMapArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MergeRegionMapArchive& from) {
    MergeRegionMapArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeRegionMapArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.MergeRegionMapArchive";
  }
  protected:
  explicit MergeRegionMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellRangeFieldNumber = 1,
  };
  // repeated .TST.CellRange cell_range = 1;
  int cell_range_size() const;
  private:
  int _internal_cell_range_size() const;
  public:
  void clear_cell_range();
  ::TST::CellRange* mutable_cell_range(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_range();
  private:
  const ::TST::CellRange& _internal_cell_range(int index) const;
  ::TST::CellRange* _internal_add_cell_range();
  public:
  const ::TST::CellRange& cell_range(int index) const;
  ::TST::CellRange* add_cell_range();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
      cell_range() const;

  // @@protoc_insertion_point(class_scope:TST.MergeRegionMapArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange > cell_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CellMapArchive_CellMapEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellMapArchive.CellMapEntry) */ {
 public:
  inline CellMapArchive_CellMapEntry() : CellMapArchive_CellMapEntry(nullptr) {}
  ~CellMapArchive_CellMapEntry() override;
  explicit PROTOBUF_CONSTEXPR CellMapArchive_CellMapEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellMapArchive_CellMapEntry(const CellMapArchive_CellMapEntry& from);
  CellMapArchive_CellMapEntry(CellMapArchive_CellMapEntry&& from) noexcept
    : CellMapArchive_CellMapEntry() {
    *this = ::std::move(from);
  }

  inline CellMapArchive_CellMapEntry& operator=(const CellMapArchive_CellMapEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellMapArchive_CellMapEntry& operator=(CellMapArchive_CellMapEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellMapArchive_CellMapEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellMapArchive_CellMapEntry* internal_default_instance() {
    return reinterpret_cast<const CellMapArchive_CellMapEntry*>(
               &_CellMapArchive_CellMapEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CellMapArchive_CellMapEntry& a, CellMapArchive_CellMapEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CellMapArchive_CellMapEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellMapArchive_CellMapEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellMapArchive_CellMapEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellMapArchive_CellMapEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellMapArchive_CellMapEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellMapArchive_CellMapEntry& from) {
    CellMapArchive_CellMapEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellMapArchive_CellMapEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellMapArchive.CellMapEntry";
  }
  protected:
  explicit CellMapArchive_CellMapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIDFieldNumber = 1,
    kCellFieldNumber = 2,
  };
  // required .TST.CellID cellID = 1;
  bool has_cellid() const;
  private:
  bool _internal_has_cellid() const;
  public:
  void clear_cellid();
  const ::TST::CellID& cellid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_cellid();
  ::TST::CellID* mutable_cellid();
  void set_allocated_cellid(::TST::CellID* cellid);
  private:
  const ::TST::CellID& _internal_cellid() const;
  ::TST::CellID* _internal_mutable_cellid();
  public:
  void unsafe_arena_set_allocated_cellid(
      ::TST::CellID* cellid);
  ::TST::CellID* unsafe_arena_release_cellid();

  // optional .TST.Cell cell = 2;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::TST::Cell& cell() const;
  PROTOBUF_NODISCARD ::TST::Cell* release_cell();
  ::TST::Cell* mutable_cell();
  void set_allocated_cell(::TST::Cell* cell);
  private:
  const ::TST::Cell& _internal_cell() const;
  ::TST::Cell* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::TST::Cell* cell);
  ::TST::Cell* unsafe_arena_release_cell();

  // @@protoc_insertion_point(class_scope:TST.CellMapArchive.CellMapEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::CellID* cellid_;
    ::TST::Cell* cell_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CellMapArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellMapArchive) */ {
 public:
  inline CellMapArchive() : CellMapArchive(nullptr) {}
  ~CellMapArchive() override;
  explicit PROTOBUF_CONSTEXPR CellMapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellMapArchive(const CellMapArchive& from);
  CellMapArchive(CellMapArchive&& from) noexcept
    : CellMapArchive() {
    *this = ::std::move(from);
  }

  inline CellMapArchive& operator=(const CellMapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellMapArchive& operator=(CellMapArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellMapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellMapArchive* internal_default_instance() {
    return reinterpret_cast<const CellMapArchive*>(
               &_CellMapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CellMapArchive& a, CellMapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CellMapArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellMapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellMapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellMapArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellMapArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellMapArchive& from) {
    CellMapArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellMapArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellMapArchive";
  }
  protected:
  explicit CellMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CellMapArchive_CellMapEntry CellMapEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kCellMapEntryFieldNumber = 3,
    kCapacityFieldNumber = 1,
    kCountFieldNumber = 2,
    kAppliesToHiddenFieldNumber = 6,
    kMayModifyFormulasInCellsFieldNumber = 4,
    kMayModifyValuesReferencedByFormulasFieldNumber = 5,
  };
  // repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
  int cellmapentry_size() const;
  private:
  int _internal_cellmapentry_size() const;
  public:
  void clear_cellmapentry();
  ::TST::CellMapArchive_CellMapEntry* mutable_cellmapentry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >*
      mutable_cellmapentry();
  private:
  const ::TST::CellMapArchive_CellMapEntry& _internal_cellmapentry(int index) const;
  ::TST::CellMapArchive_CellMapEntry* _internal_add_cellmapentry();
  public:
  const ::TST::CellMapArchive_CellMapEntry& cellmapentry(int index) const;
  ::TST::CellMapArchive_CellMapEntry* add_cellmapentry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >&
      cellmapentry() const;

  // required uint32 capacity = 1;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // required uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional bool applies_to_hidden = 6 [default = false];
  bool has_applies_to_hidden() const;
  private:
  bool _internal_has_applies_to_hidden() const;
  public:
  void clear_applies_to_hidden();
  bool applies_to_hidden() const;
  void set_applies_to_hidden(bool value);
  private:
  bool _internal_applies_to_hidden() const;
  void _internal_set_applies_to_hidden(bool value);
  public:

  // optional bool may_modify_formulas_in_cells = 4 [default = true];
  bool has_may_modify_formulas_in_cells() const;
  private:
  bool _internal_has_may_modify_formulas_in_cells() const;
  public:
  void clear_may_modify_formulas_in_cells();
  bool may_modify_formulas_in_cells() const;
  void set_may_modify_formulas_in_cells(bool value);
  private:
  bool _internal_may_modify_formulas_in_cells() const;
  void _internal_set_may_modify_formulas_in_cells(bool value);
  public:

  // optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
  bool has_may_modify_values_referenced_by_formulas() const;
  private:
  bool _internal_has_may_modify_values_referenced_by_formulas() const;
  public:
  void clear_may_modify_values_referenced_by_formulas();
  bool may_modify_values_referenced_by_formulas() const;
  void set_may_modify_values_referenced_by_formulas(bool value);
  private:
  bool _internal_may_modify_values_referenced_by_formulas() const;
  void _internal_set_may_modify_values_referenced_by_formulas(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.CellMapArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry > cellmapentry_;
    uint32_t capacity_;
    uint32_t count_;
    bool applies_to_hidden_;
    bool may_modify_formulas_in_cells_;
    bool may_modify_values_referenced_by_formulas_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DoubleStyleMapArchive_DoubleStyleMapEntryArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive) */ {
 public:
  inline DoubleStyleMapArchive_DoubleStyleMapEntryArchive() : DoubleStyleMapArchive_DoubleStyleMapEntryArchive(nullptr) {}
  ~DoubleStyleMapArchive_DoubleStyleMapEntryArchive() override;
  explicit PROTOBUF_CONSTEXPR DoubleStyleMapArchive_DoubleStyleMapEntryArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleStyleMapArchive_DoubleStyleMapEntryArchive(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from);
  DoubleStyleMapArchive_DoubleStyleMapEntryArchive(DoubleStyleMapArchive_DoubleStyleMapEntryArchive&& from) noexcept
    : DoubleStyleMapArchive_DoubleStyleMapEntryArchive() {
    *this = ::std::move(from);
  }

  inline DoubleStyleMapArchive_DoubleStyleMapEntryArchive& operator=(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleStyleMapArchive_DoubleStyleMapEntryArchive& operator=(DoubleStyleMapArchive_DoubleStyleMapEntryArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleStyleMapArchive_DoubleStyleMapEntryArchive* internal_default_instance() {
    return reinterpret_cast<const DoubleStyleMapArchive_DoubleStyleMapEntryArchive*>(
               &_DoubleStyleMapArchive_DoubleStyleMapEntryArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive& a, DoubleStyleMapArchive_DoubleStyleMapEntryArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleStyleMapArchive_DoubleStyleMapEntryArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleStyleMapArchive_DoubleStyleMapEntryArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleStyleMapArchive_DoubleStyleMapEntryArchive& from) {
    DoubleStyleMapArchive_DoubleStyleMapEntryArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleStyleMapArchive_DoubleStyleMapEntryArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive";
  }
  protected:
  explicit DoubleStyleMapArchive_DoubleStyleMapEntryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIdFieldNumber = 1,
    kOldStyleFieldNumber = 2,
    kNewStyleFieldNumber = 3,
  };
  // required .TST.CellID cell_id = 1;
  bool has_cell_id() const;
  private:
  bool _internal_has_cell_id() const;
  public:
  void clear_cell_id();
  const ::TST::CellID& cell_id() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_cell_id();
  ::TST::CellID* mutable_cell_id();
  void set_allocated_cell_id(::TST::CellID* cell_id);
  private:
  const ::TST::CellID& _internal_cell_id() const;
  ::TST::CellID* _internal_mutable_cell_id();
  public:
  void unsafe_arena_set_allocated_cell_id(
      ::TST::CellID* cell_id);
  ::TST::CellID* unsafe_arena_release_cell_id();

  // required .TSP.Reference old_style = 2;
  bool has_old_style() const;
  private:
  bool _internal_has_old_style() const;
  public:
  void clear_old_style();
  const ::TSP::Reference& old_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_old_style();
  ::TSP::Reference* mutable_old_style();
  void set_allocated_old_style(::TSP::Reference* old_style);
  private:
  const ::TSP::Reference& _internal_old_style() const;
  ::TSP::Reference* _internal_mutable_old_style();
  public:
  void unsafe_arena_set_allocated_old_style(
      ::TSP::Reference* old_style);
  ::TSP::Reference* unsafe_arena_release_old_style();

  // required .TSP.Reference new_style = 3;
  bool has_new_style() const;
  private:
  bool _internal_has_new_style() const;
  public:
  void clear_new_style();
  const ::TSP::Reference& new_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_new_style();
  ::TSP::Reference* mutable_new_style();
  void set_allocated_new_style(::TSP::Reference* new_style);
  private:
  const ::TSP::Reference& _internal_new_style() const;
  ::TSP::Reference* _internal_mutable_new_style();
  public:
  void unsafe_arena_set_allocated_new_style(
      ::TSP::Reference* new_style);
  ::TSP::Reference* unsafe_arena_release_new_style();

  // @@protoc_insertion_point(class_scope:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::CellID* cell_id_;
    ::TSP::Reference* old_style_;
    ::TSP::Reference* new_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DoubleStyleMapArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.DoubleStyleMapArchive) */ {
 public:
  inline DoubleStyleMapArchive() : DoubleStyleMapArchive(nullptr) {}
  ~DoubleStyleMapArchive() override;
  explicit PROTOBUF_CONSTEXPR DoubleStyleMapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleStyleMapArchive(const DoubleStyleMapArchive& from);
  DoubleStyleMapArchive(DoubleStyleMapArchive&& from) noexcept
    : DoubleStyleMapArchive() {
    *this = ::std::move(from);
  }

  inline DoubleStyleMapArchive& operator=(const DoubleStyleMapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleStyleMapArchive& operator=(DoubleStyleMapArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleStyleMapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleStyleMapArchive* internal_default_instance() {
    return reinterpret_cast<const DoubleStyleMapArchive*>(
               &_DoubleStyleMapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DoubleStyleMapArchive& a, DoubleStyleMapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleStyleMapArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleStyleMapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleStyleMapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleStyleMapArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleStyleMapArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleStyleMapArchive& from) {
    DoubleStyleMapArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleStyleMapArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DoubleStyleMapArchive";
  }
  protected:
  explicit DoubleStyleMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DoubleStyleMapArchive_DoubleStyleMapEntryArchive DoubleStyleMapEntryArchive;

  // accessors -------------------------------------------------------

  enum : int {
    kCellMapEntryFieldNumber = 3,
    kCapacityFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
  int cell_map_entry_size() const;
  private:
  int _internal_cell_map_entry_size() const;
  public:
  void clear_cell_map_entry();
  ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* mutable_cell_map_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >*
      mutable_cell_map_entry();
  private:
  const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& _internal_cell_map_entry(int index) const;
  ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* _internal_add_cell_map_entry();
  public:
  const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& cell_map_entry(int index) const;
  ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* add_cell_map_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >&
      cell_map_entry() const;

  // required uint32 capacity = 1;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // required uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.DoubleStyleMapArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive > cell_map_entry_;
    uint32_t capacity_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleTableMapArchive_StyleTableMapEntryArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.StyleTableMapArchive.StyleTableMapEntryArchive) */ {
 public:
  inline StyleTableMapArchive_StyleTableMapEntryArchive() : StyleTableMapArchive_StyleTableMapEntryArchive(nullptr) {}
  ~StyleTableMapArchive_StyleTableMapEntryArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleTableMapArchive_StyleTableMapEntryArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleTableMapArchive_StyleTableMapEntryArchive(const StyleTableMapArchive_StyleTableMapEntryArchive& from);
  StyleTableMapArchive_StyleTableMapEntryArchive(StyleTableMapArchive_StyleTableMapEntryArchive&& from) noexcept
    : StyleTableMapArchive_StyleTableMapEntryArchive() {
    *this = ::std::move(from);
  }

  inline StyleTableMapArchive_StyleTableMapEntryArchive& operator=(const StyleTableMapArchive_StyleTableMapEntryArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleTableMapArchive_StyleTableMapEntryArchive& operator=(StyleTableMapArchive_StyleTableMapEntryArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleTableMapArchive_StyleTableMapEntryArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleTableMapArchive_StyleTableMapEntryArchive* internal_default_instance() {
    return reinterpret_cast<const StyleTableMapArchive_StyleTableMapEntryArchive*>(
               &_StyleTableMapArchive_StyleTableMapEntryArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(StyleTableMapArchive_StyleTableMapEntryArchive& a, StyleTableMapArchive_StyleTableMapEntryArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleTableMapArchive_StyleTableMapEntryArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleTableMapArchive_StyleTableMapEntryArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleTableMapArchive_StyleTableMapEntryArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleTableMapArchive_StyleTableMapEntryArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleTableMapArchive_StyleTableMapEntryArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleTableMapArchive_StyleTableMapEntryArchive& from) {
    StyleTableMapArchive_StyleTableMapEntryArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleTableMapArchive_StyleTableMapEntryArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.StyleTableMapArchive.StyleTableMapEntryArchive";
  }
  protected:
  explicit StyleTableMapArchive_StyleTableMapEntryArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldStyleFieldNumber = 2,
    kNewStyleFieldNumber = 3,
    kKeyFieldNumber = 1,
  };
  // required .TSP.Reference old_style = 2;
  bool has_old_style() const;
  private:
  bool _internal_has_old_style() const;
  public:
  void clear_old_style();
  const ::TSP::Reference& old_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_old_style();
  ::TSP::Reference* mutable_old_style();
  void set_allocated_old_style(::TSP::Reference* old_style);
  private:
  const ::TSP::Reference& _internal_old_style() const;
  ::TSP::Reference* _internal_mutable_old_style();
  public:
  void unsafe_arena_set_allocated_old_style(
      ::TSP::Reference* old_style);
  ::TSP::Reference* unsafe_arena_release_old_style();

  // required .TSP.Reference new_style = 3;
  bool has_new_style() const;
  private:
  bool _internal_has_new_style() const;
  public:
  void clear_new_style();
  const ::TSP::Reference& new_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_new_style();
  ::TSP::Reference* mutable_new_style();
  void set_allocated_new_style(::TSP::Reference* new_style);
  private:
  const ::TSP::Reference& _internal_new_style() const;
  ::TSP::Reference* _internal_mutable_new_style();
  public:
  void unsafe_arena_set_allocated_new_style(
      ::TSP::Reference* new_style);
  ::TSP::Reference* unsafe_arena_release_new_style();

  // required uint32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  uint32_t key() const;
  void set_key(uint32_t value);
  private:
  uint32_t _internal_key() const;
  void _internal_set_key(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.StyleTableMapArchive.StyleTableMapEntryArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* old_style_;
    ::TSP::Reference* new_style_;
    uint32_t key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class StyleTableMapArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.StyleTableMapArchive) */ {
 public:
  inline StyleTableMapArchive() : StyleTableMapArchive(nullptr) {}
  ~StyleTableMapArchive() override;
  explicit PROTOBUF_CONSTEXPR StyleTableMapArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleTableMapArchive(const StyleTableMapArchive& from);
  StyleTableMapArchive(StyleTableMapArchive&& from) noexcept
    : StyleTableMapArchive() {
    *this = ::std::move(from);
  }

  inline StyleTableMapArchive& operator=(const StyleTableMapArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleTableMapArchive& operator=(StyleTableMapArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StyleTableMapArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleTableMapArchive* internal_default_instance() {
    return reinterpret_cast<const StyleTableMapArchive*>(
               &_StyleTableMapArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(StyleTableMapArchive& a, StyleTableMapArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleTableMapArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleTableMapArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleTableMapArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleTableMapArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StyleTableMapArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StyleTableMapArchive& from) {
    StyleTableMapArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StyleTableMapArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.StyleTableMapArchive";
  }
  protected:
  explicit StyleTableMapArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StyleTableMapArchive_StyleTableMapEntryArchive StyleTableMapEntryArchive;

  // accessors -------------------------------------------------------

  enum : int {
    kMapEntryFieldNumber = 3,
    kCapacityFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
  int map_entry_size() const;
  private:
  int _internal_map_entry_size() const;
  public:
  void clear_map_entry();
  ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* mutable_map_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >*
      mutable_map_entry();
  private:
  const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& _internal_map_entry(int index) const;
  ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* _internal_add_map_entry();
  public:
  const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& map_entry(int index) const;
  ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* add_map_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >&
      map_entry() const;

  // required uint32 capacity = 1;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  uint32_t capacity() const;
  void set_capacity(uint32_t value);
  private:
  uint32_t _internal_capacity() const;
  void _internal_set_capacity(uint32_t value);
  public:

  // required uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.StyleTableMapArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive > map_entry_;
    uint32_t capacity_;
    uint32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class SelectionArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.SelectionArchive) */ {
 public:
  inline SelectionArchive() : SelectionArchive(nullptr) {}
  ~SelectionArchive() override;
  explicit PROTOBUF_CONSTEXPR SelectionArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionArchive(const SelectionArchive& from);
  SelectionArchive(SelectionArchive&& from) noexcept
    : SelectionArchive() {
    *this = ::std::move(from);
  }

  inline SelectionArchive& operator=(const SelectionArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionArchive& operator=(SelectionArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectionArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionArchive* internal_default_instance() {
    return reinterpret_cast<const SelectionArchive*>(
               &_SelectionArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SelectionArchive& a, SelectionArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectionArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectionArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectionArchive& from) {
    SelectionArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectionArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.SelectionArchive";
  }
  protected:
  explicit SelectionArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellRangesFieldNumber = 6,
    kBaseRangesFieldNumber = 7,
    kTableModelFieldNumber = 1,
    kAnchorCellFieldNumber = 5,
    kCursorCellFieldNumber = 8,
    kSelectionTypeFieldNumber = 4,
  };
  // repeated .TST.CellRange cell_ranges = 6;
  int cell_ranges_size() const;
  private:
  int _internal_cell_ranges_size() const;
  public:
  void clear_cell_ranges();
  ::TST::CellRange* mutable_cell_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_ranges();
  private:
  const ::TST::CellRange& _internal_cell_ranges(int index) const;
  ::TST::CellRange* _internal_add_cell_ranges();
  public:
  const ::TST::CellRange& cell_ranges(int index) const;
  ::TST::CellRange* add_cell_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
      cell_ranges() const;

  // repeated .TST.CellRange base_ranges = 7;
  int base_ranges_size() const;
  private:
  int _internal_base_ranges_size() const;
  public:
  void clear_base_ranges();
  ::TST::CellRange* mutable_base_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
      mutable_base_ranges();
  private:
  const ::TST::CellRange& _internal_base_ranges(int index) const;
  ::TST::CellRange* _internal_add_base_ranges();
  public:
  const ::TST::CellRange& base_ranges(int index) const;
  ::TST::CellRange* add_base_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
      base_ranges() const;

  // optional .TSP.Reference tableModel = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_tablemodel() const;
  private:
  bool _internal_has_tablemodel() const;
  public:
  PROTOBUF_DEPRECATED void clear_tablemodel();
  PROTOBUF_DEPRECATED const ::TSP::Reference& tablemodel() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::TSP::Reference* release_tablemodel();
  PROTOBUF_DEPRECATED ::TSP::Reference* mutable_tablemodel();
  PROTOBUF_DEPRECATED void set_allocated_tablemodel(::TSP::Reference* tablemodel);
  private:
  const ::TSP::Reference& _internal_tablemodel() const;
  ::TSP::Reference* _internal_mutable_tablemodel();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_tablemodel(
      ::TSP::Reference* tablemodel);
  PROTOBUF_DEPRECATED ::TSP::Reference* unsafe_arena_release_tablemodel();

  // optional .TST.CellID anchor_cell = 5;
  bool has_anchor_cell() const;
  private:
  bool _internal_has_anchor_cell() const;
  public:
  void clear_anchor_cell();
  const ::TST::CellID& anchor_cell() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_anchor_cell();
  ::TST::CellID* mutable_anchor_cell();
  void set_allocated_anchor_cell(::TST::CellID* anchor_cell);
  private:
  const ::TST::CellID& _internal_anchor_cell() const;
  ::TST::CellID* _internal_mutable_anchor_cell();
  public:
  void unsafe_arena_set_allocated_anchor_cell(
      ::TST::CellID* anchor_cell);
  ::TST::CellID* unsafe_arena_release_anchor_cell();

  // optional .TST.CellID cursor_cell = 8;
  bool has_cursor_cell() const;
  private:
  bool _internal_has_cursor_cell() const;
  public:
  void clear_cursor_cell();
  const ::TST::CellID& cursor_cell() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_cursor_cell();
  ::TST::CellID* mutable_cursor_cell();
  void set_allocated_cursor_cell(::TST::CellID* cursor_cell);
  private:
  const ::TST::CellID& _internal_cursor_cell() const;
  ::TST::CellID* _internal_mutable_cursor_cell();
  public:
  void unsafe_arena_set_allocated_cursor_cell(
      ::TST::CellID* cursor_cell);
  ::TST::CellID* unsafe_arena_release_cursor_cell();

  // required .TST.SelectionTypeArchive selection_type = 4;
  bool has_selection_type() const;
  private:
  bool _internal_has_selection_type() const;
  public:
  void clear_selection_type();
  ::TST::SelectionTypeArchive selection_type() const;
  void set_selection_type(::TST::SelectionTypeArchive value);
  private:
  ::TST::SelectionTypeArchive _internal_selection_type() const;
  void _internal_set_selection_type(::TST::SelectionTypeArchive value);
  public:

  // @@protoc_insertion_point(class_scope:TST.SelectionArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange > cell_ranges_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange > base_ranges_;
    ::TSP::Reference* tablemodel_;
    ::TST::CellID* anchor_cell_;
    ::TST::CellID* cursor_cell_;
    int selection_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FilterRuleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FilterRuleArchive) */ {
 public:
  inline FilterRuleArchive() : FilterRuleArchive(nullptr) {}
  ~FilterRuleArchive() override;
  explicit PROTOBUF_CONSTEXPR FilterRuleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterRuleArchive(const FilterRuleArchive& from);
  FilterRuleArchive(FilterRuleArchive&& from) noexcept
    : FilterRuleArchive() {
    *this = ::std::move(from);
  }

  inline FilterRuleArchive& operator=(const FilterRuleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterRuleArchive& operator=(FilterRuleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterRuleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterRuleArchive* internal_default_instance() {
    return reinterpret_cast<const FilterRuleArchive*>(
               &_FilterRuleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FilterRuleArchive& a, FilterRuleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterRuleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterRuleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterRuleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterRuleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterRuleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FilterRuleArchive& from) {
    FilterRuleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterRuleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FilterRuleArchive";
  }
  protected:
  explicit FilterRuleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredicateFieldNumber = 1,
    kDisabledFieldNumber = 2,
  };
  // required .TST.FormulaPredicateArchive predicate = 1;
  bool has_predicate() const;
  private:
  bool _internal_has_predicate() const;
  public:
  void clear_predicate();
  const ::TST::FormulaPredicateArchive& predicate() const;
  PROTOBUF_NODISCARD ::TST::FormulaPredicateArchive* release_predicate();
  ::TST::FormulaPredicateArchive* mutable_predicate();
  void set_allocated_predicate(::TST::FormulaPredicateArchive* predicate);
  private:
  const ::TST::FormulaPredicateArchive& _internal_predicate() const;
  ::TST::FormulaPredicateArchive* _internal_mutable_predicate();
  public:
  void unsafe_arena_set_allocated_predicate(
      ::TST::FormulaPredicateArchive* predicate);
  ::TST::FormulaPredicateArchive* unsafe_arena_release_predicate();

  // optional bool disabled = 2;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.FilterRuleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::FormulaPredicateArchive* predicate_;
    bool disabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TableStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TableStyleArchive) */ {
 public:
  inline TableStyleArchive() : TableStyleArchive(nullptr) {}
  ~TableStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR TableStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableStyleArchive(const TableStyleArchive& from);
  TableStyleArchive(TableStyleArchive&& from) noexcept
    : TableStyleArchive() {
    *this = ::std::move(from);
  }

  inline TableStyleArchive& operator=(const TableStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableStyleArchive& operator=(TableStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableStyleArchive* internal_default_instance() {
    return reinterpret_cast<const TableStyleArchive*>(
               &_TableStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TableStyleArchive& a, TableStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TableStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableStyleArchive& from) {
    TableStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TableStyleArchive";
  }
  protected:
  explicit TableStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTablePropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TST.TableStylePropertiesArchive table_properties = 11;
  bool has_table_properties() const;
  private:
  bool _internal_has_table_properties() const;
  public:
  void clear_table_properties();
  const ::TST::TableStylePropertiesArchive& table_properties() const;
  PROTOBUF_NODISCARD ::TST::TableStylePropertiesArchive* release_table_properties();
  ::TST::TableStylePropertiesArchive* mutable_table_properties();
  void set_allocated_table_properties(::TST::TableStylePropertiesArchive* table_properties);
  private:
  const ::TST::TableStylePropertiesArchive& _internal_table_properties() const;
  ::TST::TableStylePropertiesArchive* _internal_mutable_table_properties();
  public:
  void unsafe_arena_set_allocated_table_properties(
      ::TST::TableStylePropertiesArchive* table_properties);
  ::TST::TableStylePropertiesArchive* unsafe_arena_release_table_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  uint32_t override_count() const;
  void set_override_count(uint32_t value);
  private:
  uint32_t _internal_override_count() const;
  void _internal_set_override_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.TableStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
    ::TST::TableStylePropertiesArchive* table_properties_;
    uint32_t override_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CellStyleArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellStyleArchive) */ {
 public:
  inline CellStyleArchive() : CellStyleArchive(nullptr) {}
  ~CellStyleArchive() override;
  explicit PROTOBUF_CONSTEXPR CellStyleArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellStyleArchive(const CellStyleArchive& from);
  CellStyleArchive(CellStyleArchive&& from) noexcept
    : CellStyleArchive() {
    *this = ::std::move(from);
  }

  inline CellStyleArchive& operator=(const CellStyleArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellStyleArchive& operator=(CellStyleArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellStyleArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellStyleArchive* internal_default_instance() {
    return reinterpret_cast<const CellStyleArchive*>(
               &_CellStyleArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CellStyleArchive& a, CellStyleArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CellStyleArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellStyleArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellStyleArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellStyleArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellStyleArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellStyleArchive& from) {
    CellStyleArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellStyleArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellStyleArchive";
  }
  protected:
  explicit CellStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kCellPropertiesFieldNumber = 11,
    kOverrideCountFieldNumber = 10,
  };
  // required .TSS.StyleArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSS::StyleArchive& super() const;
  PROTOBUF_NODISCARD ::TSS::StyleArchive* release_super();
  ::TSS::StyleArchive* mutable_super();
  void set_allocated_super(::TSS::StyleArchive* super);
  private:
  const ::TSS::StyleArchive& _internal_super() const;
  ::TSS::StyleArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSS::StyleArchive* super);
  ::TSS::StyleArchive* unsafe_arena_release_super();

  // optional .TST.CellStylePropertiesArchive cell_properties = 11;
  bool has_cell_properties() const;
  private:
  bool _internal_has_cell_properties() const;
  public:
  void clear_cell_properties();
  const ::TST::CellStylePropertiesArchive& cell_properties() const;
  PROTOBUF_NODISCARD ::TST::CellStylePropertiesArchive* release_cell_properties();
  ::TST::CellStylePropertiesArchive* mutable_cell_properties();
  void set_allocated_cell_properties(::TST::CellStylePropertiesArchive* cell_properties);
  private:
  const ::TST::CellStylePropertiesArchive& _internal_cell_properties() const;
  ::TST::CellStylePropertiesArchive* _internal_mutable_cell_properties();
  public:
  void unsafe_arena_set_allocated_cell_properties(
      ::TST::CellStylePropertiesArchive* cell_properties);
  ::TST::CellStylePropertiesArchive* unsafe_arena_release_cell_properties();

  // optional uint32 override_count = 10 [default = 0];
  bool has_override_count() const;
  private:
  bool _internal_has_override_count() const;
  public:
  void clear_override_count();
  uint32_t override_count() const;
  void set_override_count(uint32_t value);
  private:
  uint32_t _internal_override_count() const;
  void _internal_set_override_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.CellStyleArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSS::StyleArchive* super_;
    ::TST::CellStylePropertiesArchive* cell_properties_;
    uint32_t override_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FormulaPredicateArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FormulaPredicateArchive) */ {
 public:
  inline FormulaPredicateArchive() : FormulaPredicateArchive(nullptr) {}
  ~FormulaPredicateArchive() override;
  explicit PROTOBUF_CONSTEXPR FormulaPredicateArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormulaPredicateArchive(const FormulaPredicateArchive& from);
  FormulaPredicateArchive(FormulaPredicateArchive&& from) noexcept
    : FormulaPredicateArchive() {
    *this = ::std::move(from);
  }

  inline FormulaPredicateArchive& operator=(const FormulaPredicateArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormulaPredicateArchive& operator=(FormulaPredicateArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormulaPredicateArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormulaPredicateArchive* internal_default_instance() {
    return reinterpret_cast<const FormulaPredicateArchive*>(
               &_FormulaPredicateArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FormulaPredicateArchive& a, FormulaPredicateArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FormulaPredicateArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormulaPredicateArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormulaPredicateArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormulaPredicateArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormulaPredicateArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormulaPredicateArchive& from) {
    FormulaPredicateArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormulaPredicateArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FormulaPredicateArchive";
  }
  protected:
  explicit FormulaPredicateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FormulaPredicateArchive_FormulaPredicateType FormulaPredicateType;
  static constexpr FormulaPredicateType PredNone =
    FormulaPredicateArchive_FormulaPredicateType_PredNone;
  static constexpr FormulaPredicateType TextStartsWith =
    FormulaPredicateArchive_FormulaPredicateType_TextStartsWith;
  static constexpr FormulaPredicateType TextEndsWith =
    FormulaPredicateArchive_FormulaPredicateType_TextEndsWith;
  static constexpr FormulaPredicateType TextContains =
    FormulaPredicateArchive_FormulaPredicateType_TextContains;
  static constexpr FormulaPredicateType TextDoesNotContain =
    FormulaPredicateArchive_FormulaPredicateType_TextDoesNotContain;
  static constexpr FormulaPredicateType ValueEqual =
    FormulaPredicateArchive_FormulaPredicateType_ValueEqual;
  static constexpr FormulaPredicateType ValueNotEqual =
    FormulaPredicateArchive_FormulaPredicateType_ValueNotEqual;
  static constexpr FormulaPredicateType ValueGreaterThan =
    FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThan;
  static constexpr FormulaPredicateType ValueGreaterThanOrEqual =
    FormulaPredicateArchive_FormulaPredicateType_ValueGreaterThanOrEqual;
  static constexpr FormulaPredicateType ValueLessThan =
    FormulaPredicateArchive_FormulaPredicateType_ValueLessThan;
  static constexpr FormulaPredicateType ValueLessThanOrEqual =
    FormulaPredicateArchive_FormulaPredicateType_ValueLessThanOrEqual;
  static constexpr FormulaPredicateType ValueAboveAverage =
    FormulaPredicateArchive_FormulaPredicateType_ValueAboveAverage;
  static constexpr FormulaPredicateType ValueBelowAverage =
    FormulaPredicateArchive_FormulaPredicateType_ValueBelowAverage;
  static constexpr FormulaPredicateType ValueBetween =
    FormulaPredicateArchive_FormulaPredicateType_ValueBetween;
  static constexpr FormulaPredicateType Formula =
    FormulaPredicateArchive_FormulaPredicateType_Formula;
  static constexpr FormulaPredicateType Duplicates =
    FormulaPredicateArchive_FormulaPredicateType_Duplicates;
  static constexpr FormulaPredicateType Uniques =
    FormulaPredicateArchive_FormulaPredicateType_Uniques;
  static constexpr FormulaPredicateType DateIsToday =
    FormulaPredicateArchive_FormulaPredicateType_DateIsToday;
  static constexpr FormulaPredicateType DateIsYesterday =
    FormulaPredicateArchive_FormulaPredicateType_DateIsYesterday;
  static constexpr FormulaPredicateType DateIsTomorrow =
    FormulaPredicateArchive_FormulaPredicateType_DateIsTomorrow;
  static constexpr FormulaPredicateType DateIsTheDate =
    FormulaPredicateArchive_FormulaPredicateType_DateIsTheDate;
  static constexpr FormulaPredicateType DateBeforeTheDate =
    FormulaPredicateArchive_FormulaPredicateType_DateBeforeTheDate;
  static constexpr FormulaPredicateType DateAfterTheDate =
    FormulaPredicateArchive_FormulaPredicateType_DateAfterTheDate;
  static constexpr FormulaPredicateType DateIsInTheRange =
    FormulaPredicateArchive_FormulaPredicateType_DateIsInTheRange;
  static constexpr FormulaPredicateType DateInTheNext =
    FormulaPredicateArchive_FormulaPredicateType_DateInTheNext;
  static constexpr FormulaPredicateType DateInTheLast =
    FormulaPredicateArchive_FormulaPredicateType_DateInTheLast;
  static constexpr FormulaPredicateType DateIsExactly =
    FormulaPredicateArchive_FormulaPredicateType_DateIsExactly;
  static constexpr FormulaPredicateType DateBeforeRelative =
    FormulaPredicateArchive_FormulaPredicateType_DateBeforeRelative;
  static constexpr FormulaPredicateType DateAfterRelative =
    FormulaPredicateArchive_FormulaPredicateType_DateAfterRelative;
  static constexpr FormulaPredicateType DateBetweenRelative =
    FormulaPredicateArchive_FormulaPredicateType_DateBetweenRelative;
  static constexpr FormulaPredicateType ValueTop =
    FormulaPredicateArchive_FormulaPredicateType_ValueTop;
  static constexpr FormulaPredicateType ValueBottom =
    FormulaPredicateArchive_FormulaPredicateType_ValueBottom;
  static constexpr FormulaPredicateType ValueNotBetween =
    FormulaPredicateArchive_FormulaPredicateType_ValueNotBetween;
  static constexpr FormulaPredicateType DateInThis =
    FormulaPredicateArchive_FormulaPredicateType_DateInThis;
  static constexpr FormulaPredicateType IsBlank =
    FormulaPredicateArchive_FormulaPredicateType_IsBlank;
  static constexpr FormulaPredicateType IsNotBlank =
    FormulaPredicateArchive_FormulaPredicateType_IsNotBlank;
  static constexpr FormulaPredicateType TextIs =
    FormulaPredicateArchive_FormulaPredicateType_TextIs;
  static constexpr FormulaPredicateType TextIsNot =
    FormulaPredicateArchive_FormulaPredicateType_TextIsNot;
  static constexpr FormulaPredicateType DurationEqual =
    FormulaPredicateArchive_FormulaPredicateType_DurationEqual;
  static constexpr FormulaPredicateType DurationNotEqual =
    FormulaPredicateArchive_FormulaPredicateType_DurationNotEqual;
  static constexpr FormulaPredicateType DurationGreaterThan =
    FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThan;
  static constexpr FormulaPredicateType DurationGreaterThanOrEqual =
    FormulaPredicateArchive_FormulaPredicateType_DurationGreaterThanOrEqual;
  static constexpr FormulaPredicateType DurationLessThan =
    FormulaPredicateArchive_FormulaPredicateType_DurationLessThan;
  static constexpr FormulaPredicateType DurationLessThanOrEqual =
    FormulaPredicateArchive_FormulaPredicateType_DurationLessThanOrEqual;
  static constexpr FormulaPredicateType DurationBetween =
    FormulaPredicateArchive_FormulaPredicateType_DurationBetween;
  static constexpr FormulaPredicateType DurationNotBetween =
    FormulaPredicateArchive_FormulaPredicateType_DurationNotBetween;
  static constexpr FormulaPredicateType DurationAboveAverage =
    FormulaPredicateArchive_FormulaPredicateType_DurationAboveAverage;
  static constexpr FormulaPredicateType DurationBelowAverage =
    FormulaPredicateArchive_FormulaPredicateType_DurationBelowAverage;
  static constexpr FormulaPredicateType DurationTop =
    FormulaPredicateArchive_FormulaPredicateType_DurationTop;
  static constexpr FormulaPredicateType DurationBottom =
    FormulaPredicateArchive_FormulaPredicateType_DurationBottom;
  static inline bool FormulaPredicateType_IsValid(int value) {
    return FormulaPredicateArchive_FormulaPredicateType_IsValid(value);
  }
  static constexpr FormulaPredicateType FormulaPredicateType_MIN =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MIN;
  static constexpr FormulaPredicateType FormulaPredicateType_MAX =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_MAX;
  static constexpr int FormulaPredicateType_ARRAYSIZE =
    FormulaPredicateArchive_FormulaPredicateType_FormulaPredicateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FormulaPredicateType_descriptor() {
    return FormulaPredicateArchive_FormulaPredicateType_descriptor();
  }
  template<typename T>
  static inline const std::string& FormulaPredicateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FormulaPredicateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FormulaPredicateType_Name.");
    return FormulaPredicateArchive_FormulaPredicateType_Name(enum_t_value);
  }
  static inline bool FormulaPredicateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FormulaPredicateType* value) {
    return FormulaPredicateArchive_FormulaPredicateType_Parse(name, value);
  }

  typedef FormulaPredicateArchive_QualifierType QualifierType;
  static constexpr QualifierType QualNone =
    FormulaPredicateArchive_QualifierType_QualNone;
  static constexpr QualifierType Days =
    FormulaPredicateArchive_QualifierType_Days;
  static constexpr QualifierType Weeks =
    FormulaPredicateArchive_QualifierType_Weeks;
  static constexpr QualifierType Months =
    FormulaPredicateArchive_QualifierType_Months;
  static constexpr QualifierType Years =
    FormulaPredicateArchive_QualifierType_Years;
  static constexpr QualifierType Ago =
    FormulaPredicateArchive_QualifierType_Ago;
  static constexpr QualifierType FromNow =
    FormulaPredicateArchive_QualifierType_FromNow;
  static constexpr QualifierType Quarters =
    FormulaPredicateArchive_QualifierType_Quarters;
  static constexpr QualifierType Percent =
    FormulaPredicateArchive_QualifierType_Percent;
  static constexpr QualifierType Values =
    FormulaPredicateArchive_QualifierType_Values;
  static inline bool QualifierType_IsValid(int value) {
    return FormulaPredicateArchive_QualifierType_IsValid(value);
  }
  static constexpr QualifierType QualifierType_MIN =
    FormulaPredicateArchive_QualifierType_QualifierType_MIN;
  static constexpr QualifierType QualifierType_MAX =
    FormulaPredicateArchive_QualifierType_QualifierType_MAX;
  static constexpr int QualifierType_ARRAYSIZE =
    FormulaPredicateArchive_QualifierType_QualifierType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QualifierType_descriptor() {
    return FormulaPredicateArchive_QualifierType_descriptor();
  }
  template<typename T>
  static inline const std::string& QualifierType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QualifierType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QualifierType_Name.");
    return FormulaPredicateArchive_QualifierType_Name(enum_t_value);
  }
  static inline bool QualifierType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QualifierType* value) {
    return FormulaPredicateArchive_QualifierType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFormulaFieldNumber = 1,
    kPredicateTypeFieldNumber = 2,
    kQualifier1FieldNumber = 3,
    kQualifier2FieldNumber = 4,
    kParamIndex1FieldNumber = 5,
    kParamIndex2FieldNumber = 6,
    kParamIndex0FieldNumber = 7,
  };
  // required .TSCE.FormulaArchive formula = 1;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;
  public:
  void clear_formula();
  const ::TSCE::FormulaArchive& formula() const;
  PROTOBUF_NODISCARD ::TSCE::FormulaArchive* release_formula();
  ::TSCE::FormulaArchive* mutable_formula();
  void set_allocated_formula(::TSCE::FormulaArchive* formula);
  private:
  const ::TSCE::FormulaArchive& _internal_formula() const;
  ::TSCE::FormulaArchive* _internal_mutable_formula();
  public:
  void unsafe_arena_set_allocated_formula(
      ::TSCE::FormulaArchive* formula);
  ::TSCE::FormulaArchive* unsafe_arena_release_formula();

  // required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
  bool has_predicate_type() const;
  private:
  bool _internal_has_predicate_type() const;
  public:
  void clear_predicate_type();
  ::TST::FormulaPredicateArchive_FormulaPredicateType predicate_type() const;
  void set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value);
  private:
  ::TST::FormulaPredicateArchive_FormulaPredicateType _internal_predicate_type() const;
  void _internal_set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value);
  public:

  // required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
  bool has_qualifier1() const;
  private:
  bool _internal_has_qualifier1() const;
  public:
  void clear_qualifier1();
  ::TST::FormulaPredicateArchive_QualifierType qualifier1() const;
  void set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value);
  private:
  ::TST::FormulaPredicateArchive_QualifierType _internal_qualifier1() const;
  void _internal_set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value);
  public:

  // required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
  bool has_qualifier2() const;
  private:
  bool _internal_has_qualifier2() const;
  public:
  void clear_qualifier2();
  ::TST::FormulaPredicateArchive_QualifierType qualifier2() const;
  void set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value);
  private:
  ::TST::FormulaPredicateArchive_QualifierType _internal_qualifier2() const;
  void _internal_set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value);
  public:

  // required int32 param_index1 = 5;
  bool has_param_index1() const;
  private:
  bool _internal_has_param_index1() const;
  public:
  void clear_param_index1();
  int32_t param_index1() const;
  void set_param_index1(int32_t value);
  private:
  int32_t _internal_param_index1() const;
  void _internal_set_param_index1(int32_t value);
  public:

  // required int32 param_index2 = 6;
  bool has_param_index2() const;
  private:
  bool _internal_has_param_index2() const;
  public:
  void clear_param_index2();
  int32_t param_index2() const;
  void set_param_index2(int32_t value);
  private:
  int32_t _internal_param_index2() const;
  void _internal_set_param_index2(int32_t value);
  public:

  // required int32 param_index0 = 7;
  bool has_param_index0() const;
  private:
  bool _internal_has_param_index0() const;
  public:
  void clear_param_index0();
  int32_t param_index0() const;
  void set_param_index0(int32_t value);
  private:
  int32_t _internal_param_index0() const;
  void _internal_set_param_index0(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.FormulaPredicateArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSCE::FormulaArchive* formula_;
    int predicate_type_;
    int qualifier1_;
    int qualifier2_;
    int32_t param_index1_;
    int32_t param_index2_;
    int32_t param_index0_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ConditionalStyleSetArchive_ConditionalStyleRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ConditionalStyleSetArchive.ConditionalStyleRule) */ {
 public:
  inline ConditionalStyleSetArchive_ConditionalStyleRule() : ConditionalStyleSetArchive_ConditionalStyleRule(nullptr) {}
  ~ConditionalStyleSetArchive_ConditionalStyleRule() override;
  explicit PROTOBUF_CONSTEXPR ConditionalStyleSetArchive_ConditionalStyleRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConditionalStyleSetArchive_ConditionalStyleRule(const ConditionalStyleSetArchive_ConditionalStyleRule& from);
  ConditionalStyleSetArchive_ConditionalStyleRule(ConditionalStyleSetArchive_ConditionalStyleRule&& from) noexcept
    : ConditionalStyleSetArchive_ConditionalStyleRule() {
    *this = ::std::move(from);
  }

  inline ConditionalStyleSetArchive_ConditionalStyleRule& operator=(const ConditionalStyleSetArchive_ConditionalStyleRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionalStyleSetArchive_ConditionalStyleRule& operator=(ConditionalStyleSetArchive_ConditionalStyleRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionalStyleSetArchive_ConditionalStyleRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionalStyleSetArchive_ConditionalStyleRule* internal_default_instance() {
    return reinterpret_cast<const ConditionalStyleSetArchive_ConditionalStyleRule*>(
               &_ConditionalStyleSetArchive_ConditionalStyleRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ConditionalStyleSetArchive_ConditionalStyleRule& a, ConditionalStyleSetArchive_ConditionalStyleRule& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionalStyleSetArchive_ConditionalStyleRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionalStyleSetArchive_ConditionalStyleRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionalStyleSetArchive_ConditionalStyleRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConditionalStyleSetArchive_ConditionalStyleRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConditionalStyleSetArchive_ConditionalStyleRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConditionalStyleSetArchive_ConditionalStyleRule& from) {
    ConditionalStyleSetArchive_ConditionalStyleRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalStyleSetArchive_ConditionalStyleRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ConditionalStyleSetArchive.ConditionalStyleRule";
  }
  protected:
  explicit ConditionalStyleSetArchive_ConditionalStyleRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredicateFieldNumber = 1,
    kCellStyleFieldNumber = 2,
    kTextStyleFieldNumber = 3,
  };
  // required .TST.FormulaPredicateArchive predicate = 1;
  bool has_predicate() const;
  private:
  bool _internal_has_predicate() const;
  public:
  void clear_predicate();
  const ::TST::FormulaPredicateArchive& predicate() const;
  PROTOBUF_NODISCARD ::TST::FormulaPredicateArchive* release_predicate();
  ::TST::FormulaPredicateArchive* mutable_predicate();
  void set_allocated_predicate(::TST::FormulaPredicateArchive* predicate);
  private:
  const ::TST::FormulaPredicateArchive& _internal_predicate() const;
  ::TST::FormulaPredicateArchive* _internal_mutable_predicate();
  public:
  void unsafe_arena_set_allocated_predicate(
      ::TST::FormulaPredicateArchive* predicate);
  ::TST::FormulaPredicateArchive* unsafe_arena_release_predicate();

  // required .TSP.Reference cell_style = 2;
  bool has_cell_style() const;
  private:
  bool _internal_has_cell_style() const;
  public:
  void clear_cell_style();
  const ::TSP::Reference& cell_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_cell_style();
  ::TSP::Reference* mutable_cell_style();
  void set_allocated_cell_style(::TSP::Reference* cell_style);
  private:
  const ::TSP::Reference& _internal_cell_style() const;
  ::TSP::Reference* _internal_mutable_cell_style();
  public:
  void unsafe_arena_set_allocated_cell_style(
      ::TSP::Reference* cell_style);
  ::TSP::Reference* unsafe_arena_release_cell_style();

  // required .TSP.Reference text_style = 3;
  bool has_text_style() const;
  private:
  bool _internal_has_text_style() const;
  public:
  void clear_text_style();
  const ::TSP::Reference& text_style() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_text_style();
  ::TSP::Reference* mutable_text_style();
  void set_allocated_text_style(::TSP::Reference* text_style);
  private:
  const ::TSP::Reference& _internal_text_style() const;
  ::TSP::Reference* _internal_mutable_text_style();
  public:
  void unsafe_arena_set_allocated_text_style(
      ::TSP::Reference* text_style);
  ::TSP::Reference* unsafe_arena_release_text_style();

  // @@protoc_insertion_point(class_scope:TST.ConditionalStyleSetArchive.ConditionalStyleRule)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::FormulaPredicateArchive* predicate_;
    ::TSP::Reference* cell_style_;
    ::TSP::Reference* text_style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ConditionalStyleSetArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ConditionalStyleSetArchive) */ {
 public:
  inline ConditionalStyleSetArchive() : ConditionalStyleSetArchive(nullptr) {}
  ~ConditionalStyleSetArchive() override;
  explicit PROTOBUF_CONSTEXPR ConditionalStyleSetArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConditionalStyleSetArchive(const ConditionalStyleSetArchive& from);
  ConditionalStyleSetArchive(ConditionalStyleSetArchive&& from) noexcept
    : ConditionalStyleSetArchive() {
    *this = ::std::move(from);
  }

  inline ConditionalStyleSetArchive& operator=(const ConditionalStyleSetArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionalStyleSetArchive& operator=(ConditionalStyleSetArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConditionalStyleSetArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConditionalStyleSetArchive* internal_default_instance() {
    return reinterpret_cast<const ConditionalStyleSetArchive*>(
               &_ConditionalStyleSetArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ConditionalStyleSetArchive& a, ConditionalStyleSetArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionalStyleSetArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConditionalStyleSetArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConditionalStyleSetArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConditionalStyleSetArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConditionalStyleSetArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConditionalStyleSetArchive& from) {
    ConditionalStyleSetArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalStyleSetArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ConditionalStyleSetArchive";
  }
  protected:
  explicit ConditionalStyleSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConditionalStyleSetArchive_ConditionalStyleRule ConditionalStyleRule;

  // accessors -------------------------------------------------------

  enum : int {
    kRulesFieldNumber = 2,
    kCellIDFieldNumber = 3,
    kRuleCountFieldNumber = 1,
  };
  // repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
  int rules_size() const;
  private:
  int _internal_rules_size() const;
  public:
  void clear_rules();
  ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* mutable_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >*
      mutable_rules();
  private:
  const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& _internal_rules(int index) const;
  ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* _internal_add_rules();
  public:
  const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& rules(int index) const;
  ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* add_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >&
      rules() const;

  // optional .TST.CellID cellID = 3;
  bool has_cellid() const;
  private:
  bool _internal_has_cellid() const;
  public:
  void clear_cellid();
  const ::TST::CellID& cellid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_cellid();
  ::TST::CellID* mutable_cellid();
  void set_allocated_cellid(::TST::CellID* cellid);
  private:
  const ::TST::CellID& _internal_cellid() const;
  ::TST::CellID* _internal_mutable_cellid();
  public:
  void unsafe_arena_set_allocated_cellid(
      ::TST::CellID* cellid);
  ::TST::CellID* unsafe_arena_release_cellid();

  // required uint32 ruleCount = 1;
  bool has_rulecount() const;
  private:
  bool _internal_has_rulecount() const;
  public:
  void clear_rulecount();
  uint32_t rulecount() const;
  void set_rulecount(uint32_t value);
  private:
  uint32_t _internal_rulecount() const;
  void _internal_set_rulecount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.ConditionalStyleSetArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule > rules_;
    ::TST::CellID* cellid_;
    uint32_t rulecount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FilterSetArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FilterSetArchive) */ {
 public:
  inline FilterSetArchive() : FilterSetArchive(nullptr) {}
  ~FilterSetArchive() override;
  explicit PROTOBUF_CONSTEXPR FilterSetArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterSetArchive(const FilterSetArchive& from);
  FilterSetArchive(FilterSetArchive&& from) noexcept
    : FilterSetArchive() {
    *this = ::std::move(from);
  }

  inline FilterSetArchive& operator=(const FilterSetArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterSetArchive& operator=(FilterSetArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterSetArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterSetArchive* internal_default_instance() {
    return reinterpret_cast<const FilterSetArchive*>(
               &_FilterSetArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FilterSetArchive& a, FilterSetArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterSetArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterSetArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterSetArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterSetArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterSetArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FilterSetArchive& from) {
    FilterSetArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterSetArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FilterSetArchive";
  }
  protected:
  explicit FilterSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FilterSetArchive_FilterSetType FilterSetType;
  static constexpr FilterSetType FilterSetArchiveTypeAll =
    FilterSetArchive_FilterSetType_FilterSetArchiveTypeAll;
  static constexpr FilterSetType FilterSetArchiveTypeAny =
    FilterSetArchive_FilterSetType_FilterSetArchiveTypeAny;
  static inline bool FilterSetType_IsValid(int value) {
    return FilterSetArchive_FilterSetType_IsValid(value);
  }
  static constexpr FilterSetType FilterSetType_MIN =
    FilterSetArchive_FilterSetType_FilterSetType_MIN;
  static constexpr FilterSetType FilterSetType_MAX =
    FilterSetArchive_FilterSetType_FilterSetType_MAX;
  static constexpr int FilterSetType_ARRAYSIZE =
    FilterSetArchive_FilterSetType_FilterSetType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FilterSetType_descriptor() {
    return FilterSetArchive_FilterSetType_descriptor();
  }
  template<typename T>
  static inline const std::string& FilterSetType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FilterSetType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FilterSetType_Name.");
    return FilterSetArchive_FilterSetType_Name(enum_t_value);
  }
  static inline bool FilterSetType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FilterSetType* value) {
    return FilterSetArchive_FilterSetType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilterRulesFieldNumber = 3,
    kFilterOffsetsFieldNumber = 5,
    kFilterEnabledFieldNumber = 6,
    kTypeFieldNumber = 1,
    kNeedsFormulaRewriteForImportFieldNumber = 4,
    kIsEnabledFieldNumber = 2,
  };
  // repeated .TST.FilterRuleArchive filter_rules = 3;
  int filter_rules_size() const;
  private:
  int _internal_filter_rules_size() const;
  public:
  void clear_filter_rules();
  ::TST::FilterRuleArchive* mutable_filter_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::FilterRuleArchive >*
      mutable_filter_rules();
  private:
  const ::TST::FilterRuleArchive& _internal_filter_rules(int index) const;
  ::TST::FilterRuleArchive* _internal_add_filter_rules();
  public:
  const ::TST::FilterRuleArchive& filter_rules(int index) const;
  ::TST::FilterRuleArchive* add_filter_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::FilterRuleArchive >&
      filter_rules() const;

  // repeated uint32 filter_offsets = 5;
  int filter_offsets_size() const;
  private:
  int _internal_filter_offsets_size() const;
  public:
  void clear_filter_offsets();
  private:
  uint32_t _internal_filter_offsets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_filter_offsets() const;
  void _internal_add_filter_offsets(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_filter_offsets();
  public:
  uint32_t filter_offsets(int index) const;
  void set_filter_offsets(int index, uint32_t value);
  void add_filter_offsets(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      filter_offsets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_filter_offsets();

  // repeated bool filter_enabled = 6;
  int filter_enabled_size() const;
  private:
  int _internal_filter_enabled_size() const;
  public:
  void clear_filter_enabled();
  private:
  bool _internal_filter_enabled(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_filter_enabled() const;
  void _internal_add_filter_enabled(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_filter_enabled();
  public:
  bool filter_enabled(int index) const;
  void set_filter_enabled(int index, bool value);
  void add_filter_enabled(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      filter_enabled() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_filter_enabled();

  // optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::TST::FilterSetArchive_FilterSetType type() const;
  void set_type(::TST::FilterSetArchive_FilterSetType value);
  private:
  ::TST::FilterSetArchive_FilterSetType _internal_type() const;
  void _internal_set_type(::TST::FilterSetArchive_FilterSetType value);
  public:

  // optional bool needs_formula_rewrite_for_import = 4 [default = false];
  bool has_needs_formula_rewrite_for_import() const;
  private:
  bool _internal_has_needs_formula_rewrite_for_import() const;
  public:
  void clear_needs_formula_rewrite_for_import();
  bool needs_formula_rewrite_for_import() const;
  void set_needs_formula_rewrite_for_import(bool value);
  private:
  bool _internal_needs_formula_rewrite_for_import() const;
  void _internal_set_needs_formula_rewrite_for_import(bool value);
  public:

  // optional bool is_enabled = 2 [default = true];
  bool has_is_enabled() const;
  private:
  bool _internal_has_is_enabled() const;
  public:
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.FilterSetArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::FilterRuleArchive > filter_rules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > filter_offsets_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > filter_enabled_;
    int type_;
    bool needs_formula_rewrite_for_import_;
    bool is_enabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class TokenAttachmentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.TokenAttachmentArchive) */ {
 public:
  inline TokenAttachmentArchive() : TokenAttachmentArchive(nullptr) {}
  ~TokenAttachmentArchive() override;
  explicit PROTOBUF_CONSTEXPR TokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TokenAttachmentArchive(const TokenAttachmentArchive& from);
  TokenAttachmentArchive(TokenAttachmentArchive&& from) noexcept
    : TokenAttachmentArchive() {
    *this = ::std::move(from);
  }

  inline TokenAttachmentArchive& operator=(const TokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenAttachmentArchive& operator=(TokenAttachmentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TokenAttachmentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const TokenAttachmentArchive* internal_default_instance() {
    return reinterpret_cast<const TokenAttachmentArchive*>(
               &_TokenAttachmentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TokenAttachmentArchive& a, TokenAttachmentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenAttachmentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TokenAttachmentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TokenAttachmentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TokenAttachmentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TokenAttachmentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TokenAttachmentArchive& from) {
    TokenAttachmentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TokenAttachmentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.TokenAttachmentArchive";
  }
  protected:
  explicit TokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kExpressionNodeFieldNumber = 2,
  };
  // required .TSWP.UIGraphicalAttachment super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::UIGraphicalAttachment& super() const;
  PROTOBUF_NODISCARD ::TSWP::UIGraphicalAttachment* release_super();
  ::TSWP::UIGraphicalAttachment* mutable_super();
  void set_allocated_super(::TSWP::UIGraphicalAttachment* super);
  private:
  const ::TSWP::UIGraphicalAttachment& _internal_super() const;
  ::TSWP::UIGraphicalAttachment* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::UIGraphicalAttachment* super);
  ::TSWP::UIGraphicalAttachment* unsafe_arena_release_super();

  // optional .TSP.Reference expressionNode = 2;
  bool has_expressionnode() const;
  private:
  bool _internal_has_expressionnode() const;
  public:
  void clear_expressionnode();
  const ::TSP::Reference& expressionnode() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_expressionnode();
  ::TSP::Reference* mutable_expressionnode();
  void set_allocated_expressionnode(::TSP::Reference* expressionnode);
  private:
  const ::TSP::Reference& _internal_expressionnode() const;
  ::TSP::Reference* _internal_mutable_expressionnode();
  public:
  void unsafe_arena_set_allocated_expressionnode(
      ::TSP::Reference* expressionnode);
  ::TSP::Reference* unsafe_arena_release_expressionnode();

  // @@protoc_insertion_point(class_scope:TST.TokenAttachmentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::UIGraphicalAttachment* super_;
    ::TSP::Reference* expressionnode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FormulaArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FormulaArchive) */ {
 public:
  inline FormulaArchive() : FormulaArchive(nullptr) {}
  ~FormulaArchive() override;
  explicit PROTOBUF_CONSTEXPR FormulaArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormulaArchive(const FormulaArchive& from);
  FormulaArchive(FormulaArchive&& from) noexcept
    : FormulaArchive() {
    *this = ::std::move(from);
  }

  inline FormulaArchive& operator=(const FormulaArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormulaArchive& operator=(FormulaArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormulaArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormulaArchive* internal_default_instance() {
    return reinterpret_cast<const FormulaArchive*>(
               &_FormulaArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FormulaArchive& a, FormulaArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FormulaArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormulaArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormulaArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormulaArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormulaArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormulaArchive& from) {
    FormulaArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormulaArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FormulaArchive";
  }
  protected:
  explicit FormulaArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionTreeFieldNumber = 1,
  };
  // optional .TSP.Reference expressionTree = 1;
  bool has_expressiontree() const;
  private:
  bool _internal_has_expressiontree() const;
  public:
  void clear_expressiontree();
  const ::TSP::Reference& expressiontree() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_expressiontree();
  ::TSP::Reference* mutable_expressiontree();
  void set_allocated_expressiontree(::TSP::Reference* expressiontree);
  private:
  const ::TSP::Reference& _internal_expressiontree() const;
  ::TSP::Reference* _internal_mutable_expressiontree();
  public:
  void unsafe_arena_set_allocated_expressiontree(
      ::TSP::Reference* expressiontree);
  ::TSP::Reference* unsafe_arena_release_expressiontree();

  // @@protoc_insertion_point(class_scope:TST.FormulaArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* expressiontree_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ExpressionNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ExpressionNodeArchive) */ {
 public:
  inline ExpressionNodeArchive() : ExpressionNodeArchive(nullptr) {}
  ~ExpressionNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR ExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpressionNodeArchive(const ExpressionNodeArchive& from);
  ExpressionNodeArchive(ExpressionNodeArchive&& from) noexcept
    : ExpressionNodeArchive() {
    *this = ::std::move(from);
  }

  inline ExpressionNodeArchive& operator=(const ExpressionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpressionNodeArchive& operator=(ExpressionNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpressionNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpressionNodeArchive* internal_default_instance() {
    return reinterpret_cast<const ExpressionNodeArchive*>(
               &_ExpressionNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ExpressionNodeArchive& a, ExpressionNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpressionNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpressionNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpressionNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpressionNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpressionNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExpressionNodeArchive& from) {
    ExpressionNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpressionNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ExpressionNodeArchive";
  }
  protected:
  explicit ExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 1,
    kFirstIndexFieldNumber = 2,
    kLastIndexFieldNumber = 3,
  };
  // repeated .TSP.Reference children = 1;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::TSP::Reference* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
      mutable_children();
  private:
  const ::TSP::Reference& _internal_children(int index) const;
  ::TSP::Reference* _internal_add_children();
  public:
  const ::TSP::Reference& children(int index) const;
  ::TSP::Reference* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
      children() const;

  // optional uint64 first_index = 2 [default = 0];
  bool has_first_index() const;
  private:
  bool _internal_has_first_index() const;
  public:
  void clear_first_index();
  uint64_t first_index() const;
  void set_first_index(uint64_t value);
  private:
  uint64_t _internal_first_index() const;
  void _internal_set_first_index(uint64_t value);
  public:

  // optional uint64 last_index = 3 [default = 0];
  bool has_last_index() const;
  private:
  bool _internal_has_last_index() const;
  public:
  void clear_last_index();
  uint64_t last_index() const;
  void set_last_index(uint64_t value);
  private:
  uint64_t _internal_last_index() const;
  void _internal_set_last_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.ExpressionNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference > children_;
    uint64_t first_index_;
    uint64_t last_index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class BooleanNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.BooleanNodeArchive) */ {
 public:
  inline BooleanNodeArchive() : BooleanNodeArchive(nullptr) {}
  ~BooleanNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR BooleanNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BooleanNodeArchive(const BooleanNodeArchive& from);
  BooleanNodeArchive(BooleanNodeArchive&& from) noexcept
    : BooleanNodeArchive() {
    *this = ::std::move(from);
  }

  inline BooleanNodeArchive& operator=(const BooleanNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline BooleanNodeArchive& operator=(BooleanNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BooleanNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const BooleanNodeArchive* internal_default_instance() {
    return reinterpret_cast<const BooleanNodeArchive*>(
               &_BooleanNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(BooleanNodeArchive& a, BooleanNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(BooleanNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BooleanNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BooleanNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BooleanNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BooleanNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BooleanNodeArchive& from) {
    BooleanNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BooleanNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.BooleanNodeArchive";
  }
  protected:
  explicit BooleanNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required bool value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.BooleanNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    bool value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class NumberNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.NumberNodeArchive) */ {
 public:
  inline NumberNodeArchive() : NumberNodeArchive(nullptr) {}
  ~NumberNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR NumberNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumberNodeArchive(const NumberNodeArchive& from);
  NumberNodeArchive(NumberNodeArchive&& from) noexcept
    : NumberNodeArchive() {
    *this = ::std::move(from);
  }

  inline NumberNodeArchive& operator=(const NumberNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberNodeArchive& operator=(NumberNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberNodeArchive* internal_default_instance() {
    return reinterpret_cast<const NumberNodeArchive*>(
               &_NumberNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(NumberNodeArchive& a, NumberNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NumberNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NumberNodeArchive& from) {
    NumberNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumberNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.NumberNodeArchive";
  }
  protected:
  explicit NumberNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required double number = 2;
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  double number() const;
  void set_number(double value);
  private:
  double _internal_number() const;
  void _internal_set_number(double value);
  public:

  // @@protoc_insertion_point(class_scope:TST.NumberNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    double number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class StringNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.StringNodeArchive) */ {
 public:
  inline StringNodeArchive() : StringNodeArchive(nullptr) {}
  ~StringNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR StringNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringNodeArchive(const StringNodeArchive& from);
  StringNodeArchive(StringNodeArchive&& from) noexcept
    : StringNodeArchive() {
    *this = ::std::move(from);
  }

  inline StringNodeArchive& operator=(const StringNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringNodeArchive& operator=(StringNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringNodeArchive* internal_default_instance() {
    return reinterpret_cast<const StringNodeArchive*>(
               &_StringNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(StringNodeArchive& a, StringNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(StringNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringNodeArchive& from) {
    StringNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.StringNodeArchive";
  }
  protected:
  explicit StringNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.StringNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class IdentifierNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.IdentifierNodeArchive) */ {
 public:
  inline IdentifierNodeArchive() : IdentifierNodeArchive(nullptr) {}
  ~IdentifierNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR IdentifierNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdentifierNodeArchive(const IdentifierNodeArchive& from);
  IdentifierNodeArchive(IdentifierNodeArchive&& from) noexcept
    : IdentifierNodeArchive() {
    *this = ::std::move(from);
  }

  inline IdentifierNodeArchive& operator=(const IdentifierNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdentifierNodeArchive& operator=(IdentifierNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdentifierNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdentifierNodeArchive* internal_default_instance() {
    return reinterpret_cast<const IdentifierNodeArchive*>(
               &_IdentifierNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(IdentifierNodeArchive& a, IdentifierNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(IdentifierNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdentifierNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdentifierNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdentifierNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdentifierNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdentifierNodeArchive& from) {
    IdentifierNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdentifierNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.IdentifierNodeArchive";
  }
  protected:
  explicit IdentifierNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 2,
    kSuperFieldNumber = 1,
  };
  // optional string identifier = 2;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.IdentifierNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ArrayNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ArrayNodeArchive) */ {
 public:
  inline ArrayNodeArchive() : ArrayNodeArchive(nullptr) {}
  ~ArrayNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR ArrayNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArrayNodeArchive(const ArrayNodeArchive& from);
  ArrayNodeArchive(ArrayNodeArchive&& from) noexcept
    : ArrayNodeArchive() {
    *this = ::std::move(from);
  }

  inline ArrayNodeArchive& operator=(const ArrayNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayNodeArchive& operator=(ArrayNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrayNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayNodeArchive* internal_default_instance() {
    return reinterpret_cast<const ArrayNodeArchive*>(
               &_ArrayNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ArrayNodeArchive& a, ArrayNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArrayNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArrayNodeArchive& from) {
    ArrayNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArrayNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ArrayNodeArchive";
  }
  protected:
  explicit ArrayNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kColumnsFieldNumber = 2,
    kRowsFieldNumber = 3,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // optional uint32 columns = 2;
  bool has_columns() const;
  private:
  bool _internal_has_columns() const;
  public:
  void clear_columns();
  uint32_t columns() const;
  void set_columns(uint32_t value);
  private:
  uint32_t _internal_columns() const;
  void _internal_set_columns(uint32_t value);
  public:

  // optional uint32 rows = 3;
  bool has_rows() const;
  private:
  bool _internal_has_rows() const;
  public:
  void clear_rows();
  uint32_t rows() const;
  void set_rows(uint32_t value);
  private:
  uint32_t _internal_rows() const;
  void _internal_set_rows(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.ArrayNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    uint32_t columns_;
    uint32_t rows_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ListNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ListNodeArchive) */ {
 public:
  inline ListNodeArchive() : ListNodeArchive(nullptr) {}
  ~ListNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR ListNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNodeArchive(const ListNodeArchive& from);
  ListNodeArchive(ListNodeArchive&& from) noexcept
    : ListNodeArchive() {
    *this = ::std::move(from);
  }

  inline ListNodeArchive& operator=(const ListNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNodeArchive& operator=(ListNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNodeArchive* internal_default_instance() {
    return reinterpret_cast<const ListNodeArchive*>(
               &_ListNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ListNodeArchive& a, ListNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListNodeArchive& from) {
    ListNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ListNodeArchive";
  }
  protected:
  explicit ListNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.ListNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class OperatorNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.OperatorNodeArchive) */ {
 public:
  inline OperatorNodeArchive() : OperatorNodeArchive(nullptr) {}
  ~OperatorNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR OperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperatorNodeArchive(const OperatorNodeArchive& from);
  OperatorNodeArchive(OperatorNodeArchive&& from) noexcept
    : OperatorNodeArchive() {
    *this = ::std::move(from);
  }

  inline OperatorNodeArchive& operator=(const OperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorNodeArchive& operator=(OperatorNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperatorNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatorNodeArchive* internal_default_instance() {
    return reinterpret_cast<const OperatorNodeArchive*>(
               &_OperatorNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(OperatorNodeArchive& a, OperatorNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatorNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatorNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatorNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperatorNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperatorNodeArchive& from) {
    OperatorNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.OperatorNodeArchive";
  }
  protected:
  explicit OperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kOperatorCharFieldNumber = 2,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required uint32 operatorChar = 2;
  bool has_operatorchar() const;
  private:
  bool _internal_has_operatorchar() const;
  public:
  void clear_operatorchar();
  uint32_t operatorchar() const;
  void set_operatorchar(uint32_t value);
  private:
  uint32_t _internal_operatorchar() const;
  void _internal_set_operatorchar(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.OperatorNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    uint32_t operatorchar_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class PostfixOperatorNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.PostfixOperatorNodeArchive) */ {
 public:
  inline PostfixOperatorNodeArchive() : PostfixOperatorNodeArchive(nullptr) {}
  ~PostfixOperatorNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR PostfixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostfixOperatorNodeArchive(const PostfixOperatorNodeArchive& from);
  PostfixOperatorNodeArchive(PostfixOperatorNodeArchive&& from) noexcept
    : PostfixOperatorNodeArchive() {
    *this = ::std::move(from);
  }

  inline PostfixOperatorNodeArchive& operator=(const PostfixOperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostfixOperatorNodeArchive& operator=(PostfixOperatorNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostfixOperatorNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostfixOperatorNodeArchive* internal_default_instance() {
    return reinterpret_cast<const PostfixOperatorNodeArchive*>(
               &_PostfixOperatorNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(PostfixOperatorNodeArchive& a, PostfixOperatorNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PostfixOperatorNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostfixOperatorNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostfixOperatorNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostfixOperatorNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostfixOperatorNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostfixOperatorNodeArchive& from) {
    PostfixOperatorNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostfixOperatorNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.PostfixOperatorNodeArchive";
  }
  protected:
  explicit PostfixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TST.OperatorNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::OperatorNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::OperatorNodeArchive* release_super();
  ::TST::OperatorNodeArchive* mutable_super();
  void set_allocated_super(::TST::OperatorNodeArchive* super);
  private:
  const ::TST::OperatorNodeArchive& _internal_super() const;
  ::TST::OperatorNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::OperatorNodeArchive* super);
  ::TST::OperatorNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.PostfixOperatorNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::OperatorNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class PrefixOperatorNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.PrefixOperatorNodeArchive) */ {
 public:
  inline PrefixOperatorNodeArchive() : PrefixOperatorNodeArchive(nullptr) {}
  ~PrefixOperatorNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR PrefixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrefixOperatorNodeArchive(const PrefixOperatorNodeArchive& from);
  PrefixOperatorNodeArchive(PrefixOperatorNodeArchive&& from) noexcept
    : PrefixOperatorNodeArchive() {
    *this = ::std::move(from);
  }

  inline PrefixOperatorNodeArchive& operator=(const PrefixOperatorNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrefixOperatorNodeArchive& operator=(PrefixOperatorNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrefixOperatorNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrefixOperatorNodeArchive* internal_default_instance() {
    return reinterpret_cast<const PrefixOperatorNodeArchive*>(
               &_PrefixOperatorNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PrefixOperatorNodeArchive& a, PrefixOperatorNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(PrefixOperatorNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrefixOperatorNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrefixOperatorNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrefixOperatorNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrefixOperatorNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrefixOperatorNodeArchive& from) {
    PrefixOperatorNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrefixOperatorNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.PrefixOperatorNodeArchive";
  }
  protected:
  explicit PrefixOperatorNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TST.OperatorNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::OperatorNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::OperatorNodeArchive* release_super();
  ::TST::OperatorNodeArchive* mutable_super();
  void set_allocated_super(::TST::OperatorNodeArchive* super);
  private:
  const ::TST::OperatorNodeArchive& _internal_super() const;
  ::TST::OperatorNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::OperatorNodeArchive* super);
  ::TST::OperatorNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.PrefixOperatorNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::OperatorNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FunctionNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FunctionNodeArchive) */ {
 public:
  inline FunctionNodeArchive() : FunctionNodeArchive(nullptr) {}
  ~FunctionNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR FunctionNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionNodeArchive(const FunctionNodeArchive& from);
  FunctionNodeArchive(FunctionNodeArchive&& from) noexcept
    : FunctionNodeArchive() {
    *this = ::std::move(from);
  }

  inline FunctionNodeArchive& operator=(const FunctionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionNodeArchive& operator=(FunctionNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionNodeArchive* internal_default_instance() {
    return reinterpret_cast<const FunctionNodeArchive*>(
               &_FunctionNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(FunctionNodeArchive& a, FunctionNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionNodeArchive& from) {
    FunctionNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FunctionNodeArchive";
  }
  protected:
  explicit FunctionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInvalidFunctionNameFieldNumber = 3,
    kSuperFieldNumber = 1,
    kFunctionIndexFieldNumber = 2,
  };
  // optional string invalidFunctionName = 3;
  bool has_invalidfunctionname() const;
  private:
  bool _internal_has_invalidfunctionname() const;
  public:
  void clear_invalidfunctionname();
  const std::string& invalidfunctionname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invalidfunctionname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invalidfunctionname();
  PROTOBUF_NODISCARD std::string* release_invalidfunctionname();
  void set_allocated_invalidfunctionname(std::string* invalidfunctionname);
  private:
  const std::string& _internal_invalidfunctionname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidfunctionname(const std::string& value);
  std::string* _internal_mutable_invalidfunctionname();
  public:

  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required uint32 functionIndex = 2;
  bool has_functionindex() const;
  private:
  bool _internal_has_functionindex() const;
  public:
  void clear_functionindex();
  uint32_t functionindex() const;
  void set_functionindex(uint32_t value);
  private:
  uint32_t _internal_functionindex() const;
  void _internal_set_functionindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.FunctionNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidfunctionname_;
    ::TST::ExpressionNodeArchive* super_;
    uint32_t functionindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FunctionEndNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FunctionEndNodeArchive) */ {
 public:
  inline FunctionEndNodeArchive() : FunctionEndNodeArchive(nullptr) {}
  ~FunctionEndNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR FunctionEndNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionEndNodeArchive(const FunctionEndNodeArchive& from);
  FunctionEndNodeArchive(FunctionEndNodeArchive&& from) noexcept
    : FunctionEndNodeArchive() {
    *this = ::std::move(from);
  }

  inline FunctionEndNodeArchive& operator=(const FunctionEndNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionEndNodeArchive& operator=(FunctionEndNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionEndNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionEndNodeArchive* internal_default_instance() {
    return reinterpret_cast<const FunctionEndNodeArchive*>(
               &_FunctionEndNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(FunctionEndNodeArchive& a, FunctionEndNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionEndNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionEndNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionEndNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionEndNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionEndNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionEndNodeArchive& from) {
    FunctionEndNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionEndNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FunctionEndNodeArchive";
  }
  protected:
  explicit FunctionEndNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.FunctionEndNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DateNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.DateNodeArchive) */ {
 public:
  inline DateNodeArchive() : DateNodeArchive(nullptr) {}
  ~DateNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR DateNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateNodeArchive(const DateNodeArchive& from);
  DateNodeArchive(DateNodeArchive&& from) noexcept
    : DateNodeArchive() {
    *this = ::std::move(from);
  }

  inline DateNodeArchive& operator=(const DateNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateNodeArchive& operator=(DateNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DateNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateNodeArchive* internal_default_instance() {
    return reinterpret_cast<const DateNodeArchive*>(
               &_DateNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(DateNodeArchive& a, DateNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DateNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DateNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DateNodeArchive& from) {
    DateNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DateNodeArchive";
  }
  protected:
  explicit DateNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kFormatFieldNumber = 3,
    kSuperFieldNumber = 1,
  };
  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional string format = 3;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  const std::string& format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format();
  PROTOBUF_NODISCARD std::string* release_format();
  void set_allocated_format(std::string* format);
  private:
  const std::string& _internal_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format(const std::string& value);
  std::string* _internal_mutable_format();
  public:

  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.DateNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ReferenceNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ReferenceNodeArchive) */ {
 public:
  inline ReferenceNodeArchive() : ReferenceNodeArchive(nullptr) {}
  ~ReferenceNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR ReferenceNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReferenceNodeArchive(const ReferenceNodeArchive& from);
  ReferenceNodeArchive(ReferenceNodeArchive&& from) noexcept
    : ReferenceNodeArchive() {
    *this = ::std::move(from);
  }

  inline ReferenceNodeArchive& operator=(const ReferenceNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceNodeArchive& operator=(ReferenceNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReferenceNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReferenceNodeArchive* internal_default_instance() {
    return reinterpret_cast<const ReferenceNodeArchive*>(
               &_ReferenceNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ReferenceNodeArchive& a, ReferenceNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReferenceNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReferenceNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReferenceNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReferenceNodeArchive& from) {
    ReferenceNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ReferenceNodeArchive";
  }
  protected:
  explicit ReferenceNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostTableIDFieldNumber = 4,
    kSuperFieldNumber = 1,
    kRangeReferenceFieldNumber = 2,
    kStickyBitsFieldNumber = 3,
  };
  // optional string hostTableID = 4;
  bool has_hosttableid() const;
  private:
  bool _internal_has_hosttableid() const;
  public:
  void clear_hosttableid();
  const std::string& hosttableid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hosttableid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hosttableid();
  PROTOBUF_NODISCARD std::string* release_hosttableid();
  void set_allocated_hosttableid(std::string* hosttableid);
  private:
  const std::string& _internal_hosttableid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hosttableid(const std::string& value);
  std::string* _internal_mutable_hosttableid();
  public:

  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required .TSCE.RangeReferenceArchive rangeReference = 2;
  bool has_rangereference() const;
  private:
  bool _internal_has_rangereference() const;
  public:
  void clear_rangereference();
  const ::TSCE::RangeReferenceArchive& rangereference() const;
  PROTOBUF_NODISCARD ::TSCE::RangeReferenceArchive* release_rangereference();
  ::TSCE::RangeReferenceArchive* mutable_rangereference();
  void set_allocated_rangereference(::TSCE::RangeReferenceArchive* rangereference);
  private:
  const ::TSCE::RangeReferenceArchive& _internal_rangereference() const;
  ::TSCE::RangeReferenceArchive* _internal_mutable_rangereference();
  public:
  void unsafe_arena_set_allocated_rangereference(
      ::TSCE::RangeReferenceArchive* rangereference);
  ::TSCE::RangeReferenceArchive* unsafe_arena_release_rangereference();

  // required uint32 stickyBits = 3;
  bool has_stickybits() const;
  private:
  bool _internal_has_stickybits() const;
  public:
  void clear_stickybits();
  uint32_t stickybits() const;
  void set_stickybits(uint32_t value);
  private:
  uint32_t _internal_stickybits() const;
  void _internal_set_stickybits(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.ReferenceNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hosttableid_;
    ::TST::ExpressionNodeArchive* super_;
    ::TSCE::RangeReferenceArchive* rangereference_;
    uint32_t stickybits_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class DurationNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.DurationNodeArchive) */ {
 public:
  inline DurationNodeArchive() : DurationNodeArchive(nullptr) {}
  ~DurationNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR DurationNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DurationNodeArchive(const DurationNodeArchive& from);
  DurationNodeArchive(DurationNodeArchive&& from) noexcept
    : DurationNodeArchive() {
    *this = ::std::move(from);
  }

  inline DurationNodeArchive& operator=(const DurationNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline DurationNodeArchive& operator=(DurationNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DurationNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const DurationNodeArchive* internal_default_instance() {
    return reinterpret_cast<const DurationNodeArchive*>(
               &_DurationNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(DurationNodeArchive& a, DurationNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(DurationNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DurationNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DurationNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DurationNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DurationNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DurationNodeArchive& from) {
    DurationNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DurationNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.DurationNodeArchive";
  }
  protected:
  explicit DurationNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kTimeintervalFieldNumber = 2,
    kSmallestFieldNumber = 3,
    kLargestFieldNumber = 4,
    kStyleFieldNumber = 5,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required double timeinterval = 2;
  bool has_timeinterval() const;
  private:
  bool _internal_has_timeinterval() const;
  public:
  void clear_timeinterval();
  double timeinterval() const;
  void set_timeinterval(double value);
  private:
  double _internal_timeinterval() const;
  void _internal_set_timeinterval(double value);
  public:

  // required uint32 smallest = 3;
  bool has_smallest() const;
  private:
  bool _internal_has_smallest() const;
  public:
  void clear_smallest();
  uint32_t smallest() const;
  void set_smallest(uint32_t value);
  private:
  uint32_t _internal_smallest() const;
  void _internal_set_smallest(uint32_t value);
  public:

  // required uint32 largest = 4;
  bool has_largest() const;
  private:
  bool _internal_has_largest() const;
  public:
  void clear_largest();
  uint32_t largest() const;
  void set_largest(uint32_t value);
  private:
  uint32_t _internal_largest() const;
  void _internal_set_largest(uint32_t value);
  public:

  // required uint32 style = 5;
  bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  void clear_style();
  uint32_t style() const;
  void set_style(uint32_t value);
  private:
  uint32_t _internal_style() const;
  void _internal_set_style(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.DurationNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    double timeinterval_;
    uint32_t smallest_;
    uint32_t largest_;
    uint32_t style_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class ArgumentPlaceholderNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.ArgumentPlaceholderNodeArchive) */ {
 public:
  inline ArgumentPlaceholderNodeArchive() : ArgumentPlaceholderNodeArchive(nullptr) {}
  ~ArgumentPlaceholderNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR ArgumentPlaceholderNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArgumentPlaceholderNodeArchive(const ArgumentPlaceholderNodeArchive& from);
  ArgumentPlaceholderNodeArchive(ArgumentPlaceholderNodeArchive&& from) noexcept
    : ArgumentPlaceholderNodeArchive() {
    *this = ::std::move(from);
  }

  inline ArgumentPlaceholderNodeArchive& operator=(const ArgumentPlaceholderNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArgumentPlaceholderNodeArchive& operator=(ArgumentPlaceholderNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArgumentPlaceholderNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArgumentPlaceholderNodeArchive* internal_default_instance() {
    return reinterpret_cast<const ArgumentPlaceholderNodeArchive*>(
               &_ArgumentPlaceholderNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ArgumentPlaceholderNodeArchive& a, ArgumentPlaceholderNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(ArgumentPlaceholderNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArgumentPlaceholderNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArgumentPlaceholderNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArgumentPlaceholderNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArgumentPlaceholderNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArgumentPlaceholderNodeArchive& from) {
    ArgumentPlaceholderNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArgumentPlaceholderNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.ArgumentPlaceholderNodeArchive";
  }
  protected:
  explicit ArgumentPlaceholderNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
    kFunctionIndexFieldNumber = 2,
    kArgumentIndexFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // required uint32 functionIndex = 2;
  bool has_functionindex() const;
  private:
  bool _internal_has_functionindex() const;
  public:
  void clear_functionindex();
  uint32_t functionindex() const;
  void set_functionindex(uint32_t value);
  private:
  uint32_t _internal_functionindex() const;
  void _internal_set_functionindex(uint32_t value);
  public:

  // required uint32 argumentIndex = 3;
  bool has_argumentindex() const;
  private:
  bool _internal_has_argumentindex() const;
  public:
  void clear_argumentindex();
  uint32_t argumentindex() const;
  void set_argumentindex(uint32_t value);
  private:
  uint32_t _internal_argumentindex() const;
  void _internal_set_argumentindex(uint32_t value);
  public:

  // optional uint32 mode = 4;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  uint32_t mode() const;
  void set_mode(uint32_t value);
  private:
  uint32_t _internal_mode() const;
  void _internal_set_mode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.ArgumentPlaceholderNodeArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
    uint32_t functionindex_;
    uint32_t argumentindex_;
    uint32_t mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class EmptyExpressionNodeArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.EmptyExpressionNodeArchive) */ {
 public:
  inline EmptyExpressionNodeArchive() : EmptyExpressionNodeArchive(nullptr) {}
  ~EmptyExpressionNodeArchive() override;
  explicit PROTOBUF_CONSTEXPR EmptyExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyExpressionNodeArchive(const EmptyExpressionNodeArchive& from);
  EmptyExpressionNodeArchive(EmptyExpressionNodeArchive&& from) noexcept
    : EmptyExpressionNodeArchive() {
    *this = ::std::move(from);
  }

  inline EmptyExpressionNodeArchive& operator=(const EmptyExpressionNodeArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyExpressionNodeArchive& operator=(EmptyExpressionNodeArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyExpressionNodeArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyExpressionNodeArchive* internal_default_instance() {
    return reinterpret_cast<const EmptyExpressionNodeArchive*>(
               &_EmptyExpressionNodeArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(EmptyExpressionNodeArchive& a, EmptyExpressionNodeArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyExpressionNodeArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyExpressionNodeArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyExpressionNodeArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyExpressionNodeArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyExpressionNodeArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyExpressionNodeArchive& from) {
    EmptyExpressionNodeArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyExpressionNodeArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.EmptyExpressionNodeArchive";
  }
  protected:
  explicit EmptyExpressionNodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TST.ExpressionNodeArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::ExpressionNodeArchive& super() const;
  PROTOBUF_NODISCARD ::TST::ExpressionNodeArchive* release_super();
  ::TST::ExpressionNodeArchive* mutable_super();
  void set_allocated_super(::TST::ExpressionNodeArchive* super);
  private:
  const ::TST::ExpressionNodeArchive& _internal_super() const;
  ::TST::ExpressionNodeArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::ExpressionNodeArchive* super);
  ::TST::ExpressionNodeArchive* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.EmptyExpressionNodeArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::ExpressionNodeArchive* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class LayoutHintArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.LayoutHintArchive) */ {
 public:
  inline LayoutHintArchive() : LayoutHintArchive(nullptr) {}
  ~LayoutHintArchive() override;
  explicit PROTOBUF_CONSTEXPR LayoutHintArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayoutHintArchive(const LayoutHintArchive& from);
  LayoutHintArchive(LayoutHintArchive&& from) noexcept
    : LayoutHintArchive() {
    *this = ::std::move(from);
  }

  inline LayoutHintArchive& operator=(const LayoutHintArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayoutHintArchive& operator=(LayoutHintArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayoutHintArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayoutHintArchive* internal_default_instance() {
    return reinterpret_cast<const LayoutHintArchive*>(
               &_LayoutHintArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(LayoutHintArchive& a, LayoutHintArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(LayoutHintArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayoutHintArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayoutHintArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayoutHintArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayoutHintArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayoutHintArchive& from) {
    LayoutHintArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayoutHintArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.LayoutHintArchive";
  }
  protected:
  explicit LayoutHintArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellRangeFieldNumber = 2,
    kHintIDFieldNumber = 3,
    kMaximumSizeFieldNumber = 4,
    kEffectiveSizeFieldNumber = 7,
    kIsValidFieldNumber = 1,
    kHorizontalFieldNumber = 6,
    kPartitionPositionFieldNumber = 5,
    kPartitioningPassFieldNumber = 8,
  };
  // required .TST.CellRange cellRange = 2;
  bool has_cellrange() const;
  private:
  bool _internal_has_cellrange() const;
  public:
  void clear_cellrange();
  const ::TST::CellRange& cellrange() const;
  PROTOBUF_NODISCARD ::TST::CellRange* release_cellrange();
  ::TST::CellRange* mutable_cellrange();
  void set_allocated_cellrange(::TST::CellRange* cellrange);
  private:
  const ::TST::CellRange& _internal_cellrange() const;
  ::TST::CellRange* _internal_mutable_cellrange();
  public:
  void unsafe_arena_set_allocated_cellrange(
      ::TST::CellRange* cellrange);
  ::TST::CellRange* unsafe_arena_release_cellrange();

  // required .TST.CellID hintID = 3;
  bool has_hintid() const;
  private:
  bool _internal_has_hintid() const;
  public:
  void clear_hintid();
  const ::TST::CellID& hintid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_hintid();
  ::TST::CellID* mutable_hintid();
  void set_allocated_hintid(::TST::CellID* hintid);
  private:
  const ::TST::CellID& _internal_hintid() const;
  ::TST::CellID* _internal_mutable_hintid();
  public:
  void unsafe_arena_set_allocated_hintid(
      ::TST::CellID* hintid);
  ::TST::CellID* unsafe_arena_release_hintid();

  // required .TSP.Size maximumSize = 4;
  bool has_maximumsize() const;
  private:
  bool _internal_has_maximumsize() const;
  public:
  void clear_maximumsize();
  const ::TSP::Size& maximumsize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_maximumsize();
  ::TSP::Size* mutable_maximumsize();
  void set_allocated_maximumsize(::TSP::Size* maximumsize);
  private:
  const ::TSP::Size& _internal_maximumsize() const;
  ::TSP::Size* _internal_mutable_maximumsize();
  public:
  void unsafe_arena_set_allocated_maximumsize(
      ::TSP::Size* maximumsize);
  ::TSP::Size* unsafe_arena_release_maximumsize();

  // optional .TSP.Size effectiveSize = 7;
  bool has_effectivesize() const;
  private:
  bool _internal_has_effectivesize() const;
  public:
  void clear_effectivesize();
  const ::TSP::Size& effectivesize() const;
  PROTOBUF_NODISCARD ::TSP::Size* release_effectivesize();
  ::TSP::Size* mutable_effectivesize();
  void set_allocated_effectivesize(::TSP::Size* effectivesize);
  private:
  const ::TSP::Size& _internal_effectivesize() const;
  ::TSP::Size* _internal_mutable_effectivesize();
  public:
  void unsafe_arena_set_allocated_effectivesize(
      ::TSP::Size* effectivesize);
  ::TSP::Size* unsafe_arena_release_effectivesize();

  // required bool isValid = 1;
  bool has_isvalid() const;
  private:
  bool _internal_has_isvalid() const;
  public:
  void clear_isvalid();
  bool isvalid() const;
  void set_isvalid(bool value);
  private:
  bool _internal_isvalid() const;
  void _internal_set_isvalid(bool value);
  public:

  // required bool horizontal = 6;
  bool has_horizontal() const;
  private:
  bool _internal_has_horizontal() const;
  public:
  void clear_horizontal();
  bool horizontal() const;
  void set_horizontal(bool value);
  private:
  bool _internal_horizontal() const;
  void _internal_set_horizontal(bool value);
  public:

  // required uint32 partitionPosition = 5;
  bool has_partitionposition() const;
  private:
  bool _internal_has_partitionposition() const;
  public:
  void clear_partitionposition();
  uint32_t partitionposition() const;
  void set_partitionposition(uint32_t value);
  private:
  uint32_t _internal_partitionposition() const;
  void _internal_set_partitionposition(uint32_t value);
  public:

  // optional uint32 partitioningPass = 8;
  bool has_partitioningpass() const;
  private:
  bool _internal_has_partitioningpass() const;
  public:
  void clear_partitioningpass();
  uint32_t partitioningpass() const;
  void set_partitioningpass(uint32_t value);
  private:
  uint32_t _internal_partitioningpass() const;
  void _internal_set_partitioningpass(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.LayoutHintArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TST::CellRange* cellrange_;
    ::TST::CellID* hintid_;
    ::TSP::Size* maximumsize_;
    ::TSP::Size* effectivesize_;
    bool isvalid_;
    bool horizontal_;
    uint32_t partitionposition_;
    uint32_t partitioningpass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CompletionTokenAttachmentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CompletionTokenAttachmentArchive) */ {
 public:
  inline CompletionTokenAttachmentArchive() : CompletionTokenAttachmentArchive(nullptr) {}
  ~CompletionTokenAttachmentArchive() override;
  explicit PROTOBUF_CONSTEXPR CompletionTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionTokenAttachmentArchive(const CompletionTokenAttachmentArchive& from);
  CompletionTokenAttachmentArchive(CompletionTokenAttachmentArchive&& from) noexcept
    : CompletionTokenAttachmentArchive() {
    *this = ::std::move(from);
  }

  inline CompletionTokenAttachmentArchive& operator=(const CompletionTokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionTokenAttachmentArchive& operator=(CompletionTokenAttachmentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionTokenAttachmentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionTokenAttachmentArchive* internal_default_instance() {
    return reinterpret_cast<const CompletionTokenAttachmentArchive*>(
               &_CompletionTokenAttachmentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CompletionTokenAttachmentArchive& a, CompletionTokenAttachmentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionTokenAttachmentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionTokenAttachmentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionTokenAttachmentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionTokenAttachmentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionTokenAttachmentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompletionTokenAttachmentArchive& from) {
    CompletionTokenAttachmentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionTokenAttachmentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CompletionTokenAttachmentArchive";
  }
  protected:
  explicit CompletionTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompletionTextFieldNumber = 2,
    kSuperFieldNumber = 1,
    kCaretPositionFieldNumber = 3,
    kPrefixStartFieldNumber = 4,
  };
  // optional string completionText = 2;
  bool has_completiontext() const;
  private:
  bool _internal_has_completiontext() const;
  public:
  void clear_completiontext();
  const std::string& completiontext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_completiontext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_completiontext();
  PROTOBUF_NODISCARD std::string* release_completiontext();
  void set_allocated_completiontext(std::string* completiontext);
  private:
  const std::string& _internal_completiontext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completiontext(const std::string& value);
  std::string* _internal_mutable_completiontext();
  public:

  // required .TST.TokenAttachmentArchive super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TST::TokenAttachmentArchive& super() const;
  PROTOBUF_NODISCARD ::TST::TokenAttachmentArchive* release_super();
  ::TST::TokenAttachmentArchive* mutable_super();
  void set_allocated_super(::TST::TokenAttachmentArchive* super);
  private:
  const ::TST::TokenAttachmentArchive& _internal_super() const;
  ::TST::TokenAttachmentArchive* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TST::TokenAttachmentArchive* super);
  ::TST::TokenAttachmentArchive* unsafe_arena_release_super();

  // optional uint32 caretPosition = 3;
  bool has_caretposition() const;
  private:
  bool _internal_has_caretposition() const;
  public:
  void clear_caretposition();
  uint32_t caretposition() const;
  void set_caretposition(uint32_t value);
  private:
  uint32_t _internal_caretposition() const;
  void _internal_set_caretposition(uint32_t value);
  public:

  // optional uint32 prefixStart = 4;
  bool has_prefixstart() const;
  private:
  bool _internal_has_prefixstart() const;
  public:
  void clear_prefixstart();
  uint32_t prefixstart() const;
  void set_prefixstart(uint32_t value);
  private:
  uint32_t _internal_prefixstart() const;
  void _internal_set_prefixstart(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TST.CompletionTokenAttachmentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr completiontext_;
    ::TST::TokenAttachmentArchive* super_;
    uint32_t caretposition_;
    uint32_t prefixstart_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class HiddenStateFormulaOwnerArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.HiddenStateFormulaOwnerArchive) */ {
 public:
  inline HiddenStateFormulaOwnerArchive() : HiddenStateFormulaOwnerArchive(nullptr) {}
  ~HiddenStateFormulaOwnerArchive() override;
  explicit PROTOBUF_CONSTEXPR HiddenStateFormulaOwnerArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HiddenStateFormulaOwnerArchive(const HiddenStateFormulaOwnerArchive& from);
  HiddenStateFormulaOwnerArchive(HiddenStateFormulaOwnerArchive&& from) noexcept
    : HiddenStateFormulaOwnerArchive() {
    *this = ::std::move(from);
  }

  inline HiddenStateFormulaOwnerArchive& operator=(const HiddenStateFormulaOwnerArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline HiddenStateFormulaOwnerArchive& operator=(HiddenStateFormulaOwnerArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HiddenStateFormulaOwnerArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const HiddenStateFormulaOwnerArchive* internal_default_instance() {
    return reinterpret_cast<const HiddenStateFormulaOwnerArchive*>(
               &_HiddenStateFormulaOwnerArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(HiddenStateFormulaOwnerArchive& a, HiddenStateFormulaOwnerArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(HiddenStateFormulaOwnerArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HiddenStateFormulaOwnerArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HiddenStateFormulaOwnerArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HiddenStateFormulaOwnerArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HiddenStateFormulaOwnerArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HiddenStateFormulaOwnerArchive& from) {
    HiddenStateFormulaOwnerArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HiddenStateFormulaOwnerArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.HiddenStateFormulaOwnerArchive";
  }
  protected:
  explicit HiddenStateFormulaOwnerArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdValueFieldNumber = 2,
    kOwnerIdFieldNumber = 1,
    kNeedsToUpdateFilterSetForImportFieldNumber = 3,
  };
  // repeated .TSCE.CellValueArchive threshold_value = 2;
  int threshold_value_size() const;
  private:
  int _internal_threshold_value_size() const;
  public:
  void clear_threshold_value();
  ::TSCE::CellValueArchive* mutable_threshold_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >*
      mutable_threshold_value();
  private:
  const ::TSCE::CellValueArchive& _internal_threshold_value(int index) const;
  ::TSCE::CellValueArchive* _internal_add_threshold_value();
  public:
  const ::TSCE::CellValueArchive& threshold_value(int index) const;
  ::TSCE::CellValueArchive* add_threshold_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >&
      threshold_value() const;

  // optional .TSCE.CFUUIDArchive owner_id = 1;
  bool has_owner_id() const;
  private:
  bool _internal_has_owner_id() const;
  public:
  void clear_owner_id();
  const ::TSCE::CFUUIDArchive& owner_id() const;
  PROTOBUF_NODISCARD ::TSCE::CFUUIDArchive* release_owner_id();
  ::TSCE::CFUUIDArchive* mutable_owner_id();
  void set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id);
  private:
  const ::TSCE::CFUUIDArchive& _internal_owner_id() const;
  ::TSCE::CFUUIDArchive* _internal_mutable_owner_id();
  public:
  void unsafe_arena_set_allocated_owner_id(
      ::TSCE::CFUUIDArchive* owner_id);
  ::TSCE::CFUUIDArchive* unsafe_arena_release_owner_id();

  // optional bool needs_to_update_filter_set_for_import = 3 [default = false];
  bool has_needs_to_update_filter_set_for_import() const;
  private:
  bool _internal_has_needs_to_update_filter_set_for_import() const;
  public:
  void clear_needs_to_update_filter_set_for_import();
  bool needs_to_update_filter_set_for_import() const;
  void set_needs_to_update_filter_set_for_import(bool value);
  private:
  bool _internal_needs_to_update_filter_set_for_import() const;
  void _internal_set_needs_to_update_filter_set_for_import(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TST.HiddenStateFormulaOwnerArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive > threshold_value_;
    ::TSCE::CFUUIDArchive* owner_id_;
    bool needs_to_update_filter_set_for_import_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class RichTextPayloadArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.RichTextPayloadArchive) */ {
 public:
  inline RichTextPayloadArchive() : RichTextPayloadArchive(nullptr) {}
  ~RichTextPayloadArchive() override;
  explicit PROTOBUF_CONSTEXPR RichTextPayloadArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RichTextPayloadArchive(const RichTextPayloadArchive& from);
  RichTextPayloadArchive(RichTextPayloadArchive&& from) noexcept
    : RichTextPayloadArchive() {
    *this = ::std::move(from);
  }

  inline RichTextPayloadArchive& operator=(const RichTextPayloadArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline RichTextPayloadArchive& operator=(RichTextPayloadArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RichTextPayloadArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const RichTextPayloadArchive* internal_default_instance() {
    return reinterpret_cast<const RichTextPayloadArchive*>(
               &_RichTextPayloadArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(RichTextPayloadArchive& a, RichTextPayloadArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(RichTextPayloadArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RichTextPayloadArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RichTextPayloadArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RichTextPayloadArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RichTextPayloadArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RichTextPayloadArchive& from) {
    RichTextPayloadArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RichTextPayloadArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.RichTextPayloadArchive";
  }
  protected:
  explicit RichTextPayloadArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageFieldNumber = 1,
    kRangeFieldNumber = 2,
    kCellidFieldNumber = 3,
  };
  // required .TSP.Reference storage = 1;
  bool has_storage() const;
  private:
  bool _internal_has_storage() const;
  public:
  void clear_storage();
  const ::TSP::Reference& storage() const;
  PROTOBUF_NODISCARD ::TSP::Reference* release_storage();
  ::TSP::Reference* mutable_storage();
  void set_allocated_storage(::TSP::Reference* storage);
  private:
  const ::TSP::Reference& _internal_storage() const;
  ::TSP::Reference* _internal_mutable_storage();
  public:
  void unsafe_arena_set_allocated_storage(
      ::TSP::Reference* storage);
  ::TSP::Reference* unsafe_arena_release_storage();

  // optional .TSP.Range range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::TSP::Range& range() const;
  PROTOBUF_NODISCARD ::TSP::Range* release_range();
  ::TSP::Range* mutable_range();
  void set_allocated_range(::TSP::Range* range);
  private:
  const ::TSP::Range& _internal_range() const;
  ::TSP::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::TSP::Range* range);
  ::TSP::Range* unsafe_arena_release_range();

  // required .TST.CellID cellid = 3;
  bool has_cellid() const;
  private:
  bool _internal_has_cellid() const;
  public:
  void clear_cellid();
  const ::TST::CellID& cellid() const;
  PROTOBUF_NODISCARD ::TST::CellID* release_cellid();
  ::TST::CellID* mutable_cellid();
  void set_allocated_cellid(::TST::CellID* cellid);
  private:
  const ::TST::CellID& _internal_cellid() const;
  ::TST::CellID* _internal_mutable_cellid();
  public:
  void unsafe_arena_set_allocated_cellid(
      ::TST::CellID* cellid);
  ::TST::CellID* unsafe_arena_release_cellid();

  // @@protoc_insertion_point(class_scope:TST.RichTextPayloadArchive)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSP::Reference* storage_;
    ::TSP::Range* range_;
    ::TST::CellID* cellid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class FormulaEqualsTokenAttachmentArchive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.FormulaEqualsTokenAttachmentArchive) */ {
 public:
  inline FormulaEqualsTokenAttachmentArchive() : FormulaEqualsTokenAttachmentArchive(nullptr) {}
  ~FormulaEqualsTokenAttachmentArchive() override;
  explicit PROTOBUF_CONSTEXPR FormulaEqualsTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormulaEqualsTokenAttachmentArchive(const FormulaEqualsTokenAttachmentArchive& from);
  FormulaEqualsTokenAttachmentArchive(FormulaEqualsTokenAttachmentArchive&& from) noexcept
    : FormulaEqualsTokenAttachmentArchive() {
    *this = ::std::move(from);
  }

  inline FormulaEqualsTokenAttachmentArchive& operator=(const FormulaEqualsTokenAttachmentArchive& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormulaEqualsTokenAttachmentArchive& operator=(FormulaEqualsTokenAttachmentArchive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormulaEqualsTokenAttachmentArchive& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormulaEqualsTokenAttachmentArchive* internal_default_instance() {
    return reinterpret_cast<const FormulaEqualsTokenAttachmentArchive*>(
               &_FormulaEqualsTokenAttachmentArchive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(FormulaEqualsTokenAttachmentArchive& a, FormulaEqualsTokenAttachmentArchive& b) {
    a.Swap(&b);
  }
  inline void Swap(FormulaEqualsTokenAttachmentArchive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormulaEqualsTokenAttachmentArchive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormulaEqualsTokenAttachmentArchive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormulaEqualsTokenAttachmentArchive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormulaEqualsTokenAttachmentArchive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormulaEqualsTokenAttachmentArchive& from) {
    FormulaEqualsTokenAttachmentArchive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormulaEqualsTokenAttachmentArchive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.FormulaEqualsTokenAttachmentArchive";
  }
  protected:
  explicit FormulaEqualsTokenAttachmentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuperFieldNumber = 1,
  };
  // required .TSWP.UIGraphicalAttachment super = 1;
  bool has_super() const;
  private:
  bool _internal_has_super() const;
  public:
  void clear_super();
  const ::TSWP::UIGraphicalAttachment& super() const;
  PROTOBUF_NODISCARD ::TSWP::UIGraphicalAttachment* release_super();
  ::TSWP::UIGraphicalAttachment* mutable_super();
  void set_allocated_super(::TSWP::UIGraphicalAttachment* super);
  private:
  const ::TSWP::UIGraphicalAttachment& _internal_super() const;
  ::TSWP::UIGraphicalAttachment* _internal_mutable_super();
  public:
  void unsafe_arena_set_allocated_super(
      ::TSWP::UIGraphicalAttachment* super);
  ::TSWP::UIGraphicalAttachment* unsafe_arena_release_super();

  // @@protoc_insertion_point(class_scope:TST.FormulaEqualsTokenAttachmentArchive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::TSWP::UIGraphicalAttachment* super_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// -------------------------------------------------------------------

class CellRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TST.CellRegion) */ {
 public:
  inline CellRegion() : CellRegion(nullptr) {}
  ~CellRegion() override;
  explicit PROTOBUF_CONSTEXPR CellRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CellRegion(const CellRegion& from);
  CellRegion(CellRegion&& from) noexcept
    : CellRegion() {
    *this = ::std::move(from);
  }

  inline CellRegion& operator=(const CellRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellRegion& operator=(CellRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CellRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const CellRegion* internal_default_instance() {
    return reinterpret_cast<const CellRegion*>(
               &_CellRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CellRegion& a, CellRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(CellRegion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CellRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CellRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CellRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CellRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CellRegion& from) {
    CellRegion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellRegion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TST.CellRegion";
  }
  protected:
  explicit CellRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellRangesFieldNumber = 1,
  };
  // repeated .TST.CellRange cell_ranges = 1;
  int cell_ranges_size() const;
  private:
  int _internal_cell_ranges_size() const;
  public:
  void clear_cell_ranges();
  ::TST::CellRange* mutable_cell_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
      mutable_cell_ranges();
  private:
  const ::TST::CellRange& _internal_cell_ranges(int index) const;
  ::TST::CellRange* _internal_add_cell_ranges();
  public:
  const ::TST::CellRange& cell_ranges(int index) const;
  ::TST::CellRange* add_cell_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
      cell_ranges() const;

  // @@protoc_insertion_point(class_scope:TST.CellRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange > cell_ranges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_TSTArchives_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CellID

// required fixed32 packedData = 1;
inline bool CellID::_internal_has_packeddata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CellID::has_packeddata() const {
  return _internal_has_packeddata();
}
inline void CellID::clear_packeddata() {
  _impl_.packeddata_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CellID::_internal_packeddata() const {
  return _impl_.packeddata_;
}
inline uint32_t CellID::packeddata() const {
  // @@protoc_insertion_point(field_get:TST.CellID.packedData)
  return _internal_packeddata();
}
inline void CellID::_internal_set_packeddata(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.packeddata_ = value;
}
inline void CellID::set_packeddata(uint32_t value) {
  _internal_set_packeddata(value);
  // @@protoc_insertion_point(field_set:TST.CellID.packedData)
}

// -------------------------------------------------------------------

// TableSize

// required fixed32 packedData = 1;
inline bool TableSize::_internal_has_packeddata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableSize::has_packeddata() const {
  return _internal_has_packeddata();
}
inline void TableSize::clear_packeddata() {
  _impl_.packeddata_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TableSize::_internal_packeddata() const {
  return _impl_.packeddata_;
}
inline uint32_t TableSize::packeddata() const {
  // @@protoc_insertion_point(field_get:TST.TableSize.packedData)
  return _internal_packeddata();
}
inline void TableSize::_internal_set_packeddata(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.packeddata_ = value;
}
inline void TableSize::set_packeddata(uint32_t value) {
  _internal_set_packeddata(value);
  // @@protoc_insertion_point(field_set:TST.TableSize.packedData)
}

// -------------------------------------------------------------------

// CellRange

// required .TST.CellID origin = 1;
inline bool CellRange::_internal_has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline bool CellRange::has_origin() const {
  return _internal_has_origin();
}
inline void CellRange::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellID& CellRange::_internal_origin() const {
  const ::TST::CellID* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& CellRange::origin() const {
  // @@protoc_insertion_point(field_get:TST.CellRange.origin)
  return _internal_origin();
}
inline void CellRange::unsafe_arena_set_allocated_origin(
    ::TST::CellID* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = origin;
  if (origin) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellRange.origin)
}
inline ::TST::CellID* CellRange::release_origin() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* CellRange::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:TST.CellRange.origin)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::TST::CellID* CellRange::_internal_mutable_origin() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.origin_ = p;
  }
  return _impl_.origin_;
}
inline ::TST::CellID* CellRange::mutable_origin() {
  ::TST::CellID* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:TST.CellRange.origin)
  return _msg;
}
inline void CellRange::set_allocated_origin(::TST::CellID* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:TST.CellRange.origin)
}

// required .TST.TableSize size = 2;
inline bool CellRange::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_ != nullptr);
  return value;
}
inline bool CellRange::has_size() const {
  return _internal_has_size();
}
inline void CellRange::clear_size() {
  if (_impl_.size_ != nullptr) _impl_.size_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::TableSize& CellRange::_internal_size() const {
  const ::TST::TableSize* p = _impl_.size_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TableSize&>(
      ::TST::_TableSize_default_instance_);
}
inline const ::TST::TableSize& CellRange::size() const {
  // @@protoc_insertion_point(field_get:TST.CellRange.size)
  return _internal_size();
}
inline void CellRange::unsafe_arena_set_allocated_size(
    ::TST::TableSize* size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.size_);
  }
  _impl_.size_ = size;
  if (size) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellRange.size)
}
inline ::TST::TableSize* CellRange::release_size() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TableSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TableSize* CellRange::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:TST.CellRange.size)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TableSize* temp = _impl_.size_;
  _impl_.size_ = nullptr;
  return temp;
}
inline ::TST::TableSize* CellRange::_internal_mutable_size() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.size_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TableSize>(GetArenaForAllocation());
    _impl_.size_ = p;
  }
  return _impl_.size_;
}
inline ::TST::TableSize* CellRange::mutable_size() {
  ::TST::TableSize* _msg = _internal_mutable_size();
  // @@protoc_insertion_point(field_mutable:TST.CellRange.size)
  return _msg;
}
inline void CellRange::set_allocated_size(::TST::TableSize* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.size_ = size;
  // @@protoc_insertion_point(field_set_allocated:TST.CellRange.size)
}

// -------------------------------------------------------------------

// TableSelection

// required .TST.CellRange cellRange = 1;
inline bool TableSelection::_internal_has_cellrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cellrange_ != nullptr);
  return value;
}
inline bool TableSelection::has_cellrange() const {
  return _internal_has_cellrange();
}
inline void TableSelection::clear_cellrange() {
  if (_impl_.cellrange_ != nullptr) _impl_.cellrange_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellRange& TableSelection::_internal_cellrange() const {
  const ::TST::CellRange* p = _impl_.cellrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellRange&>(
      ::TST::_CellRange_default_instance_);
}
inline const ::TST::CellRange& TableSelection::cellrange() const {
  // @@protoc_insertion_point(field_get:TST.TableSelection.cellRange)
  return _internal_cellrange();
}
inline void TableSelection::unsafe_arena_set_allocated_cellrange(
    ::TST::CellRange* cellrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cellrange_);
  }
  _impl_.cellrange_ = cellrange;
  if (cellrange) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableSelection.cellRange)
}
inline ::TST::CellRange* TableSelection::release_cellrange() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellRange* temp = _impl_.cellrange_;
  _impl_.cellrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellRange* TableSelection::unsafe_arena_release_cellrange() {
  // @@protoc_insertion_point(field_release:TST.TableSelection.cellRange)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellRange* temp = _impl_.cellrange_;
  _impl_.cellrange_ = nullptr;
  return temp;
}
inline ::TST::CellRange* TableSelection::_internal_mutable_cellrange() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cellrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellRange>(GetArenaForAllocation());
    _impl_.cellrange_ = p;
  }
  return _impl_.cellrange_;
}
inline ::TST::CellRange* TableSelection::mutable_cellrange() {
  ::TST::CellRange* _msg = _internal_mutable_cellrange();
  // @@protoc_insertion_point(field_mutable:TST.TableSelection.cellRange)
  return _msg;
}
inline void TableSelection::set_allocated_cellrange(::TST::CellRange* cellrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cellrange_;
  }
  if (cellrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellrange);
    if (message_arena != submessage_arena) {
      cellrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellrange, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cellrange_ = cellrange;
  // @@protoc_insertion_point(field_set_allocated:TST.TableSelection.cellRange)
}

// required .TST.CellRange extendedCellRange = 2;
inline bool TableSelection::_internal_has_extendedcellrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extendedcellrange_ != nullptr);
  return value;
}
inline bool TableSelection::has_extendedcellrange() const {
  return _internal_has_extendedcellrange();
}
inline void TableSelection::clear_extendedcellrange() {
  if (_impl_.extendedcellrange_ != nullptr) _impl_.extendedcellrange_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::CellRange& TableSelection::_internal_extendedcellrange() const {
  const ::TST::CellRange* p = _impl_.extendedcellrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellRange&>(
      ::TST::_CellRange_default_instance_);
}
inline const ::TST::CellRange& TableSelection::extendedcellrange() const {
  // @@protoc_insertion_point(field_get:TST.TableSelection.extendedCellRange)
  return _internal_extendedcellrange();
}
inline void TableSelection::unsafe_arena_set_allocated_extendedcellrange(
    ::TST::CellRange* extendedcellrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extendedcellrange_);
  }
  _impl_.extendedcellrange_ = extendedcellrange;
  if (extendedcellrange) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableSelection.extendedCellRange)
}
inline ::TST::CellRange* TableSelection::release_extendedcellrange() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellRange* temp = _impl_.extendedcellrange_;
  _impl_.extendedcellrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellRange* TableSelection::unsafe_arena_release_extendedcellrange() {
  // @@protoc_insertion_point(field_release:TST.TableSelection.extendedCellRange)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellRange* temp = _impl_.extendedcellrange_;
  _impl_.extendedcellrange_ = nullptr;
  return temp;
}
inline ::TST::CellRange* TableSelection::_internal_mutable_extendedcellrange() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.extendedcellrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellRange>(GetArenaForAllocation());
    _impl_.extendedcellrange_ = p;
  }
  return _impl_.extendedcellrange_;
}
inline ::TST::CellRange* TableSelection::mutable_extendedcellrange() {
  ::TST::CellRange* _msg = _internal_mutable_extendedcellrange();
  // @@protoc_insertion_point(field_mutable:TST.TableSelection.extendedCellRange)
  return _msg;
}
inline void TableSelection::set_allocated_extendedcellrange(::TST::CellRange* extendedcellrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extendedcellrange_;
  }
  if (extendedcellrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extendedcellrange);
    if (message_arena != submessage_arena) {
      extendedcellrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extendedcellrange, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extendedcellrange_ = extendedcellrange;
  // @@protoc_insertion_point(field_set_allocated:TST.TableSelection.extendedCellRange)
}

// required bool extendedCellRangeValid = 3;
inline bool TableSelection::_internal_has_extendedcellrangevalid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableSelection::has_extendedcellrangevalid() const {
  return _internal_has_extendedcellrangevalid();
}
inline void TableSelection::clear_extendedcellrangevalid() {
  _impl_.extendedcellrangevalid_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TableSelection::_internal_extendedcellrangevalid() const {
  return _impl_.extendedcellrangevalid_;
}
inline bool TableSelection::extendedcellrangevalid() const {
  // @@protoc_insertion_point(field_get:TST.TableSelection.extendedCellRangeValid)
  return _internal_extendedcellrangevalid();
}
inline void TableSelection::_internal_set_extendedcellrangevalid(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.extendedcellrangevalid_ = value;
}
inline void TableSelection::set_extendedcellrangevalid(bool value) {
  _internal_set_extendedcellrangevalid(value);
  // @@protoc_insertion_point(field_set:TST.TableSelection.extendedCellRangeValid)
}

// required .TST.SelectionTypeArchive selection_type = 4;
inline bool TableSelection::_internal_has_selection_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TableSelection::has_selection_type() const {
  return _internal_has_selection_type();
}
inline void TableSelection::clear_selection_type() {
  _impl_.selection_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TST::SelectionTypeArchive TableSelection::_internal_selection_type() const {
  return static_cast< ::TST::SelectionTypeArchive >(_impl_.selection_type_);
}
inline ::TST::SelectionTypeArchive TableSelection::selection_type() const {
  // @@protoc_insertion_point(field_get:TST.TableSelection.selection_type)
  return _internal_selection_type();
}
inline void TableSelection::_internal_set_selection_type(::TST::SelectionTypeArchive value) {
  assert(::TST::SelectionTypeArchive_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_type_ = value;
}
inline void TableSelection::set_selection_type(::TST::SelectionTypeArchive value) {
  _internal_set_selection_type(value);
  // @@protoc_insertion_point(field_set:TST.TableSelection.selection_type)
}

// -------------------------------------------------------------------

// TileRowInfo

// optional uint32 storage_version = 5;
inline bool TileRowInfo::_internal_has_storage_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TileRowInfo::has_storage_version() const {
  return _internal_has_storage_version();
}
inline void TileRowInfo::clear_storage_version() {
  _impl_.storage_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t TileRowInfo::_internal_storage_version() const {
  return _impl_.storage_version_;
}
inline uint32_t TileRowInfo::storage_version() const {
  // @@protoc_insertion_point(field_get:TST.TileRowInfo.storage_version)
  return _internal_storage_version();
}
inline void TileRowInfo::_internal_set_storage_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.storage_version_ = value;
}
inline void TileRowInfo::set_storage_version(uint32_t value) {
  _internal_set_storage_version(value);
  // @@protoc_insertion_point(field_set:TST.TileRowInfo.storage_version)
}

// required uint32 tileRowIndex = 1;
inline bool TileRowInfo::_internal_has_tilerowindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TileRowInfo::has_tilerowindex() const {
  return _internal_has_tilerowindex();
}
inline void TileRowInfo::clear_tilerowindex() {
  _impl_.tilerowindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TileRowInfo::_internal_tilerowindex() const {
  return _impl_.tilerowindex_;
}
inline uint32_t TileRowInfo::tilerowindex() const {
  // @@protoc_insertion_point(field_get:TST.TileRowInfo.tileRowIndex)
  return _internal_tilerowindex();
}
inline void TileRowInfo::_internal_set_tilerowindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tilerowindex_ = value;
}
inline void TileRowInfo::set_tilerowindex(uint32_t value) {
  _internal_set_tilerowindex(value);
  // @@protoc_insertion_point(field_set:TST.TileRowInfo.tileRowIndex)
}

// required uint32 cellCount = 2;
inline bool TileRowInfo::_internal_has_cellcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TileRowInfo::has_cellcount() const {
  return _internal_has_cellcount();
}
inline void TileRowInfo::clear_cellcount() {
  _impl_.cellcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t TileRowInfo::_internal_cellcount() const {
  return _impl_.cellcount_;
}
inline uint32_t TileRowInfo::cellcount() const {
  // @@protoc_insertion_point(field_get:TST.TileRowInfo.cellCount)
  return _internal_cellcount();
}
inline void TileRowInfo::_internal_set_cellcount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.cellcount_ = value;
}
inline void TileRowInfo::set_cellcount(uint32_t value) {
  _internal_set_cellcount(value);
  // @@protoc_insertion_point(field_set:TST.TileRowInfo.cellCount)
}

// required bytes cellStorageBuffer = 3;
inline bool TileRowInfo::_internal_has_cellstoragebuffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TileRowInfo::has_cellstoragebuffer() const {
  return _internal_has_cellstoragebuffer();
}
inline void TileRowInfo::clear_cellstoragebuffer() {
  _impl_.cellstoragebuffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TileRowInfo::cellstoragebuffer() const {
  // @@protoc_insertion_point(field_get:TST.TileRowInfo.cellStorageBuffer)
  return _internal_cellstoragebuffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TileRowInfo::set_cellstoragebuffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.cellstoragebuffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TileRowInfo.cellStorageBuffer)
}
inline std::string* TileRowInfo::mutable_cellstoragebuffer() {
  std::string* _s = _internal_mutable_cellstoragebuffer();
  // @@protoc_insertion_point(field_mutable:TST.TileRowInfo.cellStorageBuffer)
  return _s;
}
inline const std::string& TileRowInfo::_internal_cellstoragebuffer() const {
  return _impl_.cellstoragebuffer_.Get();
}
inline void TileRowInfo::_internal_set_cellstoragebuffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cellstoragebuffer_.Set(value, GetArenaForAllocation());
}
inline std::string* TileRowInfo::_internal_mutable_cellstoragebuffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cellstoragebuffer_.Mutable(GetArenaForAllocation());
}
inline std::string* TileRowInfo::release_cellstoragebuffer() {
  // @@protoc_insertion_point(field_release:TST.TileRowInfo.cellStorageBuffer)
  if (!_internal_has_cellstoragebuffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.cellstoragebuffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cellstoragebuffer_.IsDefault()) {
    _impl_.cellstoragebuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TileRowInfo::set_allocated_cellstoragebuffer(std::string* cellstoragebuffer) {
  if (cellstoragebuffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cellstoragebuffer_.SetAllocated(cellstoragebuffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cellstoragebuffer_.IsDefault()) {
    _impl_.cellstoragebuffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TileRowInfo.cellStorageBuffer)
}

// required bytes cellOffsets = 4;
inline bool TileRowInfo::_internal_has_celloffsets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TileRowInfo::has_celloffsets() const {
  return _internal_has_celloffsets();
}
inline void TileRowInfo::clear_celloffsets() {
  _impl_.celloffsets_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TileRowInfo::celloffsets() const {
  // @@protoc_insertion_point(field_get:TST.TileRowInfo.cellOffsets)
  return _internal_celloffsets();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TileRowInfo::set_celloffsets(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.celloffsets_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TileRowInfo.cellOffsets)
}
inline std::string* TileRowInfo::mutable_celloffsets() {
  std::string* _s = _internal_mutable_celloffsets();
  // @@protoc_insertion_point(field_mutable:TST.TileRowInfo.cellOffsets)
  return _s;
}
inline const std::string& TileRowInfo::_internal_celloffsets() const {
  return _impl_.celloffsets_.Get();
}
inline void TileRowInfo::_internal_set_celloffsets(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.celloffsets_.Set(value, GetArenaForAllocation());
}
inline std::string* TileRowInfo::_internal_mutable_celloffsets() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.celloffsets_.Mutable(GetArenaForAllocation());
}
inline std::string* TileRowInfo::release_celloffsets() {
  // @@protoc_insertion_point(field_release:TST.TileRowInfo.cellOffsets)
  if (!_internal_has_celloffsets()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.celloffsets_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.celloffsets_.IsDefault()) {
    _impl_.celloffsets_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TileRowInfo::set_allocated_celloffsets(std::string* celloffsets) {
  if (celloffsets != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.celloffsets_.SetAllocated(celloffsets, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.celloffsets_.IsDefault()) {
    _impl_.celloffsets_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TileRowInfo.cellOffsets)
}

// -------------------------------------------------------------------

// Tile

// required uint32 maxColumn = 1;
inline bool Tile::_internal_has_maxcolumn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Tile::has_maxcolumn() const {
  return _internal_has_maxcolumn();
}
inline void Tile::clear_maxcolumn() {
  _impl_.maxcolumn_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Tile::_internal_maxcolumn() const {
  return _impl_.maxcolumn_;
}
inline uint32_t Tile::maxcolumn() const {
  // @@protoc_insertion_point(field_get:TST.Tile.maxColumn)
  return _internal_maxcolumn();
}
inline void Tile::_internal_set_maxcolumn(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.maxcolumn_ = value;
}
inline void Tile::set_maxcolumn(uint32_t value) {
  _internal_set_maxcolumn(value);
  // @@protoc_insertion_point(field_set:TST.Tile.maxColumn)
}

// required uint32 maxRow = 2;
inline bool Tile::_internal_has_maxrow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Tile::has_maxrow() const {
  return _internal_has_maxrow();
}
inline void Tile::clear_maxrow() {
  _impl_.maxrow_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Tile::_internal_maxrow() const {
  return _impl_.maxrow_;
}
inline uint32_t Tile::maxrow() const {
  // @@protoc_insertion_point(field_get:TST.Tile.maxRow)
  return _internal_maxrow();
}
inline void Tile::_internal_set_maxrow(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maxrow_ = value;
}
inline void Tile::set_maxrow(uint32_t value) {
  _internal_set_maxrow(value);
  // @@protoc_insertion_point(field_set:TST.Tile.maxRow)
}

// required uint32 numCells = 3;
inline bool Tile::_internal_has_numcells() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Tile::has_numcells() const {
  return _internal_has_numcells();
}
inline void Tile::clear_numcells() {
  _impl_.numcells_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Tile::_internal_numcells() const {
  return _impl_.numcells_;
}
inline uint32_t Tile::numcells() const {
  // @@protoc_insertion_point(field_get:TST.Tile.numCells)
  return _internal_numcells();
}
inline void Tile::_internal_set_numcells(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.numcells_ = value;
}
inline void Tile::set_numcells(uint32_t value) {
  _internal_set_numcells(value);
  // @@protoc_insertion_point(field_set:TST.Tile.numCells)
}

// required uint32 numrows = 4;
inline bool Tile::_internal_has_numrows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Tile::has_numrows() const {
  return _internal_has_numrows();
}
inline void Tile::clear_numrows() {
  _impl_.numrows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Tile::_internal_numrows() const {
  return _impl_.numrows_;
}
inline uint32_t Tile::numrows() const {
  // @@protoc_insertion_point(field_get:TST.Tile.numrows)
  return _internal_numrows();
}
inline void Tile::_internal_set_numrows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.numrows_ = value;
}
inline void Tile::set_numrows(uint32_t value) {
  _internal_set_numrows(value);
  // @@protoc_insertion_point(field_set:TST.Tile.numrows)
}

// optional uint32 storage_version = 6;
inline bool Tile::_internal_has_storage_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Tile::has_storage_version() const {
  return _internal_has_storage_version();
}
inline void Tile::clear_storage_version() {
  _impl_.storage_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Tile::_internal_storage_version() const {
  return _impl_.storage_version_;
}
inline uint32_t Tile::storage_version() const {
  // @@protoc_insertion_point(field_get:TST.Tile.storage_version)
  return _internal_storage_version();
}
inline void Tile::_internal_set_storage_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.storage_version_ = value;
}
inline void Tile::set_storage_version(uint32_t value) {
  _internal_set_storage_version(value);
  // @@protoc_insertion_point(field_set:TST.Tile.storage_version)
}

// repeated .TST.TileRowInfo rowInfos = 5;
inline int Tile::_internal_rowinfos_size() const {
  return _impl_.rowinfos_.size();
}
inline int Tile::rowinfos_size() const {
  return _internal_rowinfos_size();
}
inline void Tile::clear_rowinfos() {
  _impl_.rowinfos_.Clear();
}
inline ::TST::TileRowInfo* Tile::mutable_rowinfos(int index) {
  // @@protoc_insertion_point(field_mutable:TST.Tile.rowInfos)
  return _impl_.rowinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileRowInfo >*
Tile::mutable_rowinfos() {
  // @@protoc_insertion_point(field_mutable_list:TST.Tile.rowInfos)
  return &_impl_.rowinfos_;
}
inline const ::TST::TileRowInfo& Tile::_internal_rowinfos(int index) const {
  return _impl_.rowinfos_.Get(index);
}
inline const ::TST::TileRowInfo& Tile::rowinfos(int index) const {
  // @@protoc_insertion_point(field_get:TST.Tile.rowInfos)
  return _internal_rowinfos(index);
}
inline ::TST::TileRowInfo* Tile::_internal_add_rowinfos() {
  return _impl_.rowinfos_.Add();
}
inline ::TST::TileRowInfo* Tile::add_rowinfos() {
  ::TST::TileRowInfo* _add = _internal_add_rowinfos();
  // @@protoc_insertion_point(field_add:TST.Tile.rowInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileRowInfo >&
Tile::rowinfos() const {
  // @@protoc_insertion_point(field_list:TST.Tile.rowInfos)
  return _impl_.rowinfos_;
}

// -------------------------------------------------------------------

// TileStorage_Tile

// required uint32 tileid = 1;
inline bool TileStorage_Tile::_internal_has_tileid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TileStorage_Tile::has_tileid() const {
  return _internal_has_tileid();
}
inline void TileStorage_Tile::clear_tileid() {
  _impl_.tileid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TileStorage_Tile::_internal_tileid() const {
  return _impl_.tileid_;
}
inline uint32_t TileStorage_Tile::tileid() const {
  // @@protoc_insertion_point(field_get:TST.TileStorage.Tile.tileid)
  return _internal_tileid();
}
inline void TileStorage_Tile::_internal_set_tileid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.tileid_ = value;
}
inline void TileStorage_Tile::set_tileid(uint32_t value) {
  _internal_set_tileid(value);
  // @@protoc_insertion_point(field_set:TST.TileStorage.Tile.tileid)
}

// required .TSP.Reference tile = 2;
inline bool TileStorage_Tile::_internal_has_tile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tile_ != nullptr);
  return value;
}
inline bool TileStorage_Tile::has_tile() const {
  return _internal_has_tile();
}
inline const ::TSP::Reference& TileStorage_Tile::_internal_tile() const {
  const ::TSP::Reference* p = _impl_.tile_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TileStorage_Tile::tile() const {
  // @@protoc_insertion_point(field_get:TST.TileStorage.Tile.tile)
  return _internal_tile();
}
inline void TileStorage_Tile::unsafe_arena_set_allocated_tile(
    ::TSP::Reference* tile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tile_);
  }
  _impl_.tile_ = tile;
  if (tile) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TileStorage.Tile.tile)
}
inline ::TSP::Reference* TileStorage_Tile::release_tile() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.tile_;
  _impl_.tile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TileStorage_Tile::unsafe_arena_release_tile() {
  // @@protoc_insertion_point(field_release:TST.TileStorage.Tile.tile)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.tile_;
  _impl_.tile_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TileStorage_Tile::_internal_mutable_tile() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tile_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.tile_ = p;
  }
  return _impl_.tile_;
}
inline ::TSP::Reference* TileStorage_Tile::mutable_tile() {
  ::TSP::Reference* _msg = _internal_mutable_tile();
  // @@protoc_insertion_point(field_mutable:TST.TileStorage.Tile.tile)
  return _msg;
}
inline void TileStorage_Tile::set_allocated_tile(::TSP::Reference* tile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tile_);
  }
  if (tile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tile));
    if (message_arena != submessage_arena) {
      tile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tile_ = tile;
  // @@protoc_insertion_point(field_set_allocated:TST.TileStorage.Tile.tile)
}

// -------------------------------------------------------------------

// TileStorage

// repeated .TST.TileStorage.Tile tiles = 1;
inline int TileStorage::_internal_tiles_size() const {
  return _impl_.tiles_.size();
}
inline int TileStorage::tiles_size() const {
  return _internal_tiles_size();
}
inline void TileStorage::clear_tiles() {
  _impl_.tiles_.Clear();
}
inline ::TST::TileStorage_Tile* TileStorage::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:TST.TileStorage.tiles)
  return _impl_.tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileStorage_Tile >*
TileStorage::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:TST.TileStorage.tiles)
  return &_impl_.tiles_;
}
inline const ::TST::TileStorage_Tile& TileStorage::_internal_tiles(int index) const {
  return _impl_.tiles_.Get(index);
}
inline const ::TST::TileStorage_Tile& TileStorage::tiles(int index) const {
  // @@protoc_insertion_point(field_get:TST.TileStorage.tiles)
  return _internal_tiles(index);
}
inline ::TST::TileStorage_Tile* TileStorage::_internal_add_tiles() {
  return _impl_.tiles_.Add();
}
inline ::TST::TileStorage_Tile* TileStorage::add_tiles() {
  ::TST::TileStorage_Tile* _add = _internal_add_tiles();
  // @@protoc_insertion_point(field_add:TST.TileStorage.tiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TileStorage_Tile >&
TileStorage::tiles() const {
  // @@protoc_insertion_point(field_list:TST.TileStorage.tiles)
  return _impl_.tiles_;
}

// -------------------------------------------------------------------

// PopUpMenuModel_CellValue

// required .TST.PopUpMenuModel.CellValueType cell_value_type = 1;
inline bool PopUpMenuModel_CellValue::_internal_has_cell_value_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PopUpMenuModel_CellValue::has_cell_value_type() const {
  return _internal_has_cell_value_type();
}
inline void PopUpMenuModel_CellValue::clear_cell_value_type() {
  _impl_.cell_value_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::TST::PopUpMenuModel_CellValueType PopUpMenuModel_CellValue::_internal_cell_value_type() const {
  return static_cast< ::TST::PopUpMenuModel_CellValueType >(_impl_.cell_value_type_);
}
inline ::TST::PopUpMenuModel_CellValueType PopUpMenuModel_CellValue::cell_value_type() const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.CellValue.cell_value_type)
  return _internal_cell_value_type();
}
inline void PopUpMenuModel_CellValue::_internal_set_cell_value_type(::TST::PopUpMenuModel_CellValueType value) {
  assert(::TST::PopUpMenuModel_CellValueType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.cell_value_type_ = value;
}
inline void PopUpMenuModel_CellValue::set_cell_value_type(::TST::PopUpMenuModel_CellValueType value) {
  _internal_set_cell_value_type(value);
  // @@protoc_insertion_point(field_set:TST.PopUpMenuModel.CellValue.cell_value_type)
}

// optional .TSCE.BooleanCellValueArchive boolean_value = 2;
inline bool PopUpMenuModel_CellValue::_internal_has_boolean_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.boolean_value_ != nullptr);
  return value;
}
inline bool PopUpMenuModel_CellValue::has_boolean_value() const {
  return _internal_has_boolean_value();
}
inline const ::TSCE::BooleanCellValueArchive& PopUpMenuModel_CellValue::_internal_boolean_value() const {
  const ::TSCE::BooleanCellValueArchive* p = _impl_.boolean_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::BooleanCellValueArchive&>(
      ::TSCE::_BooleanCellValueArchive_default_instance_);
}
inline const ::TSCE::BooleanCellValueArchive& PopUpMenuModel_CellValue::boolean_value() const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.CellValue.boolean_value)
  return _internal_boolean_value();
}
inline void PopUpMenuModel_CellValue::unsafe_arena_set_allocated_boolean_value(
    ::TSCE::BooleanCellValueArchive* boolean_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boolean_value_);
  }
  _impl_.boolean_value_ = boolean_value;
  if (boolean_value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PopUpMenuModel.CellValue.boolean_value)
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::release_boolean_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::BooleanCellValueArchive* temp = _impl_.boolean_value_;
  _impl_.boolean_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::unsafe_arena_release_boolean_value() {
  // @@protoc_insertion_point(field_release:TST.PopUpMenuModel.CellValue.boolean_value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::BooleanCellValueArchive* temp = _impl_.boolean_value_;
  _impl_.boolean_value_ = nullptr;
  return temp;
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::_internal_mutable_boolean_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.boolean_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::BooleanCellValueArchive>(GetArenaForAllocation());
    _impl_.boolean_value_ = p;
  }
  return _impl_.boolean_value_;
}
inline ::TSCE::BooleanCellValueArchive* PopUpMenuModel_CellValue::mutable_boolean_value() {
  ::TSCE::BooleanCellValueArchive* _msg = _internal_mutable_boolean_value();
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.CellValue.boolean_value)
  return _msg;
}
inline void PopUpMenuModel_CellValue::set_allocated_boolean_value(::TSCE::BooleanCellValueArchive* boolean_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boolean_value_);
  }
  if (boolean_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boolean_value));
    if (message_arena != submessage_arena) {
      boolean_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolean_value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.boolean_value_ = boolean_value;
  // @@protoc_insertion_point(field_set_allocated:TST.PopUpMenuModel.CellValue.boolean_value)
}

// optional .TSCE.DateCellValueArchive date_value = 3;
inline bool PopUpMenuModel_CellValue::_internal_has_date_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_value_ != nullptr);
  return value;
}
inline bool PopUpMenuModel_CellValue::has_date_value() const {
  return _internal_has_date_value();
}
inline const ::TSCE::DateCellValueArchive& PopUpMenuModel_CellValue::_internal_date_value() const {
  const ::TSCE::DateCellValueArchive* p = _impl_.date_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::DateCellValueArchive&>(
      ::TSCE::_DateCellValueArchive_default_instance_);
}
inline const ::TSCE::DateCellValueArchive& PopUpMenuModel_CellValue::date_value() const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.CellValue.date_value)
  return _internal_date_value();
}
inline void PopUpMenuModel_CellValue::unsafe_arena_set_allocated_date_value(
    ::TSCE::DateCellValueArchive* date_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_value_);
  }
  _impl_.date_value_ = date_value;
  if (date_value) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PopUpMenuModel.CellValue.date_value)
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::release_date_value() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSCE::DateCellValueArchive* temp = _impl_.date_value_;
  _impl_.date_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::unsafe_arena_release_date_value() {
  // @@protoc_insertion_point(field_release:TST.PopUpMenuModel.CellValue.date_value)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSCE::DateCellValueArchive* temp = _impl_.date_value_;
  _impl_.date_value_ = nullptr;
  return temp;
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::_internal_mutable_date_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.date_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::DateCellValueArchive>(GetArenaForAllocation());
    _impl_.date_value_ = p;
  }
  return _impl_.date_value_;
}
inline ::TSCE::DateCellValueArchive* PopUpMenuModel_CellValue::mutable_date_value() {
  ::TSCE::DateCellValueArchive* _msg = _internal_mutable_date_value();
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.CellValue.date_value)
  return _msg;
}
inline void PopUpMenuModel_CellValue::set_allocated_date_value(::TSCE::DateCellValueArchive* date_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_value_);
  }
  if (date_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_value));
    if (message_arena != submessage_arena) {
      date_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.date_value_ = date_value;
  // @@protoc_insertion_point(field_set_allocated:TST.PopUpMenuModel.CellValue.date_value)
}

// optional .TSCE.NumberCellValueArchive number_value = 4;
inline bool PopUpMenuModel_CellValue::_internal_has_number_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.number_value_ != nullptr);
  return value;
}
inline bool PopUpMenuModel_CellValue::has_number_value() const {
  return _internal_has_number_value();
}
inline const ::TSCE::NumberCellValueArchive& PopUpMenuModel_CellValue::_internal_number_value() const {
  const ::TSCE::NumberCellValueArchive* p = _impl_.number_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::NumberCellValueArchive&>(
      ::TSCE::_NumberCellValueArchive_default_instance_);
}
inline const ::TSCE::NumberCellValueArchive& PopUpMenuModel_CellValue::number_value() const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.CellValue.number_value)
  return _internal_number_value();
}
inline void PopUpMenuModel_CellValue::unsafe_arena_set_allocated_number_value(
    ::TSCE::NumberCellValueArchive* number_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.number_value_);
  }
  _impl_.number_value_ = number_value;
  if (number_value) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PopUpMenuModel.CellValue.number_value)
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::release_number_value() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::NumberCellValueArchive* temp = _impl_.number_value_;
  _impl_.number_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::unsafe_arena_release_number_value() {
  // @@protoc_insertion_point(field_release:TST.PopUpMenuModel.CellValue.number_value)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::NumberCellValueArchive* temp = _impl_.number_value_;
  _impl_.number_value_ = nullptr;
  return temp;
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::_internal_mutable_number_value() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.number_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::NumberCellValueArchive>(GetArenaForAllocation());
    _impl_.number_value_ = p;
  }
  return _impl_.number_value_;
}
inline ::TSCE::NumberCellValueArchive* PopUpMenuModel_CellValue::mutable_number_value() {
  ::TSCE::NumberCellValueArchive* _msg = _internal_mutable_number_value();
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.CellValue.number_value)
  return _msg;
}
inline void PopUpMenuModel_CellValue::set_allocated_number_value(::TSCE::NumberCellValueArchive* number_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.number_value_);
  }
  if (number_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(number_value));
    if (message_arena != submessage_arena) {
      number_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, number_value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.number_value_ = number_value;
  // @@protoc_insertion_point(field_set_allocated:TST.PopUpMenuModel.CellValue.number_value)
}

// optional .TSCE.StringCellValueArchive string_value = 5;
inline bool PopUpMenuModel_CellValue::_internal_has_string_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.string_value_ != nullptr);
  return value;
}
inline bool PopUpMenuModel_CellValue::has_string_value() const {
  return _internal_has_string_value();
}
inline const ::TSCE::StringCellValueArchive& PopUpMenuModel_CellValue::_internal_string_value() const {
  const ::TSCE::StringCellValueArchive* p = _impl_.string_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::StringCellValueArchive&>(
      ::TSCE::_StringCellValueArchive_default_instance_);
}
inline const ::TSCE::StringCellValueArchive& PopUpMenuModel_CellValue::string_value() const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.CellValue.string_value)
  return _internal_string_value();
}
inline void PopUpMenuModel_CellValue::unsafe_arena_set_allocated_string_value(
    ::TSCE::StringCellValueArchive* string_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.string_value_);
  }
  _impl_.string_value_ = string_value;
  if (string_value) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PopUpMenuModel.CellValue.string_value)
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::release_string_value() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSCE::StringCellValueArchive* temp = _impl_.string_value_;
  _impl_.string_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::unsafe_arena_release_string_value() {
  // @@protoc_insertion_point(field_release:TST.PopUpMenuModel.CellValue.string_value)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSCE::StringCellValueArchive* temp = _impl_.string_value_;
  _impl_.string_value_ = nullptr;
  return temp;
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::_internal_mutable_string_value() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.string_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::StringCellValueArchive>(GetArenaForAllocation());
    _impl_.string_value_ = p;
  }
  return _impl_.string_value_;
}
inline ::TSCE::StringCellValueArchive* PopUpMenuModel_CellValue::mutable_string_value() {
  ::TSCE::StringCellValueArchive* _msg = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.CellValue.string_value)
  return _msg;
}
inline void PopUpMenuModel_CellValue::set_allocated_string_value(::TSCE::StringCellValueArchive* string_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.string_value_);
  }
  if (string_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(string_value));
    if (message_arena != submessage_arena) {
      string_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string_value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.string_value_ = string_value;
  // @@protoc_insertion_point(field_set_allocated:TST.PopUpMenuModel.CellValue.string_value)
}

// -------------------------------------------------------------------

// PopUpMenuModel

// repeated .TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];
inline int PopUpMenuModel::_internal_item_size() const {
  return _impl_.item_.size();
}
inline int PopUpMenuModel::item_size() const {
  return _internal_item_size();
}
inline void PopUpMenuModel::clear_item() {
  _impl_.item_.Clear();
}
inline ::TST::PopUpMenuModel_CellValue* PopUpMenuModel::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.item)
  return _impl_.item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >*
PopUpMenuModel::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:TST.PopUpMenuModel.item)
  return &_impl_.item_;
}
inline const ::TST::PopUpMenuModel_CellValue& PopUpMenuModel::_internal_item(int index) const {
  return _impl_.item_.Get(index);
}
inline const ::TST::PopUpMenuModel_CellValue& PopUpMenuModel::item(int index) const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.item)
  return _internal_item(index);
}
inline ::TST::PopUpMenuModel_CellValue* PopUpMenuModel::_internal_add_item() {
  return _impl_.item_.Add();
}
inline ::TST::PopUpMenuModel_CellValue* PopUpMenuModel::add_item() {
  ::TST::PopUpMenuModel_CellValue* _add = _internal_add_item();
  // @@protoc_insertion_point(field_add:TST.PopUpMenuModel.item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::PopUpMenuModel_CellValue >&
PopUpMenuModel::item() const {
  // @@protoc_insertion_point(field_list:TST.PopUpMenuModel.item)
  return _impl_.item_;
}

// repeated .TSCE.CellValueArchive tsce_item = 2;
inline int PopUpMenuModel::_internal_tsce_item_size() const {
  return _impl_.tsce_item_.size();
}
inline int PopUpMenuModel::tsce_item_size() const {
  return _internal_tsce_item_size();
}
inline ::TSCE::CellValueArchive* PopUpMenuModel::mutable_tsce_item(int index) {
  // @@protoc_insertion_point(field_mutable:TST.PopUpMenuModel.tsce_item)
  return _impl_.tsce_item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >*
PopUpMenuModel::mutable_tsce_item() {
  // @@protoc_insertion_point(field_mutable_list:TST.PopUpMenuModel.tsce_item)
  return &_impl_.tsce_item_;
}
inline const ::TSCE::CellValueArchive& PopUpMenuModel::_internal_tsce_item(int index) const {
  return _impl_.tsce_item_.Get(index);
}
inline const ::TSCE::CellValueArchive& PopUpMenuModel::tsce_item(int index) const {
  // @@protoc_insertion_point(field_get:TST.PopUpMenuModel.tsce_item)
  return _internal_tsce_item(index);
}
inline ::TSCE::CellValueArchive* PopUpMenuModel::_internal_add_tsce_item() {
  return _impl_.tsce_item_.Add();
}
inline ::TSCE::CellValueArchive* PopUpMenuModel::add_tsce_item() {
  ::TSCE::CellValueArchive* _add = _internal_add_tsce_item();
  // @@protoc_insertion_point(field_add:TST.PopUpMenuModel.tsce_item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >&
PopUpMenuModel::tsce_item() const {
  // @@protoc_insertion_point(field_list:TST.PopUpMenuModel.tsce_item)
  return _impl_.tsce_item_;
}

// -------------------------------------------------------------------

// TableDataList_ListEntry

// required uint32 key = 1;
inline bool TableDataList_ListEntry::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TableDataList_ListEntry::has_key() const {
  return _internal_has_key();
}
inline void TableDataList_ListEntry::clear_key() {
  _impl_.key_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t TableDataList_ListEntry::_internal_key() const {
  return _impl_.key_;
}
inline uint32_t TableDataList_ListEntry::key() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.key)
  return _internal_key();
}
inline void TableDataList_ListEntry::_internal_set_key(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.key_ = value;
}
inline void TableDataList_ListEntry::set_key(uint32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:TST.TableDataList.ListEntry.key)
}

// required uint32 refcount = 2;
inline bool TableDataList_ListEntry::_internal_has_refcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TableDataList_ListEntry::has_refcount() const {
  return _internal_has_refcount();
}
inline void TableDataList_ListEntry::clear_refcount() {
  _impl_.refcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t TableDataList_ListEntry::_internal_refcount() const {
  return _impl_.refcount_;
}
inline uint32_t TableDataList_ListEntry::refcount() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.refcount)
  return _internal_refcount();
}
inline void TableDataList_ListEntry::_internal_set_refcount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.refcount_ = value;
}
inline void TableDataList_ListEntry::set_refcount(uint32_t value) {
  _internal_set_refcount(value);
  // @@protoc_insertion_point(field_set:TST.TableDataList.ListEntry.refcount)
}

// optional string string = 3;
inline bool TableDataList_ListEntry::_internal_has_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableDataList_ListEntry::has_string() const {
  return _internal_has_string();
}
inline void TableDataList_ListEntry::clear_string() {
  _impl_.string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableDataList_ListEntry::string() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableDataList_ListEntry::set_string(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TableDataList.ListEntry.string)
}
inline std::string* TableDataList_ListEntry::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.string)
  return _s;
}
inline const std::string& TableDataList_ListEntry::_internal_string() const {
  return _impl_.string_.Get();
}
inline void TableDataList_ListEntry::_internal_set_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* TableDataList_ListEntry::_internal_mutable_string() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.string_.Mutable(GetArenaForAllocation());
}
inline std::string* TableDataList_ListEntry::release_string() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.string)
  if (!_internal_has_string()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_.IsDefault()) {
    _impl_.string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableDataList_ListEntry::set_allocated_string(std::string* string) {
  if (string != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.string_.SetAllocated(string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_.IsDefault()) {
    _impl_.string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.string)
}

// optional .TSP.Reference reference = 4;
inline bool TableDataList_ListEntry::_internal_has_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reference_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_reference() const {
  return _internal_has_reference();
}
inline const ::TSP::Reference& TableDataList_ListEntry::_internal_reference() const {
  const ::TSP::Reference* p = _impl_.reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableDataList_ListEntry::reference() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.reference)
  return _internal_reference();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_reference(
    ::TSP::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reference_);
  }
  _impl_.reference_ = reference;
  if (reference) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.reference)
}
inline ::TSP::Reference* TableDataList_ListEntry::release_reference() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.reference_;
  _impl_.reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.reference)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.reference_;
  _impl_.reference_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::_internal_mutable_reference() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.reference_ = p;
  }
  return _impl_.reference_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_reference() {
  ::TSP::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.reference)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_reference(::TSP::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.reference_);
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference));
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.reference)
}

// optional .TSCE.FormulaArchive formula = 5;
inline bool TableDataList_ListEntry::_internal_has_formula() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formula_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_formula() const {
  return _internal_has_formula();
}
inline const ::TSCE::FormulaArchive& TableDataList_ListEntry::_internal_formula() const {
  const ::TSCE::FormulaArchive* p = _impl_.formula_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::FormulaArchive&>(
      ::TSCE::_FormulaArchive_default_instance_);
}
inline const ::TSCE::FormulaArchive& TableDataList_ListEntry::formula() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.formula)
  return _internal_formula();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_formula(
    ::TSCE::FormulaArchive* formula) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  _impl_.formula_ = formula;
  if (formula) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.formula)
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::release_formula() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.formula)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
  return temp;
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::_internal_mutable_formula() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.formula_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::FormulaArchive>(GetArenaForAllocation());
    _impl_.formula_ = p;
  }
  return _impl_.formula_;
}
inline ::TSCE::FormulaArchive* TableDataList_ListEntry::mutable_formula() {
  ::TSCE::FormulaArchive* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.formula)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  if (formula) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formula));
    if (message_arena != submessage_arena) {
      formula = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formula, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.formula_ = formula;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.formula)
}

// optional .TSK.FormatStructArchive format = 6;
inline bool TableDataList_ListEntry::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.format_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_format() const {
  return _internal_has_format();
}
inline const ::TSK::FormatStructArchive& TableDataList_ListEntry::_internal_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& TableDataList_ListEntry::format() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.format)
  return _internal_format();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_format(
    ::TSK::FormatStructArchive* format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.format_);
  }
  _impl_.format_ = format;
  if (format) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.format)
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::release_format() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSK::FormatStructArchive* temp = _impl_.format_;
  _impl_.format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::unsafe_arena_release_format() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.format)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSK::FormatStructArchive* temp = _impl_.format_;
  _impl_.format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::_internal_mutable_format() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.format_ = p;
  }
  return _impl_.format_;
}
inline ::TSK::FormatStructArchive* TableDataList_ListEntry::mutable_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.format)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_format(::TSK::FormatStructArchive* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.format_);
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(format));
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.format_ = format;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.format)
}

// optional .TST.CellRange region = 7;
inline bool TableDataList_ListEntry::_internal_has_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.region_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_region() const {
  return _internal_has_region();
}
inline void TableDataList_ListEntry::clear_region() {
  if (_impl_.region_ != nullptr) _impl_.region_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TST::CellRange& TableDataList_ListEntry::_internal_region() const {
  const ::TST::CellRange* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellRange&>(
      ::TST::_CellRange_default_instance_);
}
inline const ::TST::CellRange& TableDataList_ListEntry::region() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.region)
  return _internal_region();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_region(
    ::TST::CellRange* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = region;
  if (region) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.region)
}
inline ::TST::CellRange* TableDataList_ListEntry::release_region() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::CellRange* temp = _impl_.region_;
  _impl_.region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellRange* TableDataList_ListEntry::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.region)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::CellRange* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::TST::CellRange* TableDataList_ListEntry::_internal_mutable_region() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.region_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellRange>(GetArenaForAllocation());
    _impl_.region_ = p;
  }
  return _impl_.region_;
}
inline ::TST::CellRange* TableDataList_ListEntry::mutable_region() {
  ::TST::CellRange* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.region)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_region(::TST::CellRange* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.region_ = region;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.region)
}

// optional .TSK.CustomFormatArchive custom_format = 8;
inline bool TableDataList_ListEntry::_internal_has_custom_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.custom_format_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_custom_format() const {
  return _internal_has_custom_format();
}
inline const ::TSK::CustomFormatArchive& TableDataList_ListEntry::_internal_custom_format() const {
  const ::TSK::CustomFormatArchive* p = _impl_.custom_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::CustomFormatArchive&>(
      ::TSK::_CustomFormatArchive_default_instance_);
}
inline const ::TSK::CustomFormatArchive& TableDataList_ListEntry::custom_format() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.custom_format)
  return _internal_custom_format();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_custom_format(
    ::TSK::CustomFormatArchive* custom_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_format_);
  }
  _impl_.custom_format_ = custom_format;
  if (custom_format) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.custom_format)
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::release_custom_format() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSK::CustomFormatArchive* temp = _impl_.custom_format_;
  _impl_.custom_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::unsafe_arena_release_custom_format() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.custom_format)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSK::CustomFormatArchive* temp = _impl_.custom_format_;
  _impl_.custom_format_ = nullptr;
  return temp;
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::_internal_mutable_custom_format() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.custom_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::CustomFormatArchive>(GetArenaForAllocation());
    _impl_.custom_format_ = p;
  }
  return _impl_.custom_format_;
}
inline ::TSK::CustomFormatArchive* TableDataList_ListEntry::mutable_custom_format() {
  ::TSK::CustomFormatArchive* _msg = _internal_mutable_custom_format();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.custom_format)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_custom_format(::TSK::CustomFormatArchive* custom_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_format_);
  }
  if (custom_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom_format));
    if (message_arena != submessage_arena) {
      custom_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.custom_format_ = custom_format;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.custom_format)
}

// optional .TSP.Reference richTextPayload = 9;
inline bool TableDataList_ListEntry::_internal_has_richtextpayload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.richtextpayload_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_richtextpayload() const {
  return _internal_has_richtextpayload();
}
inline const ::TSP::Reference& TableDataList_ListEntry::_internal_richtextpayload() const {
  const ::TSP::Reference* p = _impl_.richtextpayload_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableDataList_ListEntry::richtextpayload() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.richTextPayload)
  return _internal_richtextpayload();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_richtextpayload(
    ::TSP::Reference* richtextpayload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayload_);
  }
  _impl_.richtextpayload_ = richtextpayload;
  if (richtextpayload) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.richTextPayload)
}
inline ::TSP::Reference* TableDataList_ListEntry::release_richtextpayload() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.richtextpayload_;
  _impl_.richtextpayload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::unsafe_arena_release_richtextpayload() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.richTextPayload)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.richtextpayload_;
  _impl_.richtextpayload_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::_internal_mutable_richtextpayload() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.richtextpayload_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.richtextpayload_ = p;
  }
  return _impl_.richtextpayload_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_richtextpayload() {
  ::TSP::Reference* _msg = _internal_mutable_richtextpayload();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.richTextPayload)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_richtextpayload(::TSP::Reference* richtextpayload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayload_);
  }
  if (richtextpayload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(richtextpayload));
    if (message_arena != submessage_arena) {
      richtextpayload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, richtextpayload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.richtextpayload_ = richtextpayload;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.richTextPayload)
}

// optional .TSP.Reference comment_storage = 10;
inline bool TableDataList_ListEntry::_internal_has_comment_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.comment_storage_ != nullptr);
  return value;
}
inline bool TableDataList_ListEntry::has_comment_storage() const {
  return _internal_has_comment_storage();
}
inline const ::TSP::Reference& TableDataList_ListEntry::_internal_comment_storage() const {
  const ::TSP::Reference* p = _impl_.comment_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableDataList_ListEntry::comment_storage() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.ListEntry.comment_storage)
  return _internal_comment_storage();
}
inline void TableDataList_ListEntry::unsafe_arena_set_allocated_comment_storage(
    ::TSP::Reference* comment_storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_storage_);
  }
  _impl_.comment_storage_ = comment_storage;
  if (comment_storage) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableDataList.ListEntry.comment_storage)
}
inline ::TSP::Reference* TableDataList_ListEntry::release_comment_storage() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.comment_storage_;
  _impl_.comment_storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::unsafe_arena_release_comment_storage() {
  // @@protoc_insertion_point(field_release:TST.TableDataList.ListEntry.comment_storage)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.comment_storage_;
  _impl_.comment_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableDataList_ListEntry::_internal_mutable_comment_storage() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.comment_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.comment_storage_ = p;
  }
  return _impl_.comment_storage_;
}
inline ::TSP::Reference* TableDataList_ListEntry::mutable_comment_storage() {
  ::TSP::Reference* _msg = _internal_mutable_comment_storage();
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.ListEntry.comment_storage)
  return _msg;
}
inline void TableDataList_ListEntry::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_storage_);
  }
  if (comment_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment_storage));
    if (message_arena != submessage_arena) {
      comment_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment_storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.comment_storage_ = comment_storage;
  // @@protoc_insertion_point(field_set_allocated:TST.TableDataList.ListEntry.comment_storage)
}

// -------------------------------------------------------------------

// TableDataList

// required .TST.TableDataList.ListType listType = 1;
inline bool TableDataList::_internal_has_listtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableDataList::has_listtype() const {
  return _internal_has_listtype();
}
inline void TableDataList::clear_listtype() {
  _impl_.listtype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TST::TableDataList_ListType TableDataList::_internal_listtype() const {
  return static_cast< ::TST::TableDataList_ListType >(_impl_.listtype_);
}
inline ::TST::TableDataList_ListType TableDataList::listtype() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.listType)
  return _internal_listtype();
}
inline void TableDataList::_internal_set_listtype(::TST::TableDataList_ListType value) {
  assert(::TST::TableDataList_ListType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.listtype_ = value;
}
inline void TableDataList::set_listtype(::TST::TableDataList_ListType value) {
  _internal_set_listtype(value);
  // @@protoc_insertion_point(field_set:TST.TableDataList.listType)
}

// required uint32 nextListID = 2;
inline bool TableDataList::_internal_has_nextlistid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableDataList::has_nextlistid() const {
  return _internal_has_nextlistid();
}
inline void TableDataList::clear_nextlistid() {
  _impl_.nextlistid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TableDataList::_internal_nextlistid() const {
  return _impl_.nextlistid_;
}
inline uint32_t TableDataList::nextlistid() const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.nextListID)
  return _internal_nextlistid();
}
inline void TableDataList::_internal_set_nextlistid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nextlistid_ = value;
}
inline void TableDataList::set_nextlistid(uint32_t value) {
  _internal_set_nextlistid(value);
  // @@protoc_insertion_point(field_set:TST.TableDataList.nextListID)
}

// repeated .TST.TableDataList.ListEntry entries = 3;
inline int TableDataList::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int TableDataList::entries_size() const {
  return _internal_entries_size();
}
inline void TableDataList::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::TST::TableDataList_ListEntry* TableDataList::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:TST.TableDataList.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableDataList_ListEntry >*
TableDataList::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:TST.TableDataList.entries)
  return &_impl_.entries_;
}
inline const ::TST::TableDataList_ListEntry& TableDataList::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::TST::TableDataList_ListEntry& TableDataList::entries(int index) const {
  // @@protoc_insertion_point(field_get:TST.TableDataList.entries)
  return _internal_entries(index);
}
inline ::TST::TableDataList_ListEntry* TableDataList::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::TST::TableDataList_ListEntry* TableDataList::add_entries() {
  ::TST::TableDataList_ListEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:TST.TableDataList.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableDataList_ListEntry >&
TableDataList::entries() const {
  // @@protoc_insertion_point(field_list:TST.TableDataList.entries)
  return _impl_.entries_;
}

// -------------------------------------------------------------------

// TableRBTree_Node

// required uint32 key = 1;
inline bool TableRBTree_Node::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableRBTree_Node::has_key() const {
  return _internal_has_key();
}
inline void TableRBTree_Node::clear_key() {
  _impl_.key_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TableRBTree_Node::_internal_key() const {
  return _impl_.key_;
}
inline uint32_t TableRBTree_Node::key() const {
  // @@protoc_insertion_point(field_get:TST.TableRBTree.Node.key)
  return _internal_key();
}
inline void TableRBTree_Node::_internal_set_key(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_ = value;
}
inline void TableRBTree_Node::set_key(uint32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:TST.TableRBTree.Node.key)
}

// required uint32 value = 2;
inline bool TableRBTree_Node::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableRBTree_Node::has_value() const {
  return _internal_has_value();
}
inline void TableRBTree_Node::clear_value() {
  _impl_.value_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t TableRBTree_Node::_internal_value() const {
  return _impl_.value_;
}
inline uint32_t TableRBTree_Node::value() const {
  // @@protoc_insertion_point(field_get:TST.TableRBTree.Node.value)
  return _internal_value();
}
inline void TableRBTree_Node::_internal_set_value(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void TableRBTree_Node::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:TST.TableRBTree.Node.value)
}

// -------------------------------------------------------------------

// TableRBTree

// repeated .TST.TableRBTree.Node nodes = 1;
inline int TableRBTree::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int TableRBTree::nodes_size() const {
  return _internal_nodes_size();
}
inline void TableRBTree::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::TST::TableRBTree_Node* TableRBTree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:TST.TableRBTree.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableRBTree_Node >*
TableRBTree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:TST.TableRBTree.nodes)
  return &_impl_.nodes_;
}
inline const ::TST::TableRBTree_Node& TableRBTree::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::TST::TableRBTree_Node& TableRBTree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:TST.TableRBTree.nodes)
  return _internal_nodes(index);
}
inline ::TST::TableRBTree_Node* TableRBTree::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::TST::TableRBTree_Node* TableRBTree::add_nodes() {
  ::TST::TableRBTree_Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:TST.TableRBTree.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::TableRBTree_Node >&
TableRBTree::nodes() const {
  // @@protoc_insertion_point(field_list:TST.TableRBTree.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// HeaderStorageBucket_Header

// required uint32 index = 1;
inline bool HeaderStorageBucket_Header::_internal_has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HeaderStorageBucket_Header::has_index() const {
  return _internal_has_index();
}
inline void HeaderStorageBucket_Header::clear_index() {
  _impl_.index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t HeaderStorageBucket_Header::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t HeaderStorageBucket_Header::index() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.index)
  return _internal_index();
}
inline void HeaderStorageBucket_Header::_internal_set_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.index_ = value;
}
inline void HeaderStorageBucket_Header::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorageBucket.Header.index)
}

// required float size = 2;
inline bool HeaderStorageBucket_Header::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HeaderStorageBucket_Header::has_size() const {
  return _internal_has_size();
}
inline void HeaderStorageBucket_Header::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float HeaderStorageBucket_Header::_internal_size() const {
  return _impl_.size_;
}
inline float HeaderStorageBucket_Header::size() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.size)
  return _internal_size();
}
inline void HeaderStorageBucket_Header::_internal_set_size(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void HeaderStorageBucket_Header::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorageBucket.Header.size)
}

// required uint32 hidingState = 3;
inline bool HeaderStorageBucket_Header::_internal_has_hidingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool HeaderStorageBucket_Header::has_hidingstate() const {
  return _internal_has_hidingstate();
}
inline void HeaderStorageBucket_Header::clear_hidingstate() {
  _impl_.hidingstate_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t HeaderStorageBucket_Header::_internal_hidingstate() const {
  return _impl_.hidingstate_;
}
inline uint32_t HeaderStorageBucket_Header::hidingstate() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.hidingState)
  return _internal_hidingstate();
}
inline void HeaderStorageBucket_Header::_internal_set_hidingstate(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.hidingstate_ = value;
}
inline void HeaderStorageBucket_Header::set_hidingstate(uint32_t value) {
  _internal_set_hidingstate(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorageBucket.Header.hidingState)
}

// required uint32 numberOfCells = 4;
inline bool HeaderStorageBucket_Header::_internal_has_numberofcells() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool HeaderStorageBucket_Header::has_numberofcells() const {
  return _internal_has_numberofcells();
}
inline void HeaderStorageBucket_Header::clear_numberofcells() {
  _impl_.numberofcells_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t HeaderStorageBucket_Header::_internal_numberofcells() const {
  return _impl_.numberofcells_;
}
inline uint32_t HeaderStorageBucket_Header::numberofcells() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.numberOfCells)
  return _internal_numberofcells();
}
inline void HeaderStorageBucket_Header::_internal_set_numberofcells(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.numberofcells_ = value;
}
inline void HeaderStorageBucket_Header::set_numberofcells(uint32_t value) {
  _internal_set_numberofcells(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorageBucket.Header.numberOfCells)
}

// optional .TSP.Reference cell_style = 5;
inline bool HeaderStorageBucket_Header::_internal_has_cell_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_style_ != nullptr);
  return value;
}
inline bool HeaderStorageBucket_Header::has_cell_style() const {
  return _internal_has_cell_style();
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::_internal_cell_style() const {
  const ::TSP::Reference* p = _impl_.cell_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::cell_style() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.cell_style)
  return _internal_cell_style();
}
inline void HeaderStorageBucket_Header::unsafe_arena_set_allocated_cell_style(
    ::TSP::Reference* cell_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  _impl_.cell_style_ = cell_style;
  if (cell_style) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.HeaderStorageBucket.Header.cell_style)
}
inline ::TSP::Reference* HeaderStorageBucket_Header::release_cell_style() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::unsafe_arena_release_cell_style() {
  // @@protoc_insertion_point(field_release:TST.HeaderStorageBucket.Header.cell_style)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::_internal_mutable_cell_style() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cell_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.cell_style_ = p;
  }
  return _impl_.cell_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::mutable_cell_style() {
  ::TSP::Reference* _msg = _internal_mutable_cell_style();
  // @@protoc_insertion_point(field_mutable:TST.HeaderStorageBucket.Header.cell_style)
  return _msg;
}
inline void HeaderStorageBucket_Header::set_allocated_cell_style(::TSP::Reference* cell_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  if (cell_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_style));
    if (message_arena != submessage_arena) {
      cell_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cell_style_ = cell_style;
  // @@protoc_insertion_point(field_set_allocated:TST.HeaderStorageBucket.Header.cell_style)
}

// optional .TSP.Reference text_style = 6;
inline bool HeaderStorageBucket_Header::_internal_has_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_style_ != nullptr);
  return value;
}
inline bool HeaderStorageBucket_Header::has_text_style() const {
  return _internal_has_text_style();
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::_internal_text_style() const {
  const ::TSP::Reference* p = _impl_.text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& HeaderStorageBucket_Header::text_style() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.Header.text_style)
  return _internal_text_style();
}
inline void HeaderStorageBucket_Header::unsafe_arena_set_allocated_text_style(
    ::TSP::Reference* text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  _impl_.text_style_ = text_style;
  if (text_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.HeaderStorageBucket.Header.text_style)
}
inline ::TSP::Reference* HeaderStorageBucket_Header::release_text_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::unsafe_arena_release_text_style() {
  // @@protoc_insertion_point(field_release:TST.HeaderStorageBucket.Header.text_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::_internal_mutable_text_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.text_style_ = p;
  }
  return _impl_.text_style_;
}
inline ::TSP::Reference* HeaderStorageBucket_Header::mutable_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_text_style();
  // @@protoc_insertion_point(field_mutable:TST.HeaderStorageBucket.Header.text_style)
  return _msg;
}
inline void HeaderStorageBucket_Header::set_allocated_text_style(::TSP::Reference* text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  if (text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_style));
    if (message_arena != submessage_arena) {
      text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_style_ = text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.HeaderStorageBucket.Header.text_style)
}

// -------------------------------------------------------------------

// HeaderStorageBucket

// required uint32 bucketHashFunction = 1;
inline bool HeaderStorageBucket::_internal_has_buckethashfunction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeaderStorageBucket::has_buckethashfunction() const {
  return _internal_has_buckethashfunction();
}
inline void HeaderStorageBucket::clear_buckethashfunction() {
  _impl_.buckethashfunction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HeaderStorageBucket::_internal_buckethashfunction() const {
  return _impl_.buckethashfunction_;
}
inline uint32_t HeaderStorageBucket::buckethashfunction() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.bucketHashFunction)
  return _internal_buckethashfunction();
}
inline void HeaderStorageBucket::_internal_set_buckethashfunction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buckethashfunction_ = value;
}
inline void HeaderStorageBucket::set_buckethashfunction(uint32_t value) {
  _internal_set_buckethashfunction(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorageBucket.bucketHashFunction)
}

// repeated .TST.HeaderStorageBucket.Header headers = 2;
inline int HeaderStorageBucket::_internal_headers_size() const {
  return _impl_.headers_.size();
}
inline int HeaderStorageBucket::headers_size() const {
  return _internal_headers_size();
}
inline void HeaderStorageBucket::clear_headers() {
  _impl_.headers_.Clear();
}
inline ::TST::HeaderStorageBucket_Header* HeaderStorageBucket::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:TST.HeaderStorageBucket.headers)
  return _impl_.headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >*
HeaderStorageBucket::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:TST.HeaderStorageBucket.headers)
  return &_impl_.headers_;
}
inline const ::TST::HeaderStorageBucket_Header& HeaderStorageBucket::_internal_headers(int index) const {
  return _impl_.headers_.Get(index);
}
inline const ::TST::HeaderStorageBucket_Header& HeaderStorageBucket::headers(int index) const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorageBucket.headers)
  return _internal_headers(index);
}
inline ::TST::HeaderStorageBucket_Header* HeaderStorageBucket::_internal_add_headers() {
  return _impl_.headers_.Add();
}
inline ::TST::HeaderStorageBucket_Header* HeaderStorageBucket::add_headers() {
  ::TST::HeaderStorageBucket_Header* _add = _internal_add_headers();
  // @@protoc_insertion_point(field_add:TST.HeaderStorageBucket.headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::HeaderStorageBucket_Header >&
HeaderStorageBucket::headers() const {
  // @@protoc_insertion_point(field_list:TST.HeaderStorageBucket.headers)
  return _impl_.headers_;
}

// -------------------------------------------------------------------

// HeaderStorage

// required uint32 bucketHashFunction = 1;
inline bool HeaderStorage::_internal_has_buckethashfunction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HeaderStorage::has_buckethashfunction() const {
  return _internal_has_buckethashfunction();
}
inline void HeaderStorage::clear_buckethashfunction() {
  _impl_.buckethashfunction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t HeaderStorage::_internal_buckethashfunction() const {
  return _impl_.buckethashfunction_;
}
inline uint32_t HeaderStorage::buckethashfunction() const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorage.bucketHashFunction)
  return _internal_buckethashfunction();
}
inline void HeaderStorage::_internal_set_buckethashfunction(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buckethashfunction_ = value;
}
inline void HeaderStorage::set_buckethashfunction(uint32_t value) {
  _internal_set_buckethashfunction(value);
  // @@protoc_insertion_point(field_set:TST.HeaderStorage.bucketHashFunction)
}

// repeated .TSP.Reference buckets = 2;
inline int HeaderStorage::_internal_buckets_size() const {
  return _impl_.buckets_.size();
}
inline int HeaderStorage::buckets_size() const {
  return _internal_buckets_size();
}
inline ::TSP::Reference* HeaderStorage::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:TST.HeaderStorage.buckets)
  return _impl_.buckets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
HeaderStorage::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:TST.HeaderStorage.buckets)
  return &_impl_.buckets_;
}
inline const ::TSP::Reference& HeaderStorage::_internal_buckets(int index) const {
  return _impl_.buckets_.Get(index);
}
inline const ::TSP::Reference& HeaderStorage::buckets(int index) const {
  // @@protoc_insertion_point(field_get:TST.HeaderStorage.buckets)
  return _internal_buckets(index);
}
inline ::TSP::Reference* HeaderStorage::_internal_add_buckets() {
  return _impl_.buckets_.Add();
}
inline ::TSP::Reference* HeaderStorage::add_buckets() {
  ::TSP::Reference* _add = _internal_add_buckets();
  // @@protoc_insertion_point(field_add:TST.HeaderStorage.buckets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
HeaderStorage::buckets() const {
  // @@protoc_insertion_point(field_list:TST.HeaderStorage.buckets)
  return _impl_.buckets_;
}

// -------------------------------------------------------------------

// DataStore

// required .TST.HeaderStorage rowHeaders = 1;
inline bool DataStore::_internal_has_rowheaders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rowheaders_ != nullptr);
  return value;
}
inline bool DataStore::has_rowheaders() const {
  return _internal_has_rowheaders();
}
inline void DataStore::clear_rowheaders() {
  if (_impl_.rowheaders_ != nullptr) _impl_.rowheaders_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::HeaderStorage& DataStore::_internal_rowheaders() const {
  const ::TST::HeaderStorage* p = _impl_.rowheaders_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::HeaderStorage&>(
      ::TST::_HeaderStorage_default_instance_);
}
inline const ::TST::HeaderStorage& DataStore::rowheaders() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.rowHeaders)
  return _internal_rowheaders();
}
inline void DataStore::unsafe_arena_set_allocated_rowheaders(
    ::TST::HeaderStorage* rowheaders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rowheaders_);
  }
  _impl_.rowheaders_ = rowheaders;
  if (rowheaders) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.rowHeaders)
}
inline ::TST::HeaderStorage* DataStore::release_rowheaders() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::HeaderStorage* temp = _impl_.rowheaders_;
  _impl_.rowheaders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::HeaderStorage* DataStore::unsafe_arena_release_rowheaders() {
  // @@protoc_insertion_point(field_release:TST.DataStore.rowHeaders)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::HeaderStorage* temp = _impl_.rowheaders_;
  _impl_.rowheaders_ = nullptr;
  return temp;
}
inline ::TST::HeaderStorage* DataStore::_internal_mutable_rowheaders() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rowheaders_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::HeaderStorage>(GetArenaForAllocation());
    _impl_.rowheaders_ = p;
  }
  return _impl_.rowheaders_;
}
inline ::TST::HeaderStorage* DataStore::mutable_rowheaders() {
  ::TST::HeaderStorage* _msg = _internal_mutable_rowheaders();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.rowHeaders)
  return _msg;
}
inline void DataStore::set_allocated_rowheaders(::TST::HeaderStorage* rowheaders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rowheaders_;
  }
  if (rowheaders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rowheaders);
    if (message_arena != submessage_arena) {
      rowheaders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rowheaders, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rowheaders_ = rowheaders;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.rowHeaders)
}

// required .TSP.Reference columnHeaders = 2;
inline bool DataStore::_internal_has_columnheaders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.columnheaders_ != nullptr);
  return value;
}
inline bool DataStore::has_columnheaders() const {
  return _internal_has_columnheaders();
}
inline const ::TSP::Reference& DataStore::_internal_columnheaders() const {
  const ::TSP::Reference* p = _impl_.columnheaders_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::columnheaders() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.columnHeaders)
  return _internal_columnheaders();
}
inline void DataStore::unsafe_arena_set_allocated_columnheaders(
    ::TSP::Reference* columnheaders) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.columnheaders_);
  }
  _impl_.columnheaders_ = columnheaders;
  if (columnheaders) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.columnHeaders)
}
inline ::TSP::Reference* DataStore::release_columnheaders() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.columnheaders_;
  _impl_.columnheaders_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_columnheaders() {
  // @@protoc_insertion_point(field_release:TST.DataStore.columnHeaders)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.columnheaders_;
  _impl_.columnheaders_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_columnheaders() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.columnheaders_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.columnheaders_ = p;
  }
  return _impl_.columnheaders_;
}
inline ::TSP::Reference* DataStore::mutable_columnheaders() {
  ::TSP::Reference* _msg = _internal_mutable_columnheaders();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.columnHeaders)
  return _msg;
}
inline void DataStore::set_allocated_columnheaders(::TSP::Reference* columnheaders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.columnheaders_);
  }
  if (columnheaders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(columnheaders));
    if (message_arena != submessage_arena) {
      columnheaders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, columnheaders, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.columnheaders_ = columnheaders;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.columnHeaders)
}

// required .TST.TileStorage tiles = 3;
inline bool DataStore::_internal_has_tiles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tiles_ != nullptr);
  return value;
}
inline bool DataStore::has_tiles() const {
  return _internal_has_tiles();
}
inline void DataStore::clear_tiles() {
  if (_impl_.tiles_ != nullptr) _impl_.tiles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TST::TileStorage& DataStore::_internal_tiles() const {
  const ::TST::TileStorage* p = _impl_.tiles_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TileStorage&>(
      ::TST::_TileStorage_default_instance_);
}
inline const ::TST::TileStorage& DataStore::tiles() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.tiles)
  return _internal_tiles();
}
inline void DataStore::unsafe_arena_set_allocated_tiles(
    ::TST::TileStorage* tiles) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tiles_);
  }
  _impl_.tiles_ = tiles;
  if (tiles) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.tiles)
}
inline ::TST::TileStorage* DataStore::release_tiles() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::TileStorage* temp = _impl_.tiles_;
  _impl_.tiles_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TileStorage* DataStore::unsafe_arena_release_tiles() {
  // @@protoc_insertion_point(field_release:TST.DataStore.tiles)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::TileStorage* temp = _impl_.tiles_;
  _impl_.tiles_ = nullptr;
  return temp;
}
inline ::TST::TileStorage* DataStore::_internal_mutable_tiles() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.tiles_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TileStorage>(GetArenaForAllocation());
    _impl_.tiles_ = p;
  }
  return _impl_.tiles_;
}
inline ::TST::TileStorage* DataStore::mutable_tiles() {
  ::TST::TileStorage* _msg = _internal_mutable_tiles();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.tiles)
  return _msg;
}
inline void DataStore::set_allocated_tiles(::TST::TileStorage* tiles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tiles_;
  }
  if (tiles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tiles);
    if (message_arena != submessage_arena) {
      tiles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tiles, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tiles_ = tiles;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.tiles)
}

// required .TSP.Reference stringTable = 4;
inline bool DataStore::_internal_has_stringtable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stringtable_ != nullptr);
  return value;
}
inline bool DataStore::has_stringtable() const {
  return _internal_has_stringtable();
}
inline const ::TSP::Reference& DataStore::_internal_stringtable() const {
  const ::TSP::Reference* p = _impl_.stringtable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::stringtable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.stringTable)
  return _internal_stringtable();
}
inline void DataStore::unsafe_arena_set_allocated_stringtable(
    ::TSP::Reference* stringtable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stringtable_);
  }
  _impl_.stringtable_ = stringtable;
  if (stringtable) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.stringTable)
}
inline ::TSP::Reference* DataStore::release_stringtable() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.stringtable_;
  _impl_.stringtable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_stringtable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.stringTable)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.stringtable_;
  _impl_.stringtable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_stringtable() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.stringtable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.stringtable_ = p;
  }
  return _impl_.stringtable_;
}
inline ::TSP::Reference* DataStore::mutable_stringtable() {
  ::TSP::Reference* _msg = _internal_mutable_stringtable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.stringTable)
  return _msg;
}
inline void DataStore::set_allocated_stringtable(::TSP::Reference* stringtable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stringtable_);
  }
  if (stringtable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stringtable));
    if (message_arena != submessage_arena) {
      stringtable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringtable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.stringtable_ = stringtable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.stringTable)
}

// required .TSP.Reference styleTable = 5;
inline bool DataStore::_internal_has_styletable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.styletable_ != nullptr);
  return value;
}
inline bool DataStore::has_styletable() const {
  return _internal_has_styletable();
}
inline const ::TSP::Reference& DataStore::_internal_styletable() const {
  const ::TSP::Reference* p = _impl_.styletable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::styletable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.styleTable)
  return _internal_styletable();
}
inline void DataStore::unsafe_arena_set_allocated_styletable(
    ::TSP::Reference* styletable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.styletable_);
  }
  _impl_.styletable_ = styletable;
  if (styletable) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.styleTable)
}
inline ::TSP::Reference* DataStore::release_styletable() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.styletable_;
  _impl_.styletable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_styletable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.styleTable)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.styletable_;
  _impl_.styletable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_styletable() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.styletable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.styletable_ = p;
  }
  return _impl_.styletable_;
}
inline ::TSP::Reference* DataStore::mutable_styletable() {
  ::TSP::Reference* _msg = _internal_mutable_styletable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.styleTable)
  return _msg;
}
inline void DataStore::set_allocated_styletable(::TSP::Reference* styletable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.styletable_);
  }
  if (styletable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(styletable));
    if (message_arena != submessage_arena) {
      styletable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, styletable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.styletable_ = styletable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.styleTable)
}

// required .TSP.Reference formulaTable = 6;
inline bool DataStore::_internal_has_formulatable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formulatable_ != nullptr);
  return value;
}
inline bool DataStore::has_formulatable() const {
  return _internal_has_formulatable();
}
inline const ::TSP::Reference& DataStore::_internal_formulatable() const {
  const ::TSP::Reference* p = _impl_.formulatable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::formulatable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.formulaTable)
  return _internal_formulatable();
}
inline void DataStore::unsafe_arena_set_allocated_formulatable(
    ::TSP::Reference* formulatable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulatable_);
  }
  _impl_.formulatable_ = formulatable;
  if (formulatable) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.formulaTable)
}
inline ::TSP::Reference* DataStore::release_formulatable() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.formulatable_;
  _impl_.formulatable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_formulatable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.formulaTable)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.formulatable_;
  _impl_.formulatable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_formulatable() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.formulatable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.formulatable_ = p;
  }
  return _impl_.formulatable_;
}
inline ::TSP::Reference* DataStore::mutable_formulatable() {
  ::TSP::Reference* _msg = _internal_mutable_formulatable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.formulaTable)
  return _msg;
}
inline void DataStore::set_allocated_formulatable(::TSP::Reference* formulatable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulatable_);
  }
  if (formulatable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formulatable));
    if (message_arena != submessage_arena) {
      formulatable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formulatable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.formulatable_ = formulatable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.formulaTable)
}

// optional .TSP.Reference formulaErrorTable = 12;
inline bool DataStore::_internal_has_formulaerrortable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formulaerrortable_ != nullptr);
  return value;
}
inline bool DataStore::has_formulaerrortable() const {
  return _internal_has_formulaerrortable();
}
inline const ::TSP::Reference& DataStore::_internal_formulaerrortable() const {
  const ::TSP::Reference* p = _impl_.formulaerrortable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::formulaerrortable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.formulaErrorTable)
  return _internal_formulaerrortable();
}
inline void DataStore::unsafe_arena_set_allocated_formulaerrortable(
    ::TSP::Reference* formulaerrortable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulaerrortable_);
  }
  _impl_.formulaerrortable_ = formulaerrortable;
  if (formulaerrortable) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.formulaErrorTable)
}
inline ::TSP::Reference* DataStore::release_formulaerrortable() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.formulaerrortable_;
  _impl_.formulaerrortable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_formulaerrortable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.formulaErrorTable)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.formulaerrortable_;
  _impl_.formulaerrortable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_formulaerrortable() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.formulaerrortable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.formulaerrortable_ = p;
  }
  return _impl_.formulaerrortable_;
}
inline ::TSP::Reference* DataStore::mutable_formulaerrortable() {
  ::TSP::Reference* _msg = _internal_mutable_formulaerrortable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.formulaErrorTable)
  return _msg;
}
inline void DataStore::set_allocated_formulaerrortable(::TSP::Reference* formulaerrortable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulaerrortable_);
  }
  if (formulaerrortable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formulaerrortable));
    if (message_arena != submessage_arena) {
      formulaerrortable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formulaerrortable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.formulaerrortable_ = formulaerrortable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.formulaErrorTable)
}

// required .TSP.Reference formatTable = 11;
inline bool DataStore::_internal_has_formattable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formattable_ != nullptr);
  return value;
}
inline bool DataStore::has_formattable() const {
  return _internal_has_formattable();
}
inline const ::TSP::Reference& DataStore::_internal_formattable() const {
  const ::TSP::Reference* p = _impl_.formattable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::formattable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.formatTable)
  return _internal_formattable();
}
inline void DataStore::unsafe_arena_set_allocated_formattable(
    ::TSP::Reference* formattable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formattable_);
  }
  _impl_.formattable_ = formattable;
  if (formattable) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.formatTable)
}
inline ::TSP::Reference* DataStore::release_formattable() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.formattable_;
  _impl_.formattable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_formattable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.formatTable)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.formattable_;
  _impl_.formattable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_formattable() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.formattable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.formattable_ = p;
  }
  return _impl_.formattable_;
}
inline ::TSP::Reference* DataStore::mutable_formattable() {
  ::TSP::Reference* _msg = _internal_mutable_formattable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.formatTable)
  return _msg;
}
inline void DataStore::set_allocated_formattable(::TSP::Reference* formattable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formattable_);
  }
  if (formattable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formattable));
    if (message_arena != submessage_arena) {
      formattable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formattable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.formattable_ = formattable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.formatTable)
}

// optional .TSP.Reference multipleChoiceListFormatTable = 16;
inline bool DataStore::_internal_has_multiplechoicelistformattable() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiplechoicelistformattable_ != nullptr);
  return value;
}
inline bool DataStore::has_multiplechoicelistformattable() const {
  return _internal_has_multiplechoicelistformattable();
}
inline const ::TSP::Reference& DataStore::_internal_multiplechoicelistformattable() const {
  const ::TSP::Reference* p = _impl_.multiplechoicelistformattable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::multiplechoicelistformattable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.multipleChoiceListFormatTable)
  return _internal_multiplechoicelistformattable();
}
inline void DataStore::unsafe_arena_set_allocated_multiplechoicelistformattable(
    ::TSP::Reference* multiplechoicelistformattable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiplechoicelistformattable_);
  }
  _impl_.multiplechoicelistformattable_ = multiplechoicelistformattable;
  if (multiplechoicelistformattable) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.multipleChoiceListFormatTable)
}
inline ::TSP::Reference* DataStore::release_multiplechoicelistformattable() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSP::Reference* temp = _impl_.multiplechoicelistformattable_;
  _impl_.multiplechoicelistformattable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_multiplechoicelistformattable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.multipleChoiceListFormatTable)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSP::Reference* temp = _impl_.multiplechoicelistformattable_;
  _impl_.multiplechoicelistformattable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_multiplechoicelistformattable() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.multiplechoicelistformattable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.multiplechoicelistformattable_ = p;
  }
  return _impl_.multiplechoicelistformattable_;
}
inline ::TSP::Reference* DataStore::mutable_multiplechoicelistformattable() {
  ::TSP::Reference* _msg = _internal_mutable_multiplechoicelistformattable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.multipleChoiceListFormatTable)
  return _msg;
}
inline void DataStore::set_allocated_multiplechoicelistformattable(::TSP::Reference* multiplechoicelistformattable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiplechoicelistformattable_);
  }
  if (multiplechoicelistformattable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multiplechoicelistformattable));
    if (message_arena != submessage_arena) {
      multiplechoicelistformattable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiplechoicelistformattable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.multiplechoicelistformattable_ = multiplechoicelistformattable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.multipleChoiceListFormatTable)
}

// optional .TSP.Reference merge_region_map = 13;
inline bool DataStore::_internal_has_merge_region_map() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.merge_region_map_ != nullptr);
  return value;
}
inline bool DataStore::has_merge_region_map() const {
  return _internal_has_merge_region_map();
}
inline const ::TSP::Reference& DataStore::_internal_merge_region_map() const {
  const ::TSP::Reference* p = _impl_.merge_region_map_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::merge_region_map() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.merge_region_map)
  return _internal_merge_region_map();
}
inline void DataStore::unsafe_arena_set_allocated_merge_region_map(
    ::TSP::Reference* merge_region_map) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.merge_region_map_);
  }
  _impl_.merge_region_map_ = merge_region_map;
  if (merge_region_map) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.merge_region_map)
}
inline ::TSP::Reference* DataStore::release_merge_region_map() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Reference* temp = _impl_.merge_region_map_;
  _impl_.merge_region_map_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_merge_region_map() {
  // @@protoc_insertion_point(field_release:TST.DataStore.merge_region_map)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Reference* temp = _impl_.merge_region_map_;
  _impl_.merge_region_map_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_merge_region_map() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.merge_region_map_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.merge_region_map_ = p;
  }
  return _impl_.merge_region_map_;
}
inline ::TSP::Reference* DataStore::mutable_merge_region_map() {
  ::TSP::Reference* _msg = _internal_mutable_merge_region_map();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.merge_region_map)
  return _msg;
}
inline void DataStore::set_allocated_merge_region_map(::TSP::Reference* merge_region_map) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.merge_region_map_);
  }
  if (merge_region_map) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(merge_region_map));
    if (message_arena != submessage_arena) {
      merge_region_map = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, merge_region_map, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.merge_region_map_ = merge_region_map;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.merge_region_map)
}

// optional .TSP.Reference customFormatTable = 15;
inline bool DataStore::_internal_has_customformattable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.customformattable_ != nullptr);
  return value;
}
inline bool DataStore::has_customformattable() const {
  return _internal_has_customformattable();
}
inline const ::TSP::Reference& DataStore::_internal_customformattable() const {
  const ::TSP::Reference* p = _impl_.customformattable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::customformattable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.customFormatTable)
  return _internal_customformattable();
}
inline void DataStore::unsafe_arena_set_allocated_customformattable(
    ::TSP::Reference* customformattable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.customformattable_);
  }
  _impl_.customformattable_ = customformattable;
  if (customformattable) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.customFormatTable)
}
inline ::TSP::Reference* DataStore::release_customformattable() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::Reference* temp = _impl_.customformattable_;
  _impl_.customformattable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_customformattable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.customFormatTable)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::Reference* temp = _impl_.customformattable_;
  _impl_.customformattable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_customformattable() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.customformattable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.customformattable_ = p;
  }
  return _impl_.customformattable_;
}
inline ::TSP::Reference* DataStore::mutable_customformattable() {
  ::TSP::Reference* _msg = _internal_mutable_customformattable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.customFormatTable)
  return _msg;
}
inline void DataStore::set_allocated_customformattable(::TSP::Reference* customformattable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.customformattable_);
  }
  if (customformattable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(customformattable));
    if (message_arena != submessage_arena) {
      customformattable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, customformattable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.customformattable_ = customformattable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.customFormatTable)
}

// required uint32 nextRowStripID = 7;
inline bool DataStore::_internal_has_nextrowstripid() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DataStore::has_nextrowstripid() const {
  return _internal_has_nextrowstripid();
}
inline void DataStore::clear_nextrowstripid() {
  _impl_.nextrowstripid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline uint32_t DataStore::_internal_nextrowstripid() const {
  return _impl_.nextrowstripid_;
}
inline uint32_t DataStore::nextrowstripid() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.nextRowStripID)
  return _internal_nextrowstripid();
}
inline void DataStore::_internal_set_nextrowstripid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.nextrowstripid_ = value;
}
inline void DataStore::set_nextrowstripid(uint32_t value) {
  _internal_set_nextrowstripid(value);
  // @@protoc_insertion_point(field_set:TST.DataStore.nextRowStripID)
}

// required uint32 nextColumnStripID = 8;
inline bool DataStore::_internal_has_nextcolumnstripid() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool DataStore::has_nextcolumnstripid() const {
  return _internal_has_nextcolumnstripid();
}
inline void DataStore::clear_nextcolumnstripid() {
  _impl_.nextcolumnstripid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline uint32_t DataStore::_internal_nextcolumnstripid() const {
  return _impl_.nextcolumnstripid_;
}
inline uint32_t DataStore::nextcolumnstripid() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.nextColumnStripID)
  return _internal_nextcolumnstripid();
}
inline void DataStore::_internal_set_nextcolumnstripid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.nextcolumnstripid_ = value;
}
inline void DataStore::set_nextcolumnstripid(uint32_t value) {
  _internal_set_nextcolumnstripid(value);
  // @@protoc_insertion_point(field_set:TST.DataStore.nextColumnStripID)
}

// required .TST.TableRBTree rowTileTree = 9;
inline bool DataStore::_internal_has_rowtiletree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rowtiletree_ != nullptr);
  return value;
}
inline bool DataStore::has_rowtiletree() const {
  return _internal_has_rowtiletree();
}
inline void DataStore::clear_rowtiletree() {
  if (_impl_.rowtiletree_ != nullptr) _impl_.rowtiletree_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::TST::TableRBTree& DataStore::_internal_rowtiletree() const {
  const ::TST::TableRBTree* p = _impl_.rowtiletree_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TableRBTree&>(
      ::TST::_TableRBTree_default_instance_);
}
inline const ::TST::TableRBTree& DataStore::rowtiletree() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.rowTileTree)
  return _internal_rowtiletree();
}
inline void DataStore::unsafe_arena_set_allocated_rowtiletree(
    ::TST::TableRBTree* rowtiletree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rowtiletree_);
  }
  _impl_.rowtiletree_ = rowtiletree;
  if (rowtiletree) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.rowTileTree)
}
inline ::TST::TableRBTree* DataStore::release_rowtiletree() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TST::TableRBTree* temp = _impl_.rowtiletree_;
  _impl_.rowtiletree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TableRBTree* DataStore::unsafe_arena_release_rowtiletree() {
  // @@protoc_insertion_point(field_release:TST.DataStore.rowTileTree)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TST::TableRBTree* temp = _impl_.rowtiletree_;
  _impl_.rowtiletree_ = nullptr;
  return temp;
}
inline ::TST::TableRBTree* DataStore::_internal_mutable_rowtiletree() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.rowtiletree_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TableRBTree>(GetArenaForAllocation());
    _impl_.rowtiletree_ = p;
  }
  return _impl_.rowtiletree_;
}
inline ::TST::TableRBTree* DataStore::mutable_rowtiletree() {
  ::TST::TableRBTree* _msg = _internal_mutable_rowtiletree();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.rowTileTree)
  return _msg;
}
inline void DataStore::set_allocated_rowtiletree(::TST::TableRBTree* rowtiletree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rowtiletree_;
  }
  if (rowtiletree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rowtiletree);
    if (message_arena != submessage_arena) {
      rowtiletree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rowtiletree, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.rowtiletree_ = rowtiletree;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.rowTileTree)
}

// required .TST.TableRBTree columnTileTree = 10;
inline bool DataStore::_internal_has_columntiletree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.columntiletree_ != nullptr);
  return value;
}
inline bool DataStore::has_columntiletree() const {
  return _internal_has_columntiletree();
}
inline void DataStore::clear_columntiletree() {
  if (_impl_.columntiletree_ != nullptr) _impl_.columntiletree_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::TST::TableRBTree& DataStore::_internal_columntiletree() const {
  const ::TST::TableRBTree* p = _impl_.columntiletree_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TableRBTree&>(
      ::TST::_TableRBTree_default_instance_);
}
inline const ::TST::TableRBTree& DataStore::columntiletree() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.columnTileTree)
  return _internal_columntiletree();
}
inline void DataStore::unsafe_arena_set_allocated_columntiletree(
    ::TST::TableRBTree* columntiletree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.columntiletree_);
  }
  _impl_.columntiletree_ = columntiletree;
  if (columntiletree) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.columnTileTree)
}
inline ::TST::TableRBTree* DataStore::release_columntiletree() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TST::TableRBTree* temp = _impl_.columntiletree_;
  _impl_.columntiletree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TableRBTree* DataStore::unsafe_arena_release_columntiletree() {
  // @@protoc_insertion_point(field_release:TST.DataStore.columnTileTree)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TST::TableRBTree* temp = _impl_.columntiletree_;
  _impl_.columntiletree_ = nullptr;
  return temp;
}
inline ::TST::TableRBTree* DataStore::_internal_mutable_columntiletree() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.columntiletree_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TableRBTree>(GetArenaForAllocation());
    _impl_.columntiletree_ = p;
  }
  return _impl_.columntiletree_;
}
inline ::TST::TableRBTree* DataStore::mutable_columntiletree() {
  ::TST::TableRBTree* _msg = _internal_mutable_columntiletree();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.columnTileTree)
  return _msg;
}
inline void DataStore::set_allocated_columntiletree(::TST::TableRBTree* columntiletree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.columntiletree_;
  }
  if (columntiletree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(columntiletree);
    if (message_arena != submessage_arena) {
      columntiletree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, columntiletree, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.columntiletree_ = columntiletree;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.columnTileTree)
}

// optional uint32 storage_version = 14;
inline bool DataStore::_internal_has_storage_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool DataStore::has_storage_version() const {
  return _internal_has_storage_version();
}
inline void DataStore::clear_storage_version() {
  _impl_.storage_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint32_t DataStore::_internal_storage_version() const {
  return _impl_.storage_version_;
}
inline uint32_t DataStore::storage_version() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.storage_version)
  return _internal_storage_version();
}
inline void DataStore::_internal_set_storage_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.storage_version_ = value;
}
inline void DataStore::set_storage_version(uint32_t value) {
  _internal_set_storage_version(value);
  // @@protoc_insertion_point(field_set:TST.DataStore.storage_version)
}

// optional .TSP.Reference richTextPayloadTable = 17;
inline bool DataStore::_internal_has_richtextpayloadtable() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.richtextpayloadtable_ != nullptr);
  return value;
}
inline bool DataStore::has_richtextpayloadtable() const {
  return _internal_has_richtextpayloadtable();
}
inline const ::TSP::Reference& DataStore::_internal_richtextpayloadtable() const {
  const ::TSP::Reference* p = _impl_.richtextpayloadtable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::richtextpayloadtable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.richTextPayloadTable)
  return _internal_richtextpayloadtable();
}
inline void DataStore::unsafe_arena_set_allocated_richtextpayloadtable(
    ::TSP::Reference* richtextpayloadtable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayloadtable_);
  }
  _impl_.richtextpayloadtable_ = richtextpayloadtable;
  if (richtextpayloadtable) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.richTextPayloadTable)
}
inline ::TSP::Reference* DataStore::release_richtextpayloadtable() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::Reference* temp = _impl_.richtextpayloadtable_;
  _impl_.richtextpayloadtable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_richtextpayloadtable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.richTextPayloadTable)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::Reference* temp = _impl_.richtextpayloadtable_;
  _impl_.richtextpayloadtable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_richtextpayloadtable() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.richtextpayloadtable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.richtextpayloadtable_ = p;
  }
  return _impl_.richtextpayloadtable_;
}
inline ::TSP::Reference* DataStore::mutable_richtextpayloadtable() {
  ::TSP::Reference* _msg = _internal_mutable_richtextpayloadtable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.richTextPayloadTable)
  return _msg;
}
inline void DataStore::set_allocated_richtextpayloadtable(::TSP::Reference* richtextpayloadtable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayloadtable_);
  }
  if (richtextpayloadtable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(richtextpayloadtable));
    if (message_arena != submessage_arena) {
      richtextpayloadtable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, richtextpayloadtable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.richtextpayloadtable_ = richtextpayloadtable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.richTextPayloadTable)
}

// optional .TSP.Reference conditionalstyletable = 18;
inline bool DataStore::_internal_has_conditionalstyletable() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conditionalstyletable_ != nullptr);
  return value;
}
inline bool DataStore::has_conditionalstyletable() const {
  return _internal_has_conditionalstyletable();
}
inline const ::TSP::Reference& DataStore::_internal_conditionalstyletable() const {
  const ::TSP::Reference* p = _impl_.conditionalstyletable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::conditionalstyletable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.conditionalstyletable)
  return _internal_conditionalstyletable();
}
inline void DataStore::unsafe_arena_set_allocated_conditionalstyletable(
    ::TSP::Reference* conditionalstyletable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditionalstyletable_);
  }
  _impl_.conditionalstyletable_ = conditionalstyletable;
  if (conditionalstyletable) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.conditionalstyletable)
}
inline ::TSP::Reference* DataStore::release_conditionalstyletable() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.conditionalstyletable_;
  _impl_.conditionalstyletable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_conditionalstyletable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.conditionalstyletable)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.conditionalstyletable_;
  _impl_.conditionalstyletable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_conditionalstyletable() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.conditionalstyletable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.conditionalstyletable_ = p;
  }
  return _impl_.conditionalstyletable_;
}
inline ::TSP::Reference* DataStore::mutable_conditionalstyletable() {
  ::TSP::Reference* _msg = _internal_mutable_conditionalstyletable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.conditionalstyletable)
  return _msg;
}
inline void DataStore::set_allocated_conditionalstyletable(::TSP::Reference* conditionalstyletable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditionalstyletable_);
  }
  if (conditionalstyletable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conditionalstyletable));
    if (message_arena != submessage_arena) {
      conditionalstyletable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditionalstyletable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.conditionalstyletable_ = conditionalstyletable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.conditionalstyletable)
}

// optional .TSP.Reference commentStorageTable = 19;
inline bool DataStore::_internal_has_commentstoragetable() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commentstoragetable_ != nullptr);
  return value;
}
inline bool DataStore::has_commentstoragetable() const {
  return _internal_has_commentstoragetable();
}
inline const ::TSP::Reference& DataStore::_internal_commentstoragetable() const {
  const ::TSP::Reference* p = _impl_.commentstoragetable_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DataStore::commentstoragetable() const {
  // @@protoc_insertion_point(field_get:TST.DataStore.commentStorageTable)
  return _internal_commentstoragetable();
}
inline void DataStore::unsafe_arena_set_allocated_commentstoragetable(
    ::TSP::Reference* commentstoragetable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commentstoragetable_);
  }
  _impl_.commentstoragetable_ = commentstoragetable;
  if (commentstoragetable) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DataStore.commentStorageTable)
}
inline ::TSP::Reference* DataStore::release_commentstoragetable() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.commentstoragetable_;
  _impl_.commentstoragetable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DataStore::unsafe_arena_release_commentstoragetable() {
  // @@protoc_insertion_point(field_release:TST.DataStore.commentStorageTable)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.commentstoragetable_;
  _impl_.commentstoragetable_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DataStore::_internal_mutable_commentstoragetable() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.commentstoragetable_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.commentstoragetable_ = p;
  }
  return _impl_.commentstoragetable_;
}
inline ::TSP::Reference* DataStore::mutable_commentstoragetable() {
  ::TSP::Reference* _msg = _internal_mutable_commentstoragetable();
  // @@protoc_insertion_point(field_mutable:TST.DataStore.commentStorageTable)
  return _msg;
}
inline void DataStore::set_allocated_commentstoragetable(::TSP::Reference* commentstoragetable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commentstoragetable_);
  }
  if (commentstoragetable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commentstoragetable));
    if (message_arena != submessage_arena) {
      commentstoragetable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commentstoragetable, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.commentstoragetable_ = commentstoragetable;
  // @@protoc_insertion_point(field_set_allocated:TST.DataStore.commentStorageTable)
}

// -------------------------------------------------------------------

// TableInfoArchive

// required .TSD.DrawableArchive super = 1;
inline bool TableInfoArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TableInfoArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSD::DrawableArchive& TableInfoArchive::_internal_super() const {
  const ::TSD::DrawableArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSD::DrawableArchive&>(
      ::TSD::_DrawableArchive_default_instance_);
}
inline const ::TSD::DrawableArchive& TableInfoArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.TableInfoArchive.super)
  return _internal_super();
}
inline void TableInfoArchive::unsafe_arena_set_allocated_super(
    ::TSD::DrawableArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableInfoArchive.super)
}
inline ::TSD::DrawableArchive* TableInfoArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSD::DrawableArchive* TableInfoArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.TableInfoArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSD::DrawableArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSD::DrawableArchive* TableInfoArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSD::DrawableArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSD::DrawableArchive* TableInfoArchive::mutable_super() {
  ::TSD::DrawableArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.TableInfoArchive.super)
  return _msg;
}
inline void TableInfoArchive::set_allocated_super(::TSD::DrawableArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.TableInfoArchive.super)
}

// required .TSP.Reference tableModel = 2;
inline bool TableInfoArchive::_internal_has_tablemodel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tablemodel_ != nullptr);
  return value;
}
inline bool TableInfoArchive::has_tablemodel() const {
  return _internal_has_tablemodel();
}
inline const ::TSP::Reference& TableInfoArchive::_internal_tablemodel() const {
  const ::TSP::Reference* p = _impl_.tablemodel_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableInfoArchive::tablemodel() const {
  // @@protoc_insertion_point(field_get:TST.TableInfoArchive.tableModel)
  return _internal_tablemodel();
}
inline void TableInfoArchive::unsafe_arena_set_allocated_tablemodel(
    ::TSP::Reference* tablemodel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tablemodel_);
  }
  _impl_.tablemodel_ = tablemodel;
  if (tablemodel) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableInfoArchive.tableModel)
}
inline ::TSP::Reference* TableInfoArchive::release_tablemodel() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.tablemodel_;
  _impl_.tablemodel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableInfoArchive::unsafe_arena_release_tablemodel() {
  // @@protoc_insertion_point(field_release:TST.TableInfoArchive.tableModel)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.tablemodel_;
  _impl_.tablemodel_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableInfoArchive::_internal_mutable_tablemodel() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tablemodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.tablemodel_ = p;
  }
  return _impl_.tablemodel_;
}
inline ::TSP::Reference* TableInfoArchive::mutable_tablemodel() {
  ::TSP::Reference* _msg = _internal_mutable_tablemodel();
  // @@protoc_insertion_point(field_mutable:TST.TableInfoArchive.tableModel)
  return _msg;
}
inline void TableInfoArchive::set_allocated_tablemodel(::TSP::Reference* tablemodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tablemodel_);
  }
  if (tablemodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tablemodel));
    if (message_arena != submessage_arena) {
      tablemodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tablemodel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tablemodel_ = tablemodel;
  // @@protoc_insertion_point(field_set_allocated:TST.TableInfoArchive.tableModel)
}

// optional .TSP.Reference editingState = 3;
inline bool TableInfoArchive::_internal_has_editingstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.editingstate_ != nullptr);
  return value;
}
inline bool TableInfoArchive::has_editingstate() const {
  return _internal_has_editingstate();
}
inline const ::TSP::Reference& TableInfoArchive::_internal_editingstate() const {
  const ::TSP::Reference* p = _impl_.editingstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableInfoArchive::editingstate() const {
  // @@protoc_insertion_point(field_get:TST.TableInfoArchive.editingState)
  return _internal_editingstate();
}
inline void TableInfoArchive::unsafe_arena_set_allocated_editingstate(
    ::TSP::Reference* editingstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingstate_);
  }
  _impl_.editingstate_ = editingstate;
  if (editingstate) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableInfoArchive.editingState)
}
inline ::TSP::Reference* TableInfoArchive::release_editingstate() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.editingstate_;
  _impl_.editingstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableInfoArchive::unsafe_arena_release_editingstate() {
  // @@protoc_insertion_point(field_release:TST.TableInfoArchive.editingState)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.editingstate_;
  _impl_.editingstate_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableInfoArchive::_internal_mutable_editingstate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.editingstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.editingstate_ = p;
  }
  return _impl_.editingstate_;
}
inline ::TSP::Reference* TableInfoArchive::mutable_editingstate() {
  ::TSP::Reference* _msg = _internal_mutable_editingstate();
  // @@protoc_insertion_point(field_mutable:TST.TableInfoArchive.editingState)
  return _msg;
}
inline void TableInfoArchive::set_allocated_editingstate(::TSP::Reference* editingstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingstate_);
  }
  if (editingstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(editingstate));
    if (message_arena != submessage_arena) {
      editingstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editingstate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.editingstate_ = editingstate;
  // @@protoc_insertion_point(field_set_allocated:TST.TableInfoArchive.editingState)
}

// -------------------------------------------------------------------

// EditingStateArchive

// optional .TSP.Reference editingStorage = 1;
inline bool EditingStateArchive::_internal_has_editingstorage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.editingstorage_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_editingstorage() const {
  return _internal_has_editingstorage();
}
inline const ::TSP::Reference& EditingStateArchive::_internal_editingstorage() const {
  const ::TSP::Reference* p = _impl_.editingstorage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& EditingStateArchive::editingstorage() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.editingStorage)
  return _internal_editingstorage();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_editingstorage(
    ::TSP::Reference* editingstorage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingstorage_);
  }
  _impl_.editingstorage_ = editingstorage;
  if (editingstorage) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.editingStorage)
}
inline ::TSP::Reference* EditingStateArchive::release_editingstorage() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.editingstorage_;
  _impl_.editingstorage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* EditingStateArchive::unsafe_arena_release_editingstorage() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.editingStorage)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.editingstorage_;
  _impl_.editingstorage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* EditingStateArchive::_internal_mutable_editingstorage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.editingstorage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.editingstorage_ = p;
  }
  return _impl_.editingstorage_;
}
inline ::TSP::Reference* EditingStateArchive::mutable_editingstorage() {
  ::TSP::Reference* _msg = _internal_mutable_editingstorage();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.editingStorage)
  return _msg;
}
inline void EditingStateArchive::set_allocated_editingstorage(::TSP::Reference* editingstorage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingstorage_);
  }
  if (editingstorage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(editingstorage));
    if (message_arena != submessage_arena) {
      editingstorage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editingstorage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.editingstorage_ = editingstorage;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.editingStorage)
}

// required .TST.Cell editingCell = 2;
inline bool EditingStateArchive::_internal_has_editingcell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.editingcell_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_editingcell() const {
  return _internal_has_editingcell();
}
inline void EditingStateArchive::clear_editingcell() {
  if (_impl_.editingcell_ != nullptr) _impl_.editingcell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::Cell& EditingStateArchive::_internal_editingcell() const {
  const ::TST::Cell* p = _impl_.editingcell_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::Cell&>(
      ::TST::_Cell_default_instance_);
}
inline const ::TST::Cell& EditingStateArchive::editingcell() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.editingCell)
  return _internal_editingcell();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_editingcell(
    ::TST::Cell* editingcell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingcell_);
  }
  _impl_.editingcell_ = editingcell;
  if (editingcell) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.editingCell)
}
inline ::TST::Cell* EditingStateArchive::release_editingcell() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::Cell* temp = _impl_.editingcell_;
  _impl_.editingcell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::Cell* EditingStateArchive::unsafe_arena_release_editingcell() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.editingCell)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::Cell* temp = _impl_.editingcell_;
  _impl_.editingcell_ = nullptr;
  return temp;
}
inline ::TST::Cell* EditingStateArchive::_internal_mutable_editingcell() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.editingcell_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::Cell>(GetArenaForAllocation());
    _impl_.editingcell_ = p;
  }
  return _impl_.editingcell_;
}
inline ::TST::Cell* EditingStateArchive::mutable_editingcell() {
  ::TST::Cell* _msg = _internal_mutable_editingcell();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.editingCell)
  return _msg;
}
inline void EditingStateArchive::set_allocated_editingcell(::TST::Cell* editingcell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.editingcell_;
  }
  if (editingcell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(editingcell);
    if (message_arena != submessage_arena) {
      editingcell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editingcell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.editingcell_ = editingcell;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.editingCell)
}

// optional .TST.SelectionArchive selection = 3;
inline bool EditingStateArchive::_internal_has_selection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selection_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_selection() const {
  return _internal_has_selection();
}
inline void EditingStateArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TST::SelectionArchive& EditingStateArchive::_internal_selection() const {
  const ::TST::SelectionArchive* p = _impl_.selection_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::SelectionArchive&>(
      ::TST::_SelectionArchive_default_instance_);
}
inline const ::TST::SelectionArchive& EditingStateArchive::selection() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.selection)
  return _internal_selection();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_selection(
    ::TST::SelectionArchive* selection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selection_);
  }
  _impl_.selection_ = selection;
  if (selection) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.selection)
}
inline ::TST::SelectionArchive* EditingStateArchive::release_selection() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::SelectionArchive* temp = _impl_.selection_;
  _impl_.selection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::SelectionArchive* EditingStateArchive::unsafe_arena_release_selection() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.selection)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::SelectionArchive* temp = _impl_.selection_;
  _impl_.selection_ = nullptr;
  return temp;
}
inline ::TST::SelectionArchive* EditingStateArchive::_internal_mutable_selection() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.selection_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::SelectionArchive>(GetArenaForAllocation());
    _impl_.selection_ = p;
  }
  return _impl_.selection_;
}
inline ::TST::SelectionArchive* EditingStateArchive::mutable_selection() {
  ::TST::SelectionArchive* _msg = _internal_mutable_selection();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.selection)
  return _msg;
}
inline void EditingStateArchive::set_allocated_selection(::TST::SelectionArchive* selection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selection_;
  }
  if (selection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selection);
    if (message_arena != submessage_arena) {
      selection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selection, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.selection_ = selection;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.selection)
}

// optional .TST.CellID lasteditingcellid = 4;
inline bool EditingStateArchive::_internal_has_lasteditingcellid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lasteditingcellid_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_lasteditingcellid() const {
  return _internal_has_lasteditingcellid();
}
inline void EditingStateArchive::clear_lasteditingcellid() {
  if (_impl_.lasteditingcellid_ != nullptr) _impl_.lasteditingcellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::TST::CellID& EditingStateArchive::_internal_lasteditingcellid() const {
  const ::TST::CellID* p = _impl_.lasteditingcellid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& EditingStateArchive::lasteditingcellid() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.lasteditingcellid)
  return _internal_lasteditingcellid();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_lasteditingcellid(
    ::TST::CellID* lasteditingcellid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lasteditingcellid_);
  }
  _impl_.lasteditingcellid_ = lasteditingcellid;
  if (lasteditingcellid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.lasteditingcellid)
}
inline ::TST::CellID* EditingStateArchive::release_lasteditingcellid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TST::CellID* temp = _impl_.lasteditingcellid_;
  _impl_.lasteditingcellid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* EditingStateArchive::unsafe_arena_release_lasteditingcellid() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.lasteditingcellid)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TST::CellID* temp = _impl_.lasteditingcellid_;
  _impl_.lasteditingcellid_ = nullptr;
  return temp;
}
inline ::TST::CellID* EditingStateArchive::_internal_mutable_lasteditingcellid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.lasteditingcellid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.lasteditingcellid_ = p;
  }
  return _impl_.lasteditingcellid_;
}
inline ::TST::CellID* EditingStateArchive::mutable_lasteditingcellid() {
  ::TST::CellID* _msg = _internal_mutable_lasteditingcellid();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.lasteditingcellid)
  return _msg;
}
inline void EditingStateArchive::set_allocated_lasteditingcellid(::TST::CellID* lasteditingcellid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lasteditingcellid_;
  }
  if (lasteditingcellid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lasteditingcellid);
    if (message_arena != submessage_arena) {
      lasteditingcellid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lasteditingcellid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.lasteditingcellid_ = lasteditingcellid;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.lasteditingcellid)
}

// optional .TST.CellID editingcellid = 5;
inline bool EditingStateArchive::_internal_has_editingcellid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.editingcellid_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_editingcellid() const {
  return _internal_has_editingcellid();
}
inline void EditingStateArchive::clear_editingcellid() {
  if (_impl_.editingcellid_ != nullptr) _impl_.editingcellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TST::CellID& EditingStateArchive::_internal_editingcellid() const {
  const ::TST::CellID* p = _impl_.editingcellid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& EditingStateArchive::editingcellid() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.editingcellid)
  return _internal_editingcellid();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_editingcellid(
    ::TST::CellID* editingcellid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.editingcellid_);
  }
  _impl_.editingcellid_ = editingcellid;
  if (editingcellid) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.editingcellid)
}
inline ::TST::CellID* EditingStateArchive::release_editingcellid() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::CellID* temp = _impl_.editingcellid_;
  _impl_.editingcellid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* EditingStateArchive::unsafe_arena_release_editingcellid() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.editingcellid)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::CellID* temp = _impl_.editingcellid_;
  _impl_.editingcellid_ = nullptr;
  return temp;
}
inline ::TST::CellID* EditingStateArchive::_internal_mutable_editingcellid() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.editingcellid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.editingcellid_ = p;
  }
  return _impl_.editingcellid_;
}
inline ::TST::CellID* EditingStateArchive::mutable_editingcellid() {
  ::TST::CellID* _msg = _internal_mutable_editingcellid();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.editingcellid)
  return _msg;
}
inline void EditingStateArchive::set_allocated_editingcellid(::TST::CellID* editingcellid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.editingcellid_;
  }
  if (editingcellid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(editingcellid);
    if (message_arena != submessage_arena) {
      editingcellid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, editingcellid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.editingcellid_ = editingcellid;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.editingcellid)
}

// optional .TSWP.UndoTransaction deprecated_setup_textUndoRedoTransaction = 6;
inline bool EditingStateArchive::_internal_has_deprecated_setup_textundoredotransaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deprecated_setup_textundoredotransaction_ != nullptr);
  return value;
}
inline bool EditingStateArchive::has_deprecated_setup_textundoredotransaction() const {
  return _internal_has_deprecated_setup_textundoredotransaction();
}
inline const ::TSWP::UndoTransaction& EditingStateArchive::_internal_deprecated_setup_textundoredotransaction() const {
  const ::TSWP::UndoTransaction* p = _impl_.deprecated_setup_textundoredotransaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UndoTransaction&>(
      ::TSWP::_UndoTransaction_default_instance_);
}
inline const ::TSWP::UndoTransaction& EditingStateArchive::deprecated_setup_textundoredotransaction() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.deprecated_setup_textUndoRedoTransaction)
  return _internal_deprecated_setup_textundoredotransaction();
}
inline void EditingStateArchive::unsafe_arena_set_allocated_deprecated_setup_textundoredotransaction(
    ::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_setup_textundoredotransaction_);
  }
  _impl_.deprecated_setup_textundoredotransaction_ = deprecated_setup_textundoredotransaction;
  if (deprecated_setup_textundoredotransaction) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EditingStateArchive.deprecated_setup_textUndoRedoTransaction)
}
inline ::TSWP::UndoTransaction* EditingStateArchive::release_deprecated_setup_textundoredotransaction() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSWP::UndoTransaction* temp = _impl_.deprecated_setup_textundoredotransaction_;
  _impl_.deprecated_setup_textundoredotransaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UndoTransaction* EditingStateArchive::unsafe_arena_release_deprecated_setup_textundoredotransaction() {
  // @@protoc_insertion_point(field_release:TST.EditingStateArchive.deprecated_setup_textUndoRedoTransaction)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSWP::UndoTransaction* temp = _impl_.deprecated_setup_textundoredotransaction_;
  _impl_.deprecated_setup_textundoredotransaction_ = nullptr;
  return temp;
}
inline ::TSWP::UndoTransaction* EditingStateArchive::_internal_mutable_deprecated_setup_textundoredotransaction() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.deprecated_setup_textundoredotransaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UndoTransaction>(GetArenaForAllocation());
    _impl_.deprecated_setup_textundoredotransaction_ = p;
  }
  return _impl_.deprecated_setup_textundoredotransaction_;
}
inline ::TSWP::UndoTransaction* EditingStateArchive::mutable_deprecated_setup_textundoredotransaction() {
  ::TSWP::UndoTransaction* _msg = _internal_mutable_deprecated_setup_textundoredotransaction();
  // @@protoc_insertion_point(field_mutable:TST.EditingStateArchive.deprecated_setup_textUndoRedoTransaction)
  return _msg;
}
inline void EditingStateArchive::set_allocated_deprecated_setup_textundoredotransaction(::TSWP::UndoTransaction* deprecated_setup_textundoredotransaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deprecated_setup_textundoredotransaction_);
  }
  if (deprecated_setup_textundoredotransaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deprecated_setup_textundoredotransaction));
    if (message_arena != submessage_arena) {
      deprecated_setup_textundoredotransaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deprecated_setup_textundoredotransaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.deprecated_setup_textundoredotransaction_ = deprecated_setup_textundoredotransaction;
  // @@protoc_insertion_point(field_set_allocated:TST.EditingStateArchive.deprecated_setup_textUndoRedoTransaction)
}

// optional bool cell_was_edited_in_current_session = 7;
inline bool EditingStateArchive::_internal_has_cell_was_edited_in_current_session() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool EditingStateArchive::has_cell_was_edited_in_current_session() const {
  return _internal_has_cell_was_edited_in_current_session();
}
inline void EditingStateArchive::clear_cell_was_edited_in_current_session() {
  _impl_.cell_was_edited_in_current_session_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool EditingStateArchive::_internal_cell_was_edited_in_current_session() const {
  return _impl_.cell_was_edited_in_current_session_;
}
inline bool EditingStateArchive::cell_was_edited_in_current_session() const {
  // @@protoc_insertion_point(field_get:TST.EditingStateArchive.cell_was_edited_in_current_session)
  return _internal_cell_was_edited_in_current_session();
}
inline void EditingStateArchive::_internal_set_cell_was_edited_in_current_session(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.cell_was_edited_in_current_session_ = value;
}
inline void EditingStateArchive::set_cell_was_edited_in_current_session(bool value) {
  _internal_set_cell_was_edited_in_current_session(value);
  // @@protoc_insertion_point(field_set:TST.EditingStateArchive.cell_was_edited_in_current_session)
}

// -------------------------------------------------------------------

// WPTableInfoArchive

// required .TST.TableInfoArchive super = 1;
inline bool WPTableInfoArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool WPTableInfoArchive::has_super() const {
  return _internal_has_super();
}
inline void WPTableInfoArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::TableInfoArchive& WPTableInfoArchive::_internal_super() const {
  const ::TST::TableInfoArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TableInfoArchive&>(
      ::TST::_TableInfoArchive_default_instance_);
}
inline const ::TST::TableInfoArchive& WPTableInfoArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.WPTableInfoArchive.super)
  return _internal_super();
}
inline void WPTableInfoArchive::unsafe_arena_set_allocated_super(
    ::TST::TableInfoArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.WPTableInfoArchive.super)
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::TableInfoArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.WPTableInfoArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::TableInfoArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TableInfoArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::TableInfoArchive* WPTableInfoArchive::mutable_super() {
  ::TST::TableInfoArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.WPTableInfoArchive.super)
  return _msg;
}
inline void WPTableInfoArchive::set_allocated_super(::TST::TableInfoArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.WPTableInfoArchive.super)
}

// optional .TSP.Reference storage = 2;
inline bool WPTableInfoArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool WPTableInfoArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& WPTableInfoArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& WPTableInfoArchive::storage() const {
  // @@protoc_insertion_point(field_get:TST.WPTableInfoArchive.storage)
  return _internal_storage();
}
inline void WPTableInfoArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.WPTableInfoArchive.storage)
}
inline ::TSP::Reference* WPTableInfoArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* WPTableInfoArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TST.WPTableInfoArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* WPTableInfoArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* WPTableInfoArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TST.WPTableInfoArchive.storage)
  return _msg;
}
inline void WPTableInfoArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TST.WPTableInfoArchive.storage)
}

// -------------------------------------------------------------------

// TableStyleNetworkArchive

// required .TSP.Reference table_style = 9;
inline bool TableStyleNetworkArchive::_internal_has_table_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_table_style() const {
  return _internal_has_table_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_table_style() const {
  const ::TSP::Reference* p = _impl_.table_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.table_style)
  return _internal_table_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_table_style(
    ::TSP::Reference* table_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_style_);
  }
  _impl_.table_style_ = table_style;
  if (table_style) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.table_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_style() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.table_style_;
  _impl_.table_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_table_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.table_style)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.table_style_;
  _impl_.table_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_table_style() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.table_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_style_ = p;
  }
  return _impl_.table_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.table_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_table_style(::TSP::Reference* table_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_style_);
  }
  if (table_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_style));
    if (message_arena != submessage_arena) {
      table_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.table_style_ = table_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.table_style)
}

// required .TSP.Reference body_text_style = 1;
inline bool TableStyleNetworkArchive::_internal_has_body_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_text_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_body_text_style() const {
  return _internal_has_body_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_body_text_style() const {
  const ::TSP::Reference* p = _impl_.body_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::body_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.body_text_style)
  return _internal_body_text_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_body_text_style(
    ::TSP::Reference* body_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_text_style_);
  }
  _impl_.body_text_style_ = body_text_style;
  if (body_text_style) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.body_text_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_body_text_style() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.body_text_style_;
  _impl_.body_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_body_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.body_text_style)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.body_text_style_;
  _impl_.body_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_body_text_style() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.body_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.body_text_style_ = p;
  }
  return _impl_.body_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_body_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_body_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.body_text_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_body_text_style(::TSP::Reference* body_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_text_style_);
  }
  if (body_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_text_style));
    if (message_arena != submessage_arena) {
      body_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.body_text_style_ = body_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.body_text_style)
}

// required .TSP.Reference header_row_text_style = 2;
inline bool TableStyleNetworkArchive::_internal_has_header_row_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_row_text_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_header_row_text_style() const {
  return _internal_has_header_row_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_header_row_text_style() const {
  const ::TSP::Reference* p = _impl_.header_row_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_row_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.header_row_text_style)
  return _internal_header_row_text_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_header_row_text_style(
    ::TSP::Reference* header_row_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_text_style_);
  }
  _impl_.header_row_text_style_ = header_row_text_style;
  if (header_row_text_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.header_row_text_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_row_text_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.header_row_text_style_;
  _impl_.header_row_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_header_row_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.header_row_text_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.header_row_text_style_;
  _impl_.header_row_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_header_row_text_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.header_row_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_row_text_style_ = p;
  }
  return _impl_.header_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_row_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_row_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.header_row_text_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_text_style_);
  }
  if (header_row_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_row_text_style));
    if (message_arena != submessage_arena) {
      header_row_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_row_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_row_text_style_ = header_row_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.header_row_text_style)
}

// required .TSP.Reference header_column_text_style = 3;
inline bool TableStyleNetworkArchive::_internal_has_header_column_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_column_text_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_header_column_text_style() const {
  return _internal_has_header_column_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_header_column_text_style() const {
  const ::TSP::Reference* p = _impl_.header_column_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_column_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.header_column_text_style)
  return _internal_header_column_text_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_header_column_text_style(
    ::TSP::Reference* header_column_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_text_style_);
  }
  _impl_.header_column_text_style_ = header_column_text_style;
  if (header_column_text_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.header_column_text_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_column_text_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.header_column_text_style_;
  _impl_.header_column_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_header_column_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.header_column_text_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.header_column_text_style_;
  _impl_.header_column_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_header_column_text_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.header_column_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_column_text_style_ = p;
  }
  return _impl_.header_column_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_column_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_column_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.header_column_text_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_text_style_);
  }
  if (header_column_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_column_text_style));
    if (message_arena != submessage_arena) {
      header_column_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_column_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.header_column_text_style_ = header_column_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.header_column_text_style)
}

// required .TSP.Reference footer_row_text_style = 4;
inline bool TableStyleNetworkArchive::_internal_has_footer_row_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_row_text_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_footer_row_text_style() const {
  return _internal_has_footer_row_text_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_footer_row_text_style() const {
  const ::TSP::Reference* p = _impl_.footer_row_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::footer_row_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.footer_row_text_style)
  return _internal_footer_row_text_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_footer_row_text_style(
    ::TSP::Reference* footer_row_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_text_style_);
  }
  _impl_.footer_row_text_style_ = footer_row_text_style;
  if (footer_row_text_style) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.footer_row_text_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_footer_row_text_style() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.footer_row_text_style_;
  _impl_.footer_row_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_footer_row_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.footer_row_text_style)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.footer_row_text_style_;
  _impl_.footer_row_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_footer_row_text_style() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.footer_row_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.footer_row_text_style_ = p;
  }
  return _impl_.footer_row_text_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_footer_row_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_footer_row_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.footer_row_text_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_text_style_);
  }
  if (footer_row_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(footer_row_text_style));
    if (message_arena != submessage_arena) {
      footer_row_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer_row_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.footer_row_text_style_ = footer_row_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.footer_row_text_style)
}

// required .TSP.Reference body_cell_style = 5;
inline bool TableStyleNetworkArchive::_internal_has_body_cell_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_cell_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_body_cell_style() const {
  return _internal_has_body_cell_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_body_cell_style() const {
  const ::TSP::Reference* p = _impl_.body_cell_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::body_cell_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.body_cell_style)
  return _internal_body_cell_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_body_cell_style(
    ::TSP::Reference* body_cell_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_cell_style_);
  }
  _impl_.body_cell_style_ = body_cell_style;
  if (body_cell_style) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.body_cell_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_body_cell_style() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.body_cell_style_;
  _impl_.body_cell_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_body_cell_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.body_cell_style)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSP::Reference* temp = _impl_.body_cell_style_;
  _impl_.body_cell_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_body_cell_style() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.body_cell_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.body_cell_style_ = p;
  }
  return _impl_.body_cell_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_body_cell_style() {
  ::TSP::Reference* _msg = _internal_mutable_body_cell_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.body_cell_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_body_cell_style(::TSP::Reference* body_cell_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_cell_style_);
  }
  if (body_cell_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_cell_style));
    if (message_arena != submessage_arena) {
      body_cell_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_cell_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.body_cell_style_ = body_cell_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.body_cell_style)
}

// required .TSP.Reference header_row_style = 6;
inline bool TableStyleNetworkArchive::_internal_has_header_row_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_row_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_header_row_style() const {
  return _internal_has_header_row_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_header_row_style() const {
  const ::TSP::Reference* p = _impl_.header_row_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_row_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.header_row_style)
  return _internal_header_row_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_header_row_style(
    ::TSP::Reference* header_row_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_style_);
  }
  _impl_.header_row_style_ = header_row_style;
  if (header_row_style) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.header_row_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_row_style() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.header_row_style_;
  _impl_.header_row_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_header_row_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.header_row_style)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.header_row_style_;
  _impl_.header_row_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_header_row_style() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.header_row_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_row_style_ = p;
  }
  return _impl_.header_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_row_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_row_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.header_row_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_header_row_style(::TSP::Reference* header_row_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_style_);
  }
  if (header_row_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_row_style));
    if (message_arena != submessage_arena) {
      header_row_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_row_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.header_row_style_ = header_row_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.header_row_style)
}

// required .TSP.Reference header_column_style = 7;
inline bool TableStyleNetworkArchive::_internal_has_header_column_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_column_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_header_column_style() const {
  return _internal_has_header_column_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_header_column_style() const {
  const ::TSP::Reference* p = _impl_.header_column_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::header_column_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.header_column_style)
  return _internal_header_column_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_header_column_style(
    ::TSP::Reference* header_column_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_style_);
  }
  _impl_.header_column_style_ = header_column_style;
  if (header_column_style) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.header_column_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_header_column_style() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.header_column_style_;
  _impl_.header_column_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_header_column_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.header_column_style)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.header_column_style_;
  _impl_.header_column_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_header_column_style() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.header_column_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_column_style_ = p;
  }
  return _impl_.header_column_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_header_column_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_column_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.header_column_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_header_column_style(::TSP::Reference* header_column_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_style_);
  }
  if (header_column_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_column_style));
    if (message_arena != submessage_arena) {
      header_column_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_column_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.header_column_style_ = header_column_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.header_column_style)
}

// required .TSP.Reference footer_row_style = 8;
inline bool TableStyleNetworkArchive::_internal_has_footer_row_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_row_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_footer_row_style() const {
  return _internal_has_footer_row_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_footer_row_style() const {
  const ::TSP::Reference* p = _impl_.footer_row_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::footer_row_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.footer_row_style)
  return _internal_footer_row_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_footer_row_style(
    ::TSP::Reference* footer_row_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_style_);
  }
  _impl_.footer_row_style_ = footer_row_style;
  if (footer_row_style) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.footer_row_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_footer_row_style() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.footer_row_style_;
  _impl_.footer_row_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_footer_row_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.footer_row_style)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.footer_row_style_;
  _impl_.footer_row_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_footer_row_style() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.footer_row_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.footer_row_style_ = p;
  }
  return _impl_.footer_row_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_footer_row_style() {
  ::TSP::Reference* _msg = _internal_mutable_footer_row_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.footer_row_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_footer_row_style(::TSP::Reference* footer_row_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_style_);
  }
  if (footer_row_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(footer_row_style));
    if (message_arena != submessage_arena) {
      footer_row_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer_row_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.footer_row_style_ = footer_row_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.footer_row_style)
}

// optional .TSP.Reference table_name_style = 10;
inline bool TableStyleNetworkArchive::_internal_has_table_name_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_table_name_style() const {
  return _internal_has_table_name_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_table_name_style() const {
  const ::TSP::Reference* p = _impl_.table_name_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_name_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.table_name_style)
  return _internal_table_name_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_table_name_style(
    ::TSP::Reference* table_name_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_style_);
  }
  _impl_.table_name_style_ = table_name_style;
  if (table_name_style) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.table_name_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_name_style() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.table_name_style_;
  _impl_.table_name_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_table_name_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.table_name_style)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.table_name_style_;
  _impl_.table_name_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_table_name_style() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.table_name_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_name_style_ = p;
  }
  return _impl_.table_name_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_name_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_name_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.table_name_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_table_name_style(::TSP::Reference* table_name_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_style_);
  }
  if (table_name_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_style));
    if (message_arena != submessage_arena) {
      table_name_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.table_name_style_ = table_name_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.table_name_style)
}

// optional .TSP.Reference table_name_shape_style = 11;
inline bool TableStyleNetworkArchive::_internal_has_table_name_shape_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_shape_style_ != nullptr);
  return value;
}
inline bool TableStyleNetworkArchive::has_table_name_shape_style() const {
  return _internal_has_table_name_shape_style();
}
inline const ::TSP::Reference& TableStyleNetworkArchive::_internal_table_name_shape_style() const {
  const ::TSP::Reference* p = _impl_.table_name_shape_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableStyleNetworkArchive::table_name_shape_style() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.table_name_shape_style)
  return _internal_table_name_shape_style();
}
inline void TableStyleNetworkArchive::unsafe_arena_set_allocated_table_name_shape_style(
    ::TSP::Reference* table_name_shape_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_shape_style_);
  }
  _impl_.table_name_shape_style_ = table_name_shape_style;
  if (table_name_shape_style) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleNetworkArchive.table_name_shape_style)
}
inline ::TSP::Reference* TableStyleNetworkArchive::release_table_name_shape_style() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Reference* temp = _impl_.table_name_shape_style_;
  _impl_.table_name_shape_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::unsafe_arena_release_table_name_shape_style() {
  // @@protoc_insertion_point(field_release:TST.TableStyleNetworkArchive.table_name_shape_style)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSP::Reference* temp = _impl_.table_name_shape_style_;
  _impl_.table_name_shape_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableStyleNetworkArchive::_internal_mutable_table_name_shape_style() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.table_name_shape_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_name_shape_style_ = p;
  }
  return _impl_.table_name_shape_style_;
}
inline ::TSP::Reference* TableStyleNetworkArchive::mutable_table_name_shape_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_name_shape_style();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleNetworkArchive.table_name_shape_style)
  return _msg;
}
inline void TableStyleNetworkArchive::set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_shape_style_);
  }
  if (table_name_shape_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_shape_style));
    if (message_arena != submessage_arena) {
      table_name_shape_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_shape_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.table_name_shape_style_ = table_name_shape_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleNetworkArchive.table_name_shape_style)
}

// optional uint32 preset_index = 12;
inline bool TableStyleNetworkArchive::_internal_has_preset_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TableStyleNetworkArchive::has_preset_index() const {
  return _internal_has_preset_index();
}
inline void TableStyleNetworkArchive::clear_preset_index() {
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t TableStyleNetworkArchive::_internal_preset_index() const {
  return _impl_.preset_index_;
}
inline uint32_t TableStyleNetworkArchive::preset_index() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleNetworkArchive.preset_index)
  return _internal_preset_index();
}
inline void TableStyleNetworkArchive::_internal_set_preset_index(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.preset_index_ = value;
}
inline void TableStyleNetworkArchive::set_preset_index(uint32_t value) {
  _internal_set_preset_index(value);
  // @@protoc_insertion_point(field_set:TST.TableStyleNetworkArchive.preset_index)
}

// -------------------------------------------------------------------

// TableModelArchive

// required string table_id = 1;
inline bool TableModelArchive::_internal_has_table_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableModelArchive::has_table_id() const {
  return _internal_has_table_id();
}
inline void TableModelArchive::clear_table_id() {
  _impl_.table_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableModelArchive::table_id() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_id)
  return _internal_table_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableModelArchive::set_table_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.table_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.table_id)
}
inline std::string* TableModelArchive::mutable_table_id() {
  std::string* _s = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.table_id)
  return _s;
}
inline const std::string& TableModelArchive::_internal_table_id() const {
  return _impl_.table_id_.Get();
}
inline void TableModelArchive::_internal_set_table_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.table_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TableModelArchive::_internal_mutable_table_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.table_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TableModelArchive::release_table_id() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.table_id)
  if (!_internal_has_table_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.table_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_id_.IsDefault()) {
    _impl_.table_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableModelArchive::set_allocated_table_id(std::string* table_id) {
  if (table_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.table_id_.SetAllocated(table_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_id_.IsDefault()) {
    _impl_.table_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.table_id)
}

// optional string from_table_id = 43;
inline bool TableModelArchive::_internal_has_from_table_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableModelArchive::has_from_table_id() const {
  return _internal_has_from_table_id();
}
inline void TableModelArchive::clear_from_table_id() {
  _impl_.from_table_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TableModelArchive::from_table_id() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.from_table_id)
  return _internal_from_table_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableModelArchive::set_from_table_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.from_table_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.from_table_id)
}
inline std::string* TableModelArchive::mutable_from_table_id() {
  std::string* _s = _internal_mutable_from_table_id();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.from_table_id)
  return _s;
}
inline const std::string& TableModelArchive::_internal_from_table_id() const {
  return _impl_.from_table_id_.Get();
}
inline void TableModelArchive::_internal_set_from_table_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_table_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TableModelArchive::_internal_mutable_from_table_id() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.from_table_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TableModelArchive::release_from_table_id() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.from_table_id)
  if (!_internal_has_from_table_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.from_table_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_table_id_.IsDefault()) {
    _impl_.from_table_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableModelArchive::set_allocated_from_table_id(std::string* from_table_id) {
  if (from_table_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.from_table_id_.SetAllocated(from_table_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_table_id_.IsDefault()) {
    _impl_.from_table_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.from_table_id)
}

// required .TSP.Reference table_style = 3;
inline bool TableModelArchive::_internal_has_table_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_table_style() const {
  return _internal_has_table_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_table_style() const {
  const ::TSP::Reference* p = _impl_.table_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::table_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_style)
  return _internal_table_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_table_style(
    ::TSP::Reference* table_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_style_);
  }
  _impl_.table_style_ = table_style;
  if (table_style) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.table_style)
}
inline ::TSP::Reference* TableModelArchive::release_table_style() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.table_style_;
  _impl_.table_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_table_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.table_style)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Reference* temp = _impl_.table_style_;
  _impl_.table_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_table_style() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.table_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_style_ = p;
  }
  return _impl_.table_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.table_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_table_style(::TSP::Reference* table_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_style_);
  }
  if (table_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_style));
    if (message_arena != submessage_arena) {
      table_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.table_style_ = table_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.table_style)
}

// required .TSP.Reference body_text_style = 24;
inline bool TableModelArchive::_internal_has_body_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_text_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_body_text_style() const {
  return _internal_has_body_text_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_body_text_style() const {
  const ::TSP::Reference* p = _impl_.body_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::body_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.body_text_style)
  return _internal_body_text_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_body_text_style(
    ::TSP::Reference* body_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_text_style_);
  }
  _impl_.body_text_style_ = body_text_style;
  if (body_text_style) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.body_text_style)
}
inline ::TSP::Reference* TableModelArchive::release_body_text_style() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::Reference* temp = _impl_.body_text_style_;
  _impl_.body_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_body_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.body_text_style)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSP::Reference* temp = _impl_.body_text_style_;
  _impl_.body_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_body_text_style() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.body_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.body_text_style_ = p;
  }
  return _impl_.body_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_body_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_body_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.body_text_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_body_text_style(::TSP::Reference* body_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_text_style_);
  }
  if (body_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_text_style));
    if (message_arena != submessage_arena) {
      body_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.body_text_style_ = body_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.body_text_style)
}

// required .TSP.Reference header_row_text_style = 25;
inline bool TableModelArchive::_internal_has_header_row_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_row_text_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_header_row_text_style() const {
  return _internal_has_header_row_text_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_header_row_text_style() const {
  const ::TSP::Reference* p = _impl_.header_row_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::header_row_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_row_text_style)
  return _internal_header_row_text_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_header_row_text_style(
    ::TSP::Reference* header_row_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_text_style_);
  }
  _impl_.header_row_text_style_ = header_row_text_style;
  if (header_row_text_style) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.header_row_text_style)
}
inline ::TSP::Reference* TableModelArchive::release_header_row_text_style() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSP::Reference* temp = _impl_.header_row_text_style_;
  _impl_.header_row_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_header_row_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.header_row_text_style)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSP::Reference* temp = _impl_.header_row_text_style_;
  _impl_.header_row_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_header_row_text_style() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.header_row_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_row_text_style_ = p;
  }
  return _impl_.header_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_row_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_row_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.header_row_text_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_header_row_text_style(::TSP::Reference* header_row_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_text_style_);
  }
  if (header_row_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_row_text_style));
    if (message_arena != submessage_arena) {
      header_row_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_row_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.header_row_text_style_ = header_row_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.header_row_text_style)
}

// required .TSP.Reference header_column_text_style = 26;
inline bool TableModelArchive::_internal_has_header_column_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_column_text_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_header_column_text_style() const {
  return _internal_has_header_column_text_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_header_column_text_style() const {
  const ::TSP::Reference* p = _impl_.header_column_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::header_column_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_column_text_style)
  return _internal_header_column_text_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_header_column_text_style(
    ::TSP::Reference* header_column_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_text_style_);
  }
  _impl_.header_column_text_style_ = header_column_text_style;
  if (header_column_text_style) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.header_column_text_style)
}
inline ::TSP::Reference* TableModelArchive::release_header_column_text_style() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::Reference* temp = _impl_.header_column_text_style_;
  _impl_.header_column_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_header_column_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.header_column_text_style)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSP::Reference* temp = _impl_.header_column_text_style_;
  _impl_.header_column_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_header_column_text_style() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.header_column_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_column_text_style_ = p;
  }
  return _impl_.header_column_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_column_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_column_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.header_column_text_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_header_column_text_style(::TSP::Reference* header_column_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_text_style_);
  }
  if (header_column_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_column_text_style));
    if (message_arena != submessage_arena) {
      header_column_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_column_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.header_column_text_style_ = header_column_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.header_column_text_style)
}

// required .TSP.Reference footer_row_text_style = 27;
inline bool TableModelArchive::_internal_has_footer_row_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_row_text_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_footer_row_text_style() const {
  return _internal_has_footer_row_text_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_footer_row_text_style() const {
  const ::TSP::Reference* p = _impl_.footer_row_text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::footer_row_text_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.footer_row_text_style)
  return _internal_footer_row_text_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_footer_row_text_style(
    ::TSP::Reference* footer_row_text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_text_style_);
  }
  _impl_.footer_row_text_style_ = footer_row_text_style;
  if (footer_row_text_style) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.footer_row_text_style)
}
inline ::TSP::Reference* TableModelArchive::release_footer_row_text_style() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.footer_row_text_style_;
  _impl_.footer_row_text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_footer_row_text_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.footer_row_text_style)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.footer_row_text_style_;
  _impl_.footer_row_text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_footer_row_text_style() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.footer_row_text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.footer_row_text_style_ = p;
  }
  return _impl_.footer_row_text_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_footer_row_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_footer_row_text_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.footer_row_text_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_footer_row_text_style(::TSP::Reference* footer_row_text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_text_style_);
  }
  if (footer_row_text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(footer_row_text_style));
    if (message_arena != submessage_arena) {
      footer_row_text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer_row_text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.footer_row_text_style_ = footer_row_text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.footer_row_text_style)
}

// required .TSP.Reference body_cell_style = 18;
inline bool TableModelArchive::_internal_has_body_cell_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.body_cell_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_body_cell_style() const {
  return _internal_has_body_cell_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_body_cell_style() const {
  const ::TSP::Reference* p = _impl_.body_cell_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::body_cell_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.body_cell_style)
  return _internal_body_cell_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_body_cell_style(
    ::TSP::Reference* body_cell_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_cell_style_);
  }
  _impl_.body_cell_style_ = body_cell_style;
  if (body_cell_style) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.body_cell_style)
}
inline ::TSP::Reference* TableModelArchive::release_body_cell_style() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.body_cell_style_;
  _impl_.body_cell_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_body_cell_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.body_cell_style)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSP::Reference* temp = _impl_.body_cell_style_;
  _impl_.body_cell_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_body_cell_style() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.body_cell_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.body_cell_style_ = p;
  }
  return _impl_.body_cell_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_body_cell_style() {
  ::TSP::Reference* _msg = _internal_mutable_body_cell_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.body_cell_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_body_cell_style(::TSP::Reference* body_cell_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.body_cell_style_);
  }
  if (body_cell_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_cell_style));
    if (message_arena != submessage_arena) {
      body_cell_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_cell_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.body_cell_style_ = body_cell_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.body_cell_style)
}

// required .TSP.Reference header_row_style = 19;
inline bool TableModelArchive::_internal_has_header_row_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_row_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_header_row_style() const {
  return _internal_has_header_row_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_header_row_style() const {
  const ::TSP::Reference* p = _impl_.header_row_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::header_row_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_row_style)
  return _internal_header_row_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_header_row_style(
    ::TSP::Reference* header_row_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_style_);
  }
  _impl_.header_row_style_ = header_row_style;
  if (header_row_style) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.header_row_style)
}
inline ::TSP::Reference* TableModelArchive::release_header_row_style() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.header_row_style_;
  _impl_.header_row_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_header_row_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.header_row_style)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSP::Reference* temp = _impl_.header_row_style_;
  _impl_.header_row_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_header_row_style() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.header_row_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_row_style_ = p;
  }
  return _impl_.header_row_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_row_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_row_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.header_row_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_header_row_style(::TSP::Reference* header_row_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_row_style_);
  }
  if (header_row_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_row_style));
    if (message_arena != submessage_arena) {
      header_row_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_row_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.header_row_style_ = header_row_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.header_row_style)
}

// required .TSP.Reference header_column_style = 20;
inline bool TableModelArchive::_internal_has_header_column_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_column_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_header_column_style() const {
  return _internal_has_header_column_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_header_column_style() const {
  const ::TSP::Reference* p = _impl_.header_column_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::header_column_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_column_style)
  return _internal_header_column_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_header_column_style(
    ::TSP::Reference* header_column_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_style_);
  }
  _impl_.header_column_style_ = header_column_style;
  if (header_column_style) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.header_column_style)
}
inline ::TSP::Reference* TableModelArchive::release_header_column_style() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.header_column_style_;
  _impl_.header_column_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_header_column_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.header_column_style)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSP::Reference* temp = _impl_.header_column_style_;
  _impl_.header_column_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_header_column_style() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.header_column_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.header_column_style_ = p;
  }
  return _impl_.header_column_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_header_column_style() {
  ::TSP::Reference* _msg = _internal_mutable_header_column_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.header_column_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_header_column_style(::TSP::Reference* header_column_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_column_style_);
  }
  if (header_column_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_column_style));
    if (message_arena != submessage_arena) {
      header_column_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_column_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.header_column_style_ = header_column_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.header_column_style)
}

// required .TSP.Reference footer_row_style = 21;
inline bool TableModelArchive::_internal_has_footer_row_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_row_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_footer_row_style() const {
  return _internal_has_footer_row_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_footer_row_style() const {
  const ::TSP::Reference* p = _impl_.footer_row_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::footer_row_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.footer_row_style)
  return _internal_footer_row_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_footer_row_style(
    ::TSP::Reference* footer_row_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_style_);
  }
  _impl_.footer_row_style_ = footer_row_style;
  if (footer_row_style) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.footer_row_style)
}
inline ::TSP::Reference* TableModelArchive::release_footer_row_style() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.footer_row_style_;
  _impl_.footer_row_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_footer_row_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.footer_row_style)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSP::Reference* temp = _impl_.footer_row_style_;
  _impl_.footer_row_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_footer_row_style() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.footer_row_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.footer_row_style_ = p;
  }
  return _impl_.footer_row_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_footer_row_style() {
  ::TSP::Reference* _msg = _internal_mutable_footer_row_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.footer_row_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_footer_row_style(::TSP::Reference* footer_row_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_row_style_);
  }
  if (footer_row_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(footer_row_style));
    if (message_arena != submessage_arena) {
      footer_row_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer_row_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.footer_row_style_ = footer_row_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.footer_row_style)
}

// optional .TSP.Reference table_name_style = 30;
inline bool TableModelArchive::_internal_has_table_name_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_table_name_style() const {
  return _internal_has_table_name_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_table_name_style() const {
  const ::TSP::Reference* p = _impl_.table_name_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::table_name_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name_style)
  return _internal_table_name_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_table_name_style(
    ::TSP::Reference* table_name_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_style_);
  }
  _impl_.table_name_style_ = table_name_style;
  if (table_name_style) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.table_name_style)
}
inline ::TSP::Reference* TableModelArchive::release_table_name_style() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.table_name_style_;
  _impl_.table_name_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_table_name_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.table_name_style)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.table_name_style_;
  _impl_.table_name_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_table_name_style() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.table_name_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_name_style_ = p;
  }
  return _impl_.table_name_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_name_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_name_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.table_name_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_table_name_style(::TSP::Reference* table_name_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_style_);
  }
  if (table_name_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_style));
    if (message_arena != submessage_arena) {
      table_name_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.table_name_style_ = table_name_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.table_name_style)
}

// optional .TSP.Reference table_name_shape_style = 36;
inline bool TableModelArchive::_internal_has_table_name_shape_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_shape_style_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_table_name_shape_style() const {
  return _internal_has_table_name_shape_style();
}
inline const ::TSP::Reference& TableModelArchive::_internal_table_name_shape_style() const {
  const ::TSP::Reference* p = _impl_.table_name_shape_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::table_name_shape_style() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name_shape_style)
  return _internal_table_name_shape_style();
}
inline void TableModelArchive::unsafe_arena_set_allocated_table_name_shape_style(
    ::TSP::Reference* table_name_shape_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_shape_style_);
  }
  _impl_.table_name_shape_style_ = table_name_shape_style;
  if (table_name_shape_style) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.table_name_shape_style)
}
inline ::TSP::Reference* TableModelArchive::release_table_name_shape_style() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::TSP::Reference* temp = _impl_.table_name_shape_style_;
  _impl_.table_name_shape_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_table_name_shape_style() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.table_name_shape_style)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::TSP::Reference* temp = _impl_.table_name_shape_style_;
  _impl_.table_name_shape_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_table_name_shape_style() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.table_name_shape_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.table_name_shape_style_ = p;
  }
  return _impl_.table_name_shape_style_;
}
inline ::TSP::Reference* TableModelArchive::mutable_table_name_shape_style() {
  ::TSP::Reference* _msg = _internal_mutable_table_name_shape_style();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.table_name_shape_style)
  return _msg;
}
inline void TableModelArchive::set_allocated_table_name_shape_style(::TSP::Reference* table_name_shape_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_shape_style_);
  }
  if (table_name_shape_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_shape_style));
    if (message_arena != submessage_arena) {
      table_name_shape_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_shape_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.table_name_shape_style_ = table_name_shape_style;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.table_name_shape_style)
}

// required .TST.DataStore data_store = 4;
inline bool TableModelArchive::_internal_has_data_store() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_store_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_data_store() const {
  return _internal_has_data_store();
}
inline void TableModelArchive::clear_data_store() {
  if (_impl_.data_store_ != nullptr) _impl_.data_store_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::TST::DataStore& TableModelArchive::_internal_data_store() const {
  const ::TST::DataStore* p = _impl_.data_store_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::DataStore&>(
      ::TST::_DataStore_default_instance_);
}
inline const ::TST::DataStore& TableModelArchive::data_store() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.data_store)
  return _internal_data_store();
}
inline void TableModelArchive::unsafe_arena_set_allocated_data_store(
    ::TST::DataStore* data_store) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_store_);
  }
  _impl_.data_store_ = data_store;
  if (data_store) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.data_store)
}
inline ::TST::DataStore* TableModelArchive::release_data_store() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::DataStore* temp = _impl_.data_store_;
  _impl_.data_store_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::DataStore* TableModelArchive::unsafe_arena_release_data_store() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.data_store)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TST::DataStore* temp = _impl_.data_store_;
  _impl_.data_store_ = nullptr;
  return temp;
}
inline ::TST::DataStore* TableModelArchive::_internal_mutable_data_store() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.data_store_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::DataStore>(GetArenaForAllocation());
    _impl_.data_store_ = p;
  }
  return _impl_.data_store_;
}
inline ::TST::DataStore* TableModelArchive::mutable_data_store() {
  ::TST::DataStore* _msg = _internal_mutable_data_store();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.data_store)
  return _msg;
}
inline void TableModelArchive::set_allocated_data_store(::TST::DataStore* data_store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_store_;
  }
  if (data_store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data_store);
    if (message_arena != submessage_arena) {
      data_store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_store, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.data_store_ = data_store;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.data_store)
}

// optional .TSP.Reference provider = 5;
inline bool TableModelArchive::_internal_has_provider() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.provider_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_provider() const {
  return _internal_has_provider();
}
inline const ::TSP::Reference& TableModelArchive::_internal_provider() const {
  const ::TSP::Reference* p = _impl_.provider_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::provider() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.provider)
  return _internal_provider();
}
inline void TableModelArchive::unsafe_arena_set_allocated_provider(
    ::TSP::Reference* provider) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.provider_);
  }
  _impl_.provider_ = provider;
  if (provider) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.provider)
}
inline ::TSP::Reference* TableModelArchive::release_provider() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.provider_;
  _impl_.provider_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_provider() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.provider)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.provider_;
  _impl_.provider_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_provider() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.provider_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.provider_ = p;
  }
  return _impl_.provider_;
}
inline ::TSP::Reference* TableModelArchive::mutable_provider() {
  ::TSP::Reference* _msg = _internal_mutable_provider();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.provider)
  return _msg;
}
inline void TableModelArchive::set_allocated_provider(::TSP::Reference* provider) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.provider_);
  }
  if (provider) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(provider));
    if (message_arena != submessage_arena) {
      provider = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, provider, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.provider_ = provider;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.provider)
}

// required uint32 number_of_rows = 6;
inline bool TableModelArchive::_internal_has_number_of_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_rows() const {
  return _internal_has_number_of_rows();
}
inline void TableModelArchive::clear_number_of_rows() {
  _impl_.number_of_rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t TableModelArchive::_internal_number_of_rows() const {
  return _impl_.number_of_rows_;
}
inline uint32_t TableModelArchive::number_of_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_rows)
  return _internal_number_of_rows();
}
inline void TableModelArchive::_internal_set_number_of_rows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.number_of_rows_ = value;
}
inline void TableModelArchive::set_number_of_rows(uint32_t value) {
  _internal_set_number_of_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_rows)
}

// required uint32 number_of_columns = 7;
inline bool TableModelArchive::_internal_has_number_of_columns() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_columns() const {
  return _internal_has_number_of_columns();
}
inline void TableModelArchive::clear_number_of_columns() {
  _impl_.number_of_columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t TableModelArchive::_internal_number_of_columns() const {
  return _impl_.number_of_columns_;
}
inline uint32_t TableModelArchive::number_of_columns() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_columns)
  return _internal_number_of_columns();
}
inline void TableModelArchive::_internal_set_number_of_columns(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.number_of_columns_ = value;
}
inline void TableModelArchive::set_number_of_columns(uint32_t value) {
  _internal_set_number_of_columns(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_columns)
}

// required string table_name = 8;
inline bool TableModelArchive::_internal_has_table_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableModelArchive::has_table_name() const {
  return _internal_has_table_name();
}
inline void TableModelArchive::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TableModelArchive::table_name() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableModelArchive::set_table_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.table_name)
}
inline std::string* TableModelArchive::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.table_name)
  return _s;
}
inline const std::string& TableModelArchive::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TableModelArchive::_internal_set_table_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableModelArchive::_internal_mutable_table_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableModelArchive::release_table_name() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.table_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TableModelArchive::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.table_name)
}

// optional bool table_name_enabled = 22;
inline bool TableModelArchive::_internal_has_table_name_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_table_name_enabled() const {
  return _internal_has_table_name_enabled();
}
inline void TableModelArchive::clear_table_name_enabled() {
  _impl_.table_name_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool TableModelArchive::_internal_table_name_enabled() const {
  return _impl_.table_name_enabled_;
}
inline bool TableModelArchive::table_name_enabled() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name_enabled)
  return _internal_table_name_enabled();
}
inline void TableModelArchive::_internal_set_table_name_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.table_name_enabled_ = value;
}
inline void TableModelArchive::set_table_name_enabled(bool value) {
  _internal_set_table_name_enabled(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.table_name_enabled)
}

// optional double table_name_height = 33;
inline bool TableModelArchive::_internal_has_table_name_height() const {
  bool value = (_impl_._has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool TableModelArchive::has_table_name_height() const {
  return _internal_has_table_name_height();
}
inline void TableModelArchive::clear_table_name_height() {
  _impl_.table_name_height_ = 0;
  _impl_._has_bits_[1] &= ~0x00000040u;
}
inline double TableModelArchive::_internal_table_name_height() const {
  return _impl_.table_name_height_;
}
inline double TableModelArchive::table_name_height() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name_height)
  return _internal_table_name_height();
}
inline void TableModelArchive::_internal_set_table_name_height(double value) {
  _impl_._has_bits_[1] |= 0x00000040u;
  _impl_.table_name_height_ = value;
}
inline void TableModelArchive::set_table_name_height(double value) {
  _internal_set_table_name_height(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.table_name_height)
}

// optional bool table_name_border_enabled = 37;
inline bool TableModelArchive::_internal_has_table_name_border_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_table_name_border_enabled() const {
  return _internal_has_table_name_border_enabled();
}
inline void TableModelArchive::clear_table_name_border_enabled() {
  _impl_.table_name_border_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool TableModelArchive::_internal_table_name_border_enabled() const {
  return _impl_.table_name_border_enabled_;
}
inline bool TableModelArchive::table_name_border_enabled() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.table_name_border_enabled)
  return _internal_table_name_border_enabled();
}
inline void TableModelArchive::_internal_set_table_name_border_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.table_name_border_enabled_ = value;
}
inline void TableModelArchive::set_table_name_border_enabled(bool value) {
  _internal_set_table_name_border_enabled(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.table_name_border_enabled)
}

// optional uint32 number_of_header_rows = 9;
inline bool TableModelArchive::_internal_has_number_of_header_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_header_rows() const {
  return _internal_has_number_of_header_rows();
}
inline void TableModelArchive::clear_number_of_header_rows() {
  _impl_.number_of_header_rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint32_t TableModelArchive::_internal_number_of_header_rows() const {
  return _impl_.number_of_header_rows_;
}
inline uint32_t TableModelArchive::number_of_header_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_header_rows)
  return _internal_number_of_header_rows();
}
inline void TableModelArchive::_internal_set_number_of_header_rows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.number_of_header_rows_ = value;
}
inline void TableModelArchive::set_number_of_header_rows(uint32_t value) {
  _internal_set_number_of_header_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_header_rows)
}

// optional uint32 number_of_header_columns = 10;
inline bool TableModelArchive::_internal_has_number_of_header_columns() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_header_columns() const {
  return _internal_has_number_of_header_columns();
}
inline void TableModelArchive::clear_number_of_header_columns() {
  _impl_.number_of_header_columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline uint32_t TableModelArchive::_internal_number_of_header_columns() const {
  return _impl_.number_of_header_columns_;
}
inline uint32_t TableModelArchive::number_of_header_columns() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_header_columns)
  return _internal_number_of_header_columns();
}
inline void TableModelArchive::_internal_set_number_of_header_columns(uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.number_of_header_columns_ = value;
}
inline void TableModelArchive::set_number_of_header_columns(uint32_t value) {
  _internal_set_number_of_header_columns(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_header_columns)
}

// optional uint32 number_of_footer_rows = 11;
inline bool TableModelArchive::_internal_has_number_of_footer_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_footer_rows() const {
  return _internal_has_number_of_footer_rows();
}
inline void TableModelArchive::clear_number_of_footer_rows() {
  _impl_.number_of_footer_rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline uint32_t TableModelArchive::_internal_number_of_footer_rows() const {
  return _impl_.number_of_footer_rows_;
}
inline uint32_t TableModelArchive::number_of_footer_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_footer_rows)
  return _internal_number_of_footer_rows();
}
inline void TableModelArchive::_internal_set_number_of_footer_rows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.number_of_footer_rows_ = value;
}
inline void TableModelArchive::set_number_of_footer_rows(uint32_t value) {
  _internal_set_number_of_footer_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_footer_rows)
}

// optional bool header_rows_frozen = 12;
inline bool TableModelArchive::_internal_has_header_rows_frozen() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool TableModelArchive::has_header_rows_frozen() const {
  return _internal_has_header_rows_frozen();
}
inline void TableModelArchive::clear_header_rows_frozen() {
  _impl_.header_rows_frozen_ = false;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool TableModelArchive::_internal_header_rows_frozen() const {
  return _impl_.header_rows_frozen_;
}
inline bool TableModelArchive::header_rows_frozen() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_rows_frozen)
  return _internal_header_rows_frozen();
}
inline void TableModelArchive::_internal_set_header_rows_frozen(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.header_rows_frozen_ = value;
}
inline void TableModelArchive::set_header_rows_frozen(bool value) {
  _internal_set_header_rows_frozen(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.header_rows_frozen)
}

// optional bool header_columns_frozen = 13;
inline bool TableModelArchive::_internal_has_header_columns_frozen() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool TableModelArchive::has_header_columns_frozen() const {
  return _internal_has_header_columns_frozen();
}
inline void TableModelArchive::clear_header_columns_frozen() {
  _impl_.header_columns_frozen_ = false;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline bool TableModelArchive::_internal_header_columns_frozen() const {
  return _impl_.header_columns_frozen_;
}
inline bool TableModelArchive::header_columns_frozen() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.header_columns_frozen)
  return _internal_header_columns_frozen();
}
inline void TableModelArchive::_internal_set_header_columns_frozen(bool value) {
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.header_columns_frozen_ = value;
}
inline void TableModelArchive::set_header_columns_frozen(bool value) {
  _internal_set_header_columns_frozen(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.header_columns_frozen)
}

// optional uint32 number_of_hidden_rows = 14;
inline bool TableModelArchive::_internal_has_number_of_hidden_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_hidden_rows() const {
  return _internal_has_number_of_hidden_rows();
}
inline void TableModelArchive::clear_number_of_hidden_rows() {
  _impl_.number_of_hidden_rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline uint32_t TableModelArchive::_internal_number_of_hidden_rows() const {
  return _impl_.number_of_hidden_rows_;
}
inline uint32_t TableModelArchive::number_of_hidden_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_hidden_rows)
  return _internal_number_of_hidden_rows();
}
inline void TableModelArchive::_internal_set_number_of_hidden_rows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.number_of_hidden_rows_ = value;
}
inline void TableModelArchive::set_number_of_hidden_rows(uint32_t value) {
  _internal_set_number_of_hidden_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_hidden_rows)
}

// optional uint32 number_of_hidden_columns = 15;
inline bool TableModelArchive::_internal_has_number_of_hidden_columns() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_hidden_columns() const {
  return _internal_has_number_of_hidden_columns();
}
inline void TableModelArchive::clear_number_of_hidden_columns() {
  _impl_.number_of_hidden_columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline uint32_t TableModelArchive::_internal_number_of_hidden_columns() const {
  return _impl_.number_of_hidden_columns_;
}
inline uint32_t TableModelArchive::number_of_hidden_columns() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_hidden_columns)
  return _internal_number_of_hidden_columns();
}
inline void TableModelArchive::_internal_set_number_of_hidden_columns(uint32_t value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.number_of_hidden_columns_ = value;
}
inline void TableModelArchive::set_number_of_hidden_columns(uint32_t value) {
  _internal_set_number_of_hidden_columns(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_hidden_columns)
}

// optional uint32 number_of_user_hidden_rows = 41;
inline bool TableModelArchive::_internal_has_number_of_user_hidden_rows() const {
  bool value = (_impl_._has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_user_hidden_rows() const {
  return _internal_has_number_of_user_hidden_rows();
}
inline void TableModelArchive::clear_number_of_user_hidden_rows() {
  _impl_.number_of_user_hidden_rows_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000100u;
}
inline uint32_t TableModelArchive::_internal_number_of_user_hidden_rows() const {
  return _impl_.number_of_user_hidden_rows_;
}
inline uint32_t TableModelArchive::number_of_user_hidden_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_user_hidden_rows)
  return _internal_number_of_user_hidden_rows();
}
inline void TableModelArchive::_internal_set_number_of_user_hidden_rows(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000100u;
  _impl_.number_of_user_hidden_rows_ = value;
}
inline void TableModelArchive::set_number_of_user_hidden_rows(uint32_t value) {
  _internal_set_number_of_user_hidden_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_user_hidden_rows)
}

// optional uint32 number_of_user_hidden_columns = 42;
inline bool TableModelArchive::_internal_has_number_of_user_hidden_columns() const {
  bool value = (_impl_._has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_user_hidden_columns() const {
  return _internal_has_number_of_user_hidden_columns();
}
inline void TableModelArchive::clear_number_of_user_hidden_columns() {
  _impl_.number_of_user_hidden_columns_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000200u;
}
inline uint32_t TableModelArchive::_internal_number_of_user_hidden_columns() const {
  return _impl_.number_of_user_hidden_columns_;
}
inline uint32_t TableModelArchive::number_of_user_hidden_columns() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_user_hidden_columns)
  return _internal_number_of_user_hidden_columns();
}
inline void TableModelArchive::_internal_set_number_of_user_hidden_columns(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000200u;
  _impl_.number_of_user_hidden_columns_ = value;
}
inline void TableModelArchive::set_number_of_user_hidden_columns(uint32_t value) {
  _internal_set_number_of_user_hidden_columns(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_user_hidden_columns)
}

// optional uint32 number_of_filtered_rows = 40;
inline bool TableModelArchive::_internal_has_number_of_filtered_rows() const {
  bool value = (_impl_._has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool TableModelArchive::has_number_of_filtered_rows() const {
  return _internal_has_number_of_filtered_rows();
}
inline void TableModelArchive::clear_number_of_filtered_rows() {
  _impl_.number_of_filtered_rows_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000080u;
}
inline uint32_t TableModelArchive::_internal_number_of_filtered_rows() const {
  return _impl_.number_of_filtered_rows_;
}
inline uint32_t TableModelArchive::number_of_filtered_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.number_of_filtered_rows)
  return _internal_number_of_filtered_rows();
}
inline void TableModelArchive::_internal_set_number_of_filtered_rows(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000080u;
  _impl_.number_of_filtered_rows_ = value;
}
inline void TableModelArchive::set_number_of_filtered_rows(uint32_t value) {
  _internal_set_number_of_filtered_rows(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.number_of_filtered_rows)
}

// required double default_row_height = 16;
inline bool TableModelArchive::_internal_has_default_row_height() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_default_row_height() const {
  return _internal_has_default_row_height();
}
inline void TableModelArchive::clear_default_row_height() {
  _impl_.default_row_height_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline double TableModelArchive::_internal_default_row_height() const {
  return _impl_.default_row_height_;
}
inline double TableModelArchive::default_row_height() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.default_row_height)
  return _internal_default_row_height();
}
inline void TableModelArchive::_internal_set_default_row_height(double value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.default_row_height_ = value;
}
inline void TableModelArchive::set_default_row_height(double value) {
  _internal_set_default_row_height(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.default_row_height)
}

// required double default_column_width = 17;
inline bool TableModelArchive::_internal_has_default_column_width() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool TableModelArchive::has_default_column_width() const {
  return _internal_has_default_column_width();
}
inline void TableModelArchive::clear_default_column_width() {
  _impl_.default_column_width_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline double TableModelArchive::_internal_default_column_width() const {
  return _impl_.default_column_width_;
}
inline double TableModelArchive::default_column_width() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.default_column_width)
  return _internal_default_column_width();
}
inline void TableModelArchive::_internal_set_default_column_width(double value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.default_column_width_ = value;
}
inline void TableModelArchive::set_default_column_width(double value) {
  _internal_set_default_column_width(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.default_column_width)
}

// optional .TST.CellID origin_offset = 23 [deprecated = true];
inline bool TableModelArchive::_internal_has_origin_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_offset_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_origin_offset() const {
  return _internal_has_origin_offset();
}
inline void TableModelArchive::clear_origin_offset() {
  if (_impl_.origin_offset_ != nullptr) _impl_.origin_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::TST::CellID& TableModelArchive::_internal_origin_offset() const {
  const ::TST::CellID* p = _impl_.origin_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& TableModelArchive::origin_offset() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.origin_offset)
  return _internal_origin_offset();
}
inline void TableModelArchive::unsafe_arena_set_allocated_origin_offset(
    ::TST::CellID* origin_offset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_offset_);
  }
  _impl_.origin_offset_ = origin_offset;
  if (origin_offset) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.origin_offset)
}
inline ::TST::CellID* TableModelArchive::release_origin_offset() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TST::CellID* temp = _impl_.origin_offset_;
  _impl_.origin_offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* TableModelArchive::unsafe_arena_release_origin_offset() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.origin_offset)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TST::CellID* temp = _impl_.origin_offset_;
  _impl_.origin_offset_ = nullptr;
  return temp;
}
inline ::TST::CellID* TableModelArchive::_internal_mutable_origin_offset() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.origin_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.origin_offset_ = p;
  }
  return _impl_.origin_offset_;
}
inline ::TST::CellID* TableModelArchive::mutable_origin_offset() {
  ::TST::CellID* _msg = _internal_mutable_origin_offset();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.origin_offset)
  return _msg;
}
inline void TableModelArchive::set_allocated_origin_offset(::TST::CellID* origin_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_offset_;
  }
  if (origin_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin_offset);
    if (message_arena != submessage_arena) {
      origin_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin_offset, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.origin_offset_ = origin_offset;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.origin_offset)
}

// required uint32 preset_index = 28;
inline bool TableModelArchive::_internal_has_preset_index() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool TableModelArchive::has_preset_index() const {
  return _internal_has_preset_index();
}
inline void TableModelArchive::clear_preset_index() {
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline uint32_t TableModelArchive::_internal_preset_index() const {
  return _impl_.preset_index_;
}
inline uint32_t TableModelArchive::preset_index() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.preset_index)
  return _internal_preset_index();
}
inline void TableModelArchive::_internal_set_preset_index(uint32_t value) {
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.preset_index_ = value;
}
inline void TableModelArchive::set_preset_index(uint32_t value) {
  _internal_set_preset_index(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.preset_index)
}

// optional bool repeating_header_rows_enabled = 29;
inline bool TableModelArchive::_internal_has_repeating_header_rows_enabled() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool TableModelArchive::has_repeating_header_rows_enabled() const {
  return _internal_has_repeating_header_rows_enabled();
}
inline void TableModelArchive::clear_repeating_header_rows_enabled() {
  _impl_.repeating_header_rows_enabled_ = false;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline bool TableModelArchive::_internal_repeating_header_rows_enabled() const {
  return _impl_.repeating_header_rows_enabled_;
}
inline bool TableModelArchive::repeating_header_rows_enabled() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.repeating_header_rows_enabled)
  return _internal_repeating_header_rows_enabled();
}
inline void TableModelArchive::_internal_set_repeating_header_rows_enabled(bool value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.repeating_header_rows_enabled_ = value;
}
inline void TableModelArchive::set_repeating_header_rows_enabled(bool value) {
  _internal_set_repeating_header_rows_enabled(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.repeating_header_rows_enabled)
}

// optional bool repeating_header_columns_enabled = 32;
inline bool TableModelArchive::_internal_has_repeating_header_columns_enabled() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool TableModelArchive::has_repeating_header_columns_enabled() const {
  return _internal_has_repeating_header_columns_enabled();
}
inline void TableModelArchive::clear_repeating_header_columns_enabled() {
  _impl_.repeating_header_columns_enabled_ = false;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline bool TableModelArchive::_internal_repeating_header_columns_enabled() const {
  return _impl_.repeating_header_columns_enabled_;
}
inline bool TableModelArchive::repeating_header_columns_enabled() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.repeating_header_columns_enabled)
  return _internal_repeating_header_columns_enabled();
}
inline void TableModelArchive::_internal_set_repeating_header_columns_enabled(bool value) {
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.repeating_header_columns_enabled_ = value;
}
inline void TableModelArchive::set_repeating_header_columns_enabled(bool value) {
  _internal_set_repeating_header_columns_enabled(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.repeating_header_columns_enabled)
}

// optional bool style_apply_clears_all = 31;
inline bool TableModelArchive::_internal_has_style_apply_clears_all() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool TableModelArchive::has_style_apply_clears_all() const {
  return _internal_has_style_apply_clears_all();
}
inline void TableModelArchive::clear_style_apply_clears_all() {
  _impl_.style_apply_clears_all_ = false;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline bool TableModelArchive::_internal_style_apply_clears_all() const {
  return _impl_.style_apply_clears_all_;
}
inline bool TableModelArchive::style_apply_clears_all() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.style_apply_clears_all)
  return _internal_style_apply_clears_all();
}
inline void TableModelArchive::_internal_set_style_apply_clears_all(bool value) {
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.style_apply_clears_all_ = value;
}
inline void TableModelArchive::set_style_apply_clears_all(bool value) {
  _internal_set_style_apply_clears_all(value);
  // @@protoc_insertion_point(field_set:TST.TableModelArchive.style_apply_clears_all)
}

// optional .TSP.Reference hidden_state_formula_owner_for_columns = 34;
inline bool TableModelArchive::_internal_has_hidden_state_formula_owner_for_columns() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hidden_state_formula_owner_for_columns_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_hidden_state_formula_owner_for_columns() const {
  return _internal_has_hidden_state_formula_owner_for_columns();
}
inline const ::TSP::Reference& TableModelArchive::_internal_hidden_state_formula_owner_for_columns() const {
  const ::TSP::Reference* p = _impl_.hidden_state_formula_owner_for_columns_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::hidden_state_formula_owner_for_columns() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.hidden_state_formula_owner_for_columns)
  return _internal_hidden_state_formula_owner_for_columns();
}
inline void TableModelArchive::unsafe_arena_set_allocated_hidden_state_formula_owner_for_columns(
    ::TSP::Reference* hidden_state_formula_owner_for_columns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hidden_state_formula_owner_for_columns_);
  }
  _impl_.hidden_state_formula_owner_for_columns_ = hidden_state_formula_owner_for_columns;
  if (hidden_state_formula_owner_for_columns) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.hidden_state_formula_owner_for_columns)
}
inline ::TSP::Reference* TableModelArchive::release_hidden_state_formula_owner_for_columns() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::TSP::Reference* temp = _impl_.hidden_state_formula_owner_for_columns_;
  _impl_.hidden_state_formula_owner_for_columns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_hidden_state_formula_owner_for_columns() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.hidden_state_formula_owner_for_columns)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::TSP::Reference* temp = _impl_.hidden_state_formula_owner_for_columns_;
  _impl_.hidden_state_formula_owner_for_columns_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_hidden_state_formula_owner_for_columns() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.hidden_state_formula_owner_for_columns_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.hidden_state_formula_owner_for_columns_ = p;
  }
  return _impl_.hidden_state_formula_owner_for_columns_;
}
inline ::TSP::Reference* TableModelArchive::mutable_hidden_state_formula_owner_for_columns() {
  ::TSP::Reference* _msg = _internal_mutable_hidden_state_formula_owner_for_columns();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.hidden_state_formula_owner_for_columns)
  return _msg;
}
inline void TableModelArchive::set_allocated_hidden_state_formula_owner_for_columns(::TSP::Reference* hidden_state_formula_owner_for_columns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hidden_state_formula_owner_for_columns_);
  }
  if (hidden_state_formula_owner_for_columns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hidden_state_formula_owner_for_columns));
    if (message_arena != submessage_arena) {
      hidden_state_formula_owner_for_columns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hidden_state_formula_owner_for_columns, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.hidden_state_formula_owner_for_columns_ = hidden_state_formula_owner_for_columns;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.hidden_state_formula_owner_for_columns)
}

// optional .TSP.Reference hidden_state_formula_owner_for_rows = 35;
inline bool TableModelArchive::_internal_has_hidden_state_formula_owner_for_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hidden_state_formula_owner_for_rows_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_hidden_state_formula_owner_for_rows() const {
  return _internal_has_hidden_state_formula_owner_for_rows();
}
inline const ::TSP::Reference& TableModelArchive::_internal_hidden_state_formula_owner_for_rows() const {
  const ::TSP::Reference* p = _impl_.hidden_state_formula_owner_for_rows_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::hidden_state_formula_owner_for_rows() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.hidden_state_formula_owner_for_rows)
  return _internal_hidden_state_formula_owner_for_rows();
}
inline void TableModelArchive::unsafe_arena_set_allocated_hidden_state_formula_owner_for_rows(
    ::TSP::Reference* hidden_state_formula_owner_for_rows) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hidden_state_formula_owner_for_rows_);
  }
  _impl_.hidden_state_formula_owner_for_rows_ = hidden_state_formula_owner_for_rows;
  if (hidden_state_formula_owner_for_rows) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.hidden_state_formula_owner_for_rows)
}
inline ::TSP::Reference* TableModelArchive::release_hidden_state_formula_owner_for_rows() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::TSP::Reference* temp = _impl_.hidden_state_formula_owner_for_rows_;
  _impl_.hidden_state_formula_owner_for_rows_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_hidden_state_formula_owner_for_rows() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.hidden_state_formula_owner_for_rows)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::TSP::Reference* temp = _impl_.hidden_state_formula_owner_for_rows_;
  _impl_.hidden_state_formula_owner_for_rows_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_hidden_state_formula_owner_for_rows() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.hidden_state_formula_owner_for_rows_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.hidden_state_formula_owner_for_rows_ = p;
  }
  return _impl_.hidden_state_formula_owner_for_rows_;
}
inline ::TSP::Reference* TableModelArchive::mutable_hidden_state_formula_owner_for_rows() {
  ::TSP::Reference* _msg = _internal_mutable_hidden_state_formula_owner_for_rows();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.hidden_state_formula_owner_for_rows)
  return _msg;
}
inline void TableModelArchive::set_allocated_hidden_state_formula_owner_for_rows(::TSP::Reference* hidden_state_formula_owner_for_rows) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hidden_state_formula_owner_for_rows_);
  }
  if (hidden_state_formula_owner_for_rows) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hidden_state_formula_owner_for_rows));
    if (message_arena != submessage_arena) {
      hidden_state_formula_owner_for_rows = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hidden_state_formula_owner_for_rows, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.hidden_state_formula_owner_for_rows_ = hidden_state_formula_owner_for_rows;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.hidden_state_formula_owner_for_rows)
}

// optional .TSP.Reference filter_set = 38;
inline bool TableModelArchive::_internal_has_filter_set() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_set_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_filter_set() const {
  return _internal_has_filter_set();
}
inline const ::TSP::Reference& TableModelArchive::_internal_filter_set() const {
  const ::TSP::Reference* p = _impl_.filter_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TableModelArchive::filter_set() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.filter_set)
  return _internal_filter_set();
}
inline void TableModelArchive::unsafe_arena_set_allocated_filter_set(
    ::TSP::Reference* filter_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_set_);
  }
  _impl_.filter_set_ = filter_set;
  if (filter_set) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.filter_set)
}
inline ::TSP::Reference* TableModelArchive::release_filter_set() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::TSP::Reference* temp = _impl_.filter_set_;
  _impl_.filter_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TableModelArchive::unsafe_arena_release_filter_set() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.filter_set)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::TSP::Reference* temp = _impl_.filter_set_;
  _impl_.filter_set_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TableModelArchive::_internal_mutable_filter_set() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.filter_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.filter_set_ = p;
  }
  return _impl_.filter_set_;
}
inline ::TSP::Reference* TableModelArchive::mutable_filter_set() {
  ::TSP::Reference* _msg = _internal_mutable_filter_set();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.filter_set)
  return _msg;
}
inline void TableModelArchive::set_allocated_filter_set(::TSP::Reference* filter_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_set_);
  }
  if (filter_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_set));
    if (message_arena != submessage_arena) {
      filter_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter_set, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.filter_set_ = filter_set;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.filter_set)
}

// optional .TSCE.CFUUIDArchive conditional_style_formula_owner_id = 39;
inline bool TableModelArchive::_internal_has_conditional_style_formula_owner_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conditional_style_formula_owner_id_ != nullptr);
  return value;
}
inline bool TableModelArchive::has_conditional_style_formula_owner_id() const {
  return _internal_has_conditional_style_formula_owner_id();
}
inline const ::TSCE::CFUUIDArchive& TableModelArchive::_internal_conditional_style_formula_owner_id() const {
  const ::TSCE::CFUUIDArchive* p = _impl_.conditional_style_formula_owner_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::CFUUIDArchive&>(
      ::TSCE::_CFUUIDArchive_default_instance_);
}
inline const ::TSCE::CFUUIDArchive& TableModelArchive::conditional_style_formula_owner_id() const {
  // @@protoc_insertion_point(field_get:TST.TableModelArchive.conditional_style_formula_owner_id)
  return _internal_conditional_style_formula_owner_id();
}
inline void TableModelArchive::unsafe_arena_set_allocated_conditional_style_formula_owner_id(
    ::TSCE::CFUUIDArchive* conditional_style_formula_owner_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditional_style_formula_owner_id_);
  }
  _impl_.conditional_style_formula_owner_id_ = conditional_style_formula_owner_id;
  if (conditional_style_formula_owner_id) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableModelArchive.conditional_style_formula_owner_id)
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::release_conditional_style_formula_owner_id() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::TSCE::CFUUIDArchive* temp = _impl_.conditional_style_formula_owner_id_;
  _impl_.conditional_style_formula_owner_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::unsafe_arena_release_conditional_style_formula_owner_id() {
  // @@protoc_insertion_point(field_release:TST.TableModelArchive.conditional_style_formula_owner_id)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::TSCE::CFUUIDArchive* temp = _impl_.conditional_style_formula_owner_id_;
  _impl_.conditional_style_formula_owner_id_ = nullptr;
  return temp;
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::_internal_mutable_conditional_style_formula_owner_id() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.conditional_style_formula_owner_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::CFUUIDArchive>(GetArenaForAllocation());
    _impl_.conditional_style_formula_owner_id_ = p;
  }
  return _impl_.conditional_style_formula_owner_id_;
}
inline ::TSCE::CFUUIDArchive* TableModelArchive::mutable_conditional_style_formula_owner_id() {
  ::TSCE::CFUUIDArchive* _msg = _internal_mutable_conditional_style_formula_owner_id();
  // @@protoc_insertion_point(field_mutable:TST.TableModelArchive.conditional_style_formula_owner_id)
  return _msg;
}
inline void TableModelArchive::set_allocated_conditional_style_formula_owner_id(::TSCE::CFUUIDArchive* conditional_style_formula_owner_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditional_style_formula_owner_id_);
  }
  if (conditional_style_formula_owner_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conditional_style_formula_owner_id));
    if (message_arena != submessage_arena) {
      conditional_style_formula_owner_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditional_style_formula_owner_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.conditional_style_formula_owner_id_ = conditional_style_formula_owner_id;
  // @@protoc_insertion_point(field_set_allocated:TST.TableModelArchive.conditional_style_formula_owner_id)
}

// -------------------------------------------------------------------

// DurationWrapperArchive

// -------------------------------------------------------------------

// Cell

// required .TST.CellValueType valueType = 2;
inline bool Cell::_internal_has_valuetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Cell::has_valuetype() const {
  return _internal_has_valuetype();
}
inline void Cell::clear_valuetype() {
  _impl_.valuetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::TST::CellValueType Cell::_internal_valuetype() const {
  return static_cast< ::TST::CellValueType >(_impl_.valuetype_);
}
inline ::TST::CellValueType Cell::valuetype() const {
  // @@protoc_insertion_point(field_get:TST.Cell.valueType)
  return _internal_valuetype();
}
inline void Cell::_internal_set_valuetype(::TST::CellValueType value) {
  assert(::TST::CellValueType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.valuetype_ = value;
}
inline void Cell::set_valuetype(::TST::CellValueType value) {
  _internal_set_valuetype(value);
  // @@protoc_insertion_point(field_set:TST.Cell.valueType)
}

// optional double numberValue = 5;
inline bool Cell::_internal_has_numbervalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Cell::has_numbervalue() const {
  return _internal_has_numbervalue();
}
inline void Cell::clear_numbervalue() {
  _impl_.numbervalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline double Cell::_internal_numbervalue() const {
  return _impl_.numbervalue_;
}
inline double Cell::numbervalue() const {
  // @@protoc_insertion_point(field_get:TST.Cell.numberValue)
  return _internal_numbervalue();
}
inline void Cell::_internal_set_numbervalue(double value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.numbervalue_ = value;
}
inline void Cell::set_numbervalue(double value) {
  _internal_set_numbervalue(value);
  // @@protoc_insertion_point(field_set:TST.Cell.numberValue)
}

// optional string stringValue = 6;
inline bool Cell::_internal_has_stringvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Cell::has_stringvalue() const {
  return _internal_has_stringvalue();
}
inline void Cell::clear_stringvalue() {
  _impl_.stringvalue_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Cell::stringvalue() const {
  // @@protoc_insertion_point(field_get:TST.Cell.stringValue)
  return _internal_stringvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cell::set_stringvalue(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stringvalue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.Cell.stringValue)
}
inline std::string* Cell::mutable_stringvalue() {
  std::string* _s = _internal_mutable_stringvalue();
  // @@protoc_insertion_point(field_mutable:TST.Cell.stringValue)
  return _s;
}
inline const std::string& Cell::_internal_stringvalue() const {
  return _impl_.stringvalue_.Get();
}
inline void Cell::_internal_set_stringvalue(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stringvalue_.Set(value, GetArenaForAllocation());
}
inline std::string* Cell::_internal_mutable_stringvalue() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stringvalue_.Mutable(GetArenaForAllocation());
}
inline std::string* Cell::release_stringvalue() {
  // @@protoc_insertion_point(field_release:TST.Cell.stringValue)
  if (!_internal_has_stringvalue()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stringvalue_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stringvalue_.IsDefault()) {
    _impl_.stringvalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Cell::set_allocated_stringvalue(std::string* stringvalue) {
  if (stringvalue != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stringvalue_.SetAllocated(stringvalue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stringvalue_.IsDefault()) {
    _impl_.stringvalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.stringValue)
}

// optional bool boolValue = 7;
inline bool Cell::_internal_has_boolvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Cell::has_boolvalue() const {
  return _internal_has_boolvalue();
}
inline void Cell::clear_boolvalue() {
  _impl_.boolvalue_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool Cell::_internal_boolvalue() const {
  return _impl_.boolvalue_;
}
inline bool Cell::boolvalue() const {
  // @@protoc_insertion_point(field_get:TST.Cell.boolValue)
  return _internal_boolvalue();
}
inline void Cell::_internal_set_boolvalue(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.boolvalue_ = value;
}
inline void Cell::set_boolvalue(bool value) {
  _internal_set_boolvalue(value);
  // @@protoc_insertion_point(field_set:TST.Cell.boolValue)
}

// optional .TSP.Reference cell_style = 3;
inline bool Cell::_internal_has_cell_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_style_ != nullptr);
  return value;
}
inline bool Cell::has_cell_style() const {
  return _internal_has_cell_style();
}
inline const ::TSP::Reference& Cell::_internal_cell_style() const {
  const ::TSP::Reference* p = _impl_.cell_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::cell_style() const {
  // @@protoc_insertion_point(field_get:TST.Cell.cell_style)
  return _internal_cell_style();
}
inline void Cell::unsafe_arena_set_allocated_cell_style(
    ::TSP::Reference* cell_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  _impl_.cell_style_ = cell_style;
  if (cell_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.cell_style)
}
inline ::TSP::Reference* Cell::release_cell_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_cell_style() {
  // @@protoc_insertion_point(field_release:TST.Cell.cell_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_cell_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cell_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.cell_style_ = p;
  }
  return _impl_.cell_style_;
}
inline ::TSP::Reference* Cell::mutable_cell_style() {
  ::TSP::Reference* _msg = _internal_mutable_cell_style();
  // @@protoc_insertion_point(field_mutable:TST.Cell.cell_style)
  return _msg;
}
inline void Cell::set_allocated_cell_style(::TSP::Reference* cell_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  if (cell_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_style));
    if (message_arena != submessage_arena) {
      cell_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cell_style_ = cell_style;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.cell_style)
}

// optional .TSP.Reference text_style = 4;
inline bool Cell::_internal_has_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_style_ != nullptr);
  return value;
}
inline bool Cell::has_text_style() const {
  return _internal_has_text_style();
}
inline const ::TSP::Reference& Cell::_internal_text_style() const {
  const ::TSP::Reference* p = _impl_.text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::text_style() const {
  // @@protoc_insertion_point(field_get:TST.Cell.text_style)
  return _internal_text_style();
}
inline void Cell::unsafe_arena_set_allocated_text_style(
    ::TSP::Reference* text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  _impl_.text_style_ = text_style;
  if (text_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.text_style)
}
inline ::TSP::Reference* Cell::release_text_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_text_style() {
  // @@protoc_insertion_point(field_release:TST.Cell.text_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_text_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.text_style_ = p;
  }
  return _impl_.text_style_;
}
inline ::TSP::Reference* Cell::mutable_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_text_style();
  // @@protoc_insertion_point(field_mutable:TST.Cell.text_style)
  return _msg;
}
inline void Cell::set_allocated_text_style(::TSP::Reference* text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  if (text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_style));
    if (message_arena != submessage_arena) {
      text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.text_style_ = text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.text_style)
}

// optional .TSCE.FormulaArchive formula = 8;
inline bool Cell::_internal_has_formula() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formula_ != nullptr);
  return value;
}
inline bool Cell::has_formula() const {
  return _internal_has_formula();
}
inline const ::TSCE::FormulaArchive& Cell::_internal_formula() const {
  const ::TSCE::FormulaArchive* p = _impl_.formula_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::FormulaArchive&>(
      ::TSCE::_FormulaArchive_default_instance_);
}
inline const ::TSCE::FormulaArchive& Cell::formula() const {
  // @@protoc_insertion_point(field_get:TST.Cell.formula)
  return _internal_formula();
}
inline void Cell::unsafe_arena_set_allocated_formula(
    ::TSCE::FormulaArchive* formula) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  _impl_.formula_ = formula;
  if (formula) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.formula)
}
inline ::TSCE::FormulaArchive* Cell::release_formula() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::FormulaArchive* Cell::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_release:TST.Cell.formula)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
  return temp;
}
inline ::TSCE::FormulaArchive* Cell::_internal_mutable_formula() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.formula_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::FormulaArchive>(GetArenaForAllocation());
    _impl_.formula_ = p;
  }
  return _impl_.formula_;
}
inline ::TSCE::FormulaArchive* Cell::mutable_formula() {
  ::TSCE::FormulaArchive* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:TST.Cell.formula)
  return _msg;
}
inline void Cell::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  if (formula) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formula));
    if (message_arena != submessage_arena) {
      formula = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formula, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.formula_ = formula;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.formula)
}

// optional .TSP.Reference formulaError = 10;
inline bool Cell::_internal_has_formulaerror() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formulaerror_ != nullptr);
  return value;
}
inline bool Cell::has_formulaerror() const {
  return _internal_has_formulaerror();
}
inline const ::TSP::Reference& Cell::_internal_formulaerror() const {
  const ::TSP::Reference* p = _impl_.formulaerror_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::formulaerror() const {
  // @@protoc_insertion_point(field_get:TST.Cell.formulaError)
  return _internal_formulaerror();
}
inline void Cell::unsafe_arena_set_allocated_formulaerror(
    ::TSP::Reference* formulaerror) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulaerror_);
  }
  _impl_.formulaerror_ = formulaerror;
  if (formulaerror) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.formulaError)
}
inline ::TSP::Reference* Cell::release_formulaerror() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.formulaerror_;
  _impl_.formulaerror_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_formulaerror() {
  // @@protoc_insertion_point(field_release:TST.Cell.formulaError)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::TSP::Reference* temp = _impl_.formulaerror_;
  _impl_.formulaerror_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_formulaerror() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.formulaerror_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.formulaerror_ = p;
  }
  return _impl_.formulaerror_;
}
inline ::TSP::Reference* Cell::mutable_formulaerror() {
  ::TSP::Reference* _msg = _internal_mutable_formulaerror();
  // @@protoc_insertion_point(field_mutable:TST.Cell.formulaError)
  return _msg;
}
inline void Cell::set_allocated_formulaerror(::TSP::Reference* formulaerror) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formulaerror_);
  }
  if (formulaerror) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formulaerror));
    if (message_arena != submessage_arena) {
      formulaerror = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formulaerror, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.formulaerror_ = formulaerror;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.formulaError)
}

// optional .TSK.FormatStructArchive current_format = 9;
inline bool Cell::_internal_has_current_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_format_ != nullptr);
  return value;
}
inline bool Cell::has_current_format() const {
  return _internal_has_current_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_current_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.current_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::current_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.current_format)
  return _internal_current_format();
}
inline void Cell::unsafe_arena_set_allocated_current_format(
    ::TSK::FormatStructArchive* current_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_format_);
  }
  _impl_.current_format_ = current_format;
  if (current_format) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.current_format)
}
inline ::TSK::FormatStructArchive* Cell::release_current_format() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSK::FormatStructArchive* temp = _impl_.current_format_;
  _impl_.current_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_current_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.current_format)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::TSK::FormatStructArchive* temp = _impl_.current_format_;
  _impl_.current_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_current_format() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.current_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.current_format_ = p;
  }
  return _impl_.current_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_current_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_current_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.current_format)
  return _msg;
}
inline void Cell::set_allocated_current_format(::TSK::FormatStructArchive* current_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_format_);
  }
  if (current_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_format));
    if (message_arena != submessage_arena) {
      current_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.current_format_ = current_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.current_format)
}

// optional .TSK.FormatStructArchive number_format = 11;
inline bool Cell::_internal_has_number_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.number_format_ != nullptr);
  return value;
}
inline bool Cell::has_number_format() const {
  return _internal_has_number_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_number_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.number_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::number_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.number_format)
  return _internal_number_format();
}
inline void Cell::unsafe_arena_set_allocated_number_format(
    ::TSK::FormatStructArchive* number_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.number_format_);
  }
  _impl_.number_format_ = number_format;
  if (number_format) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.number_format)
}
inline ::TSK::FormatStructArchive* Cell::release_number_format() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSK::FormatStructArchive* temp = _impl_.number_format_;
  _impl_.number_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_number_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.number_format)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::TSK::FormatStructArchive* temp = _impl_.number_format_;
  _impl_.number_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_number_format() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.number_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.number_format_ = p;
  }
  return _impl_.number_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_number_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_number_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.number_format)
  return _msg;
}
inline void Cell::set_allocated_number_format(::TSK::FormatStructArchive* number_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.number_format_);
  }
  if (number_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(number_format));
    if (message_arena != submessage_arena) {
      number_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, number_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.number_format_ = number_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.number_format)
}

// optional .TSK.FormatStructArchive currency_format = 12;
inline bool Cell::_internal_has_currency_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.currency_format_ != nullptr);
  return value;
}
inline bool Cell::has_currency_format() const {
  return _internal_has_currency_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_currency_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.currency_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::currency_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.currency_format)
  return _internal_currency_format();
}
inline void Cell::unsafe_arena_set_allocated_currency_format(
    ::TSK::FormatStructArchive* currency_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currency_format_);
  }
  _impl_.currency_format_ = currency_format;
  if (currency_format) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.currency_format)
}
inline ::TSK::FormatStructArchive* Cell::release_currency_format() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSK::FormatStructArchive* temp = _impl_.currency_format_;
  _impl_.currency_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_currency_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.currency_format)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::TSK::FormatStructArchive* temp = _impl_.currency_format_;
  _impl_.currency_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_currency_format() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.currency_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.currency_format_ = p;
  }
  return _impl_.currency_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_currency_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_currency_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.currency_format)
  return _msg;
}
inline void Cell::set_allocated_currency_format(::TSK::FormatStructArchive* currency_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.currency_format_);
  }
  if (currency_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(currency_format));
    if (message_arena != submessage_arena) {
      currency_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currency_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.currency_format_ = currency_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.currency_format)
}

// optional .TSK.FormatStructArchive duration_format = 13;
inline bool Cell::_internal_has_duration_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.duration_format_ != nullptr);
  return value;
}
inline bool Cell::has_duration_format() const {
  return _internal_has_duration_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_duration_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.duration_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::duration_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.duration_format)
  return _internal_duration_format();
}
inline void Cell::unsafe_arena_set_allocated_duration_format(
    ::TSK::FormatStructArchive* duration_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_format_);
  }
  _impl_.duration_format_ = duration_format;
  if (duration_format) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.duration_format)
}
inline ::TSK::FormatStructArchive* Cell::release_duration_format() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSK::FormatStructArchive* temp = _impl_.duration_format_;
  _impl_.duration_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_duration_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.duration_format)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::TSK::FormatStructArchive* temp = _impl_.duration_format_;
  _impl_.duration_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_duration_format() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.duration_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.duration_format_ = p;
  }
  return _impl_.duration_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_duration_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_duration_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.duration_format)
  return _msg;
}
inline void Cell::set_allocated_duration_format(::TSK::FormatStructArchive* duration_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_format_);
  }
  if (duration_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_format));
    if (message_arena != submessage_arena) {
      duration_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.duration_format_ = duration_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.duration_format)
}

// optional .TSK.FormatStructArchive date_format = 14;
inline bool Cell::_internal_has_date_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.date_format_ != nullptr);
  return value;
}
inline bool Cell::has_date_format() const {
  return _internal_has_date_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_date_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.date_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::date_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.date_format)
  return _internal_date_format();
}
inline void Cell::unsafe_arena_set_allocated_date_format(
    ::TSK::FormatStructArchive* date_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_format_);
  }
  _impl_.date_format_ = date_format;
  if (date_format) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.date_format)
}
inline ::TSK::FormatStructArchive* Cell::release_date_format() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSK::FormatStructArchive* temp = _impl_.date_format_;
  _impl_.date_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_date_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.date_format)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::TSK::FormatStructArchive* temp = _impl_.date_format_;
  _impl_.date_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_date_format() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.date_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.date_format_ = p;
  }
  return _impl_.date_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_date_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_date_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.date_format)
  return _msg;
}
inline void Cell::set_allocated_date_format(::TSK::FormatStructArchive* date_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.date_format_);
  }
  if (date_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_format));
    if (message_arena != submessage_arena) {
      date_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.date_format_ = date_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.date_format)
}

// optional .TSK.FormatStructArchive control_format = 15;
inline bool Cell::_internal_has_control_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.control_format_ != nullptr);
  return value;
}
inline bool Cell::has_control_format() const {
  return _internal_has_control_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_control_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.control_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::control_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.control_format)
  return _internal_control_format();
}
inline void Cell::unsafe_arena_set_allocated_control_format(
    ::TSK::FormatStructArchive* control_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_format_);
  }
  _impl_.control_format_ = control_format;
  if (control_format) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.control_format)
}
inline ::TSK::FormatStructArchive* Cell::release_control_format() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSK::FormatStructArchive* temp = _impl_.control_format_;
  _impl_.control_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_control_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.control_format)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::TSK::FormatStructArchive* temp = _impl_.control_format_;
  _impl_.control_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_control_format() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.control_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.control_format_ = p;
  }
  return _impl_.control_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_control_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_control_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.control_format)
  return _msg;
}
inline void Cell::set_allocated_control_format(::TSK::FormatStructArchive* control_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.control_format_);
  }
  if (control_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_format));
    if (message_arena != submessage_arena) {
      control_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.control_format_ = control_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.control_format)
}

// optional .TSK.FormatStructArchive custom_format = 16;
inline bool Cell::_internal_has_custom_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.custom_format_ != nullptr);
  return value;
}
inline bool Cell::has_custom_format() const {
  return _internal_has_custom_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_custom_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.custom_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::custom_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.custom_format)
  return _internal_custom_format();
}
inline void Cell::unsafe_arena_set_allocated_custom_format(
    ::TSK::FormatStructArchive* custom_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_format_);
  }
  _impl_.custom_format_ = custom_format;
  if (custom_format) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.custom_format)
}
inline ::TSK::FormatStructArchive* Cell::release_custom_format() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSK::FormatStructArchive* temp = _impl_.custom_format_;
  _impl_.custom_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_custom_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.custom_format)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::TSK::FormatStructArchive* temp = _impl_.custom_format_;
  _impl_.custom_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_custom_format() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.custom_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.custom_format_ = p;
  }
  return _impl_.custom_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_custom_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_custom_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.custom_format)
  return _msg;
}
inline void Cell::set_allocated_custom_format(::TSK::FormatStructArchive* custom_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_format_);
  }
  if (custom_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(custom_format));
    if (message_arena != submessage_arena) {
      custom_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.custom_format_ = custom_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.custom_format)
}

// optional .TSK.FormatStructArchive base_format = 17;
inline bool Cell::_internal_has_base_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_format_ != nullptr);
  return value;
}
inline bool Cell::has_base_format() const {
  return _internal_has_base_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_base_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.base_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::base_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.base_format)
  return _internal_base_format();
}
inline void Cell::unsafe_arena_set_allocated_base_format(
    ::TSK::FormatStructArchive* base_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_format_);
  }
  _impl_.base_format_ = base_format;
  if (base_format) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.base_format)
}
inline ::TSK::FormatStructArchive* Cell::release_base_format() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSK::FormatStructArchive* temp = _impl_.base_format_;
  _impl_.base_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_base_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.base_format)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::TSK::FormatStructArchive* temp = _impl_.base_format_;
  _impl_.base_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_base_format() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.base_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.base_format_ = p;
  }
  return _impl_.base_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_base_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_base_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.base_format)
  return _msg;
}
inline void Cell::set_allocated_base_format(::TSK::FormatStructArchive* base_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.base_format_);
  }
  if (base_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_format));
    if (message_arena != submessage_arena) {
      base_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.base_format_ = base_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.base_format)
}

// optional .TSK.FormatStructArchive multiple_choice_list_format = 18;
inline bool Cell::_internal_has_multiple_choice_list_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiple_choice_list_format_ != nullptr);
  return value;
}
inline bool Cell::has_multiple_choice_list_format() const {
  return _internal_has_multiple_choice_list_format();
}
inline const ::TSK::FormatStructArchive& Cell::_internal_multiple_choice_list_format() const {
  const ::TSK::FormatStructArchive* p = _impl_.multiple_choice_list_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSK::FormatStructArchive&>(
      ::TSK::_FormatStructArchive_default_instance_);
}
inline const ::TSK::FormatStructArchive& Cell::multiple_choice_list_format() const {
  // @@protoc_insertion_point(field_get:TST.Cell.multiple_choice_list_format)
  return _internal_multiple_choice_list_format();
}
inline void Cell::unsafe_arena_set_allocated_multiple_choice_list_format(
    ::TSK::FormatStructArchive* multiple_choice_list_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiple_choice_list_format_);
  }
  _impl_.multiple_choice_list_format_ = multiple_choice_list_format;
  if (multiple_choice_list_format) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.multiple_choice_list_format)
}
inline ::TSK::FormatStructArchive* Cell::release_multiple_choice_list_format() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSK::FormatStructArchive* temp = _impl_.multiple_choice_list_format_;
  _impl_.multiple_choice_list_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::unsafe_arena_release_multiple_choice_list_format() {
  // @@protoc_insertion_point(field_release:TST.Cell.multiple_choice_list_format)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::TSK::FormatStructArchive* temp = _impl_.multiple_choice_list_format_;
  _impl_.multiple_choice_list_format_ = nullptr;
  return temp;
}
inline ::TSK::FormatStructArchive* Cell::_internal_mutable_multiple_choice_list_format() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.multiple_choice_list_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSK::FormatStructArchive>(GetArenaForAllocation());
    _impl_.multiple_choice_list_format_ = p;
  }
  return _impl_.multiple_choice_list_format_;
}
inline ::TSK::FormatStructArchive* Cell::mutable_multiple_choice_list_format() {
  ::TSK::FormatStructArchive* _msg = _internal_mutable_multiple_choice_list_format();
  // @@protoc_insertion_point(field_mutable:TST.Cell.multiple_choice_list_format)
  return _msg;
}
inline void Cell::set_allocated_multiple_choice_list_format(::TSK::FormatStructArchive* multiple_choice_list_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiple_choice_list_format_);
  }
  if (multiple_choice_list_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multiple_choice_list_format));
    if (message_arena != submessage_arena) {
      multiple_choice_list_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiple_choice_list_format, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.multiple_choice_list_format_ = multiple_choice_list_format;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.multiple_choice_list_format)
}

// optional uint32 explicit_format_flags = 19;
inline bool Cell::_internal_has_explicit_format_flags() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Cell::has_explicit_format_flags() const {
  return _internal_has_explicit_format_flags();
}
inline void Cell::clear_explicit_format_flags() {
  _impl_.explicit_format_flags_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint32_t Cell::_internal_explicit_format_flags() const {
  return _impl_.explicit_format_flags_;
}
inline uint32_t Cell::explicit_format_flags() const {
  // @@protoc_insertion_point(field_get:TST.Cell.explicit_format_flags)
  return _internal_explicit_format_flags();
}
inline void Cell::_internal_set_explicit_format_flags(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.explicit_format_flags_ = value;
}
inline void Cell::set_explicit_format_flags(uint32_t value) {
  _internal_set_explicit_format_flags(value);
  // @@protoc_insertion_point(field_set:TST.Cell.explicit_format_flags)
}

// optional .TSP.Reference richTextPayload = 20;
inline bool Cell::_internal_has_richtextpayload() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.richtextpayload_ != nullptr);
  return value;
}
inline bool Cell::has_richtextpayload() const {
  return _internal_has_richtextpayload();
}
inline const ::TSP::Reference& Cell::_internal_richtextpayload() const {
  const ::TSP::Reference* p = _impl_.richtextpayload_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::richtextpayload() const {
  // @@protoc_insertion_point(field_get:TST.Cell.richTextPayload)
  return _internal_richtextpayload();
}
inline void Cell::unsafe_arena_set_allocated_richtextpayload(
    ::TSP::Reference* richtextpayload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayload_);
  }
  _impl_.richtextpayload_ = richtextpayload;
  if (richtextpayload) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.richTextPayload)
}
inline ::TSP::Reference* Cell::release_richtextpayload() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.richtextpayload_;
  _impl_.richtextpayload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_richtextpayload() {
  // @@protoc_insertion_point(field_release:TST.Cell.richTextPayload)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::TSP::Reference* temp = _impl_.richtextpayload_;
  _impl_.richtextpayload_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_richtextpayload() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.richtextpayload_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.richtextpayload_ = p;
  }
  return _impl_.richtextpayload_;
}
inline ::TSP::Reference* Cell::mutable_richtextpayload() {
  ::TSP::Reference* _msg = _internal_mutable_richtextpayload();
  // @@protoc_insertion_point(field_mutable:TST.Cell.richTextPayload)
  return _msg;
}
inline void Cell::set_allocated_richtextpayload(::TSP::Reference* richtextpayload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.richtextpayload_);
  }
  if (richtextpayload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(richtextpayload));
    if (message_arena != submessage_arena) {
      richtextpayload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, richtextpayload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.richtextpayload_ = richtextpayload;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.richTextPayload)
}

// optional .TSP.Reference conditional_style = 21;
inline bool Cell::_internal_has_conditional_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.conditional_style_ != nullptr);
  return value;
}
inline bool Cell::has_conditional_style() const {
  return _internal_has_conditional_style();
}
inline const ::TSP::Reference& Cell::_internal_conditional_style() const {
  const ::TSP::Reference* p = _impl_.conditional_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::conditional_style() const {
  // @@protoc_insertion_point(field_get:TST.Cell.conditional_style)
  return _internal_conditional_style();
}
inline void Cell::unsafe_arena_set_allocated_conditional_style(
    ::TSP::Reference* conditional_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditional_style_);
  }
  _impl_.conditional_style_ = conditional_style;
  if (conditional_style) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.conditional_style)
}
inline ::TSP::Reference* Cell::release_conditional_style() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.conditional_style_;
  _impl_.conditional_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_conditional_style() {
  // @@protoc_insertion_point(field_release:TST.Cell.conditional_style)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::TSP::Reference* temp = _impl_.conditional_style_;
  _impl_.conditional_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_conditional_style() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.conditional_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.conditional_style_ = p;
  }
  return _impl_.conditional_style_;
}
inline ::TSP::Reference* Cell::mutable_conditional_style() {
  ::TSP::Reference* _msg = _internal_mutable_conditional_style();
  // @@protoc_insertion_point(field_mutable:TST.Cell.conditional_style)
  return _msg;
}
inline void Cell::set_allocated_conditional_style(::TSP::Reference* conditional_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditional_style_);
  }
  if (conditional_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conditional_style));
    if (message_arena != submessage_arena) {
      conditional_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditional_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.conditional_style_ = conditional_style;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.conditional_style)
}

// optional .TSP.Reference multiple_choice_list = 22;
inline bool Cell::_internal_has_multiple_choice_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multiple_choice_list_ != nullptr);
  return value;
}
inline bool Cell::has_multiple_choice_list() const {
  return _internal_has_multiple_choice_list();
}
inline const ::TSP::Reference& Cell::_internal_multiple_choice_list() const {
  const ::TSP::Reference* p = _impl_.multiple_choice_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::multiple_choice_list() const {
  // @@protoc_insertion_point(field_get:TST.Cell.multiple_choice_list)
  return _internal_multiple_choice_list();
}
inline void Cell::unsafe_arena_set_allocated_multiple_choice_list(
    ::TSP::Reference* multiple_choice_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiple_choice_list_);
  }
  _impl_.multiple_choice_list_ = multiple_choice_list;
  if (multiple_choice_list) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.multiple_choice_list)
}
inline ::TSP::Reference* Cell::release_multiple_choice_list() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::TSP::Reference* temp = _impl_.multiple_choice_list_;
  _impl_.multiple_choice_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_multiple_choice_list() {
  // @@protoc_insertion_point(field_release:TST.Cell.multiple_choice_list)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::TSP::Reference* temp = _impl_.multiple_choice_list_;
  _impl_.multiple_choice_list_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_multiple_choice_list() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.multiple_choice_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.multiple_choice_list_ = p;
  }
  return _impl_.multiple_choice_list_;
}
inline ::TSP::Reference* Cell::mutable_multiple_choice_list() {
  ::TSP::Reference* _msg = _internal_mutable_multiple_choice_list();
  // @@protoc_insertion_point(field_mutable:TST.Cell.multiple_choice_list)
  return _msg;
}
inline void Cell::set_allocated_multiple_choice_list(::TSP::Reference* multiple_choice_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multiple_choice_list_);
  }
  if (multiple_choice_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multiple_choice_list));
    if (message_arena != submessage_arena) {
      multiple_choice_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multiple_choice_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.multiple_choice_list_ = multiple_choice_list;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.multiple_choice_list)
}

// optional .TSP.Reference comment_storage = 23;
inline bool Cell::_internal_has_comment_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.comment_storage_ != nullptr);
  return value;
}
inline bool Cell::has_comment_storage() const {
  return _internal_has_comment_storage();
}
inline const ::TSP::Reference& Cell::_internal_comment_storage() const {
  const ::TSP::Reference* p = _impl_.comment_storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& Cell::comment_storage() const {
  // @@protoc_insertion_point(field_get:TST.Cell.comment_storage)
  return _internal_comment_storage();
}
inline void Cell::unsafe_arena_set_allocated_comment_storage(
    ::TSP::Reference* comment_storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_storage_);
  }
  _impl_.comment_storage_ = comment_storage;
  if (comment_storage) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.Cell.comment_storage)
}
inline ::TSP::Reference* Cell::release_comment_storage() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::TSP::Reference* temp = _impl_.comment_storage_;
  _impl_.comment_storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* Cell::unsafe_arena_release_comment_storage() {
  // @@protoc_insertion_point(field_release:TST.Cell.comment_storage)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::TSP::Reference* temp = _impl_.comment_storage_;
  _impl_.comment_storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* Cell::_internal_mutable_comment_storage() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.comment_storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.comment_storage_ = p;
  }
  return _impl_.comment_storage_;
}
inline ::TSP::Reference* Cell::mutable_comment_storage() {
  ::TSP::Reference* _msg = _internal_mutable_comment_storage();
  // @@protoc_insertion_point(field_mutable:TST.Cell.comment_storage)
  return _msg;
}
inline void Cell::set_allocated_comment_storage(::TSP::Reference* comment_storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.comment_storage_);
  }
  if (comment_storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(comment_storage));
    if (message_arena != submessage_arena) {
      comment_storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comment_storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.comment_storage_ = comment_storage;
  // @@protoc_insertion_point(field_set_allocated:TST.Cell.comment_storage)
}

// optional uint32 conditional_style_applied_rule = 24;
inline bool Cell::_internal_has_conditional_style_applied_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Cell::has_conditional_style_applied_rule() const {
  return _internal_has_conditional_style_applied_rule();
}
inline void Cell::clear_conditional_style_applied_rule() {
  _impl_.conditional_style_applied_rule_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint32_t Cell::_internal_conditional_style_applied_rule() const {
  return _impl_.conditional_style_applied_rule_;
}
inline uint32_t Cell::conditional_style_applied_rule() const {
  // @@protoc_insertion_point(field_get:TST.Cell.conditional_style_applied_rule)
  return _internal_conditional_style_applied_rule();
}
inline void Cell::_internal_set_conditional_style_applied_rule(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.conditional_style_applied_rule_ = value;
}
inline void Cell::set_conditional_style_applied_rule(uint32_t value) {
  _internal_set_conditional_style_applied_rule(value);
  // @@protoc_insertion_point(field_set:TST.Cell.conditional_style_applied_rule)
}

// -------------------------------------------------------------------

// MergeRegionMapArchive

// repeated .TST.CellRange cell_range = 1;
inline int MergeRegionMapArchive::_internal_cell_range_size() const {
  return _impl_.cell_range_.size();
}
inline int MergeRegionMapArchive::cell_range_size() const {
  return _internal_cell_range_size();
}
inline void MergeRegionMapArchive::clear_cell_range() {
  _impl_.cell_range_.Clear();
}
inline ::TST::CellRange* MergeRegionMapArchive::mutable_cell_range(int index) {
  // @@protoc_insertion_point(field_mutable:TST.MergeRegionMapArchive.cell_range)
  return _impl_.cell_range_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
MergeRegionMapArchive::mutable_cell_range() {
  // @@protoc_insertion_point(field_mutable_list:TST.MergeRegionMapArchive.cell_range)
  return &_impl_.cell_range_;
}
inline const ::TST::CellRange& MergeRegionMapArchive::_internal_cell_range(int index) const {
  return _impl_.cell_range_.Get(index);
}
inline const ::TST::CellRange& MergeRegionMapArchive::cell_range(int index) const {
  // @@protoc_insertion_point(field_get:TST.MergeRegionMapArchive.cell_range)
  return _internal_cell_range(index);
}
inline ::TST::CellRange* MergeRegionMapArchive::_internal_add_cell_range() {
  return _impl_.cell_range_.Add();
}
inline ::TST::CellRange* MergeRegionMapArchive::add_cell_range() {
  ::TST::CellRange* _add = _internal_add_cell_range();
  // @@protoc_insertion_point(field_add:TST.MergeRegionMapArchive.cell_range)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
MergeRegionMapArchive::cell_range() const {
  // @@protoc_insertion_point(field_list:TST.MergeRegionMapArchive.cell_range)
  return _impl_.cell_range_;
}

// -------------------------------------------------------------------

// CellMapArchive_CellMapEntry

// required .TST.CellID cellID = 1;
inline bool CellMapArchive_CellMapEntry::_internal_has_cellid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cellid_ != nullptr);
  return value;
}
inline bool CellMapArchive_CellMapEntry::has_cellid() const {
  return _internal_has_cellid();
}
inline void CellMapArchive_CellMapEntry::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellID& CellMapArchive_CellMapEntry::_internal_cellid() const {
  const ::TST::CellID* p = _impl_.cellid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& CellMapArchive_CellMapEntry::cellid() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.CellMapEntry.cellID)
  return _internal_cellid();
}
inline void CellMapArchive_CellMapEntry::unsafe_arena_set_allocated_cellid(
    ::TST::CellID* cellid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cellid_);
  }
  _impl_.cellid_ = cellid;
  if (cellid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellMapArchive.CellMapEntry.cellID)
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::release_cellid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::unsafe_arena_release_cellid() {
  // @@protoc_insertion_point(field_release:TST.CellMapArchive.CellMapEntry.cellID)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
  return temp;
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::_internal_mutable_cellid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cellid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.cellid_ = p;
  }
  return _impl_.cellid_;
}
inline ::TST::CellID* CellMapArchive_CellMapEntry::mutable_cellid() {
  ::TST::CellID* _msg = _internal_mutable_cellid();
  // @@protoc_insertion_point(field_mutable:TST.CellMapArchive.CellMapEntry.cellID)
  return _msg;
}
inline void CellMapArchive_CellMapEntry::set_allocated_cellid(::TST::CellID* cellid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cellid_;
  }
  if (cellid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellid);
    if (message_arena != submessage_arena) {
      cellid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cellid_ = cellid;
  // @@protoc_insertion_point(field_set_allocated:TST.CellMapArchive.CellMapEntry.cellID)
}

// optional .TST.Cell cell = 2;
inline bool CellMapArchive_CellMapEntry::_internal_has_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_ != nullptr);
  return value;
}
inline bool CellMapArchive_CellMapEntry::has_cell() const {
  return _internal_has_cell();
}
inline void CellMapArchive_CellMapEntry::clear_cell() {
  if (_impl_.cell_ != nullptr) _impl_.cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::Cell& CellMapArchive_CellMapEntry::_internal_cell() const {
  const ::TST::Cell* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::Cell&>(
      ::TST::_Cell_default_instance_);
}
inline const ::TST::Cell& CellMapArchive_CellMapEntry::cell() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.CellMapEntry.cell)
  return _internal_cell();
}
inline void CellMapArchive_CellMapEntry::unsafe_arena_set_allocated_cell(
    ::TST::Cell* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellMapArchive.CellMapEntry.cell)
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::release_cell() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::Cell* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:TST.CellMapArchive.CellMapEntry.cell)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::Cell* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::_internal_mutable_cell() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::Cell>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::TST::Cell* CellMapArchive_CellMapEntry::mutable_cell() {
  ::TST::Cell* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:TST.CellMapArchive.CellMapEntry.cell)
  return _msg;
}
inline void CellMapArchive_CellMapEntry::set_allocated_cell(::TST::Cell* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cell_;
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cell);
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:TST.CellMapArchive.CellMapEntry.cell)
}

// -------------------------------------------------------------------

// CellMapArchive

// required uint32 capacity = 1;
inline bool CellMapArchive::_internal_has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CellMapArchive::has_capacity() const {
  return _internal_has_capacity();
}
inline void CellMapArchive::clear_capacity() {
  _impl_.capacity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CellMapArchive::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t CellMapArchive::capacity() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.capacity)
  return _internal_capacity();
}
inline void CellMapArchive::_internal_set_capacity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.capacity_ = value;
}
inline void CellMapArchive::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:TST.CellMapArchive.capacity)
}

// required uint32 count = 2;
inline bool CellMapArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CellMapArchive::has_count() const {
  return _internal_has_count();
}
inline void CellMapArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CellMapArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t CellMapArchive::count() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.count)
  return _internal_count();
}
inline void CellMapArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}
inline void CellMapArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TST.CellMapArchive.count)
}

// repeated .TST.CellMapArchive.CellMapEntry cellMapEntry = 3;
inline int CellMapArchive::_internal_cellmapentry_size() const {
  return _impl_.cellmapentry_.size();
}
inline int CellMapArchive::cellmapentry_size() const {
  return _internal_cellmapentry_size();
}
inline void CellMapArchive::clear_cellmapentry() {
  _impl_.cellmapentry_.Clear();
}
inline ::TST::CellMapArchive_CellMapEntry* CellMapArchive::mutable_cellmapentry(int index) {
  // @@protoc_insertion_point(field_mutable:TST.CellMapArchive.cellMapEntry)
  return _impl_.cellmapentry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >*
CellMapArchive::mutable_cellmapentry() {
  // @@protoc_insertion_point(field_mutable_list:TST.CellMapArchive.cellMapEntry)
  return &_impl_.cellmapentry_;
}
inline const ::TST::CellMapArchive_CellMapEntry& CellMapArchive::_internal_cellmapentry(int index) const {
  return _impl_.cellmapentry_.Get(index);
}
inline const ::TST::CellMapArchive_CellMapEntry& CellMapArchive::cellmapentry(int index) const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.cellMapEntry)
  return _internal_cellmapentry(index);
}
inline ::TST::CellMapArchive_CellMapEntry* CellMapArchive::_internal_add_cellmapentry() {
  return _impl_.cellmapentry_.Add();
}
inline ::TST::CellMapArchive_CellMapEntry* CellMapArchive::add_cellmapentry() {
  ::TST::CellMapArchive_CellMapEntry* _add = _internal_add_cellmapentry();
  // @@protoc_insertion_point(field_add:TST.CellMapArchive.cellMapEntry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellMapArchive_CellMapEntry >&
CellMapArchive::cellmapentry() const {
  // @@protoc_insertion_point(field_list:TST.CellMapArchive.cellMapEntry)
  return _impl_.cellmapentry_;
}

// optional bool may_modify_formulas_in_cells = 4 [default = true];
inline bool CellMapArchive::_internal_has_may_modify_formulas_in_cells() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CellMapArchive::has_may_modify_formulas_in_cells() const {
  return _internal_has_may_modify_formulas_in_cells();
}
inline void CellMapArchive::clear_may_modify_formulas_in_cells() {
  _impl_.may_modify_formulas_in_cells_ = true;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CellMapArchive::_internal_may_modify_formulas_in_cells() const {
  return _impl_.may_modify_formulas_in_cells_;
}
inline bool CellMapArchive::may_modify_formulas_in_cells() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.may_modify_formulas_in_cells)
  return _internal_may_modify_formulas_in_cells();
}
inline void CellMapArchive::_internal_set_may_modify_formulas_in_cells(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.may_modify_formulas_in_cells_ = value;
}
inline void CellMapArchive::set_may_modify_formulas_in_cells(bool value) {
  _internal_set_may_modify_formulas_in_cells(value);
  // @@protoc_insertion_point(field_set:TST.CellMapArchive.may_modify_formulas_in_cells)
}

// optional bool may_modify_values_referenced_by_formulas = 5 [default = true];
inline bool CellMapArchive::_internal_has_may_modify_values_referenced_by_formulas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CellMapArchive::has_may_modify_values_referenced_by_formulas() const {
  return _internal_has_may_modify_values_referenced_by_formulas();
}
inline void CellMapArchive::clear_may_modify_values_referenced_by_formulas() {
  _impl_.may_modify_values_referenced_by_formulas_ = true;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CellMapArchive::_internal_may_modify_values_referenced_by_formulas() const {
  return _impl_.may_modify_values_referenced_by_formulas_;
}
inline bool CellMapArchive::may_modify_values_referenced_by_formulas() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.may_modify_values_referenced_by_formulas)
  return _internal_may_modify_values_referenced_by_formulas();
}
inline void CellMapArchive::_internal_set_may_modify_values_referenced_by_formulas(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.may_modify_values_referenced_by_formulas_ = value;
}
inline void CellMapArchive::set_may_modify_values_referenced_by_formulas(bool value) {
  _internal_set_may_modify_values_referenced_by_formulas(value);
  // @@protoc_insertion_point(field_set:TST.CellMapArchive.may_modify_values_referenced_by_formulas)
}

// optional bool applies_to_hidden = 6 [default = false];
inline bool CellMapArchive::_internal_has_applies_to_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CellMapArchive::has_applies_to_hidden() const {
  return _internal_has_applies_to_hidden();
}
inline void CellMapArchive::clear_applies_to_hidden() {
  _impl_.applies_to_hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CellMapArchive::_internal_applies_to_hidden() const {
  return _impl_.applies_to_hidden_;
}
inline bool CellMapArchive::applies_to_hidden() const {
  // @@protoc_insertion_point(field_get:TST.CellMapArchive.applies_to_hidden)
  return _internal_applies_to_hidden();
}
inline void CellMapArchive::_internal_set_applies_to_hidden(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.applies_to_hidden_ = value;
}
inline void CellMapArchive::set_applies_to_hidden(bool value) {
  _internal_set_applies_to_hidden(value);
  // @@protoc_insertion_point(field_set:TST.CellMapArchive.applies_to_hidden)
}

// -------------------------------------------------------------------

// DoubleStyleMapArchive_DoubleStyleMapEntryArchive

// required .TST.CellID cell_id = 1;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_has_cell_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_id_ != nullptr);
  return value;
}
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_cell_id() const {
  return _internal_has_cell_id();
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::clear_cell_id() {
  if (_impl_.cell_id_ != nullptr) _impl_.cell_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellID& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_cell_id() const {
  const ::TST::CellID* p = _impl_.cell_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::cell_id() const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.cell_id)
  return _internal_cell_id();
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_set_allocated_cell_id(
    ::TST::CellID* cell_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_id_);
  }
  _impl_.cell_id_ = cell_id;
  if (cell_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.cell_id)
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_cell_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cell_id_;
  _impl_.cell_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_release_cell_id() {
  // @@protoc_insertion_point(field_release:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.cell_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cell_id_;
  _impl_.cell_id_ = nullptr;
  return temp;
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_mutable_cell_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cell_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.cell_id_ = p;
  }
  return _impl_.cell_id_;
}
inline ::TST::CellID* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_cell_id() {
  ::TST::CellID* _msg = _internal_mutable_cell_id();
  // @@protoc_insertion_point(field_mutable:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.cell_id)
  return _msg;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_cell_id(::TST::CellID* cell_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cell_id_;
  }
  if (cell_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cell_id);
    if (message_arena != submessage_arena) {
      cell_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cell_id_ = cell_id;
  // @@protoc_insertion_point(field_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.cell_id)
}

// required .TSP.Reference old_style = 2;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_has_old_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_style_ != nullptr);
  return value;
}
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_old_style() const {
  return _internal_has_old_style();
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_old_style() const {
  const ::TSP::Reference* p = _impl_.old_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::old_style() const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.old_style)
  return _internal_old_style();
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_set_allocated_old_style(
    ::TSP::Reference* old_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_style_);
  }
  _impl_.old_style_ = old_style;
  if (old_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.old_style)
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_old_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.old_style_;
  _impl_.old_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_release_old_style() {
  // @@protoc_insertion_point(field_release:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.old_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.old_style_;
  _impl_.old_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_mutable_old_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.old_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.old_style_ = p;
  }
  return _impl_.old_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_old_style() {
  ::TSP::Reference* _msg = _internal_mutable_old_style();
  // @@protoc_insertion_point(field_mutable:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.old_style)
  return _msg;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_old_style(::TSP::Reference* old_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_style_);
  }
  if (old_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_style));
    if (message_arena != submessage_arena) {
      old_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.old_style_ = old_style;
  // @@protoc_insertion_point(field_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.old_style)
}

// required .TSP.Reference new_style = 3;
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_has_new_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new_style_ != nullptr);
  return value;
}
inline bool DoubleStyleMapArchive_DoubleStyleMapEntryArchive::has_new_style() const {
  return _internal_has_new_style();
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_new_style() const {
  const ::TSP::Reference* p = _impl_.new_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& DoubleStyleMapArchive_DoubleStyleMapEntryArchive::new_style() const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.new_style)
  return _internal_new_style();
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_set_allocated_new_style(
    ::TSP::Reference* new_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_style_);
  }
  _impl_.new_style_ = new_style;
  if (new_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.new_style)
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::release_new_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.new_style_;
  _impl_.new_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::unsafe_arena_release_new_style() {
  // @@protoc_insertion_point(field_release:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.new_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.new_style_;
  _impl_.new_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::_internal_mutable_new_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.new_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.new_style_ = p;
  }
  return _impl_.new_style_;
}
inline ::TSP::Reference* DoubleStyleMapArchive_DoubleStyleMapEntryArchive::mutable_new_style() {
  ::TSP::Reference* _msg = _internal_mutable_new_style();
  // @@protoc_insertion_point(field_mutable:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.new_style)
  return _msg;
}
inline void DoubleStyleMapArchive_DoubleStyleMapEntryArchive::set_allocated_new_style(::TSP::Reference* new_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_style_);
  }
  if (new_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_style));
    if (message_arena != submessage_arena) {
      new_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.new_style_ = new_style;
  // @@protoc_insertion_point(field_set_allocated:TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive.new_style)
}

// -------------------------------------------------------------------

// DoubleStyleMapArchive

// required uint32 capacity = 1;
inline bool DoubleStyleMapArchive::_internal_has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DoubleStyleMapArchive::has_capacity() const {
  return _internal_has_capacity();
}
inline void DoubleStyleMapArchive::clear_capacity() {
  _impl_.capacity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t DoubleStyleMapArchive::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t DoubleStyleMapArchive::capacity() const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.capacity)
  return _internal_capacity();
}
inline void DoubleStyleMapArchive::_internal_set_capacity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.capacity_ = value;
}
inline void DoubleStyleMapArchive::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:TST.DoubleStyleMapArchive.capacity)
}

// required uint32 count = 2;
inline bool DoubleStyleMapArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DoubleStyleMapArchive::has_count() const {
  return _internal_has_count();
}
inline void DoubleStyleMapArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DoubleStyleMapArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t DoubleStyleMapArchive::count() const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.count)
  return _internal_count();
}
inline void DoubleStyleMapArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}
inline void DoubleStyleMapArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TST.DoubleStyleMapArchive.count)
}

// repeated .TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3;
inline int DoubleStyleMapArchive::_internal_cell_map_entry_size() const {
  return _impl_.cell_map_entry_.size();
}
inline int DoubleStyleMapArchive::cell_map_entry_size() const {
  return _internal_cell_map_entry_size();
}
inline void DoubleStyleMapArchive::clear_cell_map_entry() {
  _impl_.cell_map_entry_.Clear();
}
inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* DoubleStyleMapArchive::mutable_cell_map_entry(int index) {
  // @@protoc_insertion_point(field_mutable:TST.DoubleStyleMapArchive.cell_map_entry)
  return _impl_.cell_map_entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >*
DoubleStyleMapArchive::mutable_cell_map_entry() {
  // @@protoc_insertion_point(field_mutable_list:TST.DoubleStyleMapArchive.cell_map_entry)
  return &_impl_.cell_map_entry_;
}
inline const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& DoubleStyleMapArchive::_internal_cell_map_entry(int index) const {
  return _impl_.cell_map_entry_.Get(index);
}
inline const ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive& DoubleStyleMapArchive::cell_map_entry(int index) const {
  // @@protoc_insertion_point(field_get:TST.DoubleStyleMapArchive.cell_map_entry)
  return _internal_cell_map_entry(index);
}
inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* DoubleStyleMapArchive::_internal_add_cell_map_entry() {
  return _impl_.cell_map_entry_.Add();
}
inline ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* DoubleStyleMapArchive::add_cell_map_entry() {
  ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive* _add = _internal_add_cell_map_entry();
  // @@protoc_insertion_point(field_add:TST.DoubleStyleMapArchive.cell_map_entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::DoubleStyleMapArchive_DoubleStyleMapEntryArchive >&
DoubleStyleMapArchive::cell_map_entry() const {
  // @@protoc_insertion_point(field_list:TST.DoubleStyleMapArchive.cell_map_entry)
  return _impl_.cell_map_entry_;
}

// -------------------------------------------------------------------

// StyleTableMapArchive_StyleTableMapEntryArchive

// required uint32 key = 1;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_key() const {
  return _internal_has_key();
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::clear_key() {
  _impl_.key_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StyleTableMapArchive_StyleTableMapEntryArchive::_internal_key() const {
  return _impl_.key_;
}
inline uint32_t StyleTableMapArchive_StyleTableMapEntryArchive::key() const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.StyleTableMapEntryArchive.key)
  return _internal_key();
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::_internal_set_key(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_ = value;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_key(uint32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:TST.StyleTableMapArchive.StyleTableMapEntryArchive.key)
}

// required .TSP.Reference old_style = 2;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::_internal_has_old_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_style_ != nullptr);
  return value;
}
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_old_style() const {
  return _internal_has_old_style();
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::_internal_old_style() const {
  const ::TSP::Reference* p = _impl_.old_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::old_style() const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.StyleTableMapEntryArchive.old_style)
  return _internal_old_style();
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::unsafe_arena_set_allocated_old_style(
    ::TSP::Reference* old_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_style_);
  }
  _impl_.old_style_ = old_style;
  if (old_style) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.StyleTableMapArchive.StyleTableMapEntryArchive.old_style)
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::release_old_style() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.old_style_;
  _impl_.old_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::unsafe_arena_release_old_style() {
  // @@protoc_insertion_point(field_release:TST.StyleTableMapArchive.StyleTableMapEntryArchive.old_style)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.old_style_;
  _impl_.old_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::_internal_mutable_old_style() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.old_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.old_style_ = p;
  }
  return _impl_.old_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::mutable_old_style() {
  ::TSP::Reference* _msg = _internal_mutable_old_style();
  // @@protoc_insertion_point(field_mutable:TST.StyleTableMapArchive.StyleTableMapEntryArchive.old_style)
  return _msg;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_allocated_old_style(::TSP::Reference* old_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.old_style_);
  }
  if (old_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(old_style));
    if (message_arena != submessage_arena) {
      old_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, old_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.old_style_ = old_style;
  // @@protoc_insertion_point(field_set_allocated:TST.StyleTableMapArchive.StyleTableMapEntryArchive.old_style)
}

// required .TSP.Reference new_style = 3;
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::_internal_has_new_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new_style_ != nullptr);
  return value;
}
inline bool StyleTableMapArchive_StyleTableMapEntryArchive::has_new_style() const {
  return _internal_has_new_style();
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::_internal_new_style() const {
  const ::TSP::Reference* p = _impl_.new_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& StyleTableMapArchive_StyleTableMapEntryArchive::new_style() const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.StyleTableMapEntryArchive.new_style)
  return _internal_new_style();
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::unsafe_arena_set_allocated_new_style(
    ::TSP::Reference* new_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_style_);
  }
  _impl_.new_style_ = new_style;
  if (new_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.StyleTableMapArchive.StyleTableMapEntryArchive.new_style)
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::release_new_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.new_style_;
  _impl_.new_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::unsafe_arena_release_new_style() {
  // @@protoc_insertion_point(field_release:TST.StyleTableMapArchive.StyleTableMapEntryArchive.new_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.new_style_;
  _impl_.new_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::_internal_mutable_new_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.new_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.new_style_ = p;
  }
  return _impl_.new_style_;
}
inline ::TSP::Reference* StyleTableMapArchive_StyleTableMapEntryArchive::mutable_new_style() {
  ::TSP::Reference* _msg = _internal_mutable_new_style();
  // @@protoc_insertion_point(field_mutable:TST.StyleTableMapArchive.StyleTableMapEntryArchive.new_style)
  return _msg;
}
inline void StyleTableMapArchive_StyleTableMapEntryArchive::set_allocated_new_style(::TSP::Reference* new_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_style_);
  }
  if (new_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_style));
    if (message_arena != submessage_arena) {
      new_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.new_style_ = new_style;
  // @@protoc_insertion_point(field_set_allocated:TST.StyleTableMapArchive.StyleTableMapEntryArchive.new_style)
}

// -------------------------------------------------------------------

// StyleTableMapArchive

// required uint32 capacity = 1;
inline bool StyleTableMapArchive::_internal_has_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StyleTableMapArchive::has_capacity() const {
  return _internal_has_capacity();
}
inline void StyleTableMapArchive::clear_capacity() {
  _impl_.capacity_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StyleTableMapArchive::_internal_capacity() const {
  return _impl_.capacity_;
}
inline uint32_t StyleTableMapArchive::capacity() const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.capacity)
  return _internal_capacity();
}
inline void StyleTableMapArchive::_internal_set_capacity(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.capacity_ = value;
}
inline void StyleTableMapArchive::set_capacity(uint32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:TST.StyleTableMapArchive.capacity)
}

// required uint32 count = 2;
inline bool StyleTableMapArchive::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StyleTableMapArchive::has_count() const {
  return _internal_has_count();
}
inline void StyleTableMapArchive::clear_count() {
  _impl_.count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StyleTableMapArchive::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t StyleTableMapArchive::count() const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.count)
  return _internal_count();
}
inline void StyleTableMapArchive::_internal_set_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}
inline void StyleTableMapArchive::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TST.StyleTableMapArchive.count)
}

// repeated .TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3;
inline int StyleTableMapArchive::_internal_map_entry_size() const {
  return _impl_.map_entry_.size();
}
inline int StyleTableMapArchive::map_entry_size() const {
  return _internal_map_entry_size();
}
inline void StyleTableMapArchive::clear_map_entry() {
  _impl_.map_entry_.Clear();
}
inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* StyleTableMapArchive::mutable_map_entry(int index) {
  // @@protoc_insertion_point(field_mutable:TST.StyleTableMapArchive.map_entry)
  return _impl_.map_entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >*
StyleTableMapArchive::mutable_map_entry() {
  // @@protoc_insertion_point(field_mutable_list:TST.StyleTableMapArchive.map_entry)
  return &_impl_.map_entry_;
}
inline const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& StyleTableMapArchive::_internal_map_entry(int index) const {
  return _impl_.map_entry_.Get(index);
}
inline const ::TST::StyleTableMapArchive_StyleTableMapEntryArchive& StyleTableMapArchive::map_entry(int index) const {
  // @@protoc_insertion_point(field_get:TST.StyleTableMapArchive.map_entry)
  return _internal_map_entry(index);
}
inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* StyleTableMapArchive::_internal_add_map_entry() {
  return _impl_.map_entry_.Add();
}
inline ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* StyleTableMapArchive::add_map_entry() {
  ::TST::StyleTableMapArchive_StyleTableMapEntryArchive* _add = _internal_add_map_entry();
  // @@protoc_insertion_point(field_add:TST.StyleTableMapArchive.map_entry)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::StyleTableMapArchive_StyleTableMapEntryArchive >&
StyleTableMapArchive::map_entry() const {
  // @@protoc_insertion_point(field_list:TST.StyleTableMapArchive.map_entry)
  return _impl_.map_entry_;
}

// -------------------------------------------------------------------

// SelectionArchive

// optional .TSP.Reference tableModel = 1 [deprecated = true];
inline bool SelectionArchive::_internal_has_tablemodel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tablemodel_ != nullptr);
  return value;
}
inline bool SelectionArchive::has_tablemodel() const {
  return _internal_has_tablemodel();
}
inline const ::TSP::Reference& SelectionArchive::_internal_tablemodel() const {
  const ::TSP::Reference* p = _impl_.tablemodel_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& SelectionArchive::tablemodel() const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.tableModel)
  return _internal_tablemodel();
}
inline void SelectionArchive::unsafe_arena_set_allocated_tablemodel(
    ::TSP::Reference* tablemodel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tablemodel_);
  }
  _impl_.tablemodel_ = tablemodel;
  if (tablemodel) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.SelectionArchive.tableModel)
}
inline ::TSP::Reference* SelectionArchive::release_tablemodel() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.tablemodel_;
  _impl_.tablemodel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* SelectionArchive::unsafe_arena_release_tablemodel() {
  // @@protoc_insertion_point(field_release:TST.SelectionArchive.tableModel)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.tablemodel_;
  _impl_.tablemodel_ = nullptr;
  return temp;
}
inline ::TSP::Reference* SelectionArchive::_internal_mutable_tablemodel() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tablemodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.tablemodel_ = p;
  }
  return _impl_.tablemodel_;
}
inline ::TSP::Reference* SelectionArchive::mutable_tablemodel() {
  ::TSP::Reference* _msg = _internal_mutable_tablemodel();
  // @@protoc_insertion_point(field_mutable:TST.SelectionArchive.tableModel)
  return _msg;
}
inline void SelectionArchive::set_allocated_tablemodel(::TSP::Reference* tablemodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tablemodel_);
  }
  if (tablemodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tablemodel));
    if (message_arena != submessage_arena) {
      tablemodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tablemodel, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tablemodel_ = tablemodel;
  // @@protoc_insertion_point(field_set_allocated:TST.SelectionArchive.tableModel)
}

// required .TST.SelectionTypeArchive selection_type = 4;
inline bool SelectionArchive::_internal_has_selection_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SelectionArchive::has_selection_type() const {
  return _internal_has_selection_type();
}
inline void SelectionArchive::clear_selection_type() {
  _impl_.selection_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TST::SelectionTypeArchive SelectionArchive::_internal_selection_type() const {
  return static_cast< ::TST::SelectionTypeArchive >(_impl_.selection_type_);
}
inline ::TST::SelectionTypeArchive SelectionArchive::selection_type() const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.selection_type)
  return _internal_selection_type();
}
inline void SelectionArchive::_internal_set_selection_type(::TST::SelectionTypeArchive value) {
  assert(::TST::SelectionTypeArchive_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.selection_type_ = value;
}
inline void SelectionArchive::set_selection_type(::TST::SelectionTypeArchive value) {
  _internal_set_selection_type(value);
  // @@protoc_insertion_point(field_set:TST.SelectionArchive.selection_type)
}

// optional .TST.CellID anchor_cell = 5;
inline bool SelectionArchive::_internal_has_anchor_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.anchor_cell_ != nullptr);
  return value;
}
inline bool SelectionArchive::has_anchor_cell() const {
  return _internal_has_anchor_cell();
}
inline void SelectionArchive::clear_anchor_cell() {
  if (_impl_.anchor_cell_ != nullptr) _impl_.anchor_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::CellID& SelectionArchive::_internal_anchor_cell() const {
  const ::TST::CellID* p = _impl_.anchor_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& SelectionArchive::anchor_cell() const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.anchor_cell)
  return _internal_anchor_cell();
}
inline void SelectionArchive::unsafe_arena_set_allocated_anchor_cell(
    ::TST::CellID* anchor_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.anchor_cell_);
  }
  _impl_.anchor_cell_ = anchor_cell;
  if (anchor_cell) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.SelectionArchive.anchor_cell)
}
inline ::TST::CellID* SelectionArchive::release_anchor_cell() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellID* temp = _impl_.anchor_cell_;
  _impl_.anchor_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* SelectionArchive::unsafe_arena_release_anchor_cell() {
  // @@protoc_insertion_point(field_release:TST.SelectionArchive.anchor_cell)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellID* temp = _impl_.anchor_cell_;
  _impl_.anchor_cell_ = nullptr;
  return temp;
}
inline ::TST::CellID* SelectionArchive::_internal_mutable_anchor_cell() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.anchor_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.anchor_cell_ = p;
  }
  return _impl_.anchor_cell_;
}
inline ::TST::CellID* SelectionArchive::mutable_anchor_cell() {
  ::TST::CellID* _msg = _internal_mutable_anchor_cell();
  // @@protoc_insertion_point(field_mutable:TST.SelectionArchive.anchor_cell)
  return _msg;
}
inline void SelectionArchive::set_allocated_anchor_cell(::TST::CellID* anchor_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.anchor_cell_;
  }
  if (anchor_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(anchor_cell);
    if (message_arena != submessage_arena) {
      anchor_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anchor_cell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.anchor_cell_ = anchor_cell;
  // @@protoc_insertion_point(field_set_allocated:TST.SelectionArchive.anchor_cell)
}

// repeated .TST.CellRange cell_ranges = 6;
inline int SelectionArchive::_internal_cell_ranges_size() const {
  return _impl_.cell_ranges_.size();
}
inline int SelectionArchive::cell_ranges_size() const {
  return _internal_cell_ranges_size();
}
inline void SelectionArchive::clear_cell_ranges() {
  _impl_.cell_ranges_.Clear();
}
inline ::TST::CellRange* SelectionArchive::mutable_cell_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:TST.SelectionArchive.cell_ranges)
  return _impl_.cell_ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
SelectionArchive::mutable_cell_ranges() {
  // @@protoc_insertion_point(field_mutable_list:TST.SelectionArchive.cell_ranges)
  return &_impl_.cell_ranges_;
}
inline const ::TST::CellRange& SelectionArchive::_internal_cell_ranges(int index) const {
  return _impl_.cell_ranges_.Get(index);
}
inline const ::TST::CellRange& SelectionArchive::cell_ranges(int index) const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.cell_ranges)
  return _internal_cell_ranges(index);
}
inline ::TST::CellRange* SelectionArchive::_internal_add_cell_ranges() {
  return _impl_.cell_ranges_.Add();
}
inline ::TST::CellRange* SelectionArchive::add_cell_ranges() {
  ::TST::CellRange* _add = _internal_add_cell_ranges();
  // @@protoc_insertion_point(field_add:TST.SelectionArchive.cell_ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
SelectionArchive::cell_ranges() const {
  // @@protoc_insertion_point(field_list:TST.SelectionArchive.cell_ranges)
  return _impl_.cell_ranges_;
}

// repeated .TST.CellRange base_ranges = 7;
inline int SelectionArchive::_internal_base_ranges_size() const {
  return _impl_.base_ranges_.size();
}
inline int SelectionArchive::base_ranges_size() const {
  return _internal_base_ranges_size();
}
inline void SelectionArchive::clear_base_ranges() {
  _impl_.base_ranges_.Clear();
}
inline ::TST::CellRange* SelectionArchive::mutable_base_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:TST.SelectionArchive.base_ranges)
  return _impl_.base_ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
SelectionArchive::mutable_base_ranges() {
  // @@protoc_insertion_point(field_mutable_list:TST.SelectionArchive.base_ranges)
  return &_impl_.base_ranges_;
}
inline const ::TST::CellRange& SelectionArchive::_internal_base_ranges(int index) const {
  return _impl_.base_ranges_.Get(index);
}
inline const ::TST::CellRange& SelectionArchive::base_ranges(int index) const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.base_ranges)
  return _internal_base_ranges(index);
}
inline ::TST::CellRange* SelectionArchive::_internal_add_base_ranges() {
  return _impl_.base_ranges_.Add();
}
inline ::TST::CellRange* SelectionArchive::add_base_ranges() {
  ::TST::CellRange* _add = _internal_add_base_ranges();
  // @@protoc_insertion_point(field_add:TST.SelectionArchive.base_ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
SelectionArchive::base_ranges() const {
  // @@protoc_insertion_point(field_list:TST.SelectionArchive.base_ranges)
  return _impl_.base_ranges_;
}

// optional .TST.CellID cursor_cell = 8;
inline bool SelectionArchive::_internal_has_cursor_cell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cursor_cell_ != nullptr);
  return value;
}
inline bool SelectionArchive::has_cursor_cell() const {
  return _internal_has_cursor_cell();
}
inline void SelectionArchive::clear_cursor_cell() {
  if (_impl_.cursor_cell_ != nullptr) _impl_.cursor_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TST::CellID& SelectionArchive::_internal_cursor_cell() const {
  const ::TST::CellID* p = _impl_.cursor_cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& SelectionArchive::cursor_cell() const {
  // @@protoc_insertion_point(field_get:TST.SelectionArchive.cursor_cell)
  return _internal_cursor_cell();
}
inline void SelectionArchive::unsafe_arena_set_allocated_cursor_cell(
    ::TST::CellID* cursor_cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cursor_cell_);
  }
  _impl_.cursor_cell_ = cursor_cell;
  if (cursor_cell) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.SelectionArchive.cursor_cell)
}
inline ::TST::CellID* SelectionArchive::release_cursor_cell() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::CellID* temp = _impl_.cursor_cell_;
  _impl_.cursor_cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* SelectionArchive::unsafe_arena_release_cursor_cell() {
  // @@protoc_insertion_point(field_release:TST.SelectionArchive.cursor_cell)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::CellID* temp = _impl_.cursor_cell_;
  _impl_.cursor_cell_ = nullptr;
  return temp;
}
inline ::TST::CellID* SelectionArchive::_internal_mutable_cursor_cell() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cursor_cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.cursor_cell_ = p;
  }
  return _impl_.cursor_cell_;
}
inline ::TST::CellID* SelectionArchive::mutable_cursor_cell() {
  ::TST::CellID* _msg = _internal_mutable_cursor_cell();
  // @@protoc_insertion_point(field_mutable:TST.SelectionArchive.cursor_cell)
  return _msg;
}
inline void SelectionArchive::set_allocated_cursor_cell(::TST::CellID* cursor_cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cursor_cell_;
  }
  if (cursor_cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cursor_cell);
    if (message_arena != submessage_arena) {
      cursor_cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor_cell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cursor_cell_ = cursor_cell;
  // @@protoc_insertion_point(field_set_allocated:TST.SelectionArchive.cursor_cell)
}

// -------------------------------------------------------------------

// FilterRuleArchive

// required .TST.FormulaPredicateArchive predicate = 1;
inline bool FilterRuleArchive::_internal_has_predicate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicate_ != nullptr);
  return value;
}
inline bool FilterRuleArchive::has_predicate() const {
  return _internal_has_predicate();
}
inline void FilterRuleArchive::clear_predicate() {
  if (_impl_.predicate_ != nullptr) _impl_.predicate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::FormulaPredicateArchive& FilterRuleArchive::_internal_predicate() const {
  const ::TST::FormulaPredicateArchive* p = _impl_.predicate_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::FormulaPredicateArchive&>(
      ::TST::_FormulaPredicateArchive_default_instance_);
}
inline const ::TST::FormulaPredicateArchive& FilterRuleArchive::predicate() const {
  // @@protoc_insertion_point(field_get:TST.FilterRuleArchive.predicate)
  return _internal_predicate();
}
inline void FilterRuleArchive::unsafe_arena_set_allocated_predicate(
    ::TST::FormulaPredicateArchive* predicate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicate_);
  }
  _impl_.predicate_ = predicate;
  if (predicate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FilterRuleArchive.predicate)
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::release_predicate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::FormulaPredicateArchive* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::unsafe_arena_release_predicate() {
  // @@protoc_insertion_point(field_release:TST.FilterRuleArchive.predicate)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::FormulaPredicateArchive* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  return temp;
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::_internal_mutable_predicate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.predicate_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::FormulaPredicateArchive>(GetArenaForAllocation());
    _impl_.predicate_ = p;
  }
  return _impl_.predicate_;
}
inline ::TST::FormulaPredicateArchive* FilterRuleArchive::mutable_predicate() {
  ::TST::FormulaPredicateArchive* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:TST.FilterRuleArchive.predicate)
  return _msg;
}
inline void FilterRuleArchive::set_allocated_predicate(::TST::FormulaPredicateArchive* predicate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.predicate_;
  }
  if (predicate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(predicate);
    if (message_arena != submessage_arena) {
      predicate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.predicate_ = predicate;
  // @@protoc_insertion_point(field_set_allocated:TST.FilterRuleArchive.predicate)
}

// optional bool disabled = 2;
inline bool FilterRuleArchive::_internal_has_disabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FilterRuleArchive::has_disabled() const {
  return _internal_has_disabled();
}
inline void FilterRuleArchive::clear_disabled() {
  _impl_.disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FilterRuleArchive::_internal_disabled() const {
  return _impl_.disabled_;
}
inline bool FilterRuleArchive::disabled() const {
  // @@protoc_insertion_point(field_get:TST.FilterRuleArchive.disabled)
  return _internal_disabled();
}
inline void FilterRuleArchive::_internal_set_disabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.disabled_ = value;
}
inline void FilterRuleArchive::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:TST.FilterRuleArchive.disabled)
}

// -------------------------------------------------------------------

// TableStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool TableStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TableStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& TableStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& TableStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleArchive.super)
  return _internal_super();
}
inline void TableStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleArchive.super)
}
inline ::TSS::StyleArchive* TableStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* TableStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.TableStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* TableStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* TableStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleArchive.super)
  return _msg;
}
inline void TableStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool TableStyleArchive::_internal_has_override_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void TableStyleArchive::clear_override_count() {
  _impl_.override_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TableStyleArchive::_internal_override_count() const {
  return _impl_.override_count_;
}
inline uint32_t TableStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleArchive.override_count)
  return _internal_override_count();
}
inline void TableStyleArchive::_internal_set_override_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.override_count_ = value;
}
inline void TableStyleArchive::set_override_count(uint32_t value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TST.TableStyleArchive.override_count)
}

// optional .TST.TableStylePropertiesArchive table_properties = 11;
inline bool TableStyleArchive::_internal_has_table_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_properties_ != nullptr);
  return value;
}
inline bool TableStyleArchive::has_table_properties() const {
  return _internal_has_table_properties();
}
inline const ::TST::TableStylePropertiesArchive& TableStyleArchive::_internal_table_properties() const {
  const ::TST::TableStylePropertiesArchive* p = _impl_.table_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TableStylePropertiesArchive&>(
      ::TST::_TableStylePropertiesArchive_default_instance_);
}
inline const ::TST::TableStylePropertiesArchive& TableStyleArchive::table_properties() const {
  // @@protoc_insertion_point(field_get:TST.TableStyleArchive.table_properties)
  return _internal_table_properties();
}
inline void TableStyleArchive::unsafe_arena_set_allocated_table_properties(
    ::TST::TableStylePropertiesArchive* table_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_properties_);
  }
  _impl_.table_properties_ = table_properties;
  if (table_properties) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TableStyleArchive.table_properties)
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::release_table_properties() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TableStylePropertiesArchive* temp = _impl_.table_properties_;
  _impl_.table_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::unsafe_arena_release_table_properties() {
  // @@protoc_insertion_point(field_release:TST.TableStyleArchive.table_properties)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TableStylePropertiesArchive* temp = _impl_.table_properties_;
  _impl_.table_properties_ = nullptr;
  return temp;
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::_internal_mutable_table_properties() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.table_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TableStylePropertiesArchive>(GetArenaForAllocation());
    _impl_.table_properties_ = p;
  }
  return _impl_.table_properties_;
}
inline ::TST::TableStylePropertiesArchive* TableStyleArchive::mutable_table_properties() {
  ::TST::TableStylePropertiesArchive* _msg = _internal_mutable_table_properties();
  // @@protoc_insertion_point(field_mutable:TST.TableStyleArchive.table_properties)
  return _msg;
}
inline void TableStyleArchive::set_allocated_table_properties(::TST::TableStylePropertiesArchive* table_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_properties_);
  }
  if (table_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_properties));
    if (message_arena != submessage_arena) {
      table_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.table_properties_ = table_properties;
  // @@protoc_insertion_point(field_set_allocated:TST.TableStyleArchive.table_properties)
}

// -------------------------------------------------------------------

// CellStyleArchive

// required .TSS.StyleArchive super = 1;
inline bool CellStyleArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool CellStyleArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSS::StyleArchive& CellStyleArchive::_internal_super() const {
  const ::TSS::StyleArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSS::StyleArchive&>(
      ::TSS::_StyleArchive_default_instance_);
}
inline const ::TSS::StyleArchive& CellStyleArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.CellStyleArchive.super)
  return _internal_super();
}
inline void CellStyleArchive::unsafe_arena_set_allocated_super(
    ::TSS::StyleArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellStyleArchive.super)
}
inline ::TSS::StyleArchive* CellStyleArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSS::StyleArchive* CellStyleArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.CellStyleArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSS::StyleArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSS::StyleArchive* CellStyleArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSS::StyleArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSS::StyleArchive* CellStyleArchive::mutable_super() {
  ::TSS::StyleArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.CellStyleArchive.super)
  return _msg;
}
inline void CellStyleArchive::set_allocated_super(::TSS::StyleArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.CellStyleArchive.super)
}

// optional uint32 override_count = 10 [default = 0];
inline bool CellStyleArchive::_internal_has_override_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CellStyleArchive::has_override_count() const {
  return _internal_has_override_count();
}
inline void CellStyleArchive::clear_override_count() {
  _impl_.override_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CellStyleArchive::_internal_override_count() const {
  return _impl_.override_count_;
}
inline uint32_t CellStyleArchive::override_count() const {
  // @@protoc_insertion_point(field_get:TST.CellStyleArchive.override_count)
  return _internal_override_count();
}
inline void CellStyleArchive::_internal_set_override_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.override_count_ = value;
}
inline void CellStyleArchive::set_override_count(uint32_t value) {
  _internal_set_override_count(value);
  // @@protoc_insertion_point(field_set:TST.CellStyleArchive.override_count)
}

// optional .TST.CellStylePropertiesArchive cell_properties = 11;
inline bool CellStyleArchive::_internal_has_cell_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_properties_ != nullptr);
  return value;
}
inline bool CellStyleArchive::has_cell_properties() const {
  return _internal_has_cell_properties();
}
inline const ::TST::CellStylePropertiesArchive& CellStyleArchive::_internal_cell_properties() const {
  const ::TST::CellStylePropertiesArchive* p = _impl_.cell_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellStylePropertiesArchive&>(
      ::TST::_CellStylePropertiesArchive_default_instance_);
}
inline const ::TST::CellStylePropertiesArchive& CellStyleArchive::cell_properties() const {
  // @@protoc_insertion_point(field_get:TST.CellStyleArchive.cell_properties)
  return _internal_cell_properties();
}
inline void CellStyleArchive::unsafe_arena_set_allocated_cell_properties(
    ::TST::CellStylePropertiesArchive* cell_properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_properties_);
  }
  _impl_.cell_properties_ = cell_properties;
  if (cell_properties) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CellStyleArchive.cell_properties)
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::release_cell_properties() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellStylePropertiesArchive* temp = _impl_.cell_properties_;
  _impl_.cell_properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::unsafe_arena_release_cell_properties() {
  // @@protoc_insertion_point(field_release:TST.CellStyleArchive.cell_properties)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellStylePropertiesArchive* temp = _impl_.cell_properties_;
  _impl_.cell_properties_ = nullptr;
  return temp;
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::_internal_mutable_cell_properties() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cell_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellStylePropertiesArchive>(GetArenaForAllocation());
    _impl_.cell_properties_ = p;
  }
  return _impl_.cell_properties_;
}
inline ::TST::CellStylePropertiesArchive* CellStyleArchive::mutable_cell_properties() {
  ::TST::CellStylePropertiesArchive* _msg = _internal_mutable_cell_properties();
  // @@protoc_insertion_point(field_mutable:TST.CellStyleArchive.cell_properties)
  return _msg;
}
inline void CellStyleArchive::set_allocated_cell_properties(::TST::CellStylePropertiesArchive* cell_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_properties_);
  }
  if (cell_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_properties));
    if (message_arena != submessage_arena) {
      cell_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cell_properties_ = cell_properties;
  // @@protoc_insertion_point(field_set_allocated:TST.CellStyleArchive.cell_properties)
}

// -------------------------------------------------------------------

// FormulaPredicateArchive

// required .TSCE.FormulaArchive formula = 1;
inline bool FormulaPredicateArchive::_internal_has_formula() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.formula_ != nullptr);
  return value;
}
inline bool FormulaPredicateArchive::has_formula() const {
  return _internal_has_formula();
}
inline const ::TSCE::FormulaArchive& FormulaPredicateArchive::_internal_formula() const {
  const ::TSCE::FormulaArchive* p = _impl_.formula_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::FormulaArchive&>(
      ::TSCE::_FormulaArchive_default_instance_);
}
inline const ::TSCE::FormulaArchive& FormulaPredicateArchive::formula() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.formula)
  return _internal_formula();
}
inline void FormulaPredicateArchive::unsafe_arena_set_allocated_formula(
    ::TSCE::FormulaArchive* formula) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  _impl_.formula_ = formula;
  if (formula) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FormulaPredicateArchive.formula)
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::release_formula() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_release:TST.FormulaPredicateArchive.formula)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::FormulaArchive* temp = _impl_.formula_;
  _impl_.formula_ = nullptr;
  return temp;
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::_internal_mutable_formula() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.formula_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::FormulaArchive>(GetArenaForAllocation());
    _impl_.formula_ = p;
  }
  return _impl_.formula_;
}
inline ::TSCE::FormulaArchive* FormulaPredicateArchive::mutable_formula() {
  ::TSCE::FormulaArchive* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:TST.FormulaPredicateArchive.formula)
  return _msg;
}
inline void FormulaPredicateArchive::set_allocated_formula(::TSCE::FormulaArchive* formula) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.formula_);
  }
  if (formula) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(formula));
    if (message_arena != submessage_arena) {
      formula = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, formula, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.formula_ = formula;
  // @@protoc_insertion_point(field_set_allocated:TST.FormulaPredicateArchive.formula)
}

// required .TST.FormulaPredicateArchive.FormulaPredicateType predicate_type = 2;
inline bool FormulaPredicateArchive::_internal_has_predicate_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_predicate_type() const {
  return _internal_has_predicate_type();
}
inline void FormulaPredicateArchive::clear_predicate_type() {
  _impl_.predicate_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::TST::FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::_internal_predicate_type() const {
  return static_cast< ::TST::FormulaPredicateArchive_FormulaPredicateType >(_impl_.predicate_type_);
}
inline ::TST::FormulaPredicateArchive_FormulaPredicateType FormulaPredicateArchive::predicate_type() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.predicate_type)
  return _internal_predicate_type();
}
inline void FormulaPredicateArchive::_internal_set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value) {
  assert(::TST::FormulaPredicateArchive_FormulaPredicateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.predicate_type_ = value;
}
inline void FormulaPredicateArchive::set_predicate_type(::TST::FormulaPredicateArchive_FormulaPredicateType value) {
  _internal_set_predicate_type(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.predicate_type)
}

// required .TST.FormulaPredicateArchive.QualifierType qualifier1 = 3;
inline bool FormulaPredicateArchive::_internal_has_qualifier1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_qualifier1() const {
  return _internal_has_qualifier1();
}
inline void FormulaPredicateArchive::clear_qualifier1() {
  _impl_.qualifier1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::_internal_qualifier1() const {
  return static_cast< ::TST::FormulaPredicateArchive_QualifierType >(_impl_.qualifier1_);
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::qualifier1() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.qualifier1)
  return _internal_qualifier1();
}
inline void FormulaPredicateArchive::_internal_set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value) {
  assert(::TST::FormulaPredicateArchive_QualifierType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.qualifier1_ = value;
}
inline void FormulaPredicateArchive::set_qualifier1(::TST::FormulaPredicateArchive_QualifierType value) {
  _internal_set_qualifier1(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.qualifier1)
}

// required .TST.FormulaPredicateArchive.QualifierType qualifier2 = 4;
inline bool FormulaPredicateArchive::_internal_has_qualifier2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_qualifier2() const {
  return _internal_has_qualifier2();
}
inline void FormulaPredicateArchive::clear_qualifier2() {
  _impl_.qualifier2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::_internal_qualifier2() const {
  return static_cast< ::TST::FormulaPredicateArchive_QualifierType >(_impl_.qualifier2_);
}
inline ::TST::FormulaPredicateArchive_QualifierType FormulaPredicateArchive::qualifier2() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.qualifier2)
  return _internal_qualifier2();
}
inline void FormulaPredicateArchive::_internal_set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value) {
  assert(::TST::FormulaPredicateArchive_QualifierType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.qualifier2_ = value;
}
inline void FormulaPredicateArchive::set_qualifier2(::TST::FormulaPredicateArchive_QualifierType value) {
  _internal_set_qualifier2(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.qualifier2)
}

// required int32 param_index1 = 5;
inline bool FormulaPredicateArchive::_internal_has_param_index1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_param_index1() const {
  return _internal_has_param_index1();
}
inline void FormulaPredicateArchive::clear_param_index1() {
  _impl_.param_index1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t FormulaPredicateArchive::_internal_param_index1() const {
  return _impl_.param_index1_;
}
inline int32_t FormulaPredicateArchive::param_index1() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.param_index1)
  return _internal_param_index1();
}
inline void FormulaPredicateArchive::_internal_set_param_index1(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.param_index1_ = value;
}
inline void FormulaPredicateArchive::set_param_index1(int32_t value) {
  _internal_set_param_index1(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.param_index1)
}

// required int32 param_index2 = 6;
inline bool FormulaPredicateArchive::_internal_has_param_index2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_param_index2() const {
  return _internal_has_param_index2();
}
inline void FormulaPredicateArchive::clear_param_index2() {
  _impl_.param_index2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t FormulaPredicateArchive::_internal_param_index2() const {
  return _impl_.param_index2_;
}
inline int32_t FormulaPredicateArchive::param_index2() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.param_index2)
  return _internal_param_index2();
}
inline void FormulaPredicateArchive::_internal_set_param_index2(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.param_index2_ = value;
}
inline void FormulaPredicateArchive::set_param_index2(int32_t value) {
  _internal_set_param_index2(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.param_index2)
}

// required int32 param_index0 = 7;
inline bool FormulaPredicateArchive::_internal_has_param_index0() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FormulaPredicateArchive::has_param_index0() const {
  return _internal_has_param_index0();
}
inline void FormulaPredicateArchive::clear_param_index0() {
  _impl_.param_index0_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t FormulaPredicateArchive::_internal_param_index0() const {
  return _impl_.param_index0_;
}
inline int32_t FormulaPredicateArchive::param_index0() const {
  // @@protoc_insertion_point(field_get:TST.FormulaPredicateArchive.param_index0)
  return _internal_param_index0();
}
inline void FormulaPredicateArchive::_internal_set_param_index0(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.param_index0_ = value;
}
inline void FormulaPredicateArchive::set_param_index0(int32_t value) {
  _internal_set_param_index0(value);
  // @@protoc_insertion_point(field_set:TST.FormulaPredicateArchive.param_index0)
}

// -------------------------------------------------------------------

// ConditionalStyleSetArchive_ConditionalStyleRule

// required .TST.FormulaPredicateArchive predicate = 1;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::_internal_has_predicate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.predicate_ != nullptr);
  return value;
}
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_predicate() const {
  return _internal_has_predicate();
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::clear_predicate() {
  if (_impl_.predicate_ != nullptr) _impl_.predicate_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::FormulaPredicateArchive& ConditionalStyleSetArchive_ConditionalStyleRule::_internal_predicate() const {
  const ::TST::FormulaPredicateArchive* p = _impl_.predicate_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::FormulaPredicateArchive&>(
      ::TST::_FormulaPredicateArchive_default_instance_);
}
inline const ::TST::FormulaPredicateArchive& ConditionalStyleSetArchive_ConditionalStyleRule::predicate() const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.ConditionalStyleRule.predicate)
  return _internal_predicate();
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_set_allocated_predicate(
    ::TST::FormulaPredicateArchive* predicate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicate_);
  }
  _impl_.predicate_ = predicate;
  if (predicate) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.predicate)
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::release_predicate() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::FormulaPredicateArchive* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_release_predicate() {
  // @@protoc_insertion_point(field_release:TST.ConditionalStyleSetArchive.ConditionalStyleRule.predicate)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::FormulaPredicateArchive* temp = _impl_.predicate_;
  _impl_.predicate_ = nullptr;
  return temp;
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::_internal_mutable_predicate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.predicate_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::FormulaPredicateArchive>(GetArenaForAllocation());
    _impl_.predicate_ = p;
  }
  return _impl_.predicate_;
}
inline ::TST::FormulaPredicateArchive* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_predicate() {
  ::TST::FormulaPredicateArchive* _msg = _internal_mutable_predicate();
  // @@protoc_insertion_point(field_mutable:TST.ConditionalStyleSetArchive.ConditionalStyleRule.predicate)
  return _msg;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_predicate(::TST::FormulaPredicateArchive* predicate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.predicate_;
  }
  if (predicate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(predicate);
    if (message_arena != submessage_arena) {
      predicate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.predicate_ = predicate;
  // @@protoc_insertion_point(field_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.predicate)
}

// required .TSP.Reference cell_style = 2;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::_internal_has_cell_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cell_style_ != nullptr);
  return value;
}
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_cell_style() const {
  return _internal_has_cell_style();
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::_internal_cell_style() const {
  const ::TSP::Reference* p = _impl_.cell_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::cell_style() const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.ConditionalStyleRule.cell_style)
  return _internal_cell_style();
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_set_allocated_cell_style(
    ::TSP::Reference* cell_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  _impl_.cell_style_ = cell_style;
  if (cell_style) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.cell_style)
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::release_cell_style() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_release_cell_style() {
  // @@protoc_insertion_point(field_release:TST.ConditionalStyleSetArchive.ConditionalStyleRule.cell_style)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.cell_style_;
  _impl_.cell_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::_internal_mutable_cell_style() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.cell_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.cell_style_ = p;
  }
  return _impl_.cell_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_cell_style() {
  ::TSP::Reference* _msg = _internal_mutable_cell_style();
  // @@protoc_insertion_point(field_mutable:TST.ConditionalStyleSetArchive.ConditionalStyleRule.cell_style)
  return _msg;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_cell_style(::TSP::Reference* cell_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_style_);
  }
  if (cell_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell_style));
    if (message_arena != submessage_arena) {
      cell_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cell_style_ = cell_style;
  // @@protoc_insertion_point(field_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.cell_style)
}

// required .TSP.Reference text_style = 3;
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::_internal_has_text_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_style_ != nullptr);
  return value;
}
inline bool ConditionalStyleSetArchive_ConditionalStyleRule::has_text_style() const {
  return _internal_has_text_style();
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::_internal_text_style() const {
  const ::TSP::Reference* p = _impl_.text_style_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& ConditionalStyleSetArchive_ConditionalStyleRule::text_style() const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.ConditionalStyleRule.text_style)
  return _internal_text_style();
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_set_allocated_text_style(
    ::TSP::Reference* text_style) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  _impl_.text_style_ = text_style;
  if (text_style) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.text_style)
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::release_text_style() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::unsafe_arena_release_text_style() {
  // @@protoc_insertion_point(field_release:TST.ConditionalStyleSetArchive.ConditionalStyleRule.text_style)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Reference* temp = _impl_.text_style_;
  _impl_.text_style_ = nullptr;
  return temp;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::_internal_mutable_text_style() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.text_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.text_style_ = p;
  }
  return _impl_.text_style_;
}
inline ::TSP::Reference* ConditionalStyleSetArchive_ConditionalStyleRule::mutable_text_style() {
  ::TSP::Reference* _msg = _internal_mutable_text_style();
  // @@protoc_insertion_point(field_mutable:TST.ConditionalStyleSetArchive.ConditionalStyleRule.text_style)
  return _msg;
}
inline void ConditionalStyleSetArchive_ConditionalStyleRule::set_allocated_text_style(::TSP::Reference* text_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.text_style_);
  }
  if (text_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_style));
    if (message_arena != submessage_arena) {
      text_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_style, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.text_style_ = text_style;
  // @@protoc_insertion_point(field_set_allocated:TST.ConditionalStyleSetArchive.ConditionalStyleRule.text_style)
}

// -------------------------------------------------------------------

// ConditionalStyleSetArchive

// required uint32 ruleCount = 1;
inline bool ConditionalStyleSetArchive::_internal_has_rulecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConditionalStyleSetArchive::has_rulecount() const {
  return _internal_has_rulecount();
}
inline void ConditionalStyleSetArchive::clear_rulecount() {
  _impl_.rulecount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ConditionalStyleSetArchive::_internal_rulecount() const {
  return _impl_.rulecount_;
}
inline uint32_t ConditionalStyleSetArchive::rulecount() const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.ruleCount)
  return _internal_rulecount();
}
inline void ConditionalStyleSetArchive::_internal_set_rulecount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rulecount_ = value;
}
inline void ConditionalStyleSetArchive::set_rulecount(uint32_t value) {
  _internal_set_rulecount(value);
  // @@protoc_insertion_point(field_set:TST.ConditionalStyleSetArchive.ruleCount)
}

// repeated .TST.ConditionalStyleSetArchive.ConditionalStyleRule rules = 2;
inline int ConditionalStyleSetArchive::_internal_rules_size() const {
  return _impl_.rules_.size();
}
inline int ConditionalStyleSetArchive::rules_size() const {
  return _internal_rules_size();
}
inline void ConditionalStyleSetArchive::clear_rules() {
  _impl_.rules_.Clear();
}
inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* ConditionalStyleSetArchive::mutable_rules(int index) {
  // @@protoc_insertion_point(field_mutable:TST.ConditionalStyleSetArchive.rules)
  return _impl_.rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >*
ConditionalStyleSetArchive::mutable_rules() {
  // @@protoc_insertion_point(field_mutable_list:TST.ConditionalStyleSetArchive.rules)
  return &_impl_.rules_;
}
inline const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& ConditionalStyleSetArchive::_internal_rules(int index) const {
  return _impl_.rules_.Get(index);
}
inline const ::TST::ConditionalStyleSetArchive_ConditionalStyleRule& ConditionalStyleSetArchive::rules(int index) const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.rules)
  return _internal_rules(index);
}
inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* ConditionalStyleSetArchive::_internal_add_rules() {
  return _impl_.rules_.Add();
}
inline ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* ConditionalStyleSetArchive::add_rules() {
  ::TST::ConditionalStyleSetArchive_ConditionalStyleRule* _add = _internal_add_rules();
  // @@protoc_insertion_point(field_add:TST.ConditionalStyleSetArchive.rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::ConditionalStyleSetArchive_ConditionalStyleRule >&
ConditionalStyleSetArchive::rules() const {
  // @@protoc_insertion_point(field_list:TST.ConditionalStyleSetArchive.rules)
  return _impl_.rules_;
}

// optional .TST.CellID cellID = 3;
inline bool ConditionalStyleSetArchive::_internal_has_cellid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cellid_ != nullptr);
  return value;
}
inline bool ConditionalStyleSetArchive::has_cellid() const {
  return _internal_has_cellid();
}
inline void ConditionalStyleSetArchive::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellID& ConditionalStyleSetArchive::_internal_cellid() const {
  const ::TST::CellID* p = _impl_.cellid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& ConditionalStyleSetArchive::cellid() const {
  // @@protoc_insertion_point(field_get:TST.ConditionalStyleSetArchive.cellID)
  return _internal_cellid();
}
inline void ConditionalStyleSetArchive::unsafe_arena_set_allocated_cellid(
    ::TST::CellID* cellid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cellid_);
  }
  _impl_.cellid_ = cellid;
  if (cellid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ConditionalStyleSetArchive.cellID)
}
inline ::TST::CellID* ConditionalStyleSetArchive::release_cellid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* ConditionalStyleSetArchive::unsafe_arena_release_cellid() {
  // @@protoc_insertion_point(field_release:TST.ConditionalStyleSetArchive.cellID)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
  return temp;
}
inline ::TST::CellID* ConditionalStyleSetArchive::_internal_mutable_cellid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cellid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.cellid_ = p;
  }
  return _impl_.cellid_;
}
inline ::TST::CellID* ConditionalStyleSetArchive::mutable_cellid() {
  ::TST::CellID* _msg = _internal_mutable_cellid();
  // @@protoc_insertion_point(field_mutable:TST.ConditionalStyleSetArchive.cellID)
  return _msg;
}
inline void ConditionalStyleSetArchive::set_allocated_cellid(::TST::CellID* cellid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cellid_;
  }
  if (cellid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellid);
    if (message_arena != submessage_arena) {
      cellid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cellid_ = cellid;
  // @@protoc_insertion_point(field_set_allocated:TST.ConditionalStyleSetArchive.cellID)
}

// -------------------------------------------------------------------

// FilterSetArchive

// optional .TST.FilterSetArchive.FilterSetType type = 1 [default = FilterSetArchiveTypeAll];
inline bool FilterSetArchive::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FilterSetArchive::has_type() const {
  return _internal_has_type();
}
inline void FilterSetArchive::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::TST::FilterSetArchive_FilterSetType FilterSetArchive::_internal_type() const {
  return static_cast< ::TST::FilterSetArchive_FilterSetType >(_impl_.type_);
}
inline ::TST::FilterSetArchive_FilterSetType FilterSetArchive::type() const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.type)
  return _internal_type();
}
inline void FilterSetArchive::_internal_set_type(::TST::FilterSetArchive_FilterSetType value) {
  assert(::TST::FilterSetArchive_FilterSetType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void FilterSetArchive::set_type(::TST::FilterSetArchive_FilterSetType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TST.FilterSetArchive.type)
}

// optional bool is_enabled = 2 [default = true];
inline bool FilterSetArchive::_internal_has_is_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FilterSetArchive::has_is_enabled() const {
  return _internal_has_is_enabled();
}
inline void FilterSetArchive::clear_is_enabled() {
  _impl_.is_enabled_ = true;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool FilterSetArchive::_internal_is_enabled() const {
  return _impl_.is_enabled_;
}
inline bool FilterSetArchive::is_enabled() const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.is_enabled)
  return _internal_is_enabled();
}
inline void FilterSetArchive::_internal_set_is_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_enabled_ = value;
}
inline void FilterSetArchive::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:TST.FilterSetArchive.is_enabled)
}

// repeated .TST.FilterRuleArchive filter_rules = 3;
inline int FilterSetArchive::_internal_filter_rules_size() const {
  return _impl_.filter_rules_.size();
}
inline int FilterSetArchive::filter_rules_size() const {
  return _internal_filter_rules_size();
}
inline void FilterSetArchive::clear_filter_rules() {
  _impl_.filter_rules_.Clear();
}
inline ::TST::FilterRuleArchive* FilterSetArchive::mutable_filter_rules(int index) {
  // @@protoc_insertion_point(field_mutable:TST.FilterSetArchive.filter_rules)
  return _impl_.filter_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::FilterRuleArchive >*
FilterSetArchive::mutable_filter_rules() {
  // @@protoc_insertion_point(field_mutable_list:TST.FilterSetArchive.filter_rules)
  return &_impl_.filter_rules_;
}
inline const ::TST::FilterRuleArchive& FilterSetArchive::_internal_filter_rules(int index) const {
  return _impl_.filter_rules_.Get(index);
}
inline const ::TST::FilterRuleArchive& FilterSetArchive::filter_rules(int index) const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.filter_rules)
  return _internal_filter_rules(index);
}
inline ::TST::FilterRuleArchive* FilterSetArchive::_internal_add_filter_rules() {
  return _impl_.filter_rules_.Add();
}
inline ::TST::FilterRuleArchive* FilterSetArchive::add_filter_rules() {
  ::TST::FilterRuleArchive* _add = _internal_add_filter_rules();
  // @@protoc_insertion_point(field_add:TST.FilterSetArchive.filter_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::FilterRuleArchive >&
FilterSetArchive::filter_rules() const {
  // @@protoc_insertion_point(field_list:TST.FilterSetArchive.filter_rules)
  return _impl_.filter_rules_;
}

// optional bool needs_formula_rewrite_for_import = 4 [default = false];
inline bool FilterSetArchive::_internal_has_needs_formula_rewrite_for_import() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FilterSetArchive::has_needs_formula_rewrite_for_import() const {
  return _internal_has_needs_formula_rewrite_for_import();
}
inline void FilterSetArchive::clear_needs_formula_rewrite_for_import() {
  _impl_.needs_formula_rewrite_for_import_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FilterSetArchive::_internal_needs_formula_rewrite_for_import() const {
  return _impl_.needs_formula_rewrite_for_import_;
}
inline bool FilterSetArchive::needs_formula_rewrite_for_import() const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.needs_formula_rewrite_for_import)
  return _internal_needs_formula_rewrite_for_import();
}
inline void FilterSetArchive::_internal_set_needs_formula_rewrite_for_import(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.needs_formula_rewrite_for_import_ = value;
}
inline void FilterSetArchive::set_needs_formula_rewrite_for_import(bool value) {
  _internal_set_needs_formula_rewrite_for_import(value);
  // @@protoc_insertion_point(field_set:TST.FilterSetArchive.needs_formula_rewrite_for_import)
}

// repeated uint32 filter_offsets = 5;
inline int FilterSetArchive::_internal_filter_offsets_size() const {
  return _impl_.filter_offsets_.size();
}
inline int FilterSetArchive::filter_offsets_size() const {
  return _internal_filter_offsets_size();
}
inline void FilterSetArchive::clear_filter_offsets() {
  _impl_.filter_offsets_.Clear();
}
inline uint32_t FilterSetArchive::_internal_filter_offsets(int index) const {
  return _impl_.filter_offsets_.Get(index);
}
inline uint32_t FilterSetArchive::filter_offsets(int index) const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.filter_offsets)
  return _internal_filter_offsets(index);
}
inline void FilterSetArchive::set_filter_offsets(int index, uint32_t value) {
  _impl_.filter_offsets_.Set(index, value);
  // @@protoc_insertion_point(field_set:TST.FilterSetArchive.filter_offsets)
}
inline void FilterSetArchive::_internal_add_filter_offsets(uint32_t value) {
  _impl_.filter_offsets_.Add(value);
}
inline void FilterSetArchive::add_filter_offsets(uint32_t value) {
  _internal_add_filter_offsets(value);
  // @@protoc_insertion_point(field_add:TST.FilterSetArchive.filter_offsets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FilterSetArchive::_internal_filter_offsets() const {
  return _impl_.filter_offsets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FilterSetArchive::filter_offsets() const {
  // @@protoc_insertion_point(field_list:TST.FilterSetArchive.filter_offsets)
  return _internal_filter_offsets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FilterSetArchive::_internal_mutable_filter_offsets() {
  return &_impl_.filter_offsets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FilterSetArchive::mutable_filter_offsets() {
  // @@protoc_insertion_point(field_mutable_list:TST.FilterSetArchive.filter_offsets)
  return _internal_mutable_filter_offsets();
}

// repeated bool filter_enabled = 6;
inline int FilterSetArchive::_internal_filter_enabled_size() const {
  return _impl_.filter_enabled_.size();
}
inline int FilterSetArchive::filter_enabled_size() const {
  return _internal_filter_enabled_size();
}
inline void FilterSetArchive::clear_filter_enabled() {
  _impl_.filter_enabled_.Clear();
}
inline bool FilterSetArchive::_internal_filter_enabled(int index) const {
  return _impl_.filter_enabled_.Get(index);
}
inline bool FilterSetArchive::filter_enabled(int index) const {
  // @@protoc_insertion_point(field_get:TST.FilterSetArchive.filter_enabled)
  return _internal_filter_enabled(index);
}
inline void FilterSetArchive::set_filter_enabled(int index, bool value) {
  _impl_.filter_enabled_.Set(index, value);
  // @@protoc_insertion_point(field_set:TST.FilterSetArchive.filter_enabled)
}
inline void FilterSetArchive::_internal_add_filter_enabled(bool value) {
  _impl_.filter_enabled_.Add(value);
}
inline void FilterSetArchive::add_filter_enabled(bool value) {
  _internal_add_filter_enabled(value);
  // @@protoc_insertion_point(field_add:TST.FilterSetArchive.filter_enabled)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FilterSetArchive::_internal_filter_enabled() const {
  return _impl_.filter_enabled_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FilterSetArchive::filter_enabled() const {
  // @@protoc_insertion_point(field_list:TST.FilterSetArchive.filter_enabled)
  return _internal_filter_enabled();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FilterSetArchive::_internal_mutable_filter_enabled() {
  return &_impl_.filter_enabled_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FilterSetArchive::mutable_filter_enabled() {
  // @@protoc_insertion_point(field_mutable_list:TST.FilterSetArchive.filter_enabled)
  return _internal_mutable_filter_enabled();
}

// -------------------------------------------------------------------

// TokenAttachmentArchive

// required .TSWP.UIGraphicalAttachment super = 1;
inline bool TokenAttachmentArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool TokenAttachmentArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::UIGraphicalAttachment& TokenAttachmentArchive::_internal_super() const {
  const ::TSWP::UIGraphicalAttachment* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UIGraphicalAttachment&>(
      ::TSWP::_UIGraphicalAttachment_default_instance_);
}
inline const ::TSWP::UIGraphicalAttachment& TokenAttachmentArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.TokenAttachmentArchive.super)
  return _internal_super();
}
inline void TokenAttachmentArchive::unsafe_arena_set_allocated_super(
    ::TSWP::UIGraphicalAttachment* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TokenAttachmentArchive.super)
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::UIGraphicalAttachment* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.TokenAttachmentArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::UIGraphicalAttachment* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UIGraphicalAttachment>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::UIGraphicalAttachment* TokenAttachmentArchive::mutable_super() {
  ::TSWP::UIGraphicalAttachment* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.TokenAttachmentArchive.super)
  return _msg;
}
inline void TokenAttachmentArchive::set_allocated_super(::TSWP::UIGraphicalAttachment* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.TokenAttachmentArchive.super)
}

// optional .TSP.Reference expressionNode = 2;
inline bool TokenAttachmentArchive::_internal_has_expressionnode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expressionnode_ != nullptr);
  return value;
}
inline bool TokenAttachmentArchive::has_expressionnode() const {
  return _internal_has_expressionnode();
}
inline const ::TSP::Reference& TokenAttachmentArchive::_internal_expressionnode() const {
  const ::TSP::Reference* p = _impl_.expressionnode_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& TokenAttachmentArchive::expressionnode() const {
  // @@protoc_insertion_point(field_get:TST.TokenAttachmentArchive.expressionNode)
  return _internal_expressionnode();
}
inline void TokenAttachmentArchive::unsafe_arena_set_allocated_expressionnode(
    ::TSP::Reference* expressionnode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expressionnode_);
  }
  _impl_.expressionnode_ = expressionnode;
  if (expressionnode) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.TokenAttachmentArchive.expressionNode)
}
inline ::TSP::Reference* TokenAttachmentArchive::release_expressionnode() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.expressionnode_;
  _impl_.expressionnode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* TokenAttachmentArchive::unsafe_arena_release_expressionnode() {
  // @@protoc_insertion_point(field_release:TST.TokenAttachmentArchive.expressionNode)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Reference* temp = _impl_.expressionnode_;
  _impl_.expressionnode_ = nullptr;
  return temp;
}
inline ::TSP::Reference* TokenAttachmentArchive::_internal_mutable_expressionnode() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expressionnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.expressionnode_ = p;
  }
  return _impl_.expressionnode_;
}
inline ::TSP::Reference* TokenAttachmentArchive::mutable_expressionnode() {
  ::TSP::Reference* _msg = _internal_mutable_expressionnode();
  // @@protoc_insertion_point(field_mutable:TST.TokenAttachmentArchive.expressionNode)
  return _msg;
}
inline void TokenAttachmentArchive::set_allocated_expressionnode(::TSP::Reference* expressionnode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expressionnode_);
  }
  if (expressionnode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expressionnode));
    if (message_arena != submessage_arena) {
      expressionnode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expressionnode, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.expressionnode_ = expressionnode;
  // @@protoc_insertion_point(field_set_allocated:TST.TokenAttachmentArchive.expressionNode)
}

// -------------------------------------------------------------------

// FormulaArchive

// optional .TSP.Reference expressionTree = 1;
inline bool FormulaArchive::_internal_has_expressiontree() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expressiontree_ != nullptr);
  return value;
}
inline bool FormulaArchive::has_expressiontree() const {
  return _internal_has_expressiontree();
}
inline const ::TSP::Reference& FormulaArchive::_internal_expressiontree() const {
  const ::TSP::Reference* p = _impl_.expressiontree_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& FormulaArchive::expressiontree() const {
  // @@protoc_insertion_point(field_get:TST.FormulaArchive.expressionTree)
  return _internal_expressiontree();
}
inline void FormulaArchive::unsafe_arena_set_allocated_expressiontree(
    ::TSP::Reference* expressiontree) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expressiontree_);
  }
  _impl_.expressiontree_ = expressiontree;
  if (expressiontree) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FormulaArchive.expressionTree)
}
inline ::TSP::Reference* FormulaArchive::release_expressiontree() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.expressiontree_;
  _impl_.expressiontree_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* FormulaArchive::unsafe_arena_release_expressiontree() {
  // @@protoc_insertion_point(field_release:TST.FormulaArchive.expressionTree)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.expressiontree_;
  _impl_.expressiontree_ = nullptr;
  return temp;
}
inline ::TSP::Reference* FormulaArchive::_internal_mutable_expressiontree() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.expressiontree_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.expressiontree_ = p;
  }
  return _impl_.expressiontree_;
}
inline ::TSP::Reference* FormulaArchive::mutable_expressiontree() {
  ::TSP::Reference* _msg = _internal_mutable_expressiontree();
  // @@protoc_insertion_point(field_mutable:TST.FormulaArchive.expressionTree)
  return _msg;
}
inline void FormulaArchive::set_allocated_expressiontree(::TSP::Reference* expressiontree) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expressiontree_);
  }
  if (expressiontree) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expressiontree));
    if (message_arena != submessage_arena) {
      expressiontree = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expressiontree, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.expressiontree_ = expressiontree;
  // @@protoc_insertion_point(field_set_allocated:TST.FormulaArchive.expressionTree)
}

// -------------------------------------------------------------------

// ExpressionNodeArchive

// repeated .TSP.Reference children = 1;
inline int ExpressionNodeArchive::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int ExpressionNodeArchive::children_size() const {
  return _internal_children_size();
}
inline ::TSP::Reference* ExpressionNodeArchive::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:TST.ExpressionNodeArchive.children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >*
ExpressionNodeArchive::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:TST.ExpressionNodeArchive.children)
  return &_impl_.children_;
}
inline const ::TSP::Reference& ExpressionNodeArchive::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::TSP::Reference& ExpressionNodeArchive::children(int index) const {
  // @@protoc_insertion_point(field_get:TST.ExpressionNodeArchive.children)
  return _internal_children(index);
}
inline ::TSP::Reference* ExpressionNodeArchive::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::TSP::Reference* ExpressionNodeArchive::add_children() {
  ::TSP::Reference* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:TST.ExpressionNodeArchive.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSP::Reference >&
ExpressionNodeArchive::children() const {
  // @@protoc_insertion_point(field_list:TST.ExpressionNodeArchive.children)
  return _impl_.children_;
}

// optional uint64 first_index = 2 [default = 0];
inline bool ExpressionNodeArchive::_internal_has_first_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExpressionNodeArchive::has_first_index() const {
  return _internal_has_first_index();
}
inline void ExpressionNodeArchive::clear_first_index() {
  _impl_.first_index_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ExpressionNodeArchive::_internal_first_index() const {
  return _impl_.first_index_;
}
inline uint64_t ExpressionNodeArchive::first_index() const {
  // @@protoc_insertion_point(field_get:TST.ExpressionNodeArchive.first_index)
  return _internal_first_index();
}
inline void ExpressionNodeArchive::_internal_set_first_index(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.first_index_ = value;
}
inline void ExpressionNodeArchive::set_first_index(uint64_t value) {
  _internal_set_first_index(value);
  // @@protoc_insertion_point(field_set:TST.ExpressionNodeArchive.first_index)
}

// optional uint64 last_index = 3 [default = 0];
inline bool ExpressionNodeArchive::_internal_has_last_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExpressionNodeArchive::has_last_index() const {
  return _internal_has_last_index();
}
inline void ExpressionNodeArchive::clear_last_index() {
  _impl_.last_index_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t ExpressionNodeArchive::_internal_last_index() const {
  return _impl_.last_index_;
}
inline uint64_t ExpressionNodeArchive::last_index() const {
  // @@protoc_insertion_point(field_get:TST.ExpressionNodeArchive.last_index)
  return _internal_last_index();
}
inline void ExpressionNodeArchive::_internal_set_last_index(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.last_index_ = value;
}
inline void ExpressionNodeArchive::set_last_index(uint64_t value) {
  _internal_set_last_index(value);
  // @@protoc_insertion_point(field_set:TST.ExpressionNodeArchive.last_index)
}

// -------------------------------------------------------------------

// BooleanNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool BooleanNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool BooleanNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void BooleanNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& BooleanNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& BooleanNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.BooleanNodeArchive.super)
  return _internal_super();
}
inline void BooleanNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.BooleanNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.BooleanNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* BooleanNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.BooleanNodeArchive.super)
  return _msg;
}
inline void BooleanNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.BooleanNodeArchive.super)
}

// required bool value = 2;
inline bool BooleanNodeArchive::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BooleanNodeArchive::has_value() const {
  return _internal_has_value();
}
inline void BooleanNodeArchive::clear_value() {
  _impl_.value_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool BooleanNodeArchive::_internal_value() const {
  return _impl_.value_;
}
inline bool BooleanNodeArchive::value() const {
  // @@protoc_insertion_point(field_get:TST.BooleanNodeArchive.value)
  return _internal_value();
}
inline void BooleanNodeArchive::_internal_set_value(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void BooleanNodeArchive::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:TST.BooleanNodeArchive.value)
}

// -------------------------------------------------------------------

// NumberNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool NumberNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool NumberNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void NumberNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& NumberNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& NumberNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.NumberNodeArchive.super)
  return _internal_super();
}
inline void NumberNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.NumberNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.NumberNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* NumberNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.NumberNodeArchive.super)
  return _msg;
}
inline void NumberNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.NumberNodeArchive.super)
}

// required double number = 2;
inline bool NumberNodeArchive::_internal_has_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NumberNodeArchive::has_number() const {
  return _internal_has_number();
}
inline void NumberNodeArchive::clear_number() {
  _impl_.number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double NumberNodeArchive::_internal_number() const {
  return _impl_.number_;
}
inline double NumberNodeArchive::number() const {
  // @@protoc_insertion_point(field_get:TST.NumberNodeArchive.number)
  return _internal_number();
}
inline void NumberNodeArchive::_internal_set_number(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.number_ = value;
}
inline void NumberNodeArchive::set_number(double value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:TST.NumberNodeArchive.number)
}

// -------------------------------------------------------------------

// StringNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool StringNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool StringNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void StringNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::ExpressionNodeArchive& StringNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& StringNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.StringNodeArchive.super)
  return _internal_super();
}
inline void StringNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.StringNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.StringNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* StringNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.StringNodeArchive.super)
  return _msg;
}
inline void StringNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.StringNodeArchive.super)
}

// required string value = 2;
inline bool StringNodeArchive::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringNodeArchive::has_value() const {
  return _internal_has_value();
}
inline void StringNodeArchive::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringNodeArchive::value() const {
  // @@protoc_insertion_point(field_get:TST.StringNodeArchive.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringNodeArchive::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.StringNodeArchive.value)
}
inline std::string* StringNodeArchive::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TST.StringNodeArchive.value)
  return _s;
}
inline const std::string& StringNodeArchive::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StringNodeArchive::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StringNodeArchive::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StringNodeArchive::release_value() {
  // @@protoc_insertion_point(field_release:TST.StringNodeArchive.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringNodeArchive::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.StringNodeArchive.value)
}

// -------------------------------------------------------------------

// IdentifierNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool IdentifierNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool IdentifierNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void IdentifierNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::ExpressionNodeArchive& IdentifierNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& IdentifierNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.IdentifierNodeArchive.super)
  return _internal_super();
}
inline void IdentifierNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.IdentifierNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.IdentifierNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* IdentifierNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.IdentifierNodeArchive.super)
  return _msg;
}
inline void IdentifierNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.IdentifierNodeArchive.super)
}

// optional string identifier = 2;
inline bool IdentifierNodeArchive::_internal_has_identifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IdentifierNodeArchive::has_identifier() const {
  return _internal_has_identifier();
}
inline void IdentifierNodeArchive::clear_identifier() {
  _impl_.identifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IdentifierNodeArchive::identifier() const {
  // @@protoc_insertion_point(field_get:TST.IdentifierNodeArchive.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IdentifierNodeArchive::set_identifier(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.IdentifierNodeArchive.identifier)
}
inline std::string* IdentifierNodeArchive::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:TST.IdentifierNodeArchive.identifier)
  return _s;
}
inline const std::string& IdentifierNodeArchive::_internal_identifier() const {
  return _impl_.identifier_.Get();
}
inline void IdentifierNodeArchive::_internal_set_identifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* IdentifierNodeArchive::_internal_mutable_identifier() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* IdentifierNodeArchive::release_identifier() {
  // @@protoc_insertion_point(field_release:TST.IdentifierNodeArchive.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identifier_.IsDefault()) {
    _impl_.identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IdentifierNodeArchive::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identifier_.IsDefault()) {
    _impl_.identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.IdentifierNodeArchive.identifier)
}

// -------------------------------------------------------------------

// ArrayNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ArrayNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ArrayNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void ArrayNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& ArrayNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& ArrayNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.ArrayNodeArchive.super)
  return _internal_super();
}
inline void ArrayNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ArrayNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.ArrayNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* ArrayNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.ArrayNodeArchive.super)
  return _msg;
}
inline void ArrayNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.ArrayNodeArchive.super)
}

// optional uint32 columns = 2;
inline bool ArrayNodeArchive::_internal_has_columns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArrayNodeArchive::has_columns() const {
  return _internal_has_columns();
}
inline void ArrayNodeArchive::clear_columns() {
  _impl_.columns_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ArrayNodeArchive::_internal_columns() const {
  return _impl_.columns_;
}
inline uint32_t ArrayNodeArchive::columns() const {
  // @@protoc_insertion_point(field_get:TST.ArrayNodeArchive.columns)
  return _internal_columns();
}
inline void ArrayNodeArchive::_internal_set_columns(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.columns_ = value;
}
inline void ArrayNodeArchive::set_columns(uint32_t value) {
  _internal_set_columns(value);
  // @@protoc_insertion_point(field_set:TST.ArrayNodeArchive.columns)
}

// optional uint32 rows = 3;
inline bool ArrayNodeArchive::_internal_has_rows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArrayNodeArchive::has_rows() const {
  return _internal_has_rows();
}
inline void ArrayNodeArchive::clear_rows() {
  _impl_.rows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ArrayNodeArchive::_internal_rows() const {
  return _impl_.rows_;
}
inline uint32_t ArrayNodeArchive::rows() const {
  // @@protoc_insertion_point(field_get:TST.ArrayNodeArchive.rows)
  return _internal_rows();
}
inline void ArrayNodeArchive::_internal_set_rows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.rows_ = value;
}
inline void ArrayNodeArchive::set_rows(uint32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:TST.ArrayNodeArchive.rows)
}

// -------------------------------------------------------------------

// ListNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ListNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ListNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void ListNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& ListNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& ListNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.ListNodeArchive.super)
  return _internal_super();
}
inline void ListNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ListNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.ListNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* ListNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.ListNodeArchive.super)
  return _msg;
}
inline void ListNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.ListNodeArchive.super)
}

// -------------------------------------------------------------------

// OperatorNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool OperatorNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool OperatorNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void OperatorNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& OperatorNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& OperatorNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.OperatorNodeArchive.super)
  return _internal_super();
}
inline void OperatorNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.OperatorNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.OperatorNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* OperatorNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.OperatorNodeArchive.super)
  return _msg;
}
inline void OperatorNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.OperatorNodeArchive.super)
}

// required uint32 operatorChar = 2;
inline bool OperatorNodeArchive::_internal_has_operatorchar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OperatorNodeArchive::has_operatorchar() const {
  return _internal_has_operatorchar();
}
inline void OperatorNodeArchive::clear_operatorchar() {
  _impl_.operatorchar_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t OperatorNodeArchive::_internal_operatorchar() const {
  return _impl_.operatorchar_;
}
inline uint32_t OperatorNodeArchive::operatorchar() const {
  // @@protoc_insertion_point(field_get:TST.OperatorNodeArchive.operatorChar)
  return _internal_operatorchar();
}
inline void OperatorNodeArchive::_internal_set_operatorchar(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operatorchar_ = value;
}
inline void OperatorNodeArchive::set_operatorchar(uint32_t value) {
  _internal_set_operatorchar(value);
  // @@protoc_insertion_point(field_set:TST.OperatorNodeArchive.operatorChar)
}

// -------------------------------------------------------------------

// PostfixOperatorNodeArchive

// required .TST.OperatorNodeArchive super = 1;
inline bool PostfixOperatorNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PostfixOperatorNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void PostfixOperatorNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::OperatorNodeArchive& PostfixOperatorNodeArchive::_internal_super() const {
  const ::TST::OperatorNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::OperatorNodeArchive&>(
      ::TST::_OperatorNodeArchive_default_instance_);
}
inline const ::TST::OperatorNodeArchive& PostfixOperatorNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.PostfixOperatorNodeArchive.super)
  return _internal_super();
}
inline void PostfixOperatorNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::OperatorNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PostfixOperatorNodeArchive.super)
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::OperatorNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.PostfixOperatorNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::OperatorNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::OperatorNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::OperatorNodeArchive* PostfixOperatorNodeArchive::mutable_super() {
  ::TST::OperatorNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.PostfixOperatorNodeArchive.super)
  return _msg;
}
inline void PostfixOperatorNodeArchive::set_allocated_super(::TST::OperatorNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.PostfixOperatorNodeArchive.super)
}

// -------------------------------------------------------------------

// PrefixOperatorNodeArchive

// required .TST.OperatorNodeArchive super = 1;
inline bool PrefixOperatorNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool PrefixOperatorNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void PrefixOperatorNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::OperatorNodeArchive& PrefixOperatorNodeArchive::_internal_super() const {
  const ::TST::OperatorNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::OperatorNodeArchive&>(
      ::TST::_OperatorNodeArchive_default_instance_);
}
inline const ::TST::OperatorNodeArchive& PrefixOperatorNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.PrefixOperatorNodeArchive.super)
  return _internal_super();
}
inline void PrefixOperatorNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::OperatorNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.PrefixOperatorNodeArchive.super)
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::OperatorNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.PrefixOperatorNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::OperatorNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::OperatorNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::OperatorNodeArchive* PrefixOperatorNodeArchive::mutable_super() {
  ::TST::OperatorNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.PrefixOperatorNodeArchive.super)
  return _msg;
}
inline void PrefixOperatorNodeArchive::set_allocated_super(::TST::OperatorNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.PrefixOperatorNodeArchive.super)
}

// -------------------------------------------------------------------

// FunctionNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool FunctionNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool FunctionNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void FunctionNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::ExpressionNodeArchive& FunctionNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& FunctionNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.FunctionNodeArchive.super)
  return _internal_super();
}
inline void FunctionNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FunctionNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.FunctionNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* FunctionNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.FunctionNodeArchive.super)
  return _msg;
}
inline void FunctionNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.FunctionNodeArchive.super)
}

// required uint32 functionIndex = 2;
inline bool FunctionNodeArchive::_internal_has_functionindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FunctionNodeArchive::has_functionindex() const {
  return _internal_has_functionindex();
}
inline void FunctionNodeArchive::clear_functionindex() {
  _impl_.functionindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t FunctionNodeArchive::_internal_functionindex() const {
  return _impl_.functionindex_;
}
inline uint32_t FunctionNodeArchive::functionindex() const {
  // @@protoc_insertion_point(field_get:TST.FunctionNodeArchive.functionIndex)
  return _internal_functionindex();
}
inline void FunctionNodeArchive::_internal_set_functionindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.functionindex_ = value;
}
inline void FunctionNodeArchive::set_functionindex(uint32_t value) {
  _internal_set_functionindex(value);
  // @@protoc_insertion_point(field_set:TST.FunctionNodeArchive.functionIndex)
}

// optional string invalidFunctionName = 3;
inline bool FunctionNodeArchive::_internal_has_invalidfunctionname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FunctionNodeArchive::has_invalidfunctionname() const {
  return _internal_has_invalidfunctionname();
}
inline void FunctionNodeArchive::clear_invalidfunctionname() {
  _impl_.invalidfunctionname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FunctionNodeArchive::invalidfunctionname() const {
  // @@protoc_insertion_point(field_get:TST.FunctionNodeArchive.invalidFunctionName)
  return _internal_invalidfunctionname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionNodeArchive::set_invalidfunctionname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.invalidfunctionname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.FunctionNodeArchive.invalidFunctionName)
}
inline std::string* FunctionNodeArchive::mutable_invalidfunctionname() {
  std::string* _s = _internal_mutable_invalidfunctionname();
  // @@protoc_insertion_point(field_mutable:TST.FunctionNodeArchive.invalidFunctionName)
  return _s;
}
inline const std::string& FunctionNodeArchive::_internal_invalidfunctionname() const {
  return _impl_.invalidfunctionname_.Get();
}
inline void FunctionNodeArchive::_internal_set_invalidfunctionname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.invalidfunctionname_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionNodeArchive::_internal_mutable_invalidfunctionname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.invalidfunctionname_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionNodeArchive::release_invalidfunctionname() {
  // @@protoc_insertion_point(field_release:TST.FunctionNodeArchive.invalidFunctionName)
  if (!_internal_has_invalidfunctionname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.invalidfunctionname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidfunctionname_.IsDefault()) {
    _impl_.invalidfunctionname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FunctionNodeArchive::set_allocated_invalidfunctionname(std::string* invalidfunctionname) {
  if (invalidfunctionname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.invalidfunctionname_.SetAllocated(invalidfunctionname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.invalidfunctionname_.IsDefault()) {
    _impl_.invalidfunctionname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.FunctionNodeArchive.invalidFunctionName)
}

// -------------------------------------------------------------------

// FunctionEndNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool FunctionEndNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool FunctionEndNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void FunctionEndNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& FunctionEndNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& FunctionEndNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.FunctionEndNodeArchive.super)
  return _internal_super();
}
inline void FunctionEndNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FunctionEndNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.FunctionEndNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* FunctionEndNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.FunctionEndNodeArchive.super)
  return _msg;
}
inline void FunctionEndNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.FunctionEndNodeArchive.super)
}

// -------------------------------------------------------------------

// DateNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool DateNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DateNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void DateNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TST::ExpressionNodeArchive& DateNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& DateNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.DateNodeArchive.super)
  return _internal_super();
}
inline void DateNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DateNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.DateNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* DateNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.DateNodeArchive.super)
  return _msg;
}
inline void DateNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.DateNodeArchive.super)
}

// required string value = 2;
inline bool DateNodeArchive::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DateNodeArchive::has_value() const {
  return _internal_has_value();
}
inline void DateNodeArchive::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DateNodeArchive::value() const {
  // @@protoc_insertion_point(field_get:TST.DateNodeArchive.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DateNodeArchive::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.DateNodeArchive.value)
}
inline std::string* DateNodeArchive::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:TST.DateNodeArchive.value)
  return _s;
}
inline const std::string& DateNodeArchive::_internal_value() const {
  return _impl_.value_.Get();
}
inline void DateNodeArchive::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* DateNodeArchive::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* DateNodeArchive::release_value() {
  // @@protoc_insertion_point(field_release:TST.DateNodeArchive.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DateNodeArchive::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.DateNodeArchive.value)
}

// optional string format = 3;
inline bool DateNodeArchive::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DateNodeArchive::has_format() const {
  return _internal_has_format();
}
inline void DateNodeArchive::clear_format() {
  _impl_.format_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DateNodeArchive::format() const {
  // @@protoc_insertion_point(field_get:TST.DateNodeArchive.format)
  return _internal_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DateNodeArchive::set_format(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.DateNodeArchive.format)
}
inline std::string* DateNodeArchive::mutable_format() {
  std::string* _s = _internal_mutable_format();
  // @@protoc_insertion_point(field_mutable:TST.DateNodeArchive.format)
  return _s;
}
inline const std::string& DateNodeArchive::_internal_format() const {
  return _impl_.format_.Get();
}
inline void DateNodeArchive::_internal_set_format(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.format_.Set(value, GetArenaForAllocation());
}
inline std::string* DateNodeArchive::_internal_mutable_format() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.format_.Mutable(GetArenaForAllocation());
}
inline std::string* DateNodeArchive::release_format() {
  // @@protoc_insertion_point(field_release:TST.DateNodeArchive.format)
  if (!_internal_has_format()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.format_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DateNodeArchive::set_allocated_format(std::string* format) {
  if (format != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.format_.SetAllocated(format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.format_.IsDefault()) {
    _impl_.format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.DateNodeArchive.format)
}

// -------------------------------------------------------------------

// ReferenceNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ReferenceNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ReferenceNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void ReferenceNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::ExpressionNodeArchive& ReferenceNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& ReferenceNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.ReferenceNodeArchive.super)
  return _internal_super();
}
inline void ReferenceNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ReferenceNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.ReferenceNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* ReferenceNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.ReferenceNodeArchive.super)
  return _msg;
}
inline void ReferenceNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.ReferenceNodeArchive.super)
}

// required .TSCE.RangeReferenceArchive rangeReference = 2;
inline bool ReferenceNodeArchive::_internal_has_rangereference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rangereference_ != nullptr);
  return value;
}
inline bool ReferenceNodeArchive::has_rangereference() const {
  return _internal_has_rangereference();
}
inline const ::TSCE::RangeReferenceArchive& ReferenceNodeArchive::_internal_rangereference() const {
  const ::TSCE::RangeReferenceArchive* p = _impl_.rangereference_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::RangeReferenceArchive&>(
      ::TSCE::_RangeReferenceArchive_default_instance_);
}
inline const ::TSCE::RangeReferenceArchive& ReferenceNodeArchive::rangereference() const {
  // @@protoc_insertion_point(field_get:TST.ReferenceNodeArchive.rangeReference)
  return _internal_rangereference();
}
inline void ReferenceNodeArchive::unsafe_arena_set_allocated_rangereference(
    ::TSCE::RangeReferenceArchive* rangereference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rangereference_);
  }
  _impl_.rangereference_ = rangereference;
  if (rangereference) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ReferenceNodeArchive.rangeReference)
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::release_rangereference() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::RangeReferenceArchive* temp = _impl_.rangereference_;
  _impl_.rangereference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::unsafe_arena_release_rangereference() {
  // @@protoc_insertion_point(field_release:TST.ReferenceNodeArchive.rangeReference)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSCE::RangeReferenceArchive* temp = _impl_.rangereference_;
  _impl_.rangereference_ = nullptr;
  return temp;
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::_internal_mutable_rangereference() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.rangereference_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::RangeReferenceArchive>(GetArenaForAllocation());
    _impl_.rangereference_ = p;
  }
  return _impl_.rangereference_;
}
inline ::TSCE::RangeReferenceArchive* ReferenceNodeArchive::mutable_rangereference() {
  ::TSCE::RangeReferenceArchive* _msg = _internal_mutable_rangereference();
  // @@protoc_insertion_point(field_mutable:TST.ReferenceNodeArchive.rangeReference)
  return _msg;
}
inline void ReferenceNodeArchive::set_allocated_rangereference(::TSCE::RangeReferenceArchive* rangereference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rangereference_);
  }
  if (rangereference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rangereference));
    if (message_arena != submessage_arena) {
      rangereference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rangereference, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.rangereference_ = rangereference;
  // @@protoc_insertion_point(field_set_allocated:TST.ReferenceNodeArchive.rangeReference)
}

// required uint32 stickyBits = 3;
inline bool ReferenceNodeArchive::_internal_has_stickybits() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReferenceNodeArchive::has_stickybits() const {
  return _internal_has_stickybits();
}
inline void ReferenceNodeArchive::clear_stickybits() {
  _impl_.stickybits_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ReferenceNodeArchive::_internal_stickybits() const {
  return _impl_.stickybits_;
}
inline uint32_t ReferenceNodeArchive::stickybits() const {
  // @@protoc_insertion_point(field_get:TST.ReferenceNodeArchive.stickyBits)
  return _internal_stickybits();
}
inline void ReferenceNodeArchive::_internal_set_stickybits(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stickybits_ = value;
}
inline void ReferenceNodeArchive::set_stickybits(uint32_t value) {
  _internal_set_stickybits(value);
  // @@protoc_insertion_point(field_set:TST.ReferenceNodeArchive.stickyBits)
}

// optional string hostTableID = 4;
inline bool ReferenceNodeArchive::_internal_has_hosttableid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceNodeArchive::has_hosttableid() const {
  return _internal_has_hosttableid();
}
inline void ReferenceNodeArchive::clear_hosttableid() {
  _impl_.hosttableid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReferenceNodeArchive::hosttableid() const {
  // @@protoc_insertion_point(field_get:TST.ReferenceNodeArchive.hostTableID)
  return _internal_hosttableid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReferenceNodeArchive::set_hosttableid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.hosttableid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.ReferenceNodeArchive.hostTableID)
}
inline std::string* ReferenceNodeArchive::mutable_hosttableid() {
  std::string* _s = _internal_mutable_hosttableid();
  // @@protoc_insertion_point(field_mutable:TST.ReferenceNodeArchive.hostTableID)
  return _s;
}
inline const std::string& ReferenceNodeArchive::_internal_hosttableid() const {
  return _impl_.hosttableid_.Get();
}
inline void ReferenceNodeArchive::_internal_set_hosttableid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hosttableid_.Set(value, GetArenaForAllocation());
}
inline std::string* ReferenceNodeArchive::_internal_mutable_hosttableid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hosttableid_.Mutable(GetArenaForAllocation());
}
inline std::string* ReferenceNodeArchive::release_hosttableid() {
  // @@protoc_insertion_point(field_release:TST.ReferenceNodeArchive.hostTableID)
  if (!_internal_has_hosttableid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.hosttableid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hosttableid_.IsDefault()) {
    _impl_.hosttableid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReferenceNodeArchive::set_allocated_hosttableid(std::string* hosttableid) {
  if (hosttableid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hosttableid_.SetAllocated(hosttableid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hosttableid_.IsDefault()) {
    _impl_.hosttableid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.ReferenceNodeArchive.hostTableID)
}

// -------------------------------------------------------------------

// DurationNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool DurationNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool DurationNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void DurationNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& DurationNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& DurationNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.DurationNodeArchive.super)
  return _internal_super();
}
inline void DurationNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.DurationNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.DurationNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* DurationNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.DurationNodeArchive.super)
  return _msg;
}
inline void DurationNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.DurationNodeArchive.super)
}

// required double timeinterval = 2;
inline bool DurationNodeArchive::_internal_has_timeinterval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DurationNodeArchive::has_timeinterval() const {
  return _internal_has_timeinterval();
}
inline void DurationNodeArchive::clear_timeinterval() {
  _impl_.timeinterval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DurationNodeArchive::_internal_timeinterval() const {
  return _impl_.timeinterval_;
}
inline double DurationNodeArchive::timeinterval() const {
  // @@protoc_insertion_point(field_get:TST.DurationNodeArchive.timeinterval)
  return _internal_timeinterval();
}
inline void DurationNodeArchive::_internal_set_timeinterval(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timeinterval_ = value;
}
inline void DurationNodeArchive::set_timeinterval(double value) {
  _internal_set_timeinterval(value);
  // @@protoc_insertion_point(field_set:TST.DurationNodeArchive.timeinterval)
}

// required uint32 smallest = 3;
inline bool DurationNodeArchive::_internal_has_smallest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DurationNodeArchive::has_smallest() const {
  return _internal_has_smallest();
}
inline void DurationNodeArchive::clear_smallest() {
  _impl_.smallest_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t DurationNodeArchive::_internal_smallest() const {
  return _impl_.smallest_;
}
inline uint32_t DurationNodeArchive::smallest() const {
  // @@protoc_insertion_point(field_get:TST.DurationNodeArchive.smallest)
  return _internal_smallest();
}
inline void DurationNodeArchive::_internal_set_smallest(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.smallest_ = value;
}
inline void DurationNodeArchive::set_smallest(uint32_t value) {
  _internal_set_smallest(value);
  // @@protoc_insertion_point(field_set:TST.DurationNodeArchive.smallest)
}

// required uint32 largest = 4;
inline bool DurationNodeArchive::_internal_has_largest() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DurationNodeArchive::has_largest() const {
  return _internal_has_largest();
}
inline void DurationNodeArchive::clear_largest() {
  _impl_.largest_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DurationNodeArchive::_internal_largest() const {
  return _impl_.largest_;
}
inline uint32_t DurationNodeArchive::largest() const {
  // @@protoc_insertion_point(field_get:TST.DurationNodeArchive.largest)
  return _internal_largest();
}
inline void DurationNodeArchive::_internal_set_largest(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.largest_ = value;
}
inline void DurationNodeArchive::set_largest(uint32_t value) {
  _internal_set_largest(value);
  // @@protoc_insertion_point(field_set:TST.DurationNodeArchive.largest)
}

// required uint32 style = 5;
inline bool DurationNodeArchive::_internal_has_style() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DurationNodeArchive::has_style() const {
  return _internal_has_style();
}
inline void DurationNodeArchive::clear_style() {
  _impl_.style_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t DurationNodeArchive::_internal_style() const {
  return _impl_.style_;
}
inline uint32_t DurationNodeArchive::style() const {
  // @@protoc_insertion_point(field_get:TST.DurationNodeArchive.style)
  return _internal_style();
}
inline void DurationNodeArchive::_internal_set_style(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.style_ = value;
}
inline void DurationNodeArchive::set_style(uint32_t value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:TST.DurationNodeArchive.style)
}

// -------------------------------------------------------------------

// ArgumentPlaceholderNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool ArgumentPlaceholderNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool ArgumentPlaceholderNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void ArgumentPlaceholderNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& ArgumentPlaceholderNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& ArgumentPlaceholderNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.ArgumentPlaceholderNodeArchive.super)
  return _internal_super();
}
inline void ArgumentPlaceholderNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.ArgumentPlaceholderNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.ArgumentPlaceholderNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* ArgumentPlaceholderNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.ArgumentPlaceholderNodeArchive.super)
  return _msg;
}
inline void ArgumentPlaceholderNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.ArgumentPlaceholderNodeArchive.super)
}

// required uint32 functionIndex = 2;
inline bool ArgumentPlaceholderNodeArchive::_internal_has_functionindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArgumentPlaceholderNodeArchive::has_functionindex() const {
  return _internal_has_functionindex();
}
inline void ArgumentPlaceholderNodeArchive::clear_functionindex() {
  _impl_.functionindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ArgumentPlaceholderNodeArchive::_internal_functionindex() const {
  return _impl_.functionindex_;
}
inline uint32_t ArgumentPlaceholderNodeArchive::functionindex() const {
  // @@protoc_insertion_point(field_get:TST.ArgumentPlaceholderNodeArchive.functionIndex)
  return _internal_functionindex();
}
inline void ArgumentPlaceholderNodeArchive::_internal_set_functionindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.functionindex_ = value;
}
inline void ArgumentPlaceholderNodeArchive::set_functionindex(uint32_t value) {
  _internal_set_functionindex(value);
  // @@protoc_insertion_point(field_set:TST.ArgumentPlaceholderNodeArchive.functionIndex)
}

// required uint32 argumentIndex = 3;
inline bool ArgumentPlaceholderNodeArchive::_internal_has_argumentindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ArgumentPlaceholderNodeArchive::has_argumentindex() const {
  return _internal_has_argumentindex();
}
inline void ArgumentPlaceholderNodeArchive::clear_argumentindex() {
  _impl_.argumentindex_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ArgumentPlaceholderNodeArchive::_internal_argumentindex() const {
  return _impl_.argumentindex_;
}
inline uint32_t ArgumentPlaceholderNodeArchive::argumentindex() const {
  // @@protoc_insertion_point(field_get:TST.ArgumentPlaceholderNodeArchive.argumentIndex)
  return _internal_argumentindex();
}
inline void ArgumentPlaceholderNodeArchive::_internal_set_argumentindex(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.argumentindex_ = value;
}
inline void ArgumentPlaceholderNodeArchive::set_argumentindex(uint32_t value) {
  _internal_set_argumentindex(value);
  // @@protoc_insertion_point(field_set:TST.ArgumentPlaceholderNodeArchive.argumentIndex)
}

// optional uint32 mode = 4;
inline bool ArgumentPlaceholderNodeArchive::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ArgumentPlaceholderNodeArchive::has_mode() const {
  return _internal_has_mode();
}
inline void ArgumentPlaceholderNodeArchive::clear_mode() {
  _impl_.mode_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ArgumentPlaceholderNodeArchive::_internal_mode() const {
  return _impl_.mode_;
}
inline uint32_t ArgumentPlaceholderNodeArchive::mode() const {
  // @@protoc_insertion_point(field_get:TST.ArgumentPlaceholderNodeArchive.mode)
  return _internal_mode();
}
inline void ArgumentPlaceholderNodeArchive::_internal_set_mode(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mode_ = value;
}
inline void ArgumentPlaceholderNodeArchive::set_mode(uint32_t value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:TST.ArgumentPlaceholderNodeArchive.mode)
}

// -------------------------------------------------------------------

// EmptyExpressionNodeArchive

// required .TST.ExpressionNodeArchive super = 1;
inline bool EmptyExpressionNodeArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool EmptyExpressionNodeArchive::has_super() const {
  return _internal_has_super();
}
inline void EmptyExpressionNodeArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::ExpressionNodeArchive& EmptyExpressionNodeArchive::_internal_super() const {
  const ::TST::ExpressionNodeArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::ExpressionNodeArchive&>(
      ::TST::_ExpressionNodeArchive_default_instance_);
}
inline const ::TST::ExpressionNodeArchive& EmptyExpressionNodeArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.EmptyExpressionNodeArchive.super)
  return _internal_super();
}
inline void EmptyExpressionNodeArchive::unsafe_arena_set_allocated_super(
    ::TST::ExpressionNodeArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.EmptyExpressionNodeArchive.super)
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.EmptyExpressionNodeArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::ExpressionNodeArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::ExpressionNodeArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::ExpressionNodeArchive* EmptyExpressionNodeArchive::mutable_super() {
  ::TST::ExpressionNodeArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.EmptyExpressionNodeArchive.super)
  return _msg;
}
inline void EmptyExpressionNodeArchive::set_allocated_super(::TST::ExpressionNodeArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.EmptyExpressionNodeArchive.super)
}

// -------------------------------------------------------------------

// LayoutHintArchive

// required bool isValid = 1;
inline bool LayoutHintArchive::_internal_has_isvalid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LayoutHintArchive::has_isvalid() const {
  return _internal_has_isvalid();
}
inline void LayoutHintArchive::clear_isvalid() {
  _impl_.isvalid_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool LayoutHintArchive::_internal_isvalid() const {
  return _impl_.isvalid_;
}
inline bool LayoutHintArchive::isvalid() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.isValid)
  return _internal_isvalid();
}
inline void LayoutHintArchive::_internal_set_isvalid(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.isvalid_ = value;
}
inline void LayoutHintArchive::set_isvalid(bool value) {
  _internal_set_isvalid(value);
  // @@protoc_insertion_point(field_set:TST.LayoutHintArchive.isValid)
}

// required .TST.CellRange cellRange = 2;
inline bool LayoutHintArchive::_internal_has_cellrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cellrange_ != nullptr);
  return value;
}
inline bool LayoutHintArchive::has_cellrange() const {
  return _internal_has_cellrange();
}
inline void LayoutHintArchive::clear_cellrange() {
  if (_impl_.cellrange_ != nullptr) _impl_.cellrange_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::TST::CellRange& LayoutHintArchive::_internal_cellrange() const {
  const ::TST::CellRange* p = _impl_.cellrange_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellRange&>(
      ::TST::_CellRange_default_instance_);
}
inline const ::TST::CellRange& LayoutHintArchive::cellrange() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.cellRange)
  return _internal_cellrange();
}
inline void LayoutHintArchive::unsafe_arena_set_allocated_cellrange(
    ::TST::CellRange* cellrange) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cellrange_);
  }
  _impl_.cellrange_ = cellrange;
  if (cellrange) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.LayoutHintArchive.cellRange)
}
inline ::TST::CellRange* LayoutHintArchive::release_cellrange() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellRange* temp = _impl_.cellrange_;
  _impl_.cellrange_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellRange* LayoutHintArchive::unsafe_arena_release_cellrange() {
  // @@protoc_insertion_point(field_release:TST.LayoutHintArchive.cellRange)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TST::CellRange* temp = _impl_.cellrange_;
  _impl_.cellrange_ = nullptr;
  return temp;
}
inline ::TST::CellRange* LayoutHintArchive::_internal_mutable_cellrange() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cellrange_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellRange>(GetArenaForAllocation());
    _impl_.cellrange_ = p;
  }
  return _impl_.cellrange_;
}
inline ::TST::CellRange* LayoutHintArchive::mutable_cellrange() {
  ::TST::CellRange* _msg = _internal_mutable_cellrange();
  // @@protoc_insertion_point(field_mutable:TST.LayoutHintArchive.cellRange)
  return _msg;
}
inline void LayoutHintArchive::set_allocated_cellrange(::TST::CellRange* cellrange) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cellrange_;
  }
  if (cellrange) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellrange);
    if (message_arena != submessage_arena) {
      cellrange = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellrange, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cellrange_ = cellrange;
  // @@protoc_insertion_point(field_set_allocated:TST.LayoutHintArchive.cellRange)
}

// required .TST.CellID hintID = 3;
inline bool LayoutHintArchive::_internal_has_hintid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hintid_ != nullptr);
  return value;
}
inline bool LayoutHintArchive::has_hintid() const {
  return _internal_has_hintid();
}
inline void LayoutHintArchive::clear_hintid() {
  if (_impl_.hintid_ != nullptr) _impl_.hintid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::CellID& LayoutHintArchive::_internal_hintid() const {
  const ::TST::CellID* p = _impl_.hintid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& LayoutHintArchive::hintid() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.hintID)
  return _internal_hintid();
}
inline void LayoutHintArchive::unsafe_arena_set_allocated_hintid(
    ::TST::CellID* hintid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hintid_);
  }
  _impl_.hintid_ = hintid;
  if (hintid) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.LayoutHintArchive.hintID)
}
inline ::TST::CellID* LayoutHintArchive::release_hintid() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellID* temp = _impl_.hintid_;
  _impl_.hintid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* LayoutHintArchive::unsafe_arena_release_hintid() {
  // @@protoc_insertion_point(field_release:TST.LayoutHintArchive.hintID)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::CellID* temp = _impl_.hintid_;
  _impl_.hintid_ = nullptr;
  return temp;
}
inline ::TST::CellID* LayoutHintArchive::_internal_mutable_hintid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.hintid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.hintid_ = p;
  }
  return _impl_.hintid_;
}
inline ::TST::CellID* LayoutHintArchive::mutable_hintid() {
  ::TST::CellID* _msg = _internal_mutable_hintid();
  // @@protoc_insertion_point(field_mutable:TST.LayoutHintArchive.hintID)
  return _msg;
}
inline void LayoutHintArchive::set_allocated_hintid(::TST::CellID* hintid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hintid_;
  }
  if (hintid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hintid);
    if (message_arena != submessage_arena) {
      hintid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hintid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hintid_ = hintid;
  // @@protoc_insertion_point(field_set_allocated:TST.LayoutHintArchive.hintID)
}

// required .TSP.Size maximumSize = 4;
inline bool LayoutHintArchive::_internal_has_maximumsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximumsize_ != nullptr);
  return value;
}
inline bool LayoutHintArchive::has_maximumsize() const {
  return _internal_has_maximumsize();
}
inline const ::TSP::Size& LayoutHintArchive::_internal_maximumsize() const {
  const ::TSP::Size* p = _impl_.maximumsize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& LayoutHintArchive::maximumsize() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.maximumSize)
  return _internal_maximumsize();
}
inline void LayoutHintArchive::unsafe_arena_set_allocated_maximumsize(
    ::TSP::Size* maximumsize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximumsize_);
  }
  _impl_.maximumsize_ = maximumsize;
  if (maximumsize) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.LayoutHintArchive.maximumSize)
}
inline ::TSP::Size* LayoutHintArchive::release_maximumsize() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.maximumsize_;
  _impl_.maximumsize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* LayoutHintArchive::unsafe_arena_release_maximumsize() {
  // @@protoc_insertion_point(field_release:TST.LayoutHintArchive.maximumSize)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TSP::Size* temp = _impl_.maximumsize_;
  _impl_.maximumsize_ = nullptr;
  return temp;
}
inline ::TSP::Size* LayoutHintArchive::_internal_mutable_maximumsize() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.maximumsize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.maximumsize_ = p;
  }
  return _impl_.maximumsize_;
}
inline ::TSP::Size* LayoutHintArchive::mutable_maximumsize() {
  ::TSP::Size* _msg = _internal_mutable_maximumsize();
  // @@protoc_insertion_point(field_mutable:TST.LayoutHintArchive.maximumSize)
  return _msg;
}
inline void LayoutHintArchive::set_allocated_maximumsize(::TSP::Size* maximumsize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maximumsize_);
  }
  if (maximumsize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximumsize));
    if (message_arena != submessage_arena) {
      maximumsize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximumsize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.maximumsize_ = maximumsize;
  // @@protoc_insertion_point(field_set_allocated:TST.LayoutHintArchive.maximumSize)
}

// required uint32 partitionPosition = 5;
inline bool LayoutHintArchive::_internal_has_partitionposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LayoutHintArchive::has_partitionposition() const {
  return _internal_has_partitionposition();
}
inline void LayoutHintArchive::clear_partitionposition() {
  _impl_.partitionposition_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t LayoutHintArchive::_internal_partitionposition() const {
  return _impl_.partitionposition_;
}
inline uint32_t LayoutHintArchive::partitionposition() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.partitionPosition)
  return _internal_partitionposition();
}
inline void LayoutHintArchive::_internal_set_partitionposition(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.partitionposition_ = value;
}
inline void LayoutHintArchive::set_partitionposition(uint32_t value) {
  _internal_set_partitionposition(value);
  // @@protoc_insertion_point(field_set:TST.LayoutHintArchive.partitionPosition)
}

// required bool horizontal = 6;
inline bool LayoutHintArchive::_internal_has_horizontal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LayoutHintArchive::has_horizontal() const {
  return _internal_has_horizontal();
}
inline void LayoutHintArchive::clear_horizontal() {
  _impl_.horizontal_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool LayoutHintArchive::_internal_horizontal() const {
  return _impl_.horizontal_;
}
inline bool LayoutHintArchive::horizontal() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.horizontal)
  return _internal_horizontal();
}
inline void LayoutHintArchive::_internal_set_horizontal(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.horizontal_ = value;
}
inline void LayoutHintArchive::set_horizontal(bool value) {
  _internal_set_horizontal(value);
  // @@protoc_insertion_point(field_set:TST.LayoutHintArchive.horizontal)
}

// optional .TSP.Size effectiveSize = 7;
inline bool LayoutHintArchive::_internal_has_effectivesize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effectivesize_ != nullptr);
  return value;
}
inline bool LayoutHintArchive::has_effectivesize() const {
  return _internal_has_effectivesize();
}
inline const ::TSP::Size& LayoutHintArchive::_internal_effectivesize() const {
  const ::TSP::Size* p = _impl_.effectivesize_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Size&>(
      ::TSP::_Size_default_instance_);
}
inline const ::TSP::Size& LayoutHintArchive::effectivesize() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.effectiveSize)
  return _internal_effectivesize();
}
inline void LayoutHintArchive::unsafe_arena_set_allocated_effectivesize(
    ::TSP::Size* effectivesize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.effectivesize_);
  }
  _impl_.effectivesize_ = effectivesize;
  if (effectivesize) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.LayoutHintArchive.effectiveSize)
}
inline ::TSP::Size* LayoutHintArchive::release_effectivesize() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = _impl_.effectivesize_;
  _impl_.effectivesize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Size* LayoutHintArchive::unsafe_arena_release_effectivesize() {
  // @@protoc_insertion_point(field_release:TST.LayoutHintArchive.effectiveSize)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::TSP::Size* temp = _impl_.effectivesize_;
  _impl_.effectivesize_ = nullptr;
  return temp;
}
inline ::TSP::Size* LayoutHintArchive::_internal_mutable_effectivesize() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.effectivesize_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Size>(GetArenaForAllocation());
    _impl_.effectivesize_ = p;
  }
  return _impl_.effectivesize_;
}
inline ::TSP::Size* LayoutHintArchive::mutable_effectivesize() {
  ::TSP::Size* _msg = _internal_mutable_effectivesize();
  // @@protoc_insertion_point(field_mutable:TST.LayoutHintArchive.effectiveSize)
  return _msg;
}
inline void LayoutHintArchive::set_allocated_effectivesize(::TSP::Size* effectivesize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.effectivesize_);
  }
  if (effectivesize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(effectivesize));
    if (message_arena != submessage_arena) {
      effectivesize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, effectivesize, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.effectivesize_ = effectivesize;
  // @@protoc_insertion_point(field_set_allocated:TST.LayoutHintArchive.effectiveSize)
}

// optional uint32 partitioningPass = 8;
inline bool LayoutHintArchive::_internal_has_partitioningpass() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LayoutHintArchive::has_partitioningpass() const {
  return _internal_has_partitioningpass();
}
inline void LayoutHintArchive::clear_partitioningpass() {
  _impl_.partitioningpass_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t LayoutHintArchive::_internal_partitioningpass() const {
  return _impl_.partitioningpass_;
}
inline uint32_t LayoutHintArchive::partitioningpass() const {
  // @@protoc_insertion_point(field_get:TST.LayoutHintArchive.partitioningPass)
  return _internal_partitioningpass();
}
inline void LayoutHintArchive::_internal_set_partitioningpass(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.partitioningpass_ = value;
}
inline void LayoutHintArchive::set_partitioningpass(uint32_t value) {
  _internal_set_partitioningpass(value);
  // @@protoc_insertion_point(field_set:TST.LayoutHintArchive.partitioningPass)
}

// -------------------------------------------------------------------

// CompletionTokenAttachmentArchive

// required .TST.TokenAttachmentArchive super = 1;
inline bool CompletionTokenAttachmentArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool CompletionTokenAttachmentArchive::has_super() const {
  return _internal_has_super();
}
inline void CompletionTokenAttachmentArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::TST::TokenAttachmentArchive& CompletionTokenAttachmentArchive::_internal_super() const {
  const ::TST::TokenAttachmentArchive* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::TokenAttachmentArchive&>(
      ::TST::_TokenAttachmentArchive_default_instance_);
}
inline const ::TST::TokenAttachmentArchive& CompletionTokenAttachmentArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.CompletionTokenAttachmentArchive.super)
  return _internal_super();
}
inline void CompletionTokenAttachmentArchive::unsafe_arena_set_allocated_super(
    ::TST::TokenAttachmentArchive* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.CompletionTokenAttachmentArchive.super)
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TokenAttachmentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.CompletionTokenAttachmentArchive.super)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TST::TokenAttachmentArchive* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::TokenAttachmentArchive>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TST::TokenAttachmentArchive* CompletionTokenAttachmentArchive::mutable_super() {
  ::TST::TokenAttachmentArchive* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.CompletionTokenAttachmentArchive.super)
  return _msg;
}
inline void CompletionTokenAttachmentArchive::set_allocated_super(::TST::TokenAttachmentArchive* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.super_;
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(super);
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.CompletionTokenAttachmentArchive.super)
}

// optional string completionText = 2;
inline bool CompletionTokenAttachmentArchive::_internal_has_completiontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompletionTokenAttachmentArchive::has_completiontext() const {
  return _internal_has_completiontext();
}
inline void CompletionTokenAttachmentArchive::clear_completiontext() {
  _impl_.completiontext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompletionTokenAttachmentArchive::completiontext() const {
  // @@protoc_insertion_point(field_get:TST.CompletionTokenAttachmentArchive.completionText)
  return _internal_completiontext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionTokenAttachmentArchive::set_completiontext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.completiontext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TST.CompletionTokenAttachmentArchive.completionText)
}
inline std::string* CompletionTokenAttachmentArchive::mutable_completiontext() {
  std::string* _s = _internal_mutable_completiontext();
  // @@protoc_insertion_point(field_mutable:TST.CompletionTokenAttachmentArchive.completionText)
  return _s;
}
inline const std::string& CompletionTokenAttachmentArchive::_internal_completiontext() const {
  return _impl_.completiontext_.Get();
}
inline void CompletionTokenAttachmentArchive::_internal_set_completiontext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.completiontext_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionTokenAttachmentArchive::_internal_mutable_completiontext() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.completiontext_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionTokenAttachmentArchive::release_completiontext() {
  // @@protoc_insertion_point(field_release:TST.CompletionTokenAttachmentArchive.completionText)
  if (!_internal_has_completiontext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.completiontext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completiontext_.IsDefault()) {
    _impl_.completiontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CompletionTokenAttachmentArchive::set_allocated_completiontext(std::string* completiontext) {
  if (completiontext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.completiontext_.SetAllocated(completiontext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.completiontext_.IsDefault()) {
    _impl_.completiontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TST.CompletionTokenAttachmentArchive.completionText)
}

// optional uint32 caretPosition = 3;
inline bool CompletionTokenAttachmentArchive::_internal_has_caretposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompletionTokenAttachmentArchive::has_caretposition() const {
  return _internal_has_caretposition();
}
inline void CompletionTokenAttachmentArchive::clear_caretposition() {
  _impl_.caretposition_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CompletionTokenAttachmentArchive::_internal_caretposition() const {
  return _impl_.caretposition_;
}
inline uint32_t CompletionTokenAttachmentArchive::caretposition() const {
  // @@protoc_insertion_point(field_get:TST.CompletionTokenAttachmentArchive.caretPosition)
  return _internal_caretposition();
}
inline void CompletionTokenAttachmentArchive::_internal_set_caretposition(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.caretposition_ = value;
}
inline void CompletionTokenAttachmentArchive::set_caretposition(uint32_t value) {
  _internal_set_caretposition(value);
  // @@protoc_insertion_point(field_set:TST.CompletionTokenAttachmentArchive.caretPosition)
}

// optional uint32 prefixStart = 4;
inline bool CompletionTokenAttachmentArchive::_internal_has_prefixstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CompletionTokenAttachmentArchive::has_prefixstart() const {
  return _internal_has_prefixstart();
}
inline void CompletionTokenAttachmentArchive::clear_prefixstart() {
  _impl_.prefixstart_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CompletionTokenAttachmentArchive::_internal_prefixstart() const {
  return _impl_.prefixstart_;
}
inline uint32_t CompletionTokenAttachmentArchive::prefixstart() const {
  // @@protoc_insertion_point(field_get:TST.CompletionTokenAttachmentArchive.prefixStart)
  return _internal_prefixstart();
}
inline void CompletionTokenAttachmentArchive::_internal_set_prefixstart(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prefixstart_ = value;
}
inline void CompletionTokenAttachmentArchive::set_prefixstart(uint32_t value) {
  _internal_set_prefixstart(value);
  // @@protoc_insertion_point(field_set:TST.CompletionTokenAttachmentArchive.prefixStart)
}

// -------------------------------------------------------------------

// HiddenStateFormulaOwnerArchive

// optional .TSCE.CFUUIDArchive owner_id = 1;
inline bool HiddenStateFormulaOwnerArchive::_internal_has_owner_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_id_ != nullptr);
  return value;
}
inline bool HiddenStateFormulaOwnerArchive::has_owner_id() const {
  return _internal_has_owner_id();
}
inline const ::TSCE::CFUUIDArchive& HiddenStateFormulaOwnerArchive::_internal_owner_id() const {
  const ::TSCE::CFUUIDArchive* p = _impl_.owner_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSCE::CFUUIDArchive&>(
      ::TSCE::_CFUUIDArchive_default_instance_);
}
inline const ::TSCE::CFUUIDArchive& HiddenStateFormulaOwnerArchive::owner_id() const {
  // @@protoc_insertion_point(field_get:TST.HiddenStateFormulaOwnerArchive.owner_id)
  return _internal_owner_id();
}
inline void HiddenStateFormulaOwnerArchive::unsafe_arena_set_allocated_owner_id(
    ::TSCE::CFUUIDArchive* owner_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_id_);
  }
  _impl_.owner_id_ = owner_id;
  if (owner_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.HiddenStateFormulaOwnerArchive.owner_id)
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::release_owner_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::CFUUIDArchive* temp = _impl_.owner_id_;
  _impl_.owner_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::unsafe_arena_release_owner_id() {
  // @@protoc_insertion_point(field_release:TST.HiddenStateFormulaOwnerArchive.owner_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSCE::CFUUIDArchive* temp = _impl_.owner_id_;
  _impl_.owner_id_ = nullptr;
  return temp;
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::_internal_mutable_owner_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.owner_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSCE::CFUUIDArchive>(GetArenaForAllocation());
    _impl_.owner_id_ = p;
  }
  return _impl_.owner_id_;
}
inline ::TSCE::CFUUIDArchive* HiddenStateFormulaOwnerArchive::mutable_owner_id() {
  ::TSCE::CFUUIDArchive* _msg = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:TST.HiddenStateFormulaOwnerArchive.owner_id)
  return _msg;
}
inline void HiddenStateFormulaOwnerArchive::set_allocated_owner_id(::TSCE::CFUUIDArchive* owner_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_id_);
  }
  if (owner_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_id));
    if (message_arena != submessage_arena) {
      owner_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.owner_id_ = owner_id;
  // @@protoc_insertion_point(field_set_allocated:TST.HiddenStateFormulaOwnerArchive.owner_id)
}

// repeated .TSCE.CellValueArchive threshold_value = 2;
inline int HiddenStateFormulaOwnerArchive::_internal_threshold_value_size() const {
  return _impl_.threshold_value_.size();
}
inline int HiddenStateFormulaOwnerArchive::threshold_value_size() const {
  return _internal_threshold_value_size();
}
inline ::TSCE::CellValueArchive* HiddenStateFormulaOwnerArchive::mutable_threshold_value(int index) {
  // @@protoc_insertion_point(field_mutable:TST.HiddenStateFormulaOwnerArchive.threshold_value)
  return _impl_.threshold_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >*
HiddenStateFormulaOwnerArchive::mutable_threshold_value() {
  // @@protoc_insertion_point(field_mutable_list:TST.HiddenStateFormulaOwnerArchive.threshold_value)
  return &_impl_.threshold_value_;
}
inline const ::TSCE::CellValueArchive& HiddenStateFormulaOwnerArchive::_internal_threshold_value(int index) const {
  return _impl_.threshold_value_.Get(index);
}
inline const ::TSCE::CellValueArchive& HiddenStateFormulaOwnerArchive::threshold_value(int index) const {
  // @@protoc_insertion_point(field_get:TST.HiddenStateFormulaOwnerArchive.threshold_value)
  return _internal_threshold_value(index);
}
inline ::TSCE::CellValueArchive* HiddenStateFormulaOwnerArchive::_internal_add_threshold_value() {
  return _impl_.threshold_value_.Add();
}
inline ::TSCE::CellValueArchive* HiddenStateFormulaOwnerArchive::add_threshold_value() {
  ::TSCE::CellValueArchive* _add = _internal_add_threshold_value();
  // @@protoc_insertion_point(field_add:TST.HiddenStateFormulaOwnerArchive.threshold_value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TSCE::CellValueArchive >&
HiddenStateFormulaOwnerArchive::threshold_value() const {
  // @@protoc_insertion_point(field_list:TST.HiddenStateFormulaOwnerArchive.threshold_value)
  return _impl_.threshold_value_;
}

// optional bool needs_to_update_filter_set_for_import = 3 [default = false];
inline bool HiddenStateFormulaOwnerArchive::_internal_has_needs_to_update_filter_set_for_import() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HiddenStateFormulaOwnerArchive::has_needs_to_update_filter_set_for_import() const {
  return _internal_has_needs_to_update_filter_set_for_import();
}
inline void HiddenStateFormulaOwnerArchive::clear_needs_to_update_filter_set_for_import() {
  _impl_.needs_to_update_filter_set_for_import_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool HiddenStateFormulaOwnerArchive::_internal_needs_to_update_filter_set_for_import() const {
  return _impl_.needs_to_update_filter_set_for_import_;
}
inline bool HiddenStateFormulaOwnerArchive::needs_to_update_filter_set_for_import() const {
  // @@protoc_insertion_point(field_get:TST.HiddenStateFormulaOwnerArchive.needs_to_update_filter_set_for_import)
  return _internal_needs_to_update_filter_set_for_import();
}
inline void HiddenStateFormulaOwnerArchive::_internal_set_needs_to_update_filter_set_for_import(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.needs_to_update_filter_set_for_import_ = value;
}
inline void HiddenStateFormulaOwnerArchive::set_needs_to_update_filter_set_for_import(bool value) {
  _internal_set_needs_to_update_filter_set_for_import(value);
  // @@protoc_insertion_point(field_set:TST.HiddenStateFormulaOwnerArchive.needs_to_update_filter_set_for_import)
}

// -------------------------------------------------------------------

// RichTextPayloadArchive

// required .TSP.Reference storage = 1;
inline bool RichTextPayloadArchive::_internal_has_storage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
  return value;
}
inline bool RichTextPayloadArchive::has_storage() const {
  return _internal_has_storage();
}
inline const ::TSP::Reference& RichTextPayloadArchive::_internal_storage() const {
  const ::TSP::Reference* p = _impl_.storage_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Reference&>(
      ::TSP::_Reference_default_instance_);
}
inline const ::TSP::Reference& RichTextPayloadArchive::storage() const {
  // @@protoc_insertion_point(field_get:TST.RichTextPayloadArchive.storage)
  return _internal_storage();
}
inline void RichTextPayloadArchive::unsafe_arena_set_allocated_storage(
    ::TSP::Reference* storage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  _impl_.storage_ = storage;
  if (storage) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.RichTextPayloadArchive.storage)
}
inline ::TSP::Reference* RichTextPayloadArchive::release_storage() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Reference* RichTextPayloadArchive::unsafe_arena_release_storage() {
  // @@protoc_insertion_point(field_release:TST.RichTextPayloadArchive.storage)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSP::Reference* temp = _impl_.storage_;
  _impl_.storage_ = nullptr;
  return temp;
}
inline ::TSP::Reference* RichTextPayloadArchive::_internal_mutable_storage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.storage_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Reference>(GetArenaForAllocation());
    _impl_.storage_ = p;
  }
  return _impl_.storage_;
}
inline ::TSP::Reference* RichTextPayloadArchive::mutable_storage() {
  ::TSP::Reference* _msg = _internal_mutable_storage();
  // @@protoc_insertion_point(field_mutable:TST.RichTextPayloadArchive.storage)
  return _msg;
}
inline void RichTextPayloadArchive::set_allocated_storage(::TSP::Reference* storage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
  }
  if (storage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage));
    if (message_arena != submessage_arena) {
      storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.storage_ = storage;
  // @@protoc_insertion_point(field_set_allocated:TST.RichTextPayloadArchive.storage)
}

// optional .TSP.Range range = 2;
inline bool RichTextPayloadArchive::_internal_has_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.range_ != nullptr);
  return value;
}
inline bool RichTextPayloadArchive::has_range() const {
  return _internal_has_range();
}
inline const ::TSP::Range& RichTextPayloadArchive::_internal_range() const {
  const ::TSP::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSP::Range&>(
      ::TSP::_Range_default_instance_);
}
inline const ::TSP::Range& RichTextPayloadArchive::range() const {
  // @@protoc_insertion_point(field_get:TST.RichTextPayloadArchive.range)
  return _internal_range();
}
inline void RichTextPayloadArchive::unsafe_arena_set_allocated_range(
    ::TSP::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.RichTextPayloadArchive.range)
}
inline ::TSP::Range* RichTextPayloadArchive::release_range() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSP::Range* RichTextPayloadArchive::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:TST.RichTextPayloadArchive.range)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::TSP::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::TSP::Range* RichTextPayloadArchive::_internal_mutable_range() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSP::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::TSP::Range* RichTextPayloadArchive::mutable_range() {
  ::TSP::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:TST.RichTextPayloadArchive.range)
  return _msg;
}
inline void RichTextPayloadArchive::set_allocated_range(::TSP::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range));
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:TST.RichTextPayloadArchive.range)
}

// required .TST.CellID cellid = 3;
inline bool RichTextPayloadArchive::_internal_has_cellid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cellid_ != nullptr);
  return value;
}
inline bool RichTextPayloadArchive::has_cellid() const {
  return _internal_has_cellid();
}
inline void RichTextPayloadArchive::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::TST::CellID& RichTextPayloadArchive::_internal_cellid() const {
  const ::TST::CellID* p = _impl_.cellid_;
  return p != nullptr ? *p : reinterpret_cast<const ::TST::CellID&>(
      ::TST::_CellID_default_instance_);
}
inline const ::TST::CellID& RichTextPayloadArchive::cellid() const {
  // @@protoc_insertion_point(field_get:TST.RichTextPayloadArchive.cellid)
  return _internal_cellid();
}
inline void RichTextPayloadArchive::unsafe_arena_set_allocated_cellid(
    ::TST::CellID* cellid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cellid_);
  }
  _impl_.cellid_ = cellid;
  if (cellid) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.RichTextPayloadArchive.cellid)
}
inline ::TST::CellID* RichTextPayloadArchive::release_cellid() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TST::CellID* RichTextPayloadArchive::unsafe_arena_release_cellid() {
  // @@protoc_insertion_point(field_release:TST.RichTextPayloadArchive.cellid)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::TST::CellID* temp = _impl_.cellid_;
  _impl_.cellid_ = nullptr;
  return temp;
}
inline ::TST::CellID* RichTextPayloadArchive::_internal_mutable_cellid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cellid_ == nullptr) {
    auto* p = CreateMaybeMessage<::TST::CellID>(GetArenaForAllocation());
    _impl_.cellid_ = p;
  }
  return _impl_.cellid_;
}
inline ::TST::CellID* RichTextPayloadArchive::mutable_cellid() {
  ::TST::CellID* _msg = _internal_mutable_cellid();
  // @@protoc_insertion_point(field_mutable:TST.RichTextPayloadArchive.cellid)
  return _msg;
}
inline void RichTextPayloadArchive::set_allocated_cellid(::TST::CellID* cellid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cellid_;
  }
  if (cellid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellid);
    if (message_arena != submessage_arena) {
      cellid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cellid_ = cellid;
  // @@protoc_insertion_point(field_set_allocated:TST.RichTextPayloadArchive.cellid)
}

// -------------------------------------------------------------------

// FormulaEqualsTokenAttachmentArchive

// required .TSWP.UIGraphicalAttachment super = 1;
inline bool FormulaEqualsTokenAttachmentArchive::_internal_has_super() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.super_ != nullptr);
  return value;
}
inline bool FormulaEqualsTokenAttachmentArchive::has_super() const {
  return _internal_has_super();
}
inline const ::TSWP::UIGraphicalAttachment& FormulaEqualsTokenAttachmentArchive::_internal_super() const {
  const ::TSWP::UIGraphicalAttachment* p = _impl_.super_;
  return p != nullptr ? *p : reinterpret_cast<const ::TSWP::UIGraphicalAttachment&>(
      ::TSWP::_UIGraphicalAttachment_default_instance_);
}
inline const ::TSWP::UIGraphicalAttachment& FormulaEqualsTokenAttachmentArchive::super() const {
  // @@protoc_insertion_point(field_get:TST.FormulaEqualsTokenAttachmentArchive.super)
  return _internal_super();
}
inline void FormulaEqualsTokenAttachmentArchive::unsafe_arena_set_allocated_super(
    ::TSWP::UIGraphicalAttachment* super) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  _impl_.super_ = super;
  if (super) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TST.FormulaEqualsTokenAttachmentArchive.super)
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::release_super() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::UIGraphicalAttachment* temp = _impl_.super_;
  _impl_.super_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::unsafe_arena_release_super() {
  // @@protoc_insertion_point(field_release:TST.FormulaEqualsTokenAttachmentArchive.super)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::TSWP::UIGraphicalAttachment* temp = _impl_.super_;
  _impl_.super_ = nullptr;
  return temp;
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::_internal_mutable_super() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.super_ == nullptr) {
    auto* p = CreateMaybeMessage<::TSWP::UIGraphicalAttachment>(GetArenaForAllocation());
    _impl_.super_ = p;
  }
  return _impl_.super_;
}
inline ::TSWP::UIGraphicalAttachment* FormulaEqualsTokenAttachmentArchive::mutable_super() {
  ::TSWP::UIGraphicalAttachment* _msg = _internal_mutable_super();
  // @@protoc_insertion_point(field_mutable:TST.FormulaEqualsTokenAttachmentArchive.super)
  return _msg;
}
inline void FormulaEqualsTokenAttachmentArchive::set_allocated_super(::TSWP::UIGraphicalAttachment* super) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.super_);
  }
  if (super) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(super));
    if (message_arena != submessage_arena) {
      super = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, super, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.super_ = super;
  // @@protoc_insertion_point(field_set_allocated:TST.FormulaEqualsTokenAttachmentArchive.super)
}

// -------------------------------------------------------------------

// CellRegion

// repeated .TST.CellRange cell_ranges = 1;
inline int CellRegion::_internal_cell_ranges_size() const {
  return _impl_.cell_ranges_.size();
}
inline int CellRegion::cell_ranges_size() const {
  return _internal_cell_ranges_size();
}
inline void CellRegion::clear_cell_ranges() {
  _impl_.cell_ranges_.Clear();
}
inline ::TST::CellRange* CellRegion::mutable_cell_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:TST.CellRegion.cell_ranges)
  return _impl_.cell_ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >*
CellRegion::mutable_cell_ranges() {
  // @@protoc_insertion_point(field_mutable_list:TST.CellRegion.cell_ranges)
  return &_impl_.cell_ranges_;
}
inline const ::TST::CellRange& CellRegion::_internal_cell_ranges(int index) const {
  return _impl_.cell_ranges_.Get(index);
}
inline const ::TST::CellRange& CellRegion::cell_ranges(int index) const {
  // @@protoc_insertion_point(field_get:TST.CellRegion.cell_ranges)
  return _internal_cell_ranges(index);
}
inline ::TST::CellRange* CellRegion::_internal_add_cell_ranges() {
  return _impl_.cell_ranges_.Add();
}
inline ::TST::CellRange* CellRegion::add_cell_ranges() {
  ::TST::CellRange* _add = _internal_add_cell_ranges();
  // @@protoc_insertion_point(field_add:TST.CellRegion.cell_ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TST::CellRange >&
CellRegion::cell_ranges() const {
  // @@protoc_insertion_point(field_list:TST.CellRegion.cell_ranges)
  return _impl_.cell_ranges_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TST

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TST::PopUpMenuModel_CellValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::PopUpMenuModel_CellValueType>() {
  return ::TST::PopUpMenuModel_CellValueType_descriptor();
}
template <> struct is_proto_enum< ::TST::TableDataList_ListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::TableDataList_ListType>() {
  return ::TST::TableDataList_ListType_descriptor();
}
template <> struct is_proto_enum< ::TST::FormulaPredicateArchive_FormulaPredicateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FormulaPredicateArchive_FormulaPredicateType>() {
  return ::TST::FormulaPredicateArchive_FormulaPredicateType_descriptor();
}
template <> struct is_proto_enum< ::TST::FormulaPredicateArchive_QualifierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FormulaPredicateArchive_QualifierType>() {
  return ::TST::FormulaPredicateArchive_QualifierType_descriptor();
}
template <> struct is_proto_enum< ::TST::FilterSetArchive_FilterSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FilterSetArchive_FilterSetType>() {
  return ::TST::FilterSetArchive_FilterSetType_descriptor();
}
template <> struct is_proto_enum< ::TST::CellType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CellType>() {
  return ::TST::CellType_descriptor();
}
template <> struct is_proto_enum< ::TST::CellValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::CellValueType>() {
  return ::TST::CellValueType_descriptor();
}
template <> struct is_proto_enum< ::TST::SelectionTypeArchive> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::SelectionTypeArchive>() {
  return ::TST::SelectionTypeArchive_descriptor();
}
template <> struct is_proto_enum< ::TST::FillDirectionArchive> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::FillDirectionArchive>() {
  return ::TST::FillDirectionArchive_descriptor();
}
template <> struct is_proto_enum< ::TST::MergeActionArchive> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::MergeActionArchive>() {
  return ::TST::MergeActionArchive_descriptor();
}
template <> struct is_proto_enum< ::TST::HideShowActionArchive> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TST::HideShowActionArchive>() {
  return ::TST::HideShowActionArchive_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TSTArchives_2eproto
