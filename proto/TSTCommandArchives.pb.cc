// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSTCommandArchives.proto

#include "TSTCommandArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TST {
PROTOBUF_CONSTEXPR TableCommandArchive::TableCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commandname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tableinfo_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.editing_mode_at_start_)*/0u} {}
struct TableCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableCommandArchiveDefaultTypeInternal() {}
  union {
    TableCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableCommandArchiveDefaultTypeInternal _TableCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandChangeFreezeHeaderStateArchive::CommandChangeFreezeHeaderStateArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.new_freeze_state_)*/false} {}
struct CommandChangeFreezeHeaderStateArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandChangeFreezeHeaderStateArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandChangeFreezeHeaderStateArchiveDefaultTypeInternal() {}
  union {
    CommandChangeFreezeHeaderStateArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandChangeFreezeHeaderStateArchiveDefaultTypeInternal _CommandChangeFreezeHeaderStateArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandDeleteCellsArchive::CommandDeleteCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.invalidate_comments_)*/false} {}
struct CommandDeleteCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDeleteCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDeleteCellsArchiveDefaultTypeInternal() {}
  union {
    CommandDeleteCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDeleteCellsArchiveDefaultTypeInternal _CommandDeleteCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandDeleteCellContentsArchive::CommandDeleteCellContentsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.invalidate_comments_)*/false} {}
struct CommandDeleteCellContentsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDeleteCellContentsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDeleteCellContentsArchiveDefaultTypeInternal() {}
  union {
    CommandDeleteCellContentsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDeleteCellContentsArchiveDefaultTypeInternal _CommandDeleteCellContentsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleCellsArchive::CommandSetMultipleCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.source_cell_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.only_if_format_differs_)*/false} {}
struct CommandSetMultipleCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleCellsArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleCellsArchiveDefaultTypeInternal _CommandSetMultipleCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleCellsCustomArchive::CommandSetMultipleCellsCustomArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.cell_format_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleCellsCustomArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleCellsCustomArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleCellsCustomArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleCellsCustomArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleCellsCustomArchiveDefaultTypeInternal _CommandSetMultipleCellsCustomArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleCellsMultipleChoiceListArchive::CommandSetMultipleCellsMultipleChoiceListArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleCellsMultipleChoiceListArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleCellsMultipleChoiceListArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleCellsMultipleChoiceListArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleCellsMultipleChoiceListArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleCellsMultipleChoiceListArchiveDefaultTypeInternal _CommandSetMultipleCellsMultipleChoiceListArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandCoerceMultipleCellsArchive::CommandCoerceMultipleCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.desired_format_)*/0} {}
struct CommandCoerceMultipleCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandCoerceMultipleCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandCoerceMultipleCellsArchiveDefaultTypeInternal() {}
  union {
    CommandCoerceMultipleCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandCoerceMultipleCellsArchiveDefaultTypeInternal _CommandCoerceMultipleCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetControlCellsDisplayNumberFormatArchive::CommandSetControlCellsDisplayNumberFormatArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetControlCellsDisplayNumberFormatArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetControlCellsDisplayNumberFormatArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetControlCellsDisplayNumberFormatArchiveDefaultTypeInternal() {}
  union {
    CommandSetControlCellsDisplayNumberFormatArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetControlCellsDisplayNumberFormatArchiveDefaultTypeInternal _CommandSetControlCellsDisplayNumberFormatArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetAutomaticFormatArchive::CommandSetAutomaticFormatArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetAutomaticFormatArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetAutomaticFormatArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetAutomaticFormatArchiveDefaultTypeInternal() {}
  union {
    CommandSetAutomaticFormatArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetAutomaticFormatArchiveDefaultTypeInternal _CommandSetAutomaticFormatArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetAutomaticDurationUnitsArchive::CommandSetAutomaticDurationUnitsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_map_)*/nullptr
  , /*decltype(_impl_.redo_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.automatic_units_)*/false} {}
struct CommandSetAutomaticDurationUnitsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetAutomaticDurationUnitsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetAutomaticDurationUnitsArchiveDefaultTypeInternal() {}
  union {
    CommandSetAutomaticDurationUnitsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetAutomaticDurationUnitsArchiveDefaultTypeInternal _CommandSetAutomaticDurationUnitsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandInsertColumnsOrRowsArchive_StyleIndexPair::CommandInsertColumnsOrRowsArchive_StyleIndexPair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.style_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct CommandInsertColumnsOrRowsArchive_StyleIndexPairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandInsertColumnsOrRowsArchive_StyleIndexPairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandInsertColumnsOrRowsArchive_StyleIndexPairDefaultTypeInternal() {}
  union {
    CommandInsertColumnsOrRowsArchive_StyleIndexPair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandInsertColumnsOrRowsArchive_StyleIndexPairDefaultTypeInternal _CommandInsertColumnsOrRowsArchive_StyleIndexPair_default_instance_;
PROTOBUF_CONSTEXPR CommandInsertColumnsOrRowsArchive::CommandInsertColumnsOrRowsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_style_index_pairs_)*/{}
  , /*decltype(_impl_.text_style_index_pairs_)*/{}
  , /*decltype(_impl_.sizes_)*/{}
  , /*decltype(_impl_.row_column_style_)*/nullptr
  , /*decltype(_impl_.cell_style_redo_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.formula_rewrite_command_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.size_)*/0
  , /*decltype(_impl_.header_count_)*/0u
  , /*decltype(_impl_.headers_added_)*/0u
  , /*decltype(_impl_.footer_count_)*/0u
  , /*decltype(_impl_.footers_added_)*/0u
  , /*decltype(_impl_.before_)*/false
  , /*decltype(_impl_.allow_horizontal_autosize_)*/false
  , /*decltype(_impl_.inherit_styles_)*/false
  , /*decltype(_impl_.inherit_formats_)*/false
  , /*decltype(_impl_.width_factor_)*/0
  , /*decltype(_impl_.height_factor_)*/0
  , /*decltype(_impl_.inherit_formulas_)*/false} {}
struct CommandInsertColumnsOrRowsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandInsertColumnsOrRowsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandInsertColumnsOrRowsArchiveDefaultTypeInternal() {}
  union {
    CommandInsertColumnsOrRowsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandInsertColumnsOrRowsArchiveDefaultTypeInternal _CommandInsertColumnsOrRowsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandPasteArchive::CommandPasteArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.formula_rewrite_commands_)*/{}
  , /*decltype(_impl_.user_selection_)*/nullptr
  , /*decltype(_impl_.final_selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.command_undo_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.invalidate_comments_)*/false} {}
struct CommandPasteArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPasteArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPasteArchiveDefaultTypeInternal() {}
  union {
    CommandPasteArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPasteArchiveDefaultTypeInternal _CommandPasteArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRemoveColumnsOrRowsArchive::CommandRemoveColumnsOrRowsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subsizes_)*/{}
  , /*decltype(_impl_.hiding_actions_)*/{}
  , /*decltype(_impl_.undo_command_collector_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.indices_to_remove_)*/nullptr
  , /*decltype(_impl_.cellmap_)*/nullptr
  , /*decltype(_impl_.oldgeom_)*/nullptr
  , /*decltype(_impl_.newgeom_)*/nullptr
  , /*decltype(_impl_.formula_rewrite_command_)*/nullptr
  , /*decltype(_impl_.undo_merge_map_)*/nullptr
  , /*decltype(_impl_.redo_merge_map_)*/nullptr
  , /*decltype(_impl_.orig_filter_set_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.width_factor_)*/0
  , /*decltype(_impl_.height_factor_)*/0
  , /*decltype(_impl_.allow_horizontal_autosize_)*/false} {}
struct CommandRemoveColumnsOrRowsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRemoveColumnsOrRowsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRemoveColumnsOrRowsArchiveDefaultTypeInternal() {}
  union {
    CommandRemoveColumnsOrRowsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRemoveColumnsOrRowsArchiveDefaultTypeInternal _CommandRemoveColumnsOrRowsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandResizeColumnOrRowArchive::CommandResizeColumnOrRowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subsizes_)*/{}
  , /*decltype(_impl_.oldgeom_)*/nullptr
  , /*decltype(_impl_.newgeom_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.newsize_)*/0
  , /*decltype(_impl_.old_default_)*/0
  , /*decltype(_impl_.uniformsizes_)*/false
  , /*decltype(_impl_.resizemode_)*/0u} {}
struct CommandResizeColumnOrRowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandResizeColumnOrRowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandResizeColumnOrRowArchiveDefaultTypeInternal() {}
  union {
    CommandResizeColumnOrRowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandResizeColumnOrRowArchiveDefaultTypeInternal _CommandResizeColumnOrRowArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetCellArchive::CommandSetCellArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellid_)*/nullptr
  , /*decltype(_impl_.newcell_)*/nullptr
  , /*decltype(_impl_.oldcell_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.post_undo_redo_selection_)*/false} {}
struct CommandSetCellArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetCellArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetCellArchiveDefaultTypeInternal() {}
  union {
    CommandSetCellArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetCellArchiveDefaultTypeInternal _CommandSetCellArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandTextPreflightInsertCellArchive::CommandTextPreflightInsertCellArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.editing_cellid_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.coalesced_textcommand_)*/nullptr
  , /*decltype(_impl_.postflightcommand_)*/nullptr
  , /*decltype(_impl_.editing_cell_)*/nullptr
  , /*decltype(_impl_.editing_storage_)*/nullptr
  , /*decltype(_impl_.grouped_with_postflight_)*/false
  , /*decltype(_impl_.last_column_hit_by_tap_)*/0u} {}
struct CommandTextPreflightInsertCellArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandTextPreflightInsertCellArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandTextPreflightInsertCellArchiveDefaultTypeInternal() {}
  union {
    CommandTextPreflightInsertCellArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandTextPreflightInsertCellArchiveDefaultTypeInternal _CommandTextPreflightInsertCellArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandPostflightSetCellArchive::CommandPostflightSetCellArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellid_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.childcommandundo_)*/nullptr
  , /*decltype(_impl_.editing_cell_)*/nullptr
  , /*decltype(_impl_.new_cell_)*/nullptr
  , /*decltype(_impl_.editing_storage_)*/nullptr
  , /*decltype(_impl_.last_column_hit_by_tap_)*/0u} {}
struct CommandPostflightSetCellArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandPostflightSetCellArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandPostflightSetCellArchiveDefaultTypeInternal() {}
  union {
    CommandPostflightSetCellArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandPostflightSetCellArchiveDefaultTypeInternal _CommandPostflightSetCellArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetNumberOfHeadersOrFootersArchive::CommandSetNumberOfHeadersOrFootersArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.oldcount_)*/0u} {}
struct CommandSetNumberOfHeadersOrFootersArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetNumberOfHeadersOrFootersArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetNumberOfHeadersOrFootersArchiveDefaultTypeInternal() {}
  union {
    CommandSetNumberOfHeadersOrFootersArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetNumberOfHeadersOrFootersArchiveDefaultTypeInternal _CommandSetNumberOfHeadersOrFootersArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandFixWPStylesInRowsOrColumnsArchive::CommandFixWPStylesInRowsOrColumnsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.reference_index_)*/0u
  , /*decltype(_impl_.inherit_styles_)*/false
  , /*decltype(_impl_.count_)*/0u} {}
struct CommandFixWPStylesInRowsOrColumnsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandFixWPStylesInRowsOrColumnsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandFixWPStylesInRowsOrColumnsArchiveDefaultTypeInternal() {}
  union {
    CommandFixWPStylesInRowsOrColumnsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandFixWPStylesInRowsOrColumnsArchiveDefaultTypeInternal _CommandFixWPStylesInRowsOrColumnsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandFixStylesInHeadersOrFootersArchive::CommandFixStylesInHeadersOrFootersArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.textundo_)*/nullptr
  , /*decltype(_impl_.region_)*/0
  , /*decltype(_impl_.old_number_)*/0u
  , /*decltype(_impl_.new_number_)*/0u} {}
struct CommandFixStylesInHeadersOrFootersArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandFixStylesInHeadersOrFootersArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandFixStylesInHeadersOrFootersArchiveDefaultTypeInternal() {}
  union {
    CommandFixStylesInHeadersOrFootersArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandFixStylesInHeadersOrFootersArchiveDefaultTypeInternal _CommandFixStylesInHeadersOrFootersArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTableNameArchive::CommandSetTableNameArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.newtablename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.oldtablename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.newstyle_)*/nullptr
  , /*decltype(_impl_.oldstyle_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_shape_style_)*/nullptr
  , /*decltype(_impl_.new_shape_style_)*/nullptr
  , /*decltype(_impl_.old_table_name_border_enabled_)*/false
  , /*decltype(_impl_.new_table_name_border_enabled_)*/false} {}
struct CommandSetTableNameArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTableNameArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTableNameArchiveDefaultTypeInternal() {}
  union {
    CommandSetTableNameArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTableNameArchiveDefaultTypeInternal _CommandSetTableNameArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTableNameEnabledArchive::CommandSetTableNameEnabledArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.table_name_enabled_)*/false} {}
struct CommandSetTableNameEnabledArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTableNameEnabledArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTableNameEnabledArchiveDefaultTypeInternal() {}
  union {
    CommandSetTableNameEnabledArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTableNameEnabledArchiveDefaultTypeInternal _CommandSetTableNameEnabledArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTableFontSizeArchive::CommandSetTableFontSizeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.text_undo_)*/nullptr
  , /*decltype(_impl_.resize_default_cells_)*/false
  , /*decltype(_impl_.scale_factor_)*/0} {}
struct CommandSetTableFontSizeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTableFontSizeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTableFontSizeArchiveDefaultTypeInternal() {}
  union {
    CommandSetTableFontSizeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTableFontSizeArchiveDefaultTypeInternal _CommandSetTableFontSizeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTableFontNameArchive::CommandSetTableFontNameArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.font_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_font_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.text_undo_)*/nullptr
  , /*decltype(_impl_.preserve_face_)*/false} {}
struct CommandSetTableFontNameArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTableFontNameArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTableFontNameArchiveDefaultTypeInternal() {}
  union {
    CommandSetTableFontNameArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTableFontNameArchiveDefaultTypeInternal _CommandSetTableFontNameArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTableNameHeightArchive::CommandSetTableNameHeightArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_table_name_height_)*/0
  , /*decltype(_impl_.new_table_name_height_)*/0} {}
struct CommandSetTableNameHeightArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTableNameHeightArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTableNameHeightArchiveDefaultTypeInternal() {}
  union {
    CommandSetTableNameHeightArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTableNameHeightArchiveDefaultTypeInternal _CommandSetTableNameHeightArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandStyleCellsArchive::CommandStyleCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.format_properties_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.text_undo_)*/nullptr} {}
struct CommandStyleCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandStyleCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandStyleCellsArchiveDefaultTypeInternal() {}
  union {
    CommandStyleCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandStyleCellsArchiveDefaultTypeInternal _CommandStyleCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandStyleTableArchive::CommandStyleTableArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.format_properties_)*/nullptr
  , /*decltype(_impl_.old_style_)*/nullptr
  , /*decltype(_impl_.new_style_)*/nullptr} {}
struct CommandStyleTableArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandStyleTableArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandStyleTableArchiveDefaultTypeInternal() {}
  union {
    CommandStyleTableArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandStyleTableArchiveDefaultTypeInternal _CommandStyleTableArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandFillCellsArchive::CommandFillCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.sourceselection_)*/nullptr
  , /*decltype(_impl_.sourcecellrange_)*/nullptr
  , /*decltype(_impl_.targetcellrange_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.targetselection_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.filldirection_)*/1} {}
struct CommandFillCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandFillCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandFillCellsArchiveDefaultTypeInternal() {}
  union {
    CommandFillCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandFillCellsArchiveDefaultTypeInternal _CommandFillCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandReplaceTextArchive::CommandReplaceTextArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cellid_)*/nullptr
  , /*decltype(_impl_.newcell_)*/nullptr
  , /*decltype(_impl_.oldcell_)*/nullptr
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.child_command_undo_)*/nullptr} {}
struct CommandReplaceTextArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandReplaceTextArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandReplaceTextArchiveDefaultTypeInternal() {}
  union {
    CommandReplaceTextArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandReplaceTextArchiveDefaultTypeInternal _CommandReplaceTextArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandReplaceAllTextArchive::CommandReplaceAllTextArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tableinfo_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr} {}
struct CommandReplaceAllTextArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandReplaceAllTextArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandReplaceAllTextArchiveDefaultTypeInternal() {}
  union {
    CommandReplaceAllTextArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandReplaceAllTextArchiveDefaultTypeInternal _CommandReplaceAllTextArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetRepeatingHeaderEnabledArchive::CommandSetRepeatingHeaderEnabledArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.repeating_header_enabled_)*/false
  , /*decltype(_impl_.direction_)*/0} {}
struct CommandSetRepeatingHeaderEnabledArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetRepeatingHeaderEnabledArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetRepeatingHeaderEnabledArchiveDefaultTypeInternal() {}
  union {
    CommandSetRepeatingHeaderEnabledArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetRepeatingHeaderEnabledArchiveDefaultTypeInternal _CommandSetRepeatingHeaderEnabledArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFiltersEnabledArchive::CommandSetFiltersEnabledArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.enable_filters_)*/false} {}
struct CommandSetFiltersEnabledArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFiltersEnabledArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFiltersEnabledArchiveDefaultTypeInternal() {}
  union {
    CommandSetFiltersEnabledArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFiltersEnabledArchiveDefaultTypeInternal _CommandSetFiltersEnabledArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandAddQuickFilterRulesArchive::CommandAddQuickFilterRulesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rules_)*/{}
  , /*decltype(_impl_.rule_indices_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_index_)*/0u
  , /*decltype(_impl_.filter_set_enabled_)*/false} {}
struct CommandAddQuickFilterRulesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandAddQuickFilterRulesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandAddQuickFilterRulesArchiveDefaultTypeInternal() {}
  union {
    CommandAddQuickFilterRulesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandAddQuickFilterRulesArchiveDefaultTypeInternal _CommandAddQuickFilterRulesArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandDeleteFilterRulesArchive::CommandDeleteFilterRulesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.undo_rules_)*/{}
  , /*decltype(_impl_.rule_indices_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_index_)*/0u
  , /*decltype(_impl_.filter_removed_)*/false
  , /*decltype(_impl_.filter_set_enabled_)*/false} {}
struct CommandDeleteFilterRulesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDeleteFilterRulesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDeleteFilterRulesArchiveDefaultTypeInternal() {}
  union {
    CommandDeleteFilterRulesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDeleteFilterRulesArchiveDefaultTypeInternal _CommandDeleteFilterRulesArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandModifyFilterRuleArchive::CommandModifyFilterRuleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_rule_)*/nullptr
  , /*decltype(_impl_.redo_rule_)*/nullptr
  , /*decltype(_impl_.rule_index_)*/0u
  , /*decltype(_impl_.filter_index_)*/0u} {}
struct CommandModifyFilterRuleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandModifyFilterRuleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandModifyFilterRuleArchiveDefaultTypeInternal() {}
  union {
    CommandModifyFilterRuleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandModifyFilterRuleArchiveDefaultTypeInternal _CommandModifyFilterRuleArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyStrokePresetArchive::CommandApplyStrokePresetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.expanded_selection_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0} {}
struct CommandApplyStrokePresetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyStrokePresetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyStrokePresetArchiveDefaultTypeInternal() {}
  union {
    CommandApplyStrokePresetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyStrokePresetArchiveDefaultTypeInternal _CommandApplyStrokePresetArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyTableStylePresetArchive_StyleIndexTuple::CommandApplyTableStylePresetArchive_StyleIndexTuple(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cell_style_)*/nullptr
  , /*decltype(_impl_.text_style_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct CommandApplyTableStylePresetArchive_StyleIndexTupleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyTableStylePresetArchive_StyleIndexTupleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyTableStylePresetArchive_StyleIndexTupleDefaultTypeInternal() {}
  union {
    CommandApplyTableStylePresetArchive_StyleIndexTuple _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyTableStylePresetArchive_StyleIndexTupleDefaultTypeInternal _CommandApplyTableStylePresetArchive_StyleIndexTuple_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyTableStylePresetArchive::CommandApplyTableStylePresetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.row_style_index_tuples_)*/{}
  , /*decltype(_impl_.col_style_index_tuples_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.old_table_styles_)*/nullptr
  , /*decltype(_impl_.new_table_styles_)*/nullptr
  , /*decltype(_impl_.font_size_command_)*/nullptr
  , /*decltype(_impl_.set_style_apply_clears_all_flag_command_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0
  , /*decltype(_impl_.apply_clears_all_)*/false} {}
struct CommandApplyTableStylePresetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyTableStylePresetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyTableStylePresetArchiveDefaultTypeInternal() {}
  union {
    CommandApplyTableStylePresetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyTableStylePresetArchiveDefaultTypeInternal _CommandApplyTableStylePresetArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetStyleApplyClearsAllFlagArchive::CommandSetStyleApplyClearsAllFlagArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.apply_clears_all_)*/false} {}
struct CommandSetStyleApplyClearsAllFlagArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetStyleApplyClearsAllFlagArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetStyleApplyClearsAllFlagArchiveDefaultTypeInternal() {}
  union {
    CommandSetStyleApplyClearsAllFlagArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetStyleApplyClearsAllFlagArchiveDefaultTypeInternal _CommandSetStyleApplyClearsAllFlagArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyThemeToTableArchive::CommandApplyThemeToTableArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.old_table_styles_)*/nullptr
  , /*decltype(_impl_.new_table_styles_)*/nullptr} {}
struct CommandApplyThemeToTableArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyThemeToTableArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyThemeToTableArchiveDefaultTypeInternal() {}
  union {
    CommandApplyThemeToTableArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyThemeToTableArchiveDefaultTypeInternal _CommandApplyThemeToTableArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyThemeChildForTableArchive::CommandApplyThemeChildForTableArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.apply_command_)*/nullptr} {}
struct CommandApplyThemeChildForTableArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyThemeChildForTableArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyThemeChildForTableArchiveDefaultTypeInternal() {}
  union {
    CommandApplyThemeChildForTableArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyThemeChildForTableArchiveDefaultTypeInternal _CommandApplyThemeChildForTableArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandToggleTextPropertyArchive::CommandToggleTextPropertyArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.default_body_cell_)*/nullptr
  , /*decltype(_impl_.default_hr_cell_)*/nullptr
  , /*decltype(_impl_.default_hc_cell_)*/nullptr
  , /*decltype(_impl_.default_fr_cell_)*/nullptr
  , /*decltype(_impl_.text_undo_)*/nullptr
  , /*decltype(_impl_.property_)*/0u} {}
struct CommandToggleTextPropertyArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandToggleTextPropertyArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandToggleTextPropertyArchiveDefaultTypeInternal() {}
  union {
    CommandToggleTextPropertyArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandToggleTextPropertyArchiveDefaultTypeInternal _CommandToggleTextPropertyArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandResetFillPropertyToDefault::CommandResetFillPropertyToDefault(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr} {}
struct CommandResetFillPropertyToDefaultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandResetFillPropertyToDefaultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandResetFillPropertyToDefaultDefaultTypeInternal() {}
  union {
    CommandResetFillPropertyToDefault _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandResetFillPropertyToDefaultDefaultTypeInternal _CommandResetFillPropertyToDefault_default_instance_;
PROTOBUF_CONSTEXPR CommandSetSingleNumberFormatParameterArchive::CommandSetSingleNumberFormatParameterArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr} {}
struct CommandSetSingleNumberFormatParameterArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetSingleNumberFormatParameterArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetSingleNumberFormatParameterArchiveDefaultTypeInternal() {}
  union {
    CommandSetSingleNumberFormatParameterArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetSingleNumberFormatParameterArchiveDefaultTypeInternal _CommandSetSingleNumberFormatParameterArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetBaseArchive::CommandSetBaseArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.base_)*/0u} {}
struct CommandSetBaseArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetBaseArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetBaseArchiveDefaultTypeInternal() {}
  union {
    CommandSetBaseArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetBaseArchiveDefaultTypeInternal _CommandSetBaseArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetBasePlacesArchive::CommandSetBasePlacesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.base_places_)*/0u} {}
struct CommandSetBasePlacesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetBasePlacesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetBasePlacesArchiveDefaultTypeInternal() {}
  union {
    CommandSetBasePlacesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetBasePlacesArchiveDefaultTypeInternal _CommandSetBasePlacesArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetBaseUseMinusSignArchive::CommandSetBaseUseMinusSignArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.base_use_minus_sign_)*/false} {}
struct CommandSetBaseUseMinusSignArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetBaseUseMinusSignArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetBaseUseMinusSignArchiveDefaultTypeInternal() {}
  union {
    CommandSetBaseUseMinusSignArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetBaseUseMinusSignArchiveDefaultTypeInternal _CommandSetBaseUseMinusSignArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetControlMinimumArchive::CommandSetControlMinimumArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.minimum_)*/0
  , /*decltype(_impl_.format_type_)*/0u} {}
struct CommandSetControlMinimumArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetControlMinimumArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetControlMinimumArchiveDefaultTypeInternal() {}
  union {
    CommandSetControlMinimumArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetControlMinimumArchiveDefaultTypeInternal _CommandSetControlMinimumArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetControlMaximumArchive::CommandSetControlMaximumArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.maximum_)*/0
  , /*decltype(_impl_.format_type_)*/0u} {}
struct CommandSetControlMaximumArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetControlMaximumArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetControlMaximumArchiveDefaultTypeInternal() {}
  union {
    CommandSetControlMaximumArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetControlMaximumArchiveDefaultTypeInternal _CommandSetControlMaximumArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetControlIncrementArchive::CommandSetControlIncrementArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.increment_)*/0
  , /*decltype(_impl_.format_type_)*/0u} {}
struct CommandSetControlIncrementArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetControlIncrementArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetControlIncrementArchiveDefaultTypeInternal() {}
  union {
    CommandSetControlIncrementArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetControlIncrementArchiveDefaultTypeInternal _CommandSetControlIncrementArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetCurrencyCodeArchive::CommandSetCurrencyCodeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.currency_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetCurrencyCodeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetCurrencyCodeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetCurrencyCodeArchiveDefaultTypeInternal() {}
  union {
    CommandSetCurrencyCodeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetCurrencyCodeArchiveDefaultTypeInternal _CommandSetCurrencyCodeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFractionAccuracyArchive::CommandSetFractionAccuracyArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.fraction_accuracy_)*/0u} {}
struct CommandSetFractionAccuracyArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFractionAccuracyArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFractionAccuracyArchiveDefaultTypeInternal() {}
  union {
    CommandSetFractionAccuracyArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFractionAccuracyArchiveDefaultTypeInternal _CommandSetFractionAccuracyArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForEditedItemArchive::CommandSetMultipleChoiceListFormatForEditedItemArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleChoiceListFormatForEditedItemArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForEditedItemArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleChoiceListFormatForEditedItemArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleChoiceListFormatForEditedItemArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleChoiceListFormatForEditedItemArchiveDefaultTypeInternal _CommandSetMultipleChoiceListFormatForEditedItemArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForDeleteItemArchive::CommandSetMultipleChoiceListFormatForDeleteItemArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleChoiceListFormatForDeleteItemArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForDeleteItemArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleChoiceListFormatForDeleteItemArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleChoiceListFormatForDeleteItemArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleChoiceListFormatForDeleteItemArchiveDefaultTypeInternal _CommandSetMultipleChoiceListFormatForDeleteItemArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForReorderItemArchive::CommandSetMultipleChoiceListFormatForReorderItemArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleChoiceListFormatForReorderItemArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForReorderItemArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleChoiceListFormatForReorderItemArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleChoiceListFormatForReorderItemArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleChoiceListFormatForReorderItemArchiveDefaultTypeInternal _CommandSetMultipleChoiceListFormatForReorderItemArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForInitialValueArchive::CommandSetMultipleChoiceListFormatForInitialValueArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetMultipleChoiceListFormatForInitialValueArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetMultipleChoiceListFormatForInitialValueArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetMultipleChoiceListFormatForInitialValueArchiveDefaultTypeInternal() {}
  union {
    CommandSetMultipleChoiceListFormatForInitialValueArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetMultipleChoiceListFormatForInitialValueArchiveDefaultTypeInternal _CommandSetMultipleChoiceListFormatForInitialValueArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetNegativeNumberStyleArchive::CommandSetNegativeNumberStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.negative_number_style_)*/0u} {}
struct CommandSetNegativeNumberStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetNegativeNumberStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetNegativeNumberStyleArchiveDefaultTypeInternal() {}
  union {
    CommandSetNegativeNumberStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetNegativeNumberStyleArchiveDefaultTypeInternal _CommandSetNegativeNumberStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetExplicitFormatArchive::CommandSetExplicitFormatArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.cell_format_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr} {}
struct CommandSetExplicitFormatArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetExplicitFormatArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetExplicitFormatArchiveDefaultTypeInternal() {}
  union {
    CommandSetExplicitFormatArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetExplicitFormatArchiveDefaultTypeInternal _CommandSetExplicitFormatArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetNumberOfDecimalPlacesArchive::CommandSetNumberOfDecimalPlacesArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.decimal_places_)*/0u} {}
struct CommandSetNumberOfDecimalPlacesArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetNumberOfDecimalPlacesArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetNumberOfDecimalPlacesArchiveDefaultTypeInternal() {}
  union {
    CommandSetNumberOfDecimalPlacesArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetNumberOfDecimalPlacesArchiveDefaultTypeInternal _CommandSetNumberOfDecimalPlacesArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetDateTimeFormatArchive::CommandSetDateTimeFormatArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandSetDateTimeFormatArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetDateTimeFormatArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetDateTimeFormatArchiveDefaultTypeInternal() {}
  union {
    CommandSetDateTimeFormatArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetDateTimeFormatArchiveDefaultTypeInternal _CommandSetDateTimeFormatArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetShowThousandsSeparatorArchive::CommandSetShowThousandsSeparatorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.show_thousands_separator_)*/false} {}
struct CommandSetShowThousandsSeparatorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetShowThousandsSeparatorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetShowThousandsSeparatorArchiveDefaultTypeInternal() {}
  union {
    CommandSetShowThousandsSeparatorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetShowThousandsSeparatorArchiveDefaultTypeInternal _CommandSetShowThousandsSeparatorArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetUseAccountingStyleArchive::CommandSetUseAccountingStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.use_accounting_style_)*/false} {}
struct CommandSetUseAccountingStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetUseAccountingStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetUseAccountingStyleArchiveDefaultTypeInternal() {}
  union {
    CommandSetUseAccountingStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetUseAccountingStyleArchiveDefaultTypeInternal _CommandSetUseAccountingStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandMoveRowsArchive::CommandMoveRowsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.formula_rewrite_command_)*/nullptr
  , /*decltype(_impl_.show_command_)*/nullptr
  , /*decltype(_impl_.unmerge_invalid_ranges_command_)*/nullptr
  , /*decltype(_impl_.start_row_index_)*/0u
  , /*decltype(_impl_.dest_row_index_)*/0u
  , /*decltype(_impl_.number_of_rows_)*/0u} {}
struct CommandMoveRowsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMoveRowsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMoveRowsArchiveDefaultTypeInternal() {}
  union {
    CommandMoveRowsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMoveRowsArchiveDefaultTypeInternal _CommandMoveRowsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandMoveColumnsArchive::CommandMoveColumnsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.formula_rewrite_command_)*/nullptr
  , /*decltype(_impl_.show_command_)*/nullptr
  , /*decltype(_impl_.start_column_index_)*/0u
  , /*decltype(_impl_.dest_column_index_)*/0u
  , /*decltype(_impl_.number_of_columns_)*/0u} {}
struct CommandMoveColumnsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMoveColumnsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMoveColumnsArchiveDefaultTypeInternal() {}
  union {
    CommandMoveColumnsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMoveColumnsArchiveDefaultTypeInternal _CommandMoveColumnsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSortArchive::CommandSortArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.mapping_)*/nullptr
  , /*decltype(_impl_.formula_rewrite_command_)*/nullptr} {}
struct CommandSortArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSortArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSortArchiveDefaultTypeInternal() {}
  union {
    CommandSortArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSortArchiveDefaultTypeInternal _CommandSortArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFormulasForSortArchive::CommandRewriteFormulasForSortArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.formula_map_)*/nullptr
  , /*decltype(_impl_.sort_mapping_)*/nullptr
  , /*decltype(_impl_.sorted_table_id_)*/nullptr
  , /*decltype(_impl_.explode_ranges_)*/false} {}
struct CommandRewriteFormulasForSortArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFormulasForSortArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFormulasForSortArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFormulasForSortArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFormulasForSortArchiveDefaultTypeInternal _CommandRewriteFormulasForSortArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFormulasForTectonicShiftArchive::CommandRewriteFormulasForTectonicShiftArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.formula_map_)*/nullptr
  , /*decltype(_impl_.tectonic_shift_)*/nullptr} {}
struct CommandRewriteFormulasForTectonicShiftArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFormulasForTectonicShiftArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFormulasForTectonicShiftArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFormulasForTectonicShiftArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFormulasForTectonicShiftArchiveDefaultTypeInternal _CommandRewriteFormulasForTectonicShiftArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFormulasForMoveArchive::CommandRewriteFormulasForMoveArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.formula_map_)*/nullptr
  , /*decltype(_impl_.from_reference_)*/nullptr
  , /*decltype(_impl_.to_reference_)*/nullptr} {}
struct CommandRewriteFormulasForMoveArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFormulasForMoveArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFormulasForMoveArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFormulasForMoveArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFormulasForMoveArchiveDefaultTypeInternal _CommandRewriteFormulasForMoveArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFormulasForCellMergeArchive::CommandRewriteFormulasForCellMergeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.formula_map_)*/nullptr
  , /*decltype(_impl_.merged_range_)*/nullptr
  , /*decltype(_impl_.table_id_)*/nullptr} {}
struct CommandRewriteFormulasForCellMergeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFormulasForCellMergeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFormulasForCellMergeArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFormulasForCellMergeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFormulasForCellMergeArchiveDefaultTypeInternal _CommandRewriteFormulasForCellMergeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForTableResizeArchive::CommandRewriteFilterFormulasForTableResizeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandRewriteFilterFormulasForTableResizeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForTableResizeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFilterFormulasForTableResizeArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFilterFormulasForTableResizeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFilterFormulasForTableResizeArchiveDefaultTypeInternal _CommandRewriteFilterFormulasForTableResizeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForTectonicShiftArchive::CommandRewriteFilterFormulasForTectonicShiftArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_set_)*/nullptr
  , /*decltype(_impl_.tectonic_shift_)*/nullptr} {}
struct CommandRewriteFilterFormulasForTectonicShiftArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForTectonicShiftArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFilterFormulasForTectonicShiftArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFilterFormulasForTectonicShiftArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFilterFormulasForTectonicShiftArchiveDefaultTypeInternal _CommandRewriteFilterFormulasForTectonicShiftArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForSortArchive::CommandRewriteFilterFormulasForSortArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_set_)*/nullptr
  , /*decltype(_impl_.sort_mapping_)*/nullptr
  , /*decltype(_impl_.sorted_table_id_)*/nullptr} {}
struct CommandRewriteFilterFormulasForSortArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteFilterFormulasForSortArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteFilterFormulasForSortArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteFilterFormulasForSortArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteFilterFormulasForSortArchiveDefaultTypeInternal _CommandRewriteFilterFormulasForSortArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForTectonicShiftArchive::CommandRewriteConditionalStylesForTectonicShiftArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.tectonic_shift_)*/nullptr
  , /*decltype(_impl_.cells_to_rewrite_)*/nullptr
  , /*decltype(_impl_.conditional_style_sets_)*/nullptr} {}
struct CommandRewriteConditionalStylesForTectonicShiftArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForTectonicShiftArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteConditionalStylesForTectonicShiftArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteConditionalStylesForTectonicShiftArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteConditionalStylesForTectonicShiftArchiveDefaultTypeInternal _CommandRewriteConditionalStylesForTectonicShiftArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForSortArchive::CommandRewriteConditionalStylesForSortArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.sort_mapping_)*/nullptr
  , /*decltype(_impl_.sorted_table_id_)*/nullptr
  , /*decltype(_impl_.cells_to_rewrite_)*/nullptr
  , /*decltype(_impl_.conditional_style_sets_)*/nullptr} {}
struct CommandRewriteConditionalStylesForSortArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForSortArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteConditionalStylesForSortArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteConditionalStylesForSortArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteConditionalStylesForSortArchiveDefaultTypeInternal _CommandRewriteConditionalStylesForSortArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForRangeMoveArchive::CommandRewriteConditionalStylesForRangeMoveArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.cells_to_rewrite_)*/nullptr
  , /*decltype(_impl_.conditional_style_sets_)*/nullptr
  , /*decltype(_impl_.from_range_reference_)*/nullptr
  , /*decltype(_impl_.to_range_reference_)*/nullptr} {}
struct CommandRewriteConditionalStylesForRangeMoveArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForRangeMoveArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteConditionalStylesForRangeMoveArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteConditionalStylesForRangeMoveArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteConditionalStylesForRangeMoveArchiveDefaultTypeInternal _CommandRewriteConditionalStylesForRangeMoveArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForCellMergeArchive::CommandRewriteConditionalStylesForCellMergeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.merged_table_id_)*/nullptr
  , /*decltype(_impl_.merged_range_)*/nullptr
  , /*decltype(_impl_.cells_to_rewrite_)*/nullptr
  , /*decltype(_impl_.conditional_style_sets_)*/nullptr} {}
struct CommandRewriteConditionalStylesForCellMergeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandRewriteConditionalStylesForCellMergeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandRewriteConditionalStylesForCellMergeArchiveDefaultTypeInternal() {}
  union {
    CommandRewriteConditionalStylesForCellMergeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandRewriteConditionalStylesForCellMergeArchiveDefaultTypeInternal _CommandRewriteConditionalStylesForCellMergeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandMergeUnmergeArchive::CommandMergeUnmergeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.old_merge_ranges_)*/nullptr
  , /*decltype(_impl_.undo_formula_rewrite_command_)*/nullptr
  , /*decltype(_impl_.merge_action_)*/0} {}
struct CommandMergeUnmergeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMergeUnmergeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMergeUnmergeArchiveDefaultTypeInternal() {}
  union {
    CommandMergeUnmergeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMergeUnmergeArchiveDefaultTypeInternal _CommandMergeUnmergeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandHideShowArchive::CommandHideShowArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.old_hiding_states_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.elements_affected_)*/nullptr
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_.hide_show_action_)*/0
  , /*decltype(_impl_.hiding_action_)*/0u} {}
struct CommandHideShowArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandHideShowArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandHideShowArchiveDefaultTypeInternal() {}
  union {
    CommandHideShowArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandHideShowArchiveDefaultTypeInternal _CommandHideShowArchive_default_instance_;
PROTOBUF_CONSTEXPR TableInfoGeometryCommandArchive::TableInfoGeometryCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.scale_factor_)*/nullptr
  , /*decltype(_impl_.table_info_)*/nullptr
  , /*decltype(_impl_.new_geometry_)*/nullptr
  , /*decltype(_impl_.old_geometry_)*/nullptr
  , /*decltype(_impl_.turn_off_auto_resize_)*/false
  , /*decltype(_impl_.should_clear_object_placeholder_flag_)*/false
  , /*decltype(_impl_.did_match_object_placeholder_geometry_)*/false} {}
struct TableInfoGeometryCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableInfoGeometryCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableInfoGeometryCommandArchiveDefaultTypeInternal() {}
  union {
    TableInfoGeometryCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableInfoGeometryCommandArchiveDefaultTypeInternal _TableInfoGeometryCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR FormulaEditingCommandGroupArchive::FormulaEditingCommandGroupArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undoselectionstart_)*/0u
  , /*decltype(_impl_.undoselectionlength_)*/0u
  , /*decltype(_impl_.undoselectionvalid_)*/false
  , /*decltype(_impl_.redoselectionvalid_)*/false
  , /*decltype(_impl_.undoactivetoken_)*/0u
  , /*decltype(_impl_.redoselectionstart_)*/0u
  , /*decltype(_impl_.redoselectionlength_)*/0u
  , /*decltype(_impl_.redoactivetoken_)*/0u} {}
struct FormulaEditingCommandGroupArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormulaEditingCommandGroupArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormulaEditingCommandGroupArchiveDefaultTypeInternal() {}
  union {
    FormulaEditingCommandGroupArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormulaEditingCommandGroupArchiveDefaultTypeInternal _FormulaEditingCommandGroupArchive_default_instance_;
PROTOBUF_CONSTEXPR FormulaEditingCommandSelectionBehaviorArchive::FormulaEditingCommandSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undoselectionstart_)*/0u
  , /*decltype(_impl_.undoselectionlength_)*/0u
  , /*decltype(_impl_.undoselectionvalid_)*/false
  , /*decltype(_impl_.redoselectionvalid_)*/false
  , /*decltype(_impl_.undoactivetoken_)*/0u
  , /*decltype(_impl_.redoselectionstart_)*/0u
  , /*decltype(_impl_.redoselectionlength_)*/0u
  , /*decltype(_impl_.redoactivetoken_)*/0u} {}
struct FormulaEditingCommandSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormulaEditingCommandSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormulaEditingCommandSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    FormulaEditingCommandSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormulaEditingCommandSelectionBehaviorArchiveDefaultTypeInternal _FormulaEditingCommandSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.before_undo_redo_state_)*/nullptr
  , /*decltype(_impl_.after_undo_redo_state_)*/nullptr
  , /*decltype(_impl_.table_info_)*/nullptr
  , /*decltype(_impl_.before_table_selection_)*/nullptr
  , /*decltype(_impl_.after_table_selection_)*/nullptr} {}
struct UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    UndoRedoStateCommandSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UndoRedoStateCommandSelectionBehaviorArchiveDefaultTypeInternal _UndoRedoStateCommandSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR TableCommandSelectionBehaviorArchive::TableCommandSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.before_table_selection_)*/nullptr
  , /*decltype(_impl_.after_table_selection_)*/nullptr
  , /*decltype(_impl_.table_info_)*/nullptr
  , /*decltype(_impl_.last_column_hit_by_tap_)*/0u} {}
struct TableCommandSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TableCommandSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TableCommandSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    TableCommandSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TableCommandSelectionBehaviorArchiveDefaultTypeInternal _TableCommandSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR DisableTableNameSelectionBehaviorArchive::DisableTableNameSelectionBehaviorArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct DisableTableNameSelectionBehaviorArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DisableTableNameSelectionBehaviorArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DisableTableNameSelectionBehaviorArchiveDefaultTypeInternal() {}
  union {
    DisableTableNameSelectionBehaviorArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisableTableNameSelectionBehaviorArchiveDefaultTypeInternal _DisableTableNameSelectionBehaviorArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyCellCommentArchive::CommandApplyCellCommentArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.cell_id_)*/nullptr
  , /*decltype(_impl_.old_comment_storage_)*/nullptr
  , /*decltype(_impl_.new_comment_storage_)*/nullptr} {}
struct CommandApplyCellCommentArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyCellCommentArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyCellCommentArchiveDefaultTypeInternal() {}
  union {
    CommandApplyCellCommentArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyCellCommentArchiveDefaultTypeInternal _CommandApplyCellCommentArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandApplyConditionalStyleSetArchive::CommandApplyConditionalStyleSetArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr} {}
struct CommandApplyConditionalStyleSetArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandApplyConditionalStyleSetArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandApplyConditionalStyleSetArchiveDefaultTypeInternal() {}
  union {
    CommandApplyConditionalStyleSetArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandApplyConditionalStyleSetArchiveDefaultTypeInternal _CommandApplyConditionalStyleSetArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFormulaTokenizationArchive::CommandSetFormulaTokenizationArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.tokenization_)*/false} {}
struct CommandSetFormulaTokenizationArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFormulaTokenizationArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFormulaTokenizationArchiveDefaultTypeInternal() {}
  union {
    CommandSetFormulaTokenizationArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFormulaTokenizationArchiveDefaultTypeInternal _CommandSetFormulaTokenizationArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFilterEnabledArchive::CommandSetFilterEnabledArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_index_)*/0u
  , /*decltype(_impl_.enabled_)*/false} {}
struct CommandSetFilterEnabledArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFilterEnabledArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFilterEnabledArchiveDefaultTypeInternal() {}
  union {
    CommandSetFilterEnabledArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFilterEnabledArchiveDefaultTypeInternal _CommandSetFilterEnabledArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFilterRuleEnabledArchive::CommandSetFilterRuleEnabledArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.filter_index_)*/0u
  , /*decltype(_impl_.rule_index_)*/0u
  , /*decltype(_impl_.enabled_)*/false} {}
struct CommandSetFilterRuleEnabledArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFilterRuleEnabledArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFilterRuleEnabledArchiveDefaultTypeInternal() {}
  union {
    CommandSetFilterRuleEnabledArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFilterRuleEnabledArchiveDefaultTypeInternal _CommandSetFilterRuleEnabledArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetFilterSetTypeArchive::CommandSetFilterSetTypeArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_filter_set_type_)*/0
  , /*decltype(_impl_.new_filter_set_type_)*/0} {}
struct CommandSetFilterSetTypeArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetFilterSetTypeArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetFilterSetTypeArchiveDefaultTypeInternal() {}
  union {
    CommandSetFilterSetTypeArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetFilterSetTypeArchiveDefaultTypeInternal _CommandSetFilterSetTypeArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetStyleNetworkArchive::CommandSetStyleNetworkArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_style_network_)*/nullptr
  , /*decltype(_impl_.new_style_network_)*/nullptr} {}
struct CommandSetStyleNetworkArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetStyleNetworkArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetStyleNetworkArchiveDefaultTypeInternal() {}
  union {
    CommandSetStyleNetworkArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetStyleNetworkArchiveDefaultTypeInternal _CommandSetStyleNetworkArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandMutateCellsArchive::CommandMutateCellsArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.selection_)*/nullptr} {}
struct CommandMutateCellsArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMutateCellsArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMutateCellsArchiveDefaultTypeInternal() {}
  union {
    CommandMutateCellsArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMutateCellsArchiveDefaultTypeInternal _CommandMutateCellsArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandDisableFilterRulesForColumnArchive::CommandDisableFilterRulesForColumnArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rule_indices_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.column_index_)*/0u} {}
struct CommandDisableFilterRulesForColumnArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDisableFilterRulesForColumnArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDisableFilterRulesForColumnArchiveDefaultTypeInternal() {}
  union {
    CommandDisableFilterRulesForColumnArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDisableFilterRulesForColumnArchiveDefaultTypeInternal _CommandDisableFilterRulesForColumnArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetTextStyleArchive::CommandSetTextStyleArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.region_)*/nullptr
  , /*decltype(_impl_.undo_cell_map_)*/nullptr
  , /*decltype(_impl_.redo_cell_map_)*/nullptr
  , /*decltype(_impl_.subcommands_)*/nullptr} {}
struct CommandSetTextStyleArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetTextStyleArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetTextStyleArchiveDefaultTypeInternal() {}
  union {
    CommandSetTextStyleArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetTextStyleArchiveDefaultTypeInternal _CommandSetTextStyleArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandNotifyForTransformingArchive::CommandNotifyForTransformingArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct CommandNotifyForTransformingArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandNotifyForTransformingArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandNotifyForTransformingArchiveDefaultTypeInternal() {}
  union {
    CommandNotifyForTransformingArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandNotifyForTransformingArchiveDefaultTypeInternal _CommandNotifyForTransformingArchive_default_instance_;
PROTOBUF_CONSTEXPR CommandSetStorageLanguageArchive::CommandSetStorageLanguageArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.range_location_)*/0u
  , /*decltype(_impl_.range_length_)*/0u} {}
struct CommandSetStorageLanguageArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandSetStorageLanguageArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandSetStorageLanguageArchiveDefaultTypeInternal() {}
  union {
    CommandSetStorageLanguageArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandSetStorageLanguageArchiveDefaultTypeInternal _CommandSetStorageLanguageArchive_default_instance_;
}  // namespace TST
static ::_pb::Metadata file_level_metadata_TSTCommandArchives_2eproto[98];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSTCommandArchives_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSTCommandArchives_2eproto = nullptr;

const uint32_t TableStruct_TSTCommandArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _impl_.tableinfo_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _impl_.commandname_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandArchive, _impl_.editing_mode_at_start_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandChangeFreezeHeaderStateArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandChangeFreezeHeaderStateArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandChangeFreezeHeaderStateArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandChangeFreezeHeaderStateArchive, _impl_.new_freeze_state_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandChangeFreezeHeaderStateArchive, _impl_.super_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellsArchive, _impl_.invalidate_comments_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteCellContentsArchive, _impl_.invalidate_comments_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.source_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.only_if_format_differs_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsArchive, _impl_.super_),
  0,
  1,
  2,
  3,
  5,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_.cell_format_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsCustomArchive, _impl_.super_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.super_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_.desired_format_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandCoerceMultipleCellsArchive, _impl_.super_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlCellsDisplayNumberFormatArchive, _impl_.super_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticFormatArchive, _impl_.super_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_.undo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_.redo_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_.automatic_units_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetAutomaticDurationUnitsArchive, _impl_.super_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair, _impl_.style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair, _impl_.index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.before_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.header_count_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.headers_added_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.footer_count_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.footers_added_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.row_column_style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.cell_style_redo_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.formula_rewrite_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.width_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.height_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.allow_horizontal_autosize_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.inherit_styles_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.inherit_formats_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.inherit_formulas_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.cell_style_index_pairs_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.text_style_index_pairs_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandInsertColumnsOrRowsArchive, _impl_.sizes_),
  4,
  5,
  6,
  7,
  12,
  8,
  9,
  10,
  11,
  0,
  1,
  2,
  3,
  16,
  17,
  13,
  14,
  15,
  18,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.user_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.final_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.command_undo_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.invalidate_comments_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPasteArchive, _impl_.formula_rewrite_commands_),
  0,
  1,
  2,
  3,
  4,
  6,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.indices_to_remove_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.cellmap_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.oldgeom_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.newgeom_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.subsizes_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.formula_rewrite_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.width_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.height_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.allow_horizontal_autosize_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.undo_merge_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.redo_merge_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.hiding_actions_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.orig_filter_set_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRemoveColumnsOrRowsArchive, _impl_.undo_command_collector_),
  0,
  9,
  1,
  2,
  3,
  4,
  ~0u,
  5,
  10,
  11,
  12,
  6,
  7,
  ~0u,
  8,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.newsize_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.oldgeom_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.newgeom_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.subsizes_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.old_default_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.uniformsizes_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.resizemode_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResizeColumnOrRowArchive, _impl_.super_),
  3,
  4,
  5,
  6,
  0,
  1,
  ~0u,
  7,
  8,
  9,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_.cellid_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_.newcell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_.oldcell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCellArchive, _impl_.post_undo_redo_selection_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.editing_cellid_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.coalesced_textcommand_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.postflightcommand_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.grouped_with_postflight_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.editing_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.editing_storage_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandTextPreflightInsertCellArchive, _impl_.last_column_hit_by_tap_),
  0,
  1,
  2,
  3,
  6,
  4,
  5,
  7,
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.cellid_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.childcommandundo_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.editing_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.new_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.editing_storage_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandPostflightSetCellArchive, _impl_.last_column_hit_by_tap_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _impl_.oldcount_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfHeadersOrFootersArchive, _impl_.super_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.reference_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.inherit_styles_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixWPStylesInRowsOrColumnsArchive, _impl_.count_),
  3,
  4,
  0,
  1,
  2,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.old_number_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.new_number_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFixStylesInHeadersOrFootersArchive, _impl_.textundo_),
  4,
  5,
  6,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.newtablename_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.oldtablename_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.newstyle_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.oldstyle_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.old_shape_style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.new_shape_style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.old_table_name_border_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameArchive, _impl_.new_table_name_border_enabled_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameEnabledArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameEnabledArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameEnabledArchive, _impl_.table_name_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameEnabledArchive, _impl_.super_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.scale_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.resize_default_cells_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontSizeArchive, _impl_.text_undo_),
  0,
  5,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.font_name_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.old_font_name_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.preserve_face_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableFontNameArchive, _impl_.text_undo_),
  2,
  0,
  1,
  6,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameHeightArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameHeightArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameHeightArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameHeightArchive, _impl_.old_table_name_height_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTableNameHeightArchive, _impl_.new_table_name_height_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.format_properties_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleCellsArchive, _impl_.text_undo_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _impl_.format_properties_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _impl_.old_style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandStyleTableArchive, _impl_.new_style_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.sourceselection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.sourcecellrange_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.targetcellrange_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.filldirection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.targetselection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandFillCellsArchive, _impl_.redo_cell_map_),
  0,
  1,
  2,
  3,
  4,
  7,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_.cellid_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_.newcell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_.oldcell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceTextArchive, _impl_.child_command_undo_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceAllTextArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceAllTextArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceAllTextArchive, _impl_.tableinfo_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceAllTextArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandReplaceAllTextArchive, _impl_.redo_cell_map_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetRepeatingHeaderEnabledArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetRepeatingHeaderEnabledArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetRepeatingHeaderEnabledArchive, _impl_.repeating_header_enabled_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetRepeatingHeaderEnabledArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetRepeatingHeaderEnabledArchive, _impl_.super_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFiltersEnabledArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFiltersEnabledArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFiltersEnabledArchive, _impl_.enable_filters_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFiltersEnabledArchive, _impl_.super_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_.rules_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_.filter_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_.rule_indices_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandAddQuickFilterRulesArchive, _impl_.filter_set_enabled_),
  0,
  ~0u,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.undo_rules_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.rule_indices_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.filter_removed_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.filter_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDeleteFilterRulesArchive, _impl_.filter_set_enabled_),
  0,
  ~0u,
  ~0u,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_.undo_rule_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_.redo_rule_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_.rule_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandModifyFilterRuleArchive, _impl_.filter_index_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.expanded_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyStrokePresetArchive, _impl_.preset_index_),
  0,
  1,
  3,
  2,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_.cell_style_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_.text_style_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.preset_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.old_table_styles_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.new_table_styles_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.apply_clears_all_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.font_size_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.set_style_apply_clears_all_flag_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.row_style_index_tuples_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyTableStylePresetArchive, _impl_.col_style_index_tuples_),
  0,
  1,
  2,
  7,
  3,
  4,
  8,
  5,
  6,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleApplyClearsAllFlagArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleApplyClearsAllFlagArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleApplyClearsAllFlagArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleApplyClearsAllFlagArchive, _impl_.apply_clears_all_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_.old_table_styles_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeToTableArchive, _impl_.new_table_styles_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeChildForTableArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeChildForTableArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeChildForTableArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyThemeChildForTableArchive, _impl_.apply_command_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.property_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.default_body_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.default_hr_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.default_hc_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.default_fr_cell_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandToggleTextPropertyArchive, _impl_.text_undo_),
  0,
  1,
  9,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandResetFillPropertyToDefault, _impl_.redo_cell_map_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetSingleNumberFormatParameterArchive, _impl_.redo_cell_map_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseArchive, _impl_.base_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBasePlacesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBasePlacesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBasePlacesArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBasePlacesArchive, _impl_.base_places_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseUseMinusSignArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseUseMinusSignArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseUseMinusSignArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetBaseUseMinusSignArchive, _impl_.base_use_minus_sign_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMinimumArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMinimumArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMinimumArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMinimumArchive, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMinimumArchive, _impl_.format_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMaximumArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMaximumArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMaximumArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMaximumArchive, _impl_.maximum_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlMaximumArchive, _impl_.format_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlIncrementArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlIncrementArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlIncrementArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlIncrementArchive, _impl_.increment_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetControlIncrementArchive, _impl_.format_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCurrencyCodeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCurrencyCodeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCurrencyCodeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetCurrencyCodeArchive, _impl_.currency_code_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFractionAccuracyArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFractionAccuracyArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFractionAccuracyArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFractionAccuracyArchive, _impl_.fraction_accuracy_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNegativeNumberStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNegativeNumberStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNegativeNumberStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNegativeNumberStyleArchive, _impl_.negative_number_style_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_.cell_format_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetExplicitFormatArchive, _impl_.redo_cell_map_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfDecimalPlacesArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfDecimalPlacesArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfDecimalPlacesArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetNumberOfDecimalPlacesArchive, _impl_.decimal_places_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetDateTimeFormatArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetDateTimeFormatArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetDateTimeFormatArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetShowThousandsSeparatorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetShowThousandsSeparatorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetShowThousandsSeparatorArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetShowThousandsSeparatorArchive, _impl_.show_thousands_separator_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetUseAccountingStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetUseAccountingStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetUseAccountingStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetUseAccountingStyleArchive, _impl_.use_accounting_style_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.start_row_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.dest_row_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.number_of_rows_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.formula_rewrite_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.show_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveRowsArchive, _impl_.unmerge_invalid_ranges_command_),
  0,
  1,
  5,
  6,
  7,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.start_column_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.dest_column_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.number_of_columns_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.formula_rewrite_command_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMoveColumnsArchive, _impl_.show_command_),
  0,
  1,
  4,
  5,
  6,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSortArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSortArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSortArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSortArchive, _impl_.mapping_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSortArchive, _impl_.formula_rewrite_command_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_.formula_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_.sort_mapping_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_.sorted_table_id_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForSortArchive, _impl_.explode_ranges_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForTectonicShiftArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForTectonicShiftArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForTectonicShiftArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForTectonicShiftArchive, _impl_.formula_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForTectonicShiftArchive, _impl_.tectonic_shift_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _impl_.formula_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _impl_.from_reference_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForMoveArchive, _impl_.to_reference_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _impl_.formula_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _impl_.merged_range_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFormulasForCellMergeArchive, _impl_.table_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTableResizeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTableResizeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTableResizeArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_.filter_set_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_.tectonic_shift_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _impl_.filter_set_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _impl_.sort_mapping_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteFilterFormulasForSortArchive, _impl_.sorted_table_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.tectonic_shift_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.cells_to_rewrite_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.conditional_style_sets_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_.sort_mapping_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_.sorted_table_id_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_.cells_to_rewrite_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForSortArchive, _impl_.conditional_style_sets_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.from_range_reference_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.to_range_reference_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.cells_to_rewrite_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.conditional_style_sets_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_.merged_table_id_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_.merged_range_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_.cells_to_rewrite_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandRewriteConditionalStylesForCellMergeArchive, _impl_.conditional_style_sets_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.merge_action_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.old_merge_ranges_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMergeUnmergeArchive, _impl_.undo_formula_rewrite_command_),
  0,
  6,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.hide_show_action_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.hiding_action_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.elements_affected_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandHideShowArchive, _impl_.old_hiding_states_),
  0,
  2,
  3,
  4,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.scale_factor_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.table_info_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.new_geometry_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.old_geometry_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.turn_off_auto_resize_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.should_clear_object_placeholder_flag_),
  PROTOBUF_FIELD_OFFSET(::TST::TableInfoGeometryCommandArchive, _impl_.did_match_object_placeholder_geometry_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.undoselectionvalid_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.undoselectionstart_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.undoselectionlength_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.undoactivetoken_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.redoselectionvalid_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.redoselectionstart_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.redoselectionlength_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandGroupArchive, _impl_.redoactivetoken_),
  0,
  3,
  1,
  2,
  5,
  4,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.undoselectionvalid_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.undoselectionstart_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.undoselectionlength_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.undoactivetoken_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.redoselectionvalid_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.redoselectionstart_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.redoselectionlength_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.redoactivetoken_),
  PROTOBUF_FIELD_OFFSET(::TST::FormulaEditingCommandSelectionBehaviorArchive, _impl_.storage_),
  3,
  1,
  2,
  5,
  4,
  6,
  7,
  8,
  0,
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.before_undo_redo_state_),
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.after_undo_redo_state_),
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.table_info_),
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.before_table_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::UndoRedoStateCommandSelectionBehaviorArchive, _impl_.after_table_selection_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _impl_.before_table_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _impl_.after_table_selection_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _impl_.table_info_),
  PROTOBUF_FIELD_OFFSET(::TST::TableCommandSelectionBehaviorArchive, _impl_.last_column_hit_by_tap_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::DisableTableNameSelectionBehaviorArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::DisableTableNameSelectionBehaviorArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::DisableTableNameSelectionBehaviorArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _impl_.cell_id_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _impl_.old_comment_storage_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyCellCommentArchive, _impl_.new_comment_storage_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _impl_.selection_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandApplyConditionalStyleSetArchive, _impl_.redo_cell_map_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFormulaTokenizationArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFormulaTokenizationArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFormulaTokenizationArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFormulaTokenizationArchive, _impl_.tokenization_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterEnabledArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterEnabledArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterEnabledArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterEnabledArchive, _impl_.filter_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterEnabledArchive, _impl_.enabled_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _impl_.filter_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _impl_.rule_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterRuleEnabledArchive, _impl_.enabled_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterSetTypeArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterSetTypeArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterSetTypeArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterSetTypeArchive, _impl_.old_filter_set_type_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetFilterSetTypeArchive, _impl_.new_filter_set_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleNetworkArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleNetworkArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleNetworkArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleNetworkArchive, _impl_.old_style_network_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStyleNetworkArchive, _impl_.new_style_network_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandMutateCellsArchive, _impl_.selection_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TST::CommandDisableFilterRulesForColumnArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDisableFilterRulesForColumnArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandDisableFilterRulesForColumnArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDisableFilterRulesForColumnArchive, _impl_.column_index_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandDisableFilterRulesForColumnArchive, _impl_.rule_indices_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_.region_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_.undo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_.redo_cell_map_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetTextStyleArchive, _impl_.subcommands_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TST::CommandNotifyForTransformingArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandNotifyForTransformingArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandNotifyForTransformingArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.range_location_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.range_length_),
  PROTOBUF_FIELD_OFFSET(::TST::CommandSetStorageLanguageArchive, _impl_.undo_transaction_),
  1,
  2,
  0,
  4,
  5,
  3,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::TST::TableCommandArchive)},
  { 14, 23, -1, sizeof(::TST::CommandChangeFreezeHeaderStateArchive)},
  { 26, 37, -1, sizeof(::TST::CommandDeleteCellsArchive)},
  { 42, 53, -1, sizeof(::TST::CommandDeleteCellContentsArchive)},
  { 58, 70, -1, sizeof(::TST::CommandSetMultipleCellsArchive)},
  { 76, 87, -1, sizeof(::TST::CommandSetMultipleCellsCustomArchive)},
  { 92, 102, -1, sizeof(::TST::CommandSetMultipleCellsMultipleChoiceListArchive)},
  { 106, 117, -1, sizeof(::TST::CommandCoerceMultipleCellsArchive)},
  { 122, 132, -1, sizeof(::TST::CommandSetControlCellsDisplayNumberFormatArchive)},
  { 136, 146, -1, sizeof(::TST::CommandSetAutomaticFormatArchive)},
  { 150, 161, -1, sizeof(::TST::CommandSetAutomaticDurationUnitsArchive)},
  { 166, 174, -1, sizeof(::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair)},
  { 176, 204, -1, sizeof(::TST::CommandInsertColumnsOrRowsArchive)},
  { 226, 240, -1, sizeof(::TST::CommandPasteArchive)},
  { 248, 270, -1, sizeof(::TST::CommandRemoveColumnsOrRowsArchive)},
  { 286, 303, -1, sizeof(::TST::CommandResizeColumnOrRowArchive)},
  { 314, 325, -1, sizeof(::TST::CommandSetCellArchive)},
  { 330, 344, -1, sizeof(::TST::CommandTextPreflightInsertCellArchive)},
  { 352, 365, -1, sizeof(::TST::CommandPostflightSetCellArchive)},
  { 372, 382, -1, sizeof(::TST::CommandSetNumberOfHeadersOrFootersArchive)},
  { 386, 400, -1, sizeof(::TST::CommandFixWPStylesInRowsOrColumnsArchive)},
  { 408, 421, -1, sizeof(::TST::CommandFixStylesInHeadersOrFootersArchive)},
  { 428, 443, -1, sizeof(::TST::CommandSetTableNameArchive)},
  { 452, 460, -1, sizeof(::TST::CommandSetTableNameEnabledArchive)},
  { 462, 474, -1, sizeof(::TST::CommandSetTableFontSizeArchive)},
  { 480, 493, -1, sizeof(::TST::CommandSetTableFontNameArchive)},
  { 500, 509, -1, sizeof(::TST::CommandSetTableNameHeightArchive)},
  { 512, 524, -1, sizeof(::TST::CommandStyleCellsArchive)},
  { 530, 540, -1, sizeof(::TST::CommandStyleTableArchive)},
  { 544, 558, -1, sizeof(::TST::CommandFillCellsArchive)},
  { 566, 577, -1, sizeof(::TST::CommandReplaceTextArchive)},
  { 582, 591, -1, sizeof(::TST::CommandReplaceAllTextArchive)},
  { 594, 603, -1, sizeof(::TST::CommandSetRepeatingHeaderEnabledArchive)},
  { 606, 614, -1, sizeof(::TST::CommandSetFiltersEnabledArchive)},
  { 616, 627, -1, sizeof(::TST::CommandAddQuickFilterRulesArchive)},
  { 632, 644, -1, sizeof(::TST::CommandDeleteFilterRulesArchive)},
  { 650, 661, -1, sizeof(::TST::CommandModifyFilterRuleArchive)},
  { 666, 678, -1, sizeof(::TST::CommandApplyStrokePresetArchive)},
  { 684, 693, -1, sizeof(::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple)},
  { 696, 713, -1, sizeof(::TST::CommandApplyTableStylePresetArchive)},
  { 724, 732, -1, sizeof(::TST::CommandSetStyleApplyClearsAllFlagArchive)},
  { 734, 745, -1, sizeof(::TST::CommandApplyThemeToTableArchive)},
  { 750, 758, -1, sizeof(::TST::CommandApplyThemeChildForTableArchive)},
  { 760, 776, -1, sizeof(::TST::CommandToggleTextPropertyArchive)},
  { 786, 796, -1, sizeof(::TST::CommandResetFillPropertyToDefault)},
  { 800, 810, -1, sizeof(::TST::CommandSetSingleNumberFormatParameterArchive)},
  { 814, 822, -1, sizeof(::TST::CommandSetBaseArchive)},
  { 824, 832, -1, sizeof(::TST::CommandSetBasePlacesArchive)},
  { 834, 842, -1, sizeof(::TST::CommandSetBaseUseMinusSignArchive)},
  { 844, 853, -1, sizeof(::TST::CommandSetControlMinimumArchive)},
  { 856, 865, -1, sizeof(::TST::CommandSetControlMaximumArchive)},
  { 868, 877, -1, sizeof(::TST::CommandSetControlIncrementArchive)},
  { 880, 888, -1, sizeof(::TST::CommandSetCurrencyCodeArchive)},
  { 890, 898, -1, sizeof(::TST::CommandSetFractionAccuracyArchive)},
  { 900, 907, -1, sizeof(::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive)},
  { 908, 915, -1, sizeof(::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive)},
  { 916, 923, -1, sizeof(::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive)},
  { 924, 931, -1, sizeof(::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive)},
  { 932, 940, -1, sizeof(::TST::CommandSetNegativeNumberStyleArchive)},
  { 942, 953, -1, sizeof(::TST::CommandSetExplicitFormatArchive)},
  { 958, 966, -1, sizeof(::TST::CommandSetNumberOfDecimalPlacesArchive)},
  { 968, 975, -1, sizeof(::TST::CommandSetDateTimeFormatArchive)},
  { 976, 984, -1, sizeof(::TST::CommandSetShowThousandsSeparatorArchive)},
  { 986, 994, -1, sizeof(::TST::CommandSetUseAccountingStyleArchive)},
  { 996, 1010, -1, sizeof(::TST::CommandMoveRowsArchive)},
  { 1018, 1031, -1, sizeof(::TST::CommandMoveColumnsArchive)},
  { 1038, 1047, -1, sizeof(::TST::CommandSortArchive)},
  { 1050, 1061, -1, sizeof(::TST::CommandRewriteFormulasForSortArchive)},
  { 1066, 1075, -1, sizeof(::TST::CommandRewriteFormulasForTectonicShiftArchive)},
  { 1078, 1088, -1, sizeof(::TST::CommandRewriteFormulasForMoveArchive)},
  { 1092, 1102, -1, sizeof(::TST::CommandRewriteFormulasForCellMergeArchive)},
  { 1106, 1113, -1, sizeof(::TST::CommandRewriteFilterFormulasForTableResizeArchive)},
  { 1114, 1123, -1, sizeof(::TST::CommandRewriteFilterFormulasForTectonicShiftArchive)},
  { 1126, 1136, -1, sizeof(::TST::CommandRewriteFilterFormulasForSortArchive)},
  { 1140, 1150, -1, sizeof(::TST::CommandRewriteConditionalStylesForTectonicShiftArchive)},
  { 1154, 1165, -1, sizeof(::TST::CommandRewriteConditionalStylesForSortArchive)},
  { 1170, 1181, -1, sizeof(::TST::CommandRewriteConditionalStylesForRangeMoveArchive)},
  { 1186, 1197, -1, sizeof(::TST::CommandRewriteConditionalStylesForCellMergeArchive)},
  { 1202, 1215, -1, sizeof(::TST::CommandMergeUnmergeArchive)},
  { 1222, 1234, -1, sizeof(::TST::CommandHideShowArchive)},
  { 1240, 1254, -1, sizeof(::TST::TableInfoGeometryCommandArchive)},
  { 1262, 1277, -1, sizeof(::TST::FormulaEditingCommandGroupArchive)},
  { 1286, 1301, -1, sizeof(::TST::FormulaEditingCommandSelectionBehaviorArchive)},
  { 1310, 1321, -1, sizeof(::TST::UndoRedoStateCommandSelectionBehaviorArchive)},
  { 1326, 1336, -1, sizeof(::TST::TableCommandSelectionBehaviorArchive)},
  { 1340, 1347, -1, sizeof(::TST::DisableTableNameSelectionBehaviorArchive)},
  { 1348, 1358, -1, sizeof(::TST::CommandApplyCellCommentArchive)},
  { 1362, 1372, -1, sizeof(::TST::CommandApplyConditionalStyleSetArchive)},
  { 1376, 1384, -1, sizeof(::TST::CommandSetFormulaTokenizationArchive)},
  { 1386, 1395, -1, sizeof(::TST::CommandSetFilterEnabledArchive)},
  { 1398, 1408, -1, sizeof(::TST::CommandSetFilterRuleEnabledArchive)},
  { 1412, 1421, -1, sizeof(::TST::CommandSetFilterSetTypeArchive)},
  { 1424, 1433, -1, sizeof(::TST::CommandSetStyleNetworkArchive)},
  { 1436, 1446, -1, sizeof(::TST::CommandMutateCellsArchive)},
  { 1450, 1459, -1, sizeof(::TST::CommandDisableFilterRulesForColumnArchive)},
  { 1462, 1473, -1, sizeof(::TST::CommandSetTextStyleArchive)},
  { 1478, 1485, -1, sizeof(::TST::CommandNotifyForTransformingArchive)},
  { 1486, 1498, -1, sizeof(::TST::CommandSetStorageLanguageArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TST::_TableCommandArchive_default_instance_._instance,
  &::TST::_CommandChangeFreezeHeaderStateArchive_default_instance_._instance,
  &::TST::_CommandDeleteCellsArchive_default_instance_._instance,
  &::TST::_CommandDeleteCellContentsArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleCellsArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleCellsCustomArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleCellsMultipleChoiceListArchive_default_instance_._instance,
  &::TST::_CommandCoerceMultipleCellsArchive_default_instance_._instance,
  &::TST::_CommandSetControlCellsDisplayNumberFormatArchive_default_instance_._instance,
  &::TST::_CommandSetAutomaticFormatArchive_default_instance_._instance,
  &::TST::_CommandSetAutomaticDurationUnitsArchive_default_instance_._instance,
  &::TST::_CommandInsertColumnsOrRowsArchive_StyleIndexPair_default_instance_._instance,
  &::TST::_CommandInsertColumnsOrRowsArchive_default_instance_._instance,
  &::TST::_CommandPasteArchive_default_instance_._instance,
  &::TST::_CommandRemoveColumnsOrRowsArchive_default_instance_._instance,
  &::TST::_CommandResizeColumnOrRowArchive_default_instance_._instance,
  &::TST::_CommandSetCellArchive_default_instance_._instance,
  &::TST::_CommandTextPreflightInsertCellArchive_default_instance_._instance,
  &::TST::_CommandPostflightSetCellArchive_default_instance_._instance,
  &::TST::_CommandSetNumberOfHeadersOrFootersArchive_default_instance_._instance,
  &::TST::_CommandFixWPStylesInRowsOrColumnsArchive_default_instance_._instance,
  &::TST::_CommandFixStylesInHeadersOrFootersArchive_default_instance_._instance,
  &::TST::_CommandSetTableNameArchive_default_instance_._instance,
  &::TST::_CommandSetTableNameEnabledArchive_default_instance_._instance,
  &::TST::_CommandSetTableFontSizeArchive_default_instance_._instance,
  &::TST::_CommandSetTableFontNameArchive_default_instance_._instance,
  &::TST::_CommandSetTableNameHeightArchive_default_instance_._instance,
  &::TST::_CommandStyleCellsArchive_default_instance_._instance,
  &::TST::_CommandStyleTableArchive_default_instance_._instance,
  &::TST::_CommandFillCellsArchive_default_instance_._instance,
  &::TST::_CommandReplaceTextArchive_default_instance_._instance,
  &::TST::_CommandReplaceAllTextArchive_default_instance_._instance,
  &::TST::_CommandSetRepeatingHeaderEnabledArchive_default_instance_._instance,
  &::TST::_CommandSetFiltersEnabledArchive_default_instance_._instance,
  &::TST::_CommandAddQuickFilterRulesArchive_default_instance_._instance,
  &::TST::_CommandDeleteFilterRulesArchive_default_instance_._instance,
  &::TST::_CommandModifyFilterRuleArchive_default_instance_._instance,
  &::TST::_CommandApplyStrokePresetArchive_default_instance_._instance,
  &::TST::_CommandApplyTableStylePresetArchive_StyleIndexTuple_default_instance_._instance,
  &::TST::_CommandApplyTableStylePresetArchive_default_instance_._instance,
  &::TST::_CommandSetStyleApplyClearsAllFlagArchive_default_instance_._instance,
  &::TST::_CommandApplyThemeToTableArchive_default_instance_._instance,
  &::TST::_CommandApplyThemeChildForTableArchive_default_instance_._instance,
  &::TST::_CommandToggleTextPropertyArchive_default_instance_._instance,
  &::TST::_CommandResetFillPropertyToDefault_default_instance_._instance,
  &::TST::_CommandSetSingleNumberFormatParameterArchive_default_instance_._instance,
  &::TST::_CommandSetBaseArchive_default_instance_._instance,
  &::TST::_CommandSetBasePlacesArchive_default_instance_._instance,
  &::TST::_CommandSetBaseUseMinusSignArchive_default_instance_._instance,
  &::TST::_CommandSetControlMinimumArchive_default_instance_._instance,
  &::TST::_CommandSetControlMaximumArchive_default_instance_._instance,
  &::TST::_CommandSetControlIncrementArchive_default_instance_._instance,
  &::TST::_CommandSetCurrencyCodeArchive_default_instance_._instance,
  &::TST::_CommandSetFractionAccuracyArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleChoiceListFormatForEditedItemArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleChoiceListFormatForDeleteItemArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleChoiceListFormatForReorderItemArchive_default_instance_._instance,
  &::TST::_CommandSetMultipleChoiceListFormatForInitialValueArchive_default_instance_._instance,
  &::TST::_CommandSetNegativeNumberStyleArchive_default_instance_._instance,
  &::TST::_CommandSetExplicitFormatArchive_default_instance_._instance,
  &::TST::_CommandSetNumberOfDecimalPlacesArchive_default_instance_._instance,
  &::TST::_CommandSetDateTimeFormatArchive_default_instance_._instance,
  &::TST::_CommandSetShowThousandsSeparatorArchive_default_instance_._instance,
  &::TST::_CommandSetUseAccountingStyleArchive_default_instance_._instance,
  &::TST::_CommandMoveRowsArchive_default_instance_._instance,
  &::TST::_CommandMoveColumnsArchive_default_instance_._instance,
  &::TST::_CommandSortArchive_default_instance_._instance,
  &::TST::_CommandRewriteFormulasForSortArchive_default_instance_._instance,
  &::TST::_CommandRewriteFormulasForTectonicShiftArchive_default_instance_._instance,
  &::TST::_CommandRewriteFormulasForMoveArchive_default_instance_._instance,
  &::TST::_CommandRewriteFormulasForCellMergeArchive_default_instance_._instance,
  &::TST::_CommandRewriteFilterFormulasForTableResizeArchive_default_instance_._instance,
  &::TST::_CommandRewriteFilterFormulasForTectonicShiftArchive_default_instance_._instance,
  &::TST::_CommandRewriteFilterFormulasForSortArchive_default_instance_._instance,
  &::TST::_CommandRewriteConditionalStylesForTectonicShiftArchive_default_instance_._instance,
  &::TST::_CommandRewriteConditionalStylesForSortArchive_default_instance_._instance,
  &::TST::_CommandRewriteConditionalStylesForRangeMoveArchive_default_instance_._instance,
  &::TST::_CommandRewriteConditionalStylesForCellMergeArchive_default_instance_._instance,
  &::TST::_CommandMergeUnmergeArchive_default_instance_._instance,
  &::TST::_CommandHideShowArchive_default_instance_._instance,
  &::TST::_TableInfoGeometryCommandArchive_default_instance_._instance,
  &::TST::_FormulaEditingCommandGroupArchive_default_instance_._instance,
  &::TST::_FormulaEditingCommandSelectionBehaviorArchive_default_instance_._instance,
  &::TST::_UndoRedoStateCommandSelectionBehaviorArchive_default_instance_._instance,
  &::TST::_TableCommandSelectionBehaviorArchive_default_instance_._instance,
  &::TST::_DisableTableNameSelectionBehaviorArchive_default_instance_._instance,
  &::TST::_CommandApplyCellCommentArchive_default_instance_._instance,
  &::TST::_CommandApplyConditionalStyleSetArchive_default_instance_._instance,
  &::TST::_CommandSetFormulaTokenizationArchive_default_instance_._instance,
  &::TST::_CommandSetFilterEnabledArchive_default_instance_._instance,
  &::TST::_CommandSetFilterRuleEnabledArchive_default_instance_._instance,
  &::TST::_CommandSetFilterSetTypeArchive_default_instance_._instance,
  &::TST::_CommandSetStyleNetworkArchive_default_instance_._instance,
  &::TST::_CommandMutateCellsArchive_default_instance_._instance,
  &::TST::_CommandDisableFilterRulesForColumnArchive_default_instance_._instance,
  &::TST::_CommandSetTextStyleArchive_default_instance_._instance,
  &::TST::_CommandNotifyForTransformingArchive_default_instance_._instance,
  &::TST::_CommandSetStorageLanguageArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSTCommandArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030TSTCommandArchives.proto\022\003TST\032\021TSPMess"
  "ages.proto\032\021TSDArchives.proto\032\021TSKArchiv"
  "es.proto\032\021TSSArchives.proto\032\022TSCEArchive"
  "s.proto\032\022TSWPArchives.proto\032\021TSTArchives"
  ".proto\"\220\001\n\023TableCommandArchive\022!\n\ttableI"
  "nfo\030\001 \002(\0132\016.TSP.Reference\022\023\n\013commandname"
  "\030\002 \001(\t\022\"\n\005super\030\003 \002(\0132\023.TSK.CommandArchi"
  "ve\022\035\n\025editing_mode_at_start\030\004 \001(\r\"\233\001\n%Co"
  "mmandChangeFreezeHeaderStateArchive\022/\n\td"
  "irection\030\001 \002(\0162\034.TST.CommandDirectionArc"
  "hive\022\030\n\020new_freeze_state\030\002 \002(\010\022\'\n\005super\030"
  "\003 \002(\0132\030.TST.TableCommandArchive\"\331\001\n\031Comm"
  "andDeleteCellsArchive\022(\n\tselection\030\001 \002(\013"
  "2\025.TST.SelectionArchive\022%\n\010undo_map\030\002 \002("
  "\0132\023.TST.CellMapArchive\022\'\n\005super\030\003 \002(\0132\030."
  "TST.TableCommandArchive\022%\n\010redo_map\030\004 \002("
  "\0132\023.TST.CellMapArchive\022\033\n\023invalidate_com"
  "ments\030\005 \002(\010\"\340\001\n CommandDeleteCellContent"
  "sArchive\022(\n\tselection\030\001 \002(\0132\025.TST.Select"
  "ionArchive\022%\n\010undo_map\030\002 \002(\0132\023.TST.CellM"
  "apArchive\022\'\n\005super\030\003 \002(\0132\030.TST.TableComm"
  "andArchive\022%\n\010redo_map\030\004 \002(\0132\023.TST.CellM"
  "apArchive\022\033\n\023invalidate_comments\030\005 \002(\010\"\201"
  "\002\n\036CommandSetMultipleCellsArchive\022(\n\tsel"
  "ection\030\001 \002(\0132\025.TST.SelectionArchive\022%\n\010u"
  "ndo_map\030\002 \002(\0132\023.TST.CellMapArchive\022%\n\010re"
  "do_map\030\003 \002(\0132\023.TST.CellMapArchive\022\036\n\013sou"
  "rce_cell\030\004 \001(\0132\t.TST.Cell\022\036\n\026only_if_for"
  "mat_differs\030\006 \001(\010\022\'\n\005super\030\007 \002(\0132\030.TST.T"
  "ableCommandArchive\"\366\001\n$CommandSetMultipl"
  "eCellsCustomArchive\022(\n\tselection\030\001 \002(\0132\025"
  ".TST.SelectionArchive\022%\n\010undo_map\030\002 \002(\0132"
  "\023.TST.CellMapArchive\022%\n\010redo_map\030\003 \002(\0132\023"
  ".TST.CellMapArchive\022-\n\013cell_format\030\004 \002(\013"
  "2\030.TSK.FormatStructArchive\022\'\n\005super\030\007 \002("
  "\0132\030.TST.TableCommandArchive\"\323\001\n0CommandS"
  "etMultipleCellsMultipleChoiceListArchive"
  "\022(\n\tselection\030\001 \002(\0132\025.TST.SelectionArchi"
  "ve\022%\n\010undo_map\030\002 \002(\0132\023.TST.CellMapArchiv"
  "e\022%\n\010redo_map\030\003 \002(\0132\023.TST.CellMapArchive"
  "\022\'\n\005super\030\005 \002(\0132\030.TST.TableCommandArchiv"
  "e\"\334\001\n!CommandCoerceMultipleCellsArchive\022"
  "(\n\tselection\030\001 \002(\0132\025.TST.SelectionArchiv"
  "e\022%\n\010undo_map\030\002 \002(\0132\023.TST.CellMapArchive"
  "\022%\n\010redo_map\030\003 \002(\0132\023.TST.CellMapArchive\022"
  "\026\n\016desired_format\030\004 \002(\005\022\'\n\005super\030\006 \002(\0132\030"
  ".TST.TableCommandArchive\"\323\001\n0CommandSetC"
  "ontrolCellsDisplayNumberFormatArchive\022(\n"
  "\tselection\030\001 \002(\0132\025.TST.SelectionArchive\022"
  "%\n\010undo_map\030\002 \002(\0132\023.TST.CellMapArchive\022%"
  "\n\010redo_map\030\003 \002(\0132\023.TST.CellMapArchive\022\'\n"
  "\005super\030\006 \002(\0132\030.TST.TableCommandArchive\"\303"
  "\001\n CommandSetAutomaticFormatArchive\022(\n\ts"
  "election\030\001 \002(\0132\025.TST.SelectionArchive\022%\n"
  "\010undo_map\030\002 \002(\0132\023.TST.CellMapArchive\022%\n\010"
  "redo_map\030\003 \002(\0132\023.TST.CellMapArchive\022\'\n\005s"
  "uper\030\006 \002(\0132\030.TST.TableCommandArchive\"\343\001\n"
  "\'CommandSetAutomaticDurationUnitsArchive"
  "\022(\n\tselection\030\001 \002(\0132\025.TST.SelectionArchi"
  "ve\022%\n\010undo_map\030\002 \002(\0132\023.TST.CellMapArchiv"
  "e\022%\n\010redo_map\030\003 \002(\0132\023.TST.CellMapArchive"
  "\022\027\n\017automatic_units\030\004 \001(\010\022\'\n\005super\030\006 \002(\013"
  "2\030.TST.TableCommandArchive\"\264\006\n!CommandIn"
  "sertColumnsOrRowsArchive\022/\n\tdirection\030\001 "
  "\002(\0162\034.TST.CommandDirectionArchive\022\r\n\005ind"
  "ex\030\002 \002(\r\022\r\n\005count\030\003 \002(\r\022\014\n\004size\030\004 \002(\002\022\016\n"
  "\006before\030\005 \002(\010\022\024\n\014header_count\030\013 \002(\r\022\025\n\rh"
  "eaders_added\030\014 \002(\r\022\024\n\014footer_count\030\r \002(\r"
  "\022\025\n\rfooters_added\030\016 \002(\r\022(\n\020row_column_st"
  "yle\030\010 \001(\0132\016.TSP.Reference\022,\n\017cell_style_"
  "redo\030\t \001(\0132\023.TST.CellMapArchive\022\'\n\005super"
  "\030\n \002(\0132\030.TST.TableCommandArchive\022/\n\027form"
  "ula_rewrite_command\030\017 \001(\0132\016.TSP.Referenc"
  "e\022\024\n\014width_factor\030\020 \002(\002\022\025\n\rheight_factor"
  "\030\021 \002(\002\022!\n\031allow_horizontal_autosize\030\022 \001("
  "\010\022\026\n\016inherit_styles\030\023 \001(\010\022\027\n\017inherit_for"
  "mats\030\024 \001(\010\022\030\n\020inherit_formulas\030\030 \001(\010\022U\n\026"
  "cell_style_index_pairs\030\025 \003(\01325.TST.Comma"
  "ndInsertColumnsOrRowsArchive.StyleIndexP"
  "air\022U\n\026text_style_index_pairs\030\026 \003(\01325.TS"
  "T.CommandInsertColumnsOrRowsArchive.Styl"
  "eIndexPair\022\r\n\005sizes\030\027 \003(\001\032>\n\016StyleIndexP"
  "air\022\035\n\005style\030\001 \002(\0132\016.TSP.Reference\022\r\n\005in"
  "dex\030\002 \002(\r\"\352\002\n\023CommandPasteArchive\022-\n\016use"
  "r_selection\030\001 \002(\0132\025.TST.SelectionArchive"
  "\022.\n\017final_selection\030\002 \002(\0132\025.TST.Selectio"
  "nArchive\022*\n\rundo_cell_map\030\003 \002(\0132\023.TST.Ce"
  "llMapArchive\022*\n\rredo_cell_map\030\004 \002(\0132\023.TS"
  "T.CellMapArchive\022$\n\014command_undo\030\006 \001(\0132\016"
  ".TSP.Reference\022\033\n\023invalidate_comments\030\007 "
  "\002(\010\022\'\n\005super\030\013 \002(\0132\030.TST.TableCommandArc"
  "hive\0220\n\030formula_rewrite_commands\030\017 \003(\0132\016"
  ".TSP.Reference\"\357\004\n!CommandRemoveColumnsO"
  "rRowsArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableC"
  "ommandArchive\022/\n\tdirection\030\002 \002(\0162\034.TST.C"
  "ommandDirectionArchive\022(\n\021indices_to_rem"
  "ove\030\003 \002(\0132\r.TSP.IndexSet\022$\n\007cellMap\030\004 \001("
  "\0132\023.TST.CellMapArchive\022%\n\007oldgeom\030\005 \002(\0132"
  "\024.TSD.GeometryArchive\022%\n\007newgeom\030\006 \002(\0132\024"
  ".TSD.GeometryArchive\022\020\n\010subsizes\030\007 \003(\002\022/"
  "\n\027formula_rewrite_command\030\010 \001(\0132\016.TSP.Re"
  "ference\022\024\n\014width_factor\030\t \002(\002\022\025\n\rheight_"
  "factor\030\n \002(\002\022!\n\031allow_horizontal_autosiz"
  "e\030\013 \001(\010\022&\n\016undo_merge_map\030\014 \001(\0132\016.TSP.Re"
  "ference\022&\n\016redo_merge_map\030\r \001(\0132\016.TSP.Re"
  "ference\022\026\n\016hiding_actions\030\016 \003(\r\022\'\n\017orig_"
  "filter_set\030\017 \001(\0132\016.TSP.Reference\022.\n\026undo"
  "_command_collector\030\020 \003(\0132\016.TSP.Reference"
  "\"\311\002\n\037CommandResizeColumnOrRowArchive\022/\n\t"
  "direction\030\001 \002(\0162\034.TST.CommandDirectionAr"
  "chive\022\r\n\005index\030\002 \002(\r\022\r\n\005count\030\003 \002(\r\022\017\n\007n"
  "ewsize\030\004 \002(\002\022%\n\007oldgeom\030\005 \001(\0132\024.TSD.Geom"
  "etryArchive\022%\n\007newgeom\030\006 \001(\0132\024.TSD.Geome"
  "tryArchive\022\020\n\010subsizes\030\007 \003(\002\022\023\n\013old_defa"
  "ult\030\010 \001(\002\022\024\n\014uniformsizes\030\t \001(\010\022\022\n\nresiz"
  "emode\030\n \001(\r\022\'\n\005super\030\013 \002(\0132\030.TST.TableCo"
  "mmandArchive\"\267\001\n\025CommandSetCellArchive\022\033"
  "\n\006cellID\030\001 \002(\0132\013.TST.CellID\022\032\n\007newcell\030\002"
  " \001(\0132\t.TST.Cell\022\032\n\007oldcell\030\003 \001(\0132\t.TST.C"
  "ell\022\'\n\005super\030\005 \002(\0132\030.TST.TableCommandArc"
  "hive\022 \n\030post_undo_redo_selection\030\006 \001(\010\"\332"
  "\002\n%CommandTextPreflightInsertCellArchive"
  "\022#\n\016editing_cellID\030\001 \002(\0132\013.TST.CellID\022\'\n"
  "\005super\030\003 \002(\0132\030.TST.TableCommandArchive\022-"
  "\n\025coalesced_textcommand\030\006 \001(\0132\016.TSP.Refe"
  "rence\022)\n\021postflightcommand\030\010 \001(\0132\016.TSP.R"
  "eference\022\037\n\027grouped_with_postflight\030\t \001("
  "\010\022\037\n\014editing_cell\030\n \002(\0132\t.TST.Cell\022\'\n\017ed"
  "iting_storage\030\013 \002(\0132\016.TSP.Reference\022\036\n\026l"
  "ast_column_hit_by_tap\030\014 \001(\r\"\230\002\n\037CommandP"
  "ostflightSetCellArchive\022\033\n\006cellID\030\001 \002(\0132"
  "\013.TST.CellID\022\'\n\005super\030\003 \002(\0132\030.TST.TableC"
  "ommandArchive\022(\n\020childcommandundo\030\004 \001(\0132"
  "\016.TSP.Reference\022\037\n\014editing_cell\030\006 \002(\0132\t."
  "TST.Cell\022\033\n\010new_cell\030\007 \002(\0132\t.TST.Cell\022\'\n"
  "\017editing_storage\030\010 \002(\0132\016.TSP.Reference\022\036"
  "\n\026last_column_hit_by_tap\030\t \001(\r\"\240\001\n)Comma"
  "ndSetNumberOfHeadersOrFootersArchive\022)\n\006"
  "region\030\001 \002(\0162\031.TST.CommandRegionArchive\022"
  "\r\n\005count\030\002 \002(\r\022\020\n\010oldcount\030\003 \002(\r\022\'\n\005supe"
  "r\030\006 \002(\0132\030.TST.TableCommandArchive\"\253\002\n(Co"
  "mmandFixWPStylesInRowsOrColumnsArchive\022/"
  "\n\tdirection\030\001 \002(\0162\034.TST.CommandDirection"
  "Archive\022\r\n\005index\030\002 \002(\r\022*\n\rundo_cell_map\030"
  "\003 \002(\0132\023.TST.CellMapArchive\022*\n\rredo_cell_"
  "map\030\004 \002(\0132\023.TST.CellMapArchive\022\'\n\005super\030"
  "\006 \002(\0132\030.TST.TableCommandArchive\022\027\n\017refer"
  "ence_index\030\007 \002(\r\022\026\n\016inherit_styles\030\010 \002(\010"
  "\022\r\n\005count\030\t \001(\r\"\241\002\n)CommandFixStylesInHe"
  "adersOrFootersArchive\022)\n\006region\030\001 \002(\0162\031."
  "TST.CommandRegionArchive\022\022\n\nold_number\030\002"
  " \002(\r\022\022\n\nnew_number\030\003 \002(\r\022*\n\rredo_cell_ma"
  "p\030\004 \002(\0132\023.TST.CellMapArchive\022*\n\rundo_cel"
  "l_map\030\005 \002(\0132\023.TST.CellMapArchive\022\'\n\005supe"
  "r\030\006 \002(\0132\030.TST.TableCommandArchive\022 \n\010tex"
  "tundo\030\007 \001(\0132\016.TSP.Reference\"\325\002\n\032CommandS"
  "etTableNameArchive\022\024\n\014newtablename\030\001 \002(\t"
  "\022\024\n\014oldtablename\030\002 \002(\t\022 \n\010newstyle\030\003 \001(\013"
  "2\016.TSP.Reference\022 \n\010oldstyle\030\004 \001(\0132\016.TSP"
  ".Reference\022\'\n\005super\030\005 \002(\0132\030.TST.TableCom"
  "mandArchive\022\'\n\017old_shape_style\030\006 \001(\0132\016.T"
  "SP.Reference\022\'\n\017new_shape_style\030\007 \001(\0132\016."
  "TSP.Reference\022%\n\035old_table_name_border_e"
  "nabled\030\010 \001(\010\022%\n\035new_table_name_border_en"
  "abled\030\t \001(\010\"h\n!CommandSetTableNameEnable"
  "dArchive\022\032\n\022table_name_enabled\030\001 \002(\010\022\'\n\005"
  "super\030\003 \002(\0132\030.TST.TableCommandArchive\"\370\001"
  "\n\036CommandSetTableFontSizeArchive\022\'\n\005supe"
  "r\030\001 \002(\0132\030.TST.TableCommandArchive\022\024\n\014sca"
  "le_factor\030\t \002(\002\022*\n\rundo_cell_map\030\005 \001(\0132\023"
  ".TST.CellMapArchive\022*\n\rredo_cell_map\030\006 \001"
  "(\0132\023.TST.CellMapArchive\022\034\n\024resize_defaul"
  "t_cells\030\007 \001(\010\022!\n\ttext_undo\030\010 \001(\0132\016.TSP.R"
  "eference\"\205\002\n\036CommandSetTableFontNameArch"
  "ive\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArc"
  "hive\022\021\n\tfont_name\030\002 \002(\t\022\025\n\rold_font_name"
  "\030\003 \002(\t\022\025\n\rpreserve_face\030\005 \001(\010\022*\n\rundo_ce"
  "ll_map\030\006 \001(\0132\023.TST.CellMapArchive\022*\n\rred"
  "o_cell_map\030\007 \001(\0132\023.TST.CellMapArchive\022!\n"
  "\ttext_undo\030\010 \001(\0132\016.TSP.Reference\"\211\001\n Com"
  "mandSetTableNameHeightArchive\022\'\n\005super\030\001"
  " \002(\0132\030.TST.TableCommandArchive\022\035\n\025old_ta"
  "ble_name_height\030\002 \002(\001\022\035\n\025new_table_name_"
  "height\030\003 \002(\001\"\235\002\n\030CommandStyleCellsArchiv"
  "e\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArchi"
  "ve\0223\n\021format_properties\030\002 \001(\0132\030.TSP.Refe"
  "renceDictionary\022(\n\tselection\030\003 \002(\0132\025.TST"
  ".SelectionArchive\022*\n\rundo_cell_map\030\004 \002(\013"
  "2\023.TST.CellMapArchive\022*\n\rredo_cell_map\030\005"
  " \002(\0132\023.TST.CellMapArchive\022!\n\ttext_undo\030\006"
  " \001(\0132\016.TSP.Reference\"\276\001\n\030CommandStyleTab"
  "leArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableComm"
  "andArchive\0223\n\021format_properties\030\002 \001(\0132\030."
  "TSP.ReferenceDictionary\022!\n\told_style\030\003 \001"
  "(\0132\016.TSP.Reference\022!\n\tnew_style\030\004 \001(\0132\016."
  "TSP.Reference\"\376\002\n\027CommandFillCellsArchiv"
  "e\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArchi"
  "ve\022.\n\017sourceselection\030\002 \002(\0132\025.TST.Select"
  "ionArchive\022\'\n\017sourcecellrange\030\003 \002(\0132\016.TS"
  "T.CellRange\022\'\n\017targetcellrange\030\004 \002(\0132\016.T"
  "ST.CellRange\022*\n\rundo_cell_map\030\005 \002(\0132\023.TS"
  "T.CellMapArchive\0220\n\rfillDirection\030\006 \002(\0162"
  "\031.TST.FillDirectionArchive\022.\n\017targetsele"
  "ction\030\007 \002(\0132\025.TST.SelectionArchive\022*\n\rre"
  "do_cell_map\030\010 \002(\0132\023.TST.CellMapArchive\"\305"
  "\001\n\031CommandReplaceTextArchive\022\033\n\006cellID\030\001"
  " \002(\0132\013.TST.CellID\022\032\n\007newcell\030\002 \002(\0132\t.TST"
  ".Cell\022\032\n\007oldcell\030\003 \002(\0132\t.TST.Cell\022\'\n\005sup"
  "er\030\004 \002(\0132\030.TST.TableCommandArchive\022*\n\022ch"
  "ild_command_undo\030\005 \001(\0132\016.TSP.Reference\"\231"
  "\001\n\034CommandReplaceAllTextArchive\022!\n\ttable"
  "Info\030\001 \002(\0132\016.TSP.Reference\022*\n\rundo_cell_"
  "map\030\002 \002(\0132\023.TST.CellMapArchive\022*\n\rredo_c"
  "ell_map\030\003 \002(\0132\023.TST.CellMapArchive\"\245\001\n\'C"
  "ommandSetRepeatingHeaderEnabledArchive\022 "
  "\n\030repeating_header_enabled\030\001 \002(\010\022/\n\tdire"
  "ction\030\002 \002(\0162\034.TST.CommandDirectionArchiv"
  "e\022\'\n\005super\030\003 \002(\0132\030.TST.TableCommandArchi"
  "ve\"b\n\037CommandSetFiltersEnabledArchive\022\026\n"
  "\016enable_filters\030\001 \002(\010\022\'\n\005super\030\002 \002(\0132\030.T"
  "ST.TableCommandArchive\"\273\001\n!CommandAddQui"
  "ckFilterRulesArchive\022\'\n\005super\030\001 \002(\0132\030.TS"
  "T.TableCommandArchive\022%\n\005rules\030\002 \003(\0132\026.T"
  "ST.FilterRuleArchive\022\024\n\014filter_index\030\003 \002"
  "(\r\022\024\n\014rule_indices\030\004 \003(\r\022\032\n\022filter_set_e"
  "nabled\030\005 \002(\010\"\326\001\n\037CommandDeleteFilterRule"
  "sArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableComma"
  "ndArchive\022*\n\nundo_rules\030\002 \003(\0132\026.TST.Filt"
  "erRuleArchive\022\024\n\014rule_indices\030\003 \003(\r\022\026\n\016f"
  "ilter_removed\030\004 \002(\010\022\024\n\014filter_index\030\005 \002("
  "\r\022\032\n\022filter_set_enabled\030\006 \002(\010\"\311\001\n\036Comman"
  "dModifyFilterRuleArchive\022\'\n\005super\030\001 \002(\0132"
  "\030.TST.TableCommandArchive\022)\n\tundo_rule\030\002"
  " \002(\0132\026.TST.FilterRuleArchive\022)\n\tredo_rul"
  "e\030\003 \002(\0132\026.TST.FilterRuleArchive\022\022\n\nrule_"
  "index\030\004 \002(\r\022\024\n\014filter_index\030\005 \002(\r\"\225\002\n\037Co"
  "mmandApplyStrokePresetArchive\022\'\n\005super\030\001"
  " \002(\0132\030.TST.TableCommandArchive\022*\n\rundo_c"
  "ell_map\030\002 \002(\0132\023.TST.CellMapArchive\022*\n\rre"
  "do_cell_map\030\004 \002(\0132\023.TST.CellMapArchive\022("
  "\n\tselection\030\003 \002(\0132\025.TST.SelectionArchive"
  "\0221\n\022expanded_selection\030\006 \001(\0132\025.TST.Selec"
  "tionArchive\022\024\n\014preset_index\030\005 \002(\005\"\322\005\n#Co"
  "mmandApplyTableStylePresetArchive\022\'\n\005sup"
  "er\030\001 \002(\0132\030.TST.TableCommandArchive\022*\n\run"
  "do_cell_map\030\002 \002(\0132\023.TST.CellMapArchive\022*"
  "\n\rredo_cell_map\030\004 \002(\0132\023.TST.CellMapArchi"
  "ve\022\024\n\014preset_index\030\005 \002(\005\0227\n\020old_table_st"
  "yles\030\007 \002(\0132\035.TST.TableStyleNetworkArchiv"
  "e\0227\n\020new_table_styles\030\010 \002(\0132\035.TST.TableS"
  "tyleNetworkArchive\022\030\n\020apply_clears_all\030\n"
  " \001(\010\022)\n\021font_size_command\030\013 \001(\0132\016.TSP.Re"
  "ference\022\?\n\'set_style_apply_clears_all_fl"
  "ag_command\030\014 \001(\0132\016.TSP.Reference\022X\n\026row_"
  "style_index_tuples\030\r \003(\01328.TST.CommandAp"
  "plyTableStylePresetArchive.StyleIndexTup"
  "le\022X\n\026col_style_index_tuples\030\016 \003(\01328.TST"
  ".CommandApplyTableStylePresetArchive.Sty"
  "leIndexTuple\032h\n\017StyleIndexTuple\022\r\n\005index"
  "\030\001 \002(\r\022\"\n\ncell_style\030\005 \001(\0132\016.TSP.Referen"
  "ce\022\"\n\ntext_style\030\006 \001(\0132\016.TSP.Reference\"m"
  "\n(CommandSetStyleApplyClearsAllFlagArchi"
  "ve\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArch"
  "ive\022\030\n\020apply_clears_all\030\002 \002(\010\"\224\002\n\037Comman"
  "dApplyThemeToTableArchive\022\'\n\005super\030\001 \002(\013"
  "2\030.TST.TableCommandArchive\022*\n\rundo_cell_"
  "map\030\002 \002(\0132\023.TST.CellMapArchive\022*\n\rredo_c"
  "ell_map\030\004 \002(\0132\023.TST.CellMapArchive\0227\n\020ol"
  "d_table_styles\030\007 \002(\0132\035.TST.TableStyleNet"
  "workArchive\0227\n\020new_table_styles\030\010 \002(\0132\035."
  "TST.TableStyleNetworkArchive\"\201\001\n%Command"
  "ApplyThemeChildForTableArchive\0221\n\005super\030"
  "\001 \002(\0132\".TSS.ApplyThemeChildCommandArchiv"
  "e\022%\n\rapply_command\030\002 \002(\0132\016.TSP.Reference"
  "\"\224\003\n CommandToggleTextPropertyArchive\022\'\n"
  "\005super\030\001 \002(\0132\030.TST.TableCommandArchive\022("
  "\n\tselection\030\002 \002(\0132\025.TST.SelectionArchive"
  "\022\020\n\010property\030\003 \002(\r\022*\n\rundo_cell_map\030\004 \002("
  "\0132\023.TST.CellMapArchive\022*\n\rredo_cell_map\030"
  "\005 \002(\0132\023.TST.CellMapArchive\022$\n\021default_bo"
  "dy_cell\030\006 \002(\0132\t.TST.Cell\022\"\n\017default_hr_c"
  "ell\030\007 \002(\0132\t.TST.Cell\022\"\n\017default_hc_cell\030"
  "\010 \002(\0132\t.TST.Cell\022\"\n\017default_fr_cell\030\t \002("
  "\0132\t.TST.Cell\022!\n\ttext_undo\030\n \001(\0132\016.TSP.Re"
  "ference\"\316\001\n!CommandResetFillPropertyToDe"
  "fault\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandA"
  "rchive\022(\n\tselection\030\002 \002(\0132\025.TST.Selectio"
  "nArchive\022*\n\rundo_cell_map\030\004 \002(\0132\023.TST.Ce"
  "llMapArchive\022*\n\rredo_cell_map\030\005 \002(\0132\023.TS"
  "T.CellMapArchive\"\331\001\n,CommandSetSingleNum"
  "berFormatParameterArchive\022\'\n\005super\030\001 \002(\013"
  "2\030.TST.TableCommandArchive\022(\n\tselection\030"
  "\002 \002(\0132\025.TST.SelectionArchive\022*\n\rundo_cel"
  "l_map\030\003 \002(\0132\023.TST.CellMapArchive\022*\n\rredo"
  "_cell_map\030\004 \002(\0132\023.TST.CellMapArchive\"g\n\025"
  "CommandSetBaseArchive\022@\n\005super\030\001 \002(\01321.T"
  "ST.CommandSetSingleNumberFormatParameter"
  "Archive\022\014\n\004base\030\002 \002(\r\"t\n\033CommandSetBaseP"
  "lacesArchive\022@\n\005super\030\001 \002(\01321.TST.Comman"
  "dSetSingleNumberFormatParameterArchive\022\023"
  "\n\013base_places\030\002 \002(\r\"\202\001\n!CommandSetBaseUs"
  "eMinusSignArchive\022@\n\005super\030\001 \002(\01321.TST.C"
  "ommandSetSingleNumberFormatParameterArch"
  "ive\022\033\n\023base_use_minus_sign\030\002 \002(\010\"\211\001\n\037Com"
  "mandSetControlMinimumArchive\022@\n\005super\030\001 "
  "\002(\01321.TST.CommandSetSingleNumberFormatPa"
  "rameterArchive\022\017\n\007minimum\030\002 \002(\001\022\023\n\013forma"
  "t_type\030\003 \002(\r\"\211\001\n\037CommandSetControlMaximu"
  "mArchive\022@\n\005super\030\001 \002(\01321.TST.CommandSet"
  "SingleNumberFormatParameterArchive\022\017\n\007ma"
  "ximum\030\002 \002(\001\022\023\n\013format_type\030\003 \002(\r\"\215\001\n!Com"
  "mandSetControlIncrementArchive\022@\n\005super\030"
  "\001 \002(\01321.TST.CommandSetSingleNumberFormat"
  "ParameterArchive\022\021\n\tincrement\030\002 \002(\001\022\023\n\013f"
  "ormat_type\030\003 \002(\r\"x\n\035CommandSetCurrencyCo"
  "deArchive\022@\n\005super\030\001 \002(\01321.TST.CommandSe"
  "tSingleNumberFormatParameterArchive\022\025\n\rc"
  "urrency_code\030\002 \002(\t\"\200\001\n!CommandSetFractio"
  "nAccuracyArchive\022@\n\005super\030\001 \002(\01321.TST.Co"
  "mmandSetSingleNumberFormatParameterArchi"
  "ve\022\031\n\021fraction_accuracy\030\002 \002(\r\"z\n6Command"
  "SetMultipleChoiceListFormatForEditedItem"
  "Archive\022@\n\005super\030\001 \002(\01321.TST.CommandSetS"
  "ingleNumberFormatParameterArchive\"z\n6Com"
  "mandSetMultipleChoiceListFormatForDelete"
  "ItemArchive\022@\n\005super\030\001 \002(\01321.TST.Command"
  "SetSingleNumberFormatParameterArchive\"{\n"
  "7CommandSetMultipleChoiceListFormatForRe"
  "orderItemArchive\022@\n\005super\030\001 \002(\01321.TST.Co"
  "mmandSetSingleNumberFormatParameterArchi"
  "ve\"|\n8CommandSetMultipleChoiceListFormat"
  "ForInitialValueArchive\022@\n\005super\030\001 \002(\01321."
  "TST.CommandSetSingleNumberFormatParamete"
  "rArchive\"\207\001\n$CommandSetNegativeNumberSty"
  "leArchive\022@\n\005super\030\001 \002(\01321.TST.CommandSe"
  "tSingleNumberFormatParameterArchive\022\035\n\025n"
  "egative_number_style\030\002 \002(\r\"\373\001\n\037CommandSe"
  "tExplicitFormatArchive\022\'\n\005super\030\001 \002(\0132\030."
  "TST.TableCommandArchive\022(\n\tselection\030\002 \002"
  "(\0132\025.TST.SelectionArchive\022-\n\013cell_format"
  "\030\003 \002(\0132\030.TSK.FormatStructArchive\022*\n\rundo"
  "_cell_map\030\004 \002(\0132\023.TST.CellMapArchive\022*\n\r"
  "redo_cell_map\030\005 \002(\0132\023.TST.CellMapArchive"
  "\"\202\001\n&CommandSetNumberOfDecimalPlacesArch"
  "ive\022@\n\005super\030\001 \002(\01321.TST.CommandSetSingl"
  "eNumberFormatParameterArchive\022\026\n\016decimal"
  "_places\030\002 \002(\r\"c\n\037CommandSetDateTimeForma"
  "tArchive\022@\n\005super\030\001 \002(\01321.TST.CommandSet"
  "SingleNumberFormatParameterArchive\"\215\001\n\'C"
  "ommandSetShowThousandsSeparatorArchive\022@"
  "\n\005super\030\001 \002(\01321.TST.CommandSetSingleNumb"
  "erFormatParameterArchive\022 \n\030show_thousan"
  "ds_separator\030\002 \002(\010\"\205\001\n#CommandSetUseAcco"
  "untingStyleArchive\022@\n\005super\030\001 \002(\01321.TST."
  "CommandSetSingleNumberFormatParameterArc"
  "hive\022\034\n\024use_accounting_style\030\002 \002(\010\"\303\002\n\026C"
  "ommandMoveRowsArchive\022\'\n\005super\030\001 \002(\0132\030.T"
  "ST.TableCommandArchive\022(\n\tselection\030\002 \001("
  "\0132\025.TST.SelectionArchive\022\027\n\017start_row_in"
  "dex\030\003 \002(\r\022\026\n\016dest_row_index\030\004 \002(\r\022\026\n\016num"
  "ber_of_rows\030\005 \002(\r\022/\n\027formula_rewrite_com"
  "mand\030\007 \001(\0132\016.TSP.Reference\022$\n\014show_comma"
  "nd\030\010 \001(\0132\016.TSP.Reference\0226\n\036unmerge_inva"
  "lid_ranges_command\030\t \001(\0132\016.TSP.Reference"
  "\"\227\002\n\031CommandMoveColumnsArchive\022\'\n\005super\030"
  "\001 \002(\0132\030.TST.TableCommandArchive\022(\n\tselec"
  "tion\030\002 \001(\0132\025.TST.SelectionArchive\022\032\n\022sta"
  "rt_column_index\030\003 \002(\r\022\031\n\021dest_column_ind"
  "ex\030\004 \002(\r\022\031\n\021number_of_columns\030\005 \002(\r\022/\n\027f"
  "ormula_rewrite_command\030\007 \001(\0132\016.TSP.Refer"
  "ence\022$\n\014show_command\030\010 \001(\0132\016.TSP.Referen"
  "ce\"\233\001\n\022CommandSortArchive\022\'\n\005super\030\001 \002(\013"
  "2\030.TST.TableCommandArchive\022+\n\007mapping\030\005 "
  "\002(\0132\032.TSK.ShuffleMappingArchive\022/\n\027formu"
  "la_rewrite_command\030\007 \001(\0132\016.TSP.Reference"
  "\"\372\001\n$CommandRewriteFormulasForSortArchiv"
  "e\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArchi"
  "ve\0221\n\013formula_map\030\002 \002(\0132\034.TSCE.OwnerForm"
  "ulaMapArchive\0220\n\014sort_mapping\030\003 \002(\0132\032.TS"
  "K.ShuffleMappingArchive\022,\n\017sorted_table_"
  "id\030\004 \002(\0132\023.TSCE.CFUUIDArchive\022\026\n\016explode"
  "_ranges\030\005 \002(\010\"\277\001\n-CommandRewriteFormulas"
  "ForTectonicShiftArchive\022\'\n\005super\030\001 \002(\0132\030"
  ".TST.TableCommandArchive\0221\n\013formula_map\030"
  "\002 \002(\0132\034.TSCE.OwnerFormulaMapArchive\0222\n\016t"
  "ectonic_shift\030\003 \002(\0132\032.TSCE.TectonicShift"
  "Archive\"\352\001\n$CommandRewriteFormulasForMov"
  "eArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableComma"
  "ndArchive\0221\n\013formula_map\030\002 \002(\0132\034.TSCE.Ow"
  "nerFormulaMapArchive\0223\n\016from_reference\030\006"
  " \002(\0132\033.TSCE.RangeReferenceArchive\0221\n\014to_"
  "reference\030\007 \002(\0132\033.TSCE.RangeReferenceArc"
  "hive\"\342\001\n)CommandRewriteFormulasForCellMe"
  "rgeArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableCom"
  "mandArchive\0221\n\013formula_map\030\002 \002(\0132\034.TSCE."
  "OwnerFormulaMapArchive\0222\n\014merged_range\030\003"
  " \002(\0132\034.TSCE.RangeCoordinateArchive\022%\n\010ta"
  "ble_id\030\004 \002(\0132\023.TSCE.CFUUIDArchive\"\\\n1Com"
  "mandRewriteFilterFormulasForTableResizeA"
  "rchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableCommand"
  "Archive\"\266\001\n3CommandRewriteFilterFormulas"
  "ForTectonicShiftArchive\022\'\n\005super\030\001 \002(\0132\030"
  ".TST.TableCommandArchive\022\"\n\nfilter_set\030\002"
  " \002(\0132\016.TSP.Reference\0222\n\016tectonic_shift\030\003"
  " \002(\0132\032.TSCE.TectonicShiftArchive\"\331\001\n*Com"
  "mandRewriteFilterFormulasForSortArchive\022"
  "\'\n\005super\030\001 \002(\0132\030.TST.TableCommandArchive"
  "\022\"\n\nfilter_set\030\002 \002(\0132\016.TSP.Reference\0220\n\014"
  "sort_mapping\030\003 \002(\0132\032.TSK.ShuffleMappingA"
  "rchive\022,\n\017sorted_table_id\030\004 \002(\0132\023.TSCE.C"
  "FUUIDArchive\"\230\002\n6CommandRewriteCondition"
  "alStylesForTectonicShiftArchive\022\'\n\005super"
  "\030\001 \002(\0132\030.TST.TableCommandArchive\0222\n\016tect"
  "onic_shift\030\002 \002(\0132\032.TSCE.TectonicShiftArc"
  "hive\022;\n\020cells_to_rewrite\030\003 \001(\0132!.TSCE.Ce"
  "llCoordinateVectorArchive\022D\n\026conditional"
  "_style_sets\030\004 \001(\0132$.TSCE.CellCoordinateO"
  "bjectMapArchive\"\273\002\n-CommandRewriteCondit"
  "ionalStylesForSortArchive\022\'\n\005super\030\001 \002(\013"
  "2\030.TST.TableCommandArchive\0220\n\014sort_mappi"
  "ng\030\002 \002(\0132\032.TSK.ShuffleMappingArchive\022,\n\017"
  "sorted_table_id\030\003 \002(\0132\023.TSCE.CFUUIDArchi"
  "ve\022;\n\020cells_to_rewrite\030\004 \001(\0132!.TSCE.Cell"
  "CoordinateVectorArchive\022D\n\026conditional_s"
  "tyle_sets\030\005 \001(\0132$.TSCE.CellCoordinateObj"
  "ectMapArchive\"\324\002\n2CommandRewriteConditio"
  "nalStylesForRangeMoveArchive\022\'\n\005super\030\001 "
  "\002(\0132\030.TST.TableCommandArchive\0229\n\024from_ra"
  "nge_reference\030\007 \001(\0132\033.TSCE.RangeReferenc"
  "eArchive\0227\n\022to_range_reference\030\010 \001(\0132\033.T"
  "SCE.RangeReferenceArchive\022;\n\020cells_to_re"
  "write\030\005 \001(\0132!.TSCE.CellCoordinateVectorA"
  "rchive\022D\n\026conditional_style_sets\030\006 \001(\0132$"
  ".TSCE.CellCoordinateObjectMapArchive\"\302\002\n"
  "2CommandRewriteConditionalStylesForCellM"
  "ergeArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableCo"
  "mmandArchive\022,\n\017merged_table_id\030\002 \002(\0132\023."
  "TSCE.CFUUIDArchive\0222\n\014merged_range\030\003 \002(\013"
  "2\034.TSCE.RangeCoordinateArchive\022;\n\020cells_"
  "to_rewrite\030\004 \001(\0132!.TSCE.CellCoordinateVe"
  "ctorArchive\022D\n\026conditional_style_sets\030\005 "
  "\001(\0132$.TSCE.CellCoordinateObjectMapArchiv"
  "e\"\326\002\n\032CommandMergeUnmergeArchive\022\'\n\005supe"
  "r\030\001 \002(\0132\030.TST.TableCommandArchive\022-\n\014mer"
  "ge_action\030\002 \002(\0162\027.TST.MergeActionArchive"
  "\022(\n\tselection\030\003 \002(\0132\025.TST.SelectionArchi"
  "ve\022*\n\rundo_cell_map\030\004 \002(\0132\023.TST.CellMapA"
  "rchive\022*\n\rredo_cell_map\030\005 \002(\0132\023.TST.Cell"
  "MapArchive\022(\n\020old_merge_ranges\030\010 \001(\0132\016.T"
  "SP.Reference\0224\n\034undo_formula_rewrite_com"
  "mand\030\t \001(\0132\016.TSP.Reference\"\204\002\n\026CommandHi"
  "deShowArchive\022\'\n\005super\030\001 \002(\0132\030.TST.Table"
  "CommandArchive\022/\n\tdirection\030\002 \002(\0162\034.TST."
  "CommandDirectionArchive\0224\n\020hide_show_act"
  "ion\030\003 \002(\0162\032.TST.HideShowActionArchive\022\025\n"
  "\rhiding_action\030\004 \002(\r\022(\n\021elements_affecte"
  "d\030\005 \002(\0132\r.TSP.IndexSet\022\031\n\021old_hiding_sta"
  "tes\030\007 \003(\r\"\335\002\n\037TableInfoGeometryCommandAr"
  "chive\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchiv"
  "e\022\037\n\014scale_factor\030\002 \002(\0132\t.TSP.Size\022\"\n\nta"
  "ble_info\030\003 \001(\0132\016.TSP.Reference\022*\n\014new_ge"
  "ometry\030\004 \001(\0132\024.TSD.GeometryArchive\022*\n\014ol"
  "d_geometry\030\005 \001(\0132\024.TSD.GeometryArchive\022\034"
  "\n\024turn_off_auto_resize\030\006 \001(\010\022,\n$should_c"
  "lear_object_placeholder_flag\030\007 \001(\010\022-\n%di"
  "d_match_object_placeholder_geometry\030\010 \001("
  "\010\"\263\002\n!FormulaEditingCommandGroupArchive\022"
  "2\n\005super\030\001 \002(\0132#.TSK.ProgressiveCommandG"
  "roupArchive\022\032\n\022undoSelectionValid\030\002 \002(\010\022"
  "\032\n\022undoSelectionStart\030\003 \002(\r\022\033\n\023undoSelec"
  "tionLength\030\004 \002(\r\022\027\n\017undoActiveToken\030\005 \002("
  "\r\022\032\n\022redoSelectionValid\030\006 \002(\010\022\032\n\022redoSel"
  "ectionStart\030\007 \002(\r\022\033\n\023redoSelectionLength"
  "\030\010 \002(\r\022\027\n\017redoActiveToken\030\t \002(\r\"\254\002\n-Form"
  "ulaEditingCommandSelectionBehaviorArchiv"
  "e\022\032\n\022undoSelectionValid\030\002 \001(\010\022\032\n\022undoSel"
  "ectionStart\030\003 \001(\r\022\033\n\023undoSelectionLength"
  "\030\004 \001(\r\022\027\n\017undoActiveToken\030\005 \001(\r\022\032\n\022redoS"
  "electionValid\030\006 \001(\010\022\032\n\022redoSelectionStar"
  "t\030\007 \001(\r\022\033\n\023redoSelectionLength\030\010 \001(\r\022\027\n\017"
  "redoActiveToken\030\t \001(\r\022\037\n\007storage\030\n \001(\0132\016"
  ".TSP.Reference\"\246\002\n,UndoRedoStateCommandS"
  "electionBehaviorArchive\0222\n\026before_undo_r"
  "edo_state\030\001 \001(\0132\016.TSP.ReferenceB\002\030\001\0221\n\025a"
  "fter_undo_redo_state\030\002 \001(\0132\016.TSP.Referen"
  "ceB\002\030\001\022\"\n\ntable_info\030\003 \001(\0132\016.TSP.Referen"
  "ce\0225\n\026before_table_selection\030\004 \001(\0132\025.TST"
  ".SelectionArchive\0224\n\025after_table_selecti"
  "on\030\006 \001(\0132\025.TST.SelectionArchive\"\327\001\n$Tabl"
  "eCommandSelectionBehaviorArchive\0225\n\026befo"
  "re_table_selection\030\001 \001(\0132\025.TST.Selection"
  "Archive\0224\n\025after_table_selection\030\002 \001(\0132\025"
  ".TST.SelectionArchive\022\"\n\ntable_info\030\003 \001("
  "\0132\016.TSP.Reference\022\036\n\026last_column_hit_by_"
  "tap\030\004 \001(\r\"d\n(DisableTableNameSelectionBe"
  "haviorArchive\0228\n\005super\030\001 \002(\0132).TST.Table"
  "CommandSelectionBehaviorArchive\"\301\001\n\036Comm"
  "andApplyCellCommentArchive\022\'\n\005super\030\001 \002("
  "\0132\030.TST.TableCommandArchive\022\034\n\007cell_id\030\002"
  " \002(\0132\013.TST.CellID\022+\n\023old_comment_storage"
  "\030\003 \001(\0132\016.TSP.Reference\022+\n\023new_comment_st"
  "orage\030\004 \001(\0132\016.TSP.Reference\"\323\001\n&CommandA"
  "pplyConditionalStyleSetArchive\022\'\n\005super\030"
  "\001 \002(\0132\030.TST.TableCommandArchive\022(\n\tselec"
  "tion\030\002 \002(\0132\025.TST.SelectionArchive\022*\n\rund"
  "o_cell_map\030\003 \002(\0132\023.TST.CellMapArchive\022*\n"
  "\rredo_cell_map\030\004 \002(\0132\023.TST.CellMapArchiv"
  "e\"`\n$CommandSetFormulaTokenizationArchiv"
  "e\022\"\n\005super\030\001 \002(\0132\023.TSK.CommandArchive\022\024\n"
  "\014tokenization\030\002 \002(\010\"p\n\036CommandSetFilterE"
  "nabledArchive\022\'\n\005super\030\001 \002(\0132\030.TST.Table"
  "CommandArchive\022\024\n\014filter_index\030\002 \002(\r\022\017\n\007"
  "enabled\030\004 \002(\010\"\210\001\n\"CommandSetFilterRuleEn"
  "abledArchive\022\'\n\005super\030\001 \002(\0132\030.TST.TableC"
  "ommandArchive\022\024\n\014filter_index\030\002 \002(\r\022\022\n\nr"
  "ule_index\030\003 \002(\r\022\017\n\007enabled\030\004 \002(\010\"\315\001\n\036Com"
  "mandSetFilterSetTypeArchive\022\'\n\005super\030\001 \002"
  "(\0132\030.TST.TableCommandArchive\022@\n\023old_filt"
  "er_set_type\030\002 \002(\0162#.TST.FilterSetArchive"
  ".FilterSetType\022@\n\023new_filter_set_type\030\003 "
  "\002(\0162#.TST.FilterSetArchive.FilterSetType"
  "\"\274\001\n\035CommandSetStyleNetworkArchive\022\'\n\005su"
  "per\030\001 \002(\0132\030.TST.TableCommandArchive\0228\n\021o"
  "ld_style_network\030\002 \002(\0132\035.TST.TableStyleN"
  "etworkArchive\0228\n\021new_style_network\030\003 \002(\013"
  "2\035.TST.TableStyleNetworkArchive\"\306\001\n\031Comm"
  "andMutateCellsArchive\022\'\n\005super\030\001 \002(\0132\030.T"
  "ST.TableCommandArchive\022*\n\rundo_cell_map\030"
  "\002 \002(\0132\023.TST.CellMapArchive\022*\n\rredo_cell_"
  "map\030\003 \002(\0132\023.TST.CellMapArchive\022(\n\tselect"
  "ion\030\004 \001(\0132\025.TST.SelectionArchive\"\200\001\n)Com"
  "mandDisableFilterRulesForColumnArchive\022\'"
  "\n\005super\030\001 \002(\0132\030.TST.TableCommandArchive\022"
  "\024\n\014column_index\030\002 \002(\r\022\024\n\014rule_indices\030\003 "
  "\003(\r\"\343\001\n\032CommandSetTextStyleArchive\022\'\n\005su"
  "per\030\001 \002(\0132\030.TST.TableCommandArchive\022\037\n\006r"
  "egion\030\002 \002(\0132\017.TST.CellRegion\022*\n\rundo_cel"
  "l_map\030\003 \001(\0132\023.TST.CellMapArchive\022*\n\rredo"
  "_cell_map\030\004 \001(\0132\023.TST.CellMapArchive\022#\n\013"
  "subcommands\030\005 \001(\0132\016.TSP.Reference\"N\n#Com"
  "mandNotifyForTransformingArchive\022\'\n\005supe"
  "r\030\001 \002(\0132\030.TST.TableCommandArchive\"\330\001\n Co"
  "mmandSetStorageLanguageArchive\022\"\n\005super\030"
  "\001 \002(\0132\023.TSK.CommandArchive\022\037\n\007storage\030\002 "
  "\002(\0132\016.TSP.Reference\022\020\n\010language\030\003 \002(\t\022\026\n"
  "\016range_location\030\004 \002(\r\022\024\n\014range_length\030\005 "
  "\002(\r\022/\n\020undo_transaction\030\006 \001(\0132\025.TSWP.Und"
  "oTransaction*@\n\027CommandDirectionArchive\022"
  "\020\n\014directionRow\020\000\022\023\n\017directionColumn\020\001*h"
  "\n\024CommandRegionArchive\022\016\n\nbodyRegion\020\000\022\023"
  "\n\017headerRowRegion\020\001\022\026\n\022headerColumnRegio"
  "n\020\002\022\023\n\017footerRowRegion\020\003"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSTCommandArchives_2eproto_deps[7] = {
  &::descriptor_table_TSCEArchives_2eproto,
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
  &::descriptor_table_TSTArchives_2eproto,
  &::descriptor_table_TSWPArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSTCommandArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSTCommandArchives_2eproto = {
    false, false, 22064, descriptor_table_protodef_TSTCommandArchives_2eproto,
    "TSTCommandArchives.proto",
    &descriptor_table_TSTCommandArchives_2eproto_once, descriptor_table_TSTCommandArchives_2eproto_deps, 7, 98,
    schemas, file_default_instances, TableStruct_TSTCommandArchives_2eproto::offsets,
    file_level_metadata_TSTCommandArchives_2eproto, file_level_enum_descriptors_TSTCommandArchives_2eproto,
    file_level_service_descriptors_TSTCommandArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSTCommandArchives_2eproto_getter() {
  return &descriptor_table_TSTCommandArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSTCommandArchives_2eproto(&descriptor_table_TSTCommandArchives_2eproto);
namespace TST {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandDirectionArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTCommandArchives_2eproto);
  return file_level_enum_descriptors_TSTCommandArchives_2eproto[0];
}
bool CommandDirectionArchive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandRegionArchive_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSTCommandArchives_2eproto);
  return file_level_enum_descriptors_TSTCommandArchives_2eproto[1];
}
bool CommandRegionArchive_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TableCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableCommandArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& tableinfo(const TableCommandArchive* msg);
  static void set_has_tableinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_commandname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSK::CommandArchive& super(const TableCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_editing_mode_at_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

const ::TSP::Reference&
TableCommandArchive::_Internal::tableinfo(const TableCommandArchive* msg) {
  return *msg->_impl_.tableinfo_;
}
const ::TSK::CommandArchive&
TableCommandArchive::_Internal::super(const TableCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void TableCommandArchive::clear_tableinfo() {
  if (_impl_.tableinfo_ != nullptr) _impl_.tableinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TableCommandArchive::TableCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableCommandArchive)
}
TableCommandArchive::TableCommandArchive(const TableCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commandname_){}
    , decltype(_impl_.tableinfo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.editing_mode_at_start_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.commandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.commandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_commandname()) {
    _this->_impl_.commandname_.Set(from._internal_commandname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_tableinfo()) {
    _this->_impl_.tableinfo_ = new ::TSP::Reference(*from._impl_.tableinfo_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.editing_mode_at_start_ = from._impl_.editing_mode_at_start_;
  // @@protoc_insertion_point(copy_constructor:TST.TableCommandArchive)
}

inline void TableCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commandname_){}
    , decltype(_impl_.tableinfo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.editing_mode_at_start_){0u}
  };
  _impl_.commandname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.commandname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TableCommandArchive::~TableCommandArchive() {
  // @@protoc_insertion_point(destructor:TST.TableCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.commandname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.tableinfo_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void TableCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.commandname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tableinfo_ != nullptr);
      _impl_.tableinfo_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.editing_mode_at_start_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference tableInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tableinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string commandname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_commandname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.TableCommandArchive.commandname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required .TSK.CommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 editing_mode_at_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_editing_mode_at_start(&has_bits);
          _impl_.editing_mode_at_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference tableInfo = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tableinfo(this),
        _Internal::tableinfo(this).GetCachedSize(), target, stream);
  }

  // optional string commandname = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_commandname().data(), static_cast<int>(this->_internal_commandname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.TableCommandArchive.commandname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_commandname(), target);
  }

  // required .TSK.CommandArchive super = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 editing_mode_at_start = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_editing_mode_at_start(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableCommandArchive)
  return target;
}

size_t TableCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableCommandArchive)
  size_t total_size = 0;

  if (_internal_has_tableinfo()) {
    // required .TSP.Reference tableInfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tableinfo_);
  }

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t TableCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .TSP.Reference tableInfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tableinfo_);

    // required .TSK.CommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string commandname = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_commandname());
  }

  // optional uint32 editing_mode_at_start = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_editing_mode_at_start());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableCommandArchive::GetClassData() const { return &_class_data_; }


void TableCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableCommandArchive*>(&to_msg);
  auto& from = static_cast<const TableCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_commandname(from._internal_commandname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tableinfo()->::TSP::Reference::MergeFrom(
          from._internal_tableinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.editing_mode_at_start_ = from._impl_.editing_mode_at_start_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableCommandArchive::CopyFrom(const TableCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_tableinfo()) {
    if (!_impl_.tableinfo_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void TableCommandArchive::InternalSwap(TableCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.commandname_, lhs_arena,
      &other->_impl_.commandname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableCommandArchive, _impl_.editing_mode_at_start_)
      + sizeof(TableCommandArchive::_impl_.editing_mode_at_start_)
      - PROTOBUF_FIELD_OFFSET(TableCommandArchive, _impl_.tableinfo_)>(
          reinterpret_cast<char*>(&_impl_.tableinfo_),
          reinterpret_cast<char*>(&other->_impl_.tableinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[0]);
}

// ===================================================================

class CommandChangeFreezeHeaderStateArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandChangeFreezeHeaderStateArchive>()._impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_freeze_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandChangeFreezeHeaderStateArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandChangeFreezeHeaderStateArchive::_Internal::super(const CommandChangeFreezeHeaderStateArchive* msg) {
  return *msg->_impl_.super_;
}
CommandChangeFreezeHeaderStateArchive::CommandChangeFreezeHeaderStateArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandChangeFreezeHeaderStateArchive)
}
CommandChangeFreezeHeaderStateArchive::CommandChangeFreezeHeaderStateArchive(const CommandChangeFreezeHeaderStateArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandChangeFreezeHeaderStateArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.new_freeze_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_freeze_state_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.new_freeze_state_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandChangeFreezeHeaderStateArchive)
}

inline void CommandChangeFreezeHeaderStateArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.new_freeze_state_){false}
  };
}

CommandChangeFreezeHeaderStateArchive::~CommandChangeFreezeHeaderStateArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandChangeFreezeHeaderStateArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandChangeFreezeHeaderStateArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandChangeFreezeHeaderStateArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandChangeFreezeHeaderStateArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandChangeFreezeHeaderStateArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_freeze_state_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.new_freeze_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandChangeFreezeHeaderStateArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandDirectionArchive direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bool new_freeze_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_new_freeze_state(&has_bits);
          _impl_.new_freeze_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandChangeFreezeHeaderStateArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandChangeFreezeHeaderStateArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandDirectionArchive direction = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_direction(), target);
  }

  // required bool new_freeze_state = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_new_freeze_state(), target);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandChangeFreezeHeaderStateArchive)
  return target;
}

size_t CommandChangeFreezeHeaderStateArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandChangeFreezeHeaderStateArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_new_freeze_state()) {
    // required bool new_freeze_state = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandChangeFreezeHeaderStateArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandChangeFreezeHeaderStateArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required bool new_freeze_state = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandChangeFreezeHeaderStateArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandChangeFreezeHeaderStateArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandChangeFreezeHeaderStateArchive::GetClassData() const { return &_class_data_; }


void CommandChangeFreezeHeaderStateArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandChangeFreezeHeaderStateArchive*>(&to_msg);
  auto& from = static_cast<const CommandChangeFreezeHeaderStateArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandChangeFreezeHeaderStateArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_freeze_state_ = from._impl_.new_freeze_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandChangeFreezeHeaderStateArchive::CopyFrom(const CommandChangeFreezeHeaderStateArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandChangeFreezeHeaderStateArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandChangeFreezeHeaderStateArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandChangeFreezeHeaderStateArchive::InternalSwap(CommandChangeFreezeHeaderStateArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandChangeFreezeHeaderStateArchive, _impl_.new_freeze_state_)
      + sizeof(CommandChangeFreezeHeaderStateArchive::_impl_.new_freeze_state_)
      - PROTOBUF_FIELD_OFFSET(CommandChangeFreezeHeaderStateArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandChangeFreezeHeaderStateArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[1]);
}

// ===================================================================

class CommandDeleteCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandDeleteCellsArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandDeleteCellsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandDeleteCellsArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandDeleteCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandDeleteCellsArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_invalidate_comments(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandDeleteCellsArchive::_Internal::selection(const CommandDeleteCellsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandDeleteCellsArchive::_Internal::undo_map(const CommandDeleteCellsArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::TableCommandArchive&
CommandDeleteCellsArchive::_Internal::super(const CommandDeleteCellsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandDeleteCellsArchive::_Internal::redo_map(const CommandDeleteCellsArchive* msg) {
  return *msg->_impl_.redo_map_;
}
void CommandDeleteCellsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandDeleteCellsArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandDeleteCellsArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandDeleteCellsArchive::CommandDeleteCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandDeleteCellsArchive)
}
CommandDeleteCellsArchive::CommandDeleteCellsArchive(const CommandDeleteCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandDeleteCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.invalidate_comments_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandDeleteCellsArchive)
}

inline void CommandDeleteCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.invalidate_comments_){false}
  };
}

CommandDeleteCellsArchive::~CommandDeleteCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandDeleteCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandDeleteCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
}

void CommandDeleteCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandDeleteCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandDeleteCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
  }
  _impl_.invalidate_comments_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandDeleteCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool invalidate_comments = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_invalidate_comments(&has_bits);
          _impl_.invalidate_comments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandDeleteCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandDeleteCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required bool invalidate_comments = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_invalidate_comments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandDeleteCellsArchive)
  return target;
}

size_t CommandDeleteCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandDeleteCellsArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_invalidate_comments()) {
    // required bool invalidate_comments = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandDeleteCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandDeleteCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive redo_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required bool invalidate_comments = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandDeleteCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandDeleteCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandDeleteCellsArchive::GetClassData() const { return &_class_data_; }


void CommandDeleteCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandDeleteCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandDeleteCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandDeleteCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandDeleteCellsArchive::CopyFrom(const CommandDeleteCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandDeleteCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandDeleteCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandDeleteCellsArchive::InternalSwap(CommandDeleteCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandDeleteCellsArchive, _impl_.invalidate_comments_)
      + sizeof(CommandDeleteCellsArchive::_impl_.invalidate_comments_)
      - PROTOBUF_FIELD_OFFSET(CommandDeleteCellsArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandDeleteCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[2]);
}

// ===================================================================

class CommandDeleteCellContentsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandDeleteCellContentsArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandDeleteCellContentsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandDeleteCellContentsArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandDeleteCellContentsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandDeleteCellContentsArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_invalidate_comments(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandDeleteCellContentsArchive::_Internal::selection(const CommandDeleteCellContentsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandDeleteCellContentsArchive::_Internal::undo_map(const CommandDeleteCellContentsArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::TableCommandArchive&
CommandDeleteCellContentsArchive::_Internal::super(const CommandDeleteCellContentsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandDeleteCellContentsArchive::_Internal::redo_map(const CommandDeleteCellContentsArchive* msg) {
  return *msg->_impl_.redo_map_;
}
void CommandDeleteCellContentsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandDeleteCellContentsArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandDeleteCellContentsArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandDeleteCellContentsArchive::CommandDeleteCellContentsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandDeleteCellContentsArchive)
}
CommandDeleteCellContentsArchive::CommandDeleteCellContentsArchive(const CommandDeleteCellContentsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandDeleteCellContentsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.invalidate_comments_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandDeleteCellContentsArchive)
}

inline void CommandDeleteCellContentsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.invalidate_comments_){false}
  };
}

CommandDeleteCellContentsArchive::~CommandDeleteCellContentsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandDeleteCellContentsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandDeleteCellContentsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
}

void CommandDeleteCellContentsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandDeleteCellContentsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandDeleteCellContentsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
  }
  _impl_.invalidate_comments_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandDeleteCellContentsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool invalidate_comments = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_invalidate_comments(&has_bits);
          _impl_.invalidate_comments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandDeleteCellContentsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandDeleteCellContentsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required bool invalidate_comments = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_invalidate_comments(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandDeleteCellContentsArchive)
  return target;
}

size_t CommandDeleteCellContentsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandDeleteCellContentsArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_invalidate_comments()) {
    // required bool invalidate_comments = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandDeleteCellContentsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandDeleteCellContentsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive redo_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required bool invalidate_comments = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandDeleteCellContentsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandDeleteCellContentsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandDeleteCellContentsArchive::GetClassData() const { return &_class_data_; }


void CommandDeleteCellContentsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandDeleteCellContentsArchive*>(&to_msg);
  auto& from = static_cast<const CommandDeleteCellContentsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandDeleteCellContentsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandDeleteCellContentsArchive::CopyFrom(const CommandDeleteCellContentsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandDeleteCellContentsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandDeleteCellContentsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandDeleteCellContentsArchive::InternalSwap(CommandDeleteCellContentsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandDeleteCellContentsArchive, _impl_.invalidate_comments_)
      + sizeof(CommandDeleteCellContentsArchive::_impl_.invalidate_comments_)
      - PROTOBUF_FIELD_OFFSET(CommandDeleteCellContentsArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandDeleteCellContentsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[3]);
}

// ===================================================================

class CommandSetMultipleCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleCellsArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetMultipleCellsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetMultipleCellsArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetMultipleCellsArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::Cell& source_cell(const CommandSetMultipleCellsArchive* msg);
  static void set_has_source_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_only_if_format_differs(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetMultipleCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000017) ^ 0x00000017) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetMultipleCellsArchive::_Internal::selection(const CommandSetMultipleCellsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsArchive::_Internal::undo_map(const CommandSetMultipleCellsArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsArchive::_Internal::redo_map(const CommandSetMultipleCellsArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::Cell&
CommandSetMultipleCellsArchive::_Internal::source_cell(const CommandSetMultipleCellsArchive* msg) {
  return *msg->_impl_.source_cell_;
}
const ::TST::TableCommandArchive&
CommandSetMultipleCellsArchive::_Internal::super(const CommandSetMultipleCellsArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetMultipleCellsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetMultipleCellsArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetMultipleCellsArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetMultipleCellsArchive::clear_source_cell() {
  if (_impl_.source_cell_ != nullptr) _impl_.source_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandSetMultipleCellsArchive::CommandSetMultipleCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleCellsArchive)
}
CommandSetMultipleCellsArchive::CommandSetMultipleCellsArchive(const CommandSetMultipleCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.source_cell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.only_if_format_differs_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_source_cell()) {
    _this->_impl_.source_cell_ = new ::TST::Cell(*from._impl_.source_cell_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.only_if_format_differs_ = from._impl_.only_if_format_differs_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleCellsArchive)
}

inline void CommandSetMultipleCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.source_cell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.only_if_format_differs_){false}
  };
}

CommandSetMultipleCellsArchive::~CommandSetMultipleCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.source_cell_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.source_cell_ != nullptr);
      _impl_.source_cell_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.only_if_format_differs_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.Cell source_cell = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_source_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool only_if_format_differs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_only_if_format_differs(&has_bits);
          _impl_.only_if_format_differs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // optional .TST.Cell source_cell = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::source_cell(this),
        _Internal::source_cell(this).GetCachedSize(), target, stream);
  }

  // optional bool only_if_format_differs = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_only_if_format_differs(), target);
  }

  // required .TST.TableCommandArchive super = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleCellsArchive)
  return target;
}

size_t CommandSetMultipleCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetMultipleCellsArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetMultipleCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000017) ^ 0x00000017) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TST.Cell source_cell = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.source_cell_);
  }

  // optional bool only_if_format_differs = 6;
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleCellsArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_source_cell()->::TST::Cell::MergeFrom(
          from._internal_source_cell());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.only_if_format_differs_ = from._impl_.only_if_format_differs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleCellsArchive::CopyFrom(const CommandSetMultipleCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_source_cell()) {
    if (!_impl_.source_cell_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleCellsArchive::InternalSwap(CommandSetMultipleCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsArchive, _impl_.only_if_format_differs_)
      + sizeof(CommandSetMultipleCellsArchive::_impl_.only_if_format_differs_)
      - PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[4]);
}

// ===================================================================

class CommandSetMultipleCellsCustomArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleCellsCustomArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetMultipleCellsCustomArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetMultipleCellsCustomArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetMultipleCellsCustomArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSK::FormatStructArchive& cell_format(const CommandSetMultipleCellsCustomArchive* msg);
  static void set_has_cell_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetMultipleCellsCustomArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetMultipleCellsCustomArchive::_Internal::selection(const CommandSetMultipleCellsCustomArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsCustomArchive::_Internal::undo_map(const CommandSetMultipleCellsCustomArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsCustomArchive::_Internal::redo_map(const CommandSetMultipleCellsCustomArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TSK::FormatStructArchive&
CommandSetMultipleCellsCustomArchive::_Internal::cell_format(const CommandSetMultipleCellsCustomArchive* msg) {
  return *msg->_impl_.cell_format_;
}
const ::TST::TableCommandArchive&
CommandSetMultipleCellsCustomArchive::_Internal::super(const CommandSetMultipleCellsCustomArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetMultipleCellsCustomArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetMultipleCellsCustomArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetMultipleCellsCustomArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetMultipleCellsCustomArchive::clear_cell_format() {
  if (_impl_.cell_format_ != nullptr) _impl_.cell_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandSetMultipleCellsCustomArchive::CommandSetMultipleCellsCustomArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleCellsCustomArchive)
}
CommandSetMultipleCellsCustomArchive::CommandSetMultipleCellsCustomArchive(const CommandSetMultipleCellsCustomArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleCellsCustomArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.cell_format_){nullptr}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_cell_format()) {
    _this->_impl_.cell_format_ = new ::TSK::FormatStructArchive(*from._impl_.cell_format_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleCellsCustomArchive)
}

inline void CommandSetMultipleCellsCustomArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.cell_format_){nullptr}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleCellsCustomArchive::~CommandSetMultipleCellsCustomArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleCellsCustomArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleCellsCustomArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.cell_format_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleCellsCustomArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleCellsCustomArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleCellsCustomArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cell_format_ != nullptr);
      _impl_.cell_format_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleCellsCustomArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.FormatStructArchive cell_format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleCellsCustomArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleCellsCustomArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required .TSK.FormatStructArchive cell_format = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cell_format(this),
        _Internal::cell_format(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleCellsCustomArchive)
  return target;
}

size_t CommandSetMultipleCellsCustomArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetMultipleCellsCustomArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_cell_format()) {
    // required .TSK.FormatStructArchive cell_format = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_format_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetMultipleCellsCustomArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleCellsCustomArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TSK.FormatStructArchive cell_format = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_format_);

    // required .TST.TableCommandArchive super = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleCellsCustomArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleCellsCustomArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleCellsCustomArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleCellsCustomArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleCellsCustomArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleCellsCustomArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleCellsCustomArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cell_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_cell_format());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleCellsCustomArchive::CopyFrom(const CommandSetMultipleCellsCustomArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleCellsCustomArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleCellsCustomArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_cell_format()) {
    if (!_impl_.cell_format_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleCellsCustomArchive::InternalSwap(CommandSetMultipleCellsCustomArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsCustomArchive, _impl_.super_)
      + sizeof(CommandSetMultipleCellsCustomArchive::_impl_.super_)
      - PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsCustomArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleCellsCustomArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[5]);
}

// ===================================================================

class CommandSetMultipleCellsMultipleChoiceListArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleCellsMultipleChoiceListArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetMultipleCellsMultipleChoiceListArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetMultipleCellsMultipleChoiceListArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetMultipleCellsMultipleChoiceListArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetMultipleCellsMultipleChoiceListArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetMultipleCellsMultipleChoiceListArchive::_Internal::selection(const CommandSetMultipleCellsMultipleChoiceListArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsMultipleChoiceListArchive::_Internal::undo_map(const CommandSetMultipleCellsMultipleChoiceListArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetMultipleCellsMultipleChoiceListArchive::_Internal::redo_map(const CommandSetMultipleCellsMultipleChoiceListArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::TableCommandArchive&
CommandSetMultipleCellsMultipleChoiceListArchive::_Internal::super(const CommandSetMultipleCellsMultipleChoiceListArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetMultipleCellsMultipleChoiceListArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetMultipleCellsMultipleChoiceListArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetMultipleCellsMultipleChoiceListArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetMultipleCellsMultipleChoiceListArchive::CommandSetMultipleCellsMultipleChoiceListArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
}
CommandSetMultipleCellsMultipleChoiceListArchive::CommandSetMultipleCellsMultipleChoiceListArchive(const CommandSetMultipleCellsMultipleChoiceListArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleCellsMultipleChoiceListArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
}

inline void CommandSetMultipleCellsMultipleChoiceListArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleCellsMultipleChoiceListArchive::~CommandSetMultipleCellsMultipleChoiceListArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleCellsMultipleChoiceListArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleCellsMultipleChoiceListArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleCellsMultipleChoiceListArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleCellsMultipleChoiceListArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleCellsMultipleChoiceListArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  return target;
}

size_t CommandSetMultipleCellsMultipleChoiceListArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetMultipleCellsMultipleChoiceListArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleCellsMultipleChoiceListArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleCellsMultipleChoiceListArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleCellsMultipleChoiceListArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleCellsMultipleChoiceListArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleCellsMultipleChoiceListArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleCellsMultipleChoiceListArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleCellsMultipleChoiceListArchive::CopyFrom(const CommandSetMultipleCellsMultipleChoiceListArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleCellsMultipleChoiceListArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleCellsMultipleChoiceListArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleCellsMultipleChoiceListArchive::InternalSwap(CommandSetMultipleCellsMultipleChoiceListArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.super_)
      + sizeof(CommandSetMultipleCellsMultipleChoiceListArchive::_impl_.super_)
      - PROTOBUF_FIELD_OFFSET(CommandSetMultipleCellsMultipleChoiceListArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleCellsMultipleChoiceListArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[6]);
}

// ===================================================================

class CommandCoerceMultipleCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandCoerceMultipleCellsArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandCoerceMultipleCellsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandCoerceMultipleCellsArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandCoerceMultipleCellsArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_desired_format(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TST::TableCommandArchive& super(const CommandCoerceMultipleCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandCoerceMultipleCellsArchive::_Internal::selection(const CommandCoerceMultipleCellsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandCoerceMultipleCellsArchive::_Internal::undo_map(const CommandCoerceMultipleCellsArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandCoerceMultipleCellsArchive::_Internal::redo_map(const CommandCoerceMultipleCellsArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::TableCommandArchive&
CommandCoerceMultipleCellsArchive::_Internal::super(const CommandCoerceMultipleCellsArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandCoerceMultipleCellsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandCoerceMultipleCellsArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandCoerceMultipleCellsArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandCoerceMultipleCellsArchive::CommandCoerceMultipleCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandCoerceMultipleCellsArchive)
}
CommandCoerceMultipleCellsArchive::CommandCoerceMultipleCellsArchive(const CommandCoerceMultipleCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandCoerceMultipleCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.desired_format_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.desired_format_ = from._impl_.desired_format_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandCoerceMultipleCellsArchive)
}

inline void CommandCoerceMultipleCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.desired_format_){0}
  };
}

CommandCoerceMultipleCellsArchive::~CommandCoerceMultipleCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandCoerceMultipleCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandCoerceMultipleCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandCoerceMultipleCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandCoerceMultipleCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandCoerceMultipleCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.desired_format_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandCoerceMultipleCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 desired_format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_desired_format(&has_bits);
          _impl_.desired_format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandCoerceMultipleCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandCoerceMultipleCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required int32 desired_format = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_desired_format(), target);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandCoerceMultipleCellsArchive)
  return target;
}

size_t CommandCoerceMultipleCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandCoerceMultipleCellsArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_desired_format()) {
    // required int32 desired_format = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_desired_format());
  }

  return total_size;
}
size_t CommandCoerceMultipleCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandCoerceMultipleCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required int32 desired_format = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_desired_format());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandCoerceMultipleCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandCoerceMultipleCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandCoerceMultipleCellsArchive::GetClassData() const { return &_class_data_; }


void CommandCoerceMultipleCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandCoerceMultipleCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandCoerceMultipleCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandCoerceMultipleCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.desired_format_ = from._impl_.desired_format_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandCoerceMultipleCellsArchive::CopyFrom(const CommandCoerceMultipleCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandCoerceMultipleCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandCoerceMultipleCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandCoerceMultipleCellsArchive::InternalSwap(CommandCoerceMultipleCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandCoerceMultipleCellsArchive, _impl_.desired_format_)
      + sizeof(CommandCoerceMultipleCellsArchive::_impl_.desired_format_)
      - PROTOBUF_FIELD_OFFSET(CommandCoerceMultipleCellsArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandCoerceMultipleCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[7]);
}

// ===================================================================

class CommandSetControlCellsDisplayNumberFormatArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetControlCellsDisplayNumberFormatArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetControlCellsDisplayNumberFormatArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetControlCellsDisplayNumberFormatArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetControlCellsDisplayNumberFormatArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetControlCellsDisplayNumberFormatArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetControlCellsDisplayNumberFormatArchive::_Internal::selection(const CommandSetControlCellsDisplayNumberFormatArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetControlCellsDisplayNumberFormatArchive::_Internal::undo_map(const CommandSetControlCellsDisplayNumberFormatArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetControlCellsDisplayNumberFormatArchive::_Internal::redo_map(const CommandSetControlCellsDisplayNumberFormatArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::TableCommandArchive&
CommandSetControlCellsDisplayNumberFormatArchive::_Internal::super(const CommandSetControlCellsDisplayNumberFormatArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetControlCellsDisplayNumberFormatArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetControlCellsDisplayNumberFormatArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetControlCellsDisplayNumberFormatArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetControlCellsDisplayNumberFormatArchive::CommandSetControlCellsDisplayNumberFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetControlCellsDisplayNumberFormatArchive)
}
CommandSetControlCellsDisplayNumberFormatArchive::CommandSetControlCellsDisplayNumberFormatArchive(const CommandSetControlCellsDisplayNumberFormatArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetControlCellsDisplayNumberFormatArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetControlCellsDisplayNumberFormatArchive)
}

inline void CommandSetControlCellsDisplayNumberFormatArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetControlCellsDisplayNumberFormatArchive::~CommandSetControlCellsDisplayNumberFormatArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetControlCellsDisplayNumberFormatArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetControlCellsDisplayNumberFormatArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetControlCellsDisplayNumberFormatArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetControlCellsDisplayNumberFormatArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetControlCellsDisplayNumberFormatArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  return target;
}

size_t CommandSetControlCellsDisplayNumberFormatArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetControlCellsDisplayNumberFormatArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetControlCellsDisplayNumberFormatArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetControlCellsDisplayNumberFormatArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetControlCellsDisplayNumberFormatArchive::GetClassData() const { return &_class_data_; }


void CommandSetControlCellsDisplayNumberFormatArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetControlCellsDisplayNumberFormatArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetControlCellsDisplayNumberFormatArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetControlCellsDisplayNumberFormatArchive::CopyFrom(const CommandSetControlCellsDisplayNumberFormatArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetControlCellsDisplayNumberFormatArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetControlCellsDisplayNumberFormatArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetControlCellsDisplayNumberFormatArchive::InternalSwap(CommandSetControlCellsDisplayNumberFormatArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetControlCellsDisplayNumberFormatArchive, _impl_.super_)
      + sizeof(CommandSetControlCellsDisplayNumberFormatArchive::_impl_.super_)
      - PROTOBUF_FIELD_OFFSET(CommandSetControlCellsDisplayNumberFormatArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetControlCellsDisplayNumberFormatArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[8]);
}

// ===================================================================

class CommandSetAutomaticFormatArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetAutomaticFormatArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetAutomaticFormatArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetAutomaticFormatArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetAutomaticFormatArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetAutomaticFormatArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetAutomaticFormatArchive::_Internal::selection(const CommandSetAutomaticFormatArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetAutomaticFormatArchive::_Internal::undo_map(const CommandSetAutomaticFormatArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetAutomaticFormatArchive::_Internal::redo_map(const CommandSetAutomaticFormatArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::TableCommandArchive&
CommandSetAutomaticFormatArchive::_Internal::super(const CommandSetAutomaticFormatArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetAutomaticFormatArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetAutomaticFormatArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetAutomaticFormatArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetAutomaticFormatArchive::CommandSetAutomaticFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetAutomaticFormatArchive)
}
CommandSetAutomaticFormatArchive::CommandSetAutomaticFormatArchive(const CommandSetAutomaticFormatArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetAutomaticFormatArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetAutomaticFormatArchive)
}

inline void CommandSetAutomaticFormatArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetAutomaticFormatArchive::~CommandSetAutomaticFormatArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetAutomaticFormatArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetAutomaticFormatArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetAutomaticFormatArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetAutomaticFormatArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetAutomaticFormatArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetAutomaticFormatArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetAutomaticFormatArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetAutomaticFormatArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetAutomaticFormatArchive)
  return target;
}

size_t CommandSetAutomaticFormatArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetAutomaticFormatArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetAutomaticFormatArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetAutomaticFormatArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetAutomaticFormatArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetAutomaticFormatArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetAutomaticFormatArchive::GetClassData() const { return &_class_data_; }


void CommandSetAutomaticFormatArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetAutomaticFormatArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetAutomaticFormatArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetAutomaticFormatArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetAutomaticFormatArchive::CopyFrom(const CommandSetAutomaticFormatArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetAutomaticFormatArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetAutomaticFormatArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetAutomaticFormatArchive::InternalSwap(CommandSetAutomaticFormatArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetAutomaticFormatArchive, _impl_.super_)
      + sizeof(CommandSetAutomaticFormatArchive::_impl_.super_)
      - PROTOBUF_FIELD_OFFSET(CommandSetAutomaticFormatArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetAutomaticFormatArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[9]);
}

// ===================================================================

class CommandSetAutomaticDurationUnitsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetAutomaticDurationUnitsArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& selection(const CommandSetAutomaticDurationUnitsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_map(const CommandSetAutomaticDurationUnitsArchive* msg);
  static void set_has_undo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_map(const CommandSetAutomaticDurationUnitsArchive* msg);
  static void set_has_redo_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_automatic_units(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetAutomaticDurationUnitsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandSetAutomaticDurationUnitsArchive::_Internal::selection(const CommandSetAutomaticDurationUnitsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetAutomaticDurationUnitsArchive::_Internal::undo_map(const CommandSetAutomaticDurationUnitsArchive* msg) {
  return *msg->_impl_.undo_map_;
}
const ::TST::CellMapArchive&
CommandSetAutomaticDurationUnitsArchive::_Internal::redo_map(const CommandSetAutomaticDurationUnitsArchive* msg) {
  return *msg->_impl_.redo_map_;
}
const ::TST::TableCommandArchive&
CommandSetAutomaticDurationUnitsArchive::_Internal::super(const CommandSetAutomaticDurationUnitsArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetAutomaticDurationUnitsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetAutomaticDurationUnitsArchive::clear_undo_map() {
  if (_impl_.undo_map_ != nullptr) _impl_.undo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetAutomaticDurationUnitsArchive::clear_redo_map() {
  if (_impl_.redo_map_ != nullptr) _impl_.redo_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetAutomaticDurationUnitsArchive::CommandSetAutomaticDurationUnitsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetAutomaticDurationUnitsArchive)
}
CommandSetAutomaticDurationUnitsArchive::CommandSetAutomaticDurationUnitsArchive(const CommandSetAutomaticDurationUnitsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetAutomaticDurationUnitsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.automatic_units_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_map()) {
    _this->_impl_.undo_map_ = new ::TST::CellMapArchive(*from._impl_.undo_map_);
  }
  if (from._internal_has_redo_map()) {
    _this->_impl_.redo_map_ = new ::TST::CellMapArchive(*from._impl_.redo_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.automatic_units_ = from._impl_.automatic_units_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetAutomaticDurationUnitsArchive)
}

inline void CommandSetAutomaticDurationUnitsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_map_){nullptr}
    , decltype(_impl_.redo_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.automatic_units_){false}
  };
}

CommandSetAutomaticDurationUnitsArchive::~CommandSetAutomaticDurationUnitsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetAutomaticDurationUnitsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetAutomaticDurationUnitsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_map_;
  if (this != internal_default_instance()) delete _impl_.redo_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetAutomaticDurationUnitsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetAutomaticDurationUnitsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetAutomaticDurationUnitsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_map_ != nullptr);
      _impl_.undo_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_map_ != nullptr);
      _impl_.redo_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.automatic_units_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetAutomaticDurationUnitsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool automatic_units = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_automatic_units(&has_bits);
          _impl_.automatic_units_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetAutomaticDurationUnitsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetAutomaticDurationUnitsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_map(this),
        _Internal::undo_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_map(this),
        _Internal::redo_map(this).GetCachedSize(), target, stream);
  }

  // optional bool automatic_units = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_automatic_units(), target);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetAutomaticDurationUnitsArchive)
  return target;
}

size_t CommandSetAutomaticDurationUnitsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetAutomaticDurationUnitsArchive)
  size_t total_size = 0;

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_map()) {
    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);
  }

  if (_internal_has_redo_map()) {
    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetAutomaticDurationUnitsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetAutomaticDurationUnitsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_map_);

    // required .TST.CellMapArchive redo_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool automatic_units = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetAutomaticDurationUnitsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetAutomaticDurationUnitsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetAutomaticDurationUnitsArchive::GetClassData() const { return &_class_data_; }


void CommandSetAutomaticDurationUnitsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetAutomaticDurationUnitsArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetAutomaticDurationUnitsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetAutomaticDurationUnitsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.automatic_units_ = from._impl_.automatic_units_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetAutomaticDurationUnitsArchive::CopyFrom(const CommandSetAutomaticDurationUnitsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetAutomaticDurationUnitsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetAutomaticDurationUnitsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_map()) {
    if (!_impl_.undo_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_map()) {
    if (!_impl_.redo_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetAutomaticDurationUnitsArchive::InternalSwap(CommandSetAutomaticDurationUnitsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetAutomaticDurationUnitsArchive, _impl_.automatic_units_)
      + sizeof(CommandSetAutomaticDurationUnitsArchive::_impl_.automatic_units_)
      - PROTOBUF_FIELD_OFFSET(CommandSetAutomaticDurationUnitsArchive, _impl_.selection_)>(
          reinterpret_cast<char*>(&_impl_.selection_),
          reinterpret_cast<char*>(&other->_impl_.selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetAutomaticDurationUnitsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[10]);
}

// ===================================================================

class CommandInsertColumnsOrRowsArchive_StyleIndexPair::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandInsertColumnsOrRowsArchive_StyleIndexPair>()._impl_._has_bits_);
  static const ::TSP::Reference& style(const CommandInsertColumnsOrRowsArchive_StyleIndexPair* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSP::Reference&
CommandInsertColumnsOrRowsArchive_StyleIndexPair::_Internal::style(const CommandInsertColumnsOrRowsArchive_StyleIndexPair* msg) {
  return *msg->_impl_.style_;
}
void CommandInsertColumnsOrRowsArchive_StyleIndexPair::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CommandInsertColumnsOrRowsArchive_StyleIndexPair::CommandInsertColumnsOrRowsArchive_StyleIndexPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
}
CommandInsertColumnsOrRowsArchive_StyleIndexPair::CommandInsertColumnsOrRowsArchive_StyleIndexPair(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandInsertColumnsOrRowsArchive_StyleIndexPair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
}

inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.style_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

CommandInsertColumnsOrRowsArchive_StyleIndexPair::~CommandInsertColumnsOrRowsArchive_StyleIndexPair() {
  // @@protoc_insertion_point(destructor:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandInsertColumnsOrRowsArchive_StyleIndexPair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.style_;
}

void CommandInsertColumnsOrRowsArchive_StyleIndexPair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandInsertColumnsOrRowsArchive_StyleIndexPair::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.style_ != nullptr);
    _impl_.style_->Clear();
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandInsertColumnsOrRowsArchive_StyleIndexPair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference style = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandInsertColumnsOrRowsArchive_StyleIndexPair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference style = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  // required uint32 index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  return target;
}

size_t CommandInsertColumnsOrRowsArchive_StyleIndexPair::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  size_t total_size = 0;

  if (_internal_has_style()) {
    // required .TSP.Reference style = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.style_);
  }

  if (_internal_has_index()) {
    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  return total_size;
}
size_t CommandInsertColumnsOrRowsArchive_StyleIndexPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSP.Reference style = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.style_);

    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandInsertColumnsOrRowsArchive_StyleIndexPair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandInsertColumnsOrRowsArchive_StyleIndexPair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandInsertColumnsOrRowsArchive_StyleIndexPair::GetClassData() const { return &_class_data_; }


void CommandInsertColumnsOrRowsArchive_StyleIndexPair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandInsertColumnsOrRowsArchive_StyleIndexPair*>(&to_msg);
  auto& from = static_cast<const CommandInsertColumnsOrRowsArchive_StyleIndexPair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandInsertColumnsOrRowsArchive_StyleIndexPair::CopyFrom(const CommandInsertColumnsOrRowsArchive_StyleIndexPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInsertColumnsOrRowsArchive_StyleIndexPair::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  return true;
}

void CommandInsertColumnsOrRowsArchive_StyleIndexPair::InternalSwap(CommandInsertColumnsOrRowsArchive_StyleIndexPair* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandInsertColumnsOrRowsArchive_StyleIndexPair, _impl_.index_)
      + sizeof(CommandInsertColumnsOrRowsArchive_StyleIndexPair::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CommandInsertColumnsOrRowsArchive_StyleIndexPair, _impl_.style_)>(
          reinterpret_cast<char*>(&_impl_.style_),
          reinterpret_cast<char*>(&other->_impl_.style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandInsertColumnsOrRowsArchive_StyleIndexPair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[11]);
}

// ===================================================================

class CommandInsertColumnsOrRowsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandInsertColumnsOrRowsArchive>()._impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_before(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_header_count(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_headers_added(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_footer_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_footers_added(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::TSP::Reference& row_column_style(const CommandInsertColumnsOrRowsArchive* msg);
  static void set_has_row_column_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& cell_style_redo(const CommandInsertColumnsOrRowsArchive* msg);
  static void set_has_cell_style_redo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandInsertColumnsOrRowsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& formula_rewrite_command(const CommandInsertColumnsOrRowsArchive* msg);
  static void set_has_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_height_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_allow_horizontal_autosize(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_inherit_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_inherit_formats(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_inherit_formulas(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00031ff4) ^ 0x00031ff4) != 0;
  }
};

const ::TSP::Reference&
CommandInsertColumnsOrRowsArchive::_Internal::row_column_style(const CommandInsertColumnsOrRowsArchive* msg) {
  return *msg->_impl_.row_column_style_;
}
const ::TST::CellMapArchive&
CommandInsertColumnsOrRowsArchive::_Internal::cell_style_redo(const CommandInsertColumnsOrRowsArchive* msg) {
  return *msg->_impl_.cell_style_redo_;
}
const ::TST::TableCommandArchive&
CommandInsertColumnsOrRowsArchive::_Internal::super(const CommandInsertColumnsOrRowsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandInsertColumnsOrRowsArchive::_Internal::formula_rewrite_command(const CommandInsertColumnsOrRowsArchive* msg) {
  return *msg->_impl_.formula_rewrite_command_;
}
void CommandInsertColumnsOrRowsArchive::clear_row_column_style() {
  if (_impl_.row_column_style_ != nullptr) _impl_.row_column_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandInsertColumnsOrRowsArchive::clear_cell_style_redo() {
  if (_impl_.cell_style_redo_ != nullptr) _impl_.cell_style_redo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandInsertColumnsOrRowsArchive::clear_formula_rewrite_command() {
  if (_impl_.formula_rewrite_command_ != nullptr) _impl_.formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandInsertColumnsOrRowsArchive::CommandInsertColumnsOrRowsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandInsertColumnsOrRowsArchive)
}
CommandInsertColumnsOrRowsArchive::CommandInsertColumnsOrRowsArchive(const CommandInsertColumnsOrRowsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandInsertColumnsOrRowsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_index_pairs_){from._impl_.cell_style_index_pairs_}
    , decltype(_impl_.text_style_index_pairs_){from._impl_.text_style_index_pairs_}
    , decltype(_impl_.sizes_){from._impl_.sizes_}
    , decltype(_impl_.row_column_style_){nullptr}
    , decltype(_impl_.cell_style_redo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.size_){}
    , decltype(_impl_.header_count_){}
    , decltype(_impl_.headers_added_){}
    , decltype(_impl_.footer_count_){}
    , decltype(_impl_.footers_added_){}
    , decltype(_impl_.before_){}
    , decltype(_impl_.allow_horizontal_autosize_){}
    , decltype(_impl_.inherit_styles_){}
    , decltype(_impl_.inherit_formats_){}
    , decltype(_impl_.width_factor_){}
    , decltype(_impl_.height_factor_){}
    , decltype(_impl_.inherit_formulas_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_row_column_style()) {
    _this->_impl_.row_column_style_ = new ::TSP::Reference(*from._impl_.row_column_style_);
  }
  if (from._internal_has_cell_style_redo()) {
    _this->_impl_.cell_style_redo_ = new ::TST::CellMapArchive(*from._impl_.cell_style_redo_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_formula_rewrite_command()) {
    _this->_impl_.formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.formula_rewrite_command_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inherit_formulas_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.inherit_formulas_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandInsertColumnsOrRowsArchive)
}

inline void CommandInsertColumnsOrRowsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_index_pairs_){arena}
    , decltype(_impl_.text_style_index_pairs_){arena}
    , decltype(_impl_.sizes_){arena}
    , decltype(_impl_.row_column_style_){nullptr}
    , decltype(_impl_.cell_style_redo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.size_){0}
    , decltype(_impl_.header_count_){0u}
    , decltype(_impl_.headers_added_){0u}
    , decltype(_impl_.footer_count_){0u}
    , decltype(_impl_.footers_added_){0u}
    , decltype(_impl_.before_){false}
    , decltype(_impl_.allow_horizontal_autosize_){false}
    , decltype(_impl_.inherit_styles_){false}
    , decltype(_impl_.inherit_formats_){false}
    , decltype(_impl_.width_factor_){0}
    , decltype(_impl_.height_factor_){0}
    , decltype(_impl_.inherit_formulas_){false}
  };
}

CommandInsertColumnsOrRowsArchive::~CommandInsertColumnsOrRowsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandInsertColumnsOrRowsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandInsertColumnsOrRowsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cell_style_index_pairs_.~RepeatedPtrField();
  _impl_.text_style_index_pairs_.~RepeatedPtrField();
  _impl_.sizes_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.row_column_style_;
  if (this != internal_default_instance()) delete _impl_.cell_style_redo_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.formula_rewrite_command_;
}

void CommandInsertColumnsOrRowsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandInsertColumnsOrRowsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandInsertColumnsOrRowsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cell_style_index_pairs_.Clear();
  _impl_.text_style_index_pairs_.Clear();
  _impl_.sizes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.row_column_style_ != nullptr);
      _impl_.row_column_style_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_style_redo_ != nullptr);
      _impl_.cell_style_redo_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.formula_rewrite_command_ != nullptr);
      _impl_.formula_rewrite_command_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.size_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.header_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inherit_formats_) -
        reinterpret_cast<char*>(&_impl_.header_count_)) + sizeof(_impl_.inherit_formats_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.width_factor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.inherit_formulas_) -
        reinterpret_cast<char*>(&_impl_.width_factor_)) + sizeof(_impl_.inherit_formulas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandInsertColumnsOrRowsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandDirectionArchive direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required bool before = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_before(&has_bits);
          _impl_.before_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference row_column_style = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_row_column_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive cell_style_redo = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_style_redo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 header_count = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_header_count(&has_bits);
          _impl_.header_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 headers_added = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_headers_added(&has_bits);
          _impl_.headers_added_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 footer_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_footer_count(&has_bits);
          _impl_.footer_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 footers_added = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_footers_added(&has_bits);
          _impl_.footers_added_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formula_rewrite_command = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float width_factor = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_width_factor(&has_bits);
          _impl_.width_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float height_factor = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_height_factor(&has_bits);
          _impl_.height_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_horizontal_autosize = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_allow_horizontal_autosize(&has_bits);
          _impl_.allow_horizontal_autosize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool inherit_styles = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_inherit_styles(&has_bits);
          _impl_.inherit_styles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool inherit_formats = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_inherit_formats(&has_bits);
          _impl_.inherit_formats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair cell_style_index_pairs = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cell_style_index_pairs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair text_style_index_pairs = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_text_style_index_pairs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated double sizes = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_sizes(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<185>(ptr));
        } else if (static_cast<uint8_t>(tag) == 186) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_sizes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool inherit_formulas = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_inherit_formulas(&has_bits);
          _impl_.inherit_formulas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandInsertColumnsOrRowsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandInsertColumnsOrRowsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandDirectionArchive direction = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_direction(), target);
  }

  // required uint32 index = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // required uint32 count = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // required float size = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_size(), target);
  }

  // required bool before = 5;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_before(), target);
  }

  // optional .TSP.Reference row_column_style = 8;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::row_column_style(this),
        _Internal::row_column_style(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive cell_style_redo = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::cell_style_redo(this),
        _Internal::cell_style_redo(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 header_count = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_header_count(), target);
  }

  // required uint32 headers_added = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_headers_added(), target);
  }

  // required uint32 footer_count = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_footer_count(), target);
  }

  // required uint32 footers_added = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_footers_added(), target);
  }

  // optional .TSP.Reference formula_rewrite_command = 15;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::formula_rewrite_command(this),
        _Internal::formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  // required float width_factor = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_width_factor(), target);
  }

  // required float height_factor = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_height_factor(), target);
  }

  // optional bool allow_horizontal_autosize = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_allow_horizontal_autosize(), target);
  }

  // optional bool inherit_styles = 19;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_inherit_styles(), target);
  }

  // optional bool inherit_formats = 20;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_inherit_formats(), target);
  }

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair cell_style_index_pairs = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cell_style_index_pairs_size()); i < n; i++) {
    const auto& repfield = this->_internal_cell_style_index_pairs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair text_style_index_pairs = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_text_style_index_pairs_size()); i < n; i++) {
    const auto& repfield = this->_internal_text_style_index_pairs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated double sizes = 23;
  for (int i = 0, n = this->_internal_sizes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(23, this->_internal_sizes(i), target);
  }

  // optional bool inherit_formulas = 24;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_inherit_formulas(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandInsertColumnsOrRowsArchive)
  return target;
}

size_t CommandInsertColumnsOrRowsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandInsertColumnsOrRowsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_index()) {
    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  if (_internal_has_count()) {
    // required uint32 count = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  if (_internal_has_size()) {
    // required float size = 4;
    total_size += 1 + 4;
  }

  if (_internal_has_header_count()) {
    // required uint32 header_count = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_count());
  }

  if (_internal_has_headers_added()) {
    // required uint32 headers_added = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_headers_added());
  }

  if (_internal_has_footer_count()) {
    // required uint32 footer_count = 13;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footer_count());
  }

  if (_internal_has_footers_added()) {
    // required uint32 footers_added = 14;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footers_added());
  }

  if (_internal_has_before()) {
    // required bool before = 5;
    total_size += 1 + 1;
  }

  if (_internal_has_width_factor()) {
    // required float width_factor = 16;
    total_size += 2 + 4;
  }

  if (_internal_has_height_factor()) {
    // required float height_factor = 17;
    total_size += 2 + 4;
  }

  return total_size;
}
size_t CommandInsertColumnsOrRowsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandInsertColumnsOrRowsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00031ff4) ^ 0x00031ff4) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

    // required uint32 count = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

    // required float size = 4;
    total_size += 1 + 4;

    // required uint32 header_count = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_count());

    // required uint32 headers_added = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_headers_added());

    // required uint32 footer_count = 13;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footer_count());

    // required uint32 footers_added = 14;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footers_added());

    // required bool before = 5;
    total_size += 1 + 1;

    // required float width_factor = 16;
    total_size += 2 + 4;

    // required float height_factor = 17;
    total_size += 2 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair cell_style_index_pairs = 21;
  total_size += 2UL * this->_internal_cell_style_index_pairs_size();
  for (const auto& msg : this->_impl_.cell_style_index_pairs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TST.CommandInsertColumnsOrRowsArchive.StyleIndexPair text_style_index_pairs = 22;
  total_size += 2UL * this->_internal_text_style_index_pairs_size();
  for (const auto& msg : this->_impl_.text_style_index_pairs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double sizes = 23;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_sizes_size());
    size_t data_size = 8UL * count;
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_sizes_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference row_column_style = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.row_column_style_);
    }

    // optional .TST.CellMapArchive cell_style_redo = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cell_style_redo_);
    }

  }
  // optional .TSP.Reference formula_rewrite_command = 15;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_rewrite_command_);
  }

  if (cached_has_bits & 0x0000e000u) {
    // optional bool allow_horizontal_autosize = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool inherit_styles = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool inherit_formats = 20;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  // optional bool inherit_formulas = 24;
  if (cached_has_bits & 0x00040000u) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandInsertColumnsOrRowsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandInsertColumnsOrRowsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandInsertColumnsOrRowsArchive::GetClassData() const { return &_class_data_; }


void CommandInsertColumnsOrRowsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandInsertColumnsOrRowsArchive*>(&to_msg);
  auto& from = static_cast<const CommandInsertColumnsOrRowsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandInsertColumnsOrRowsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cell_style_index_pairs_.MergeFrom(from._impl_.cell_style_index_pairs_);
  _this->_impl_.text_style_index_pairs_.MergeFrom(from._impl_.text_style_index_pairs_);
  _this->_impl_.sizes_.MergeFrom(from._impl_.sizes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_row_column_style()->::TSP::Reference::MergeFrom(
          from._internal_row_column_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell_style_redo()->::TST::CellMapArchive::MergeFrom(
          from._internal_cell_style_redo());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_formula_rewrite_command());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.header_count_ = from._impl_.header_count_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.headers_added_ = from._impl_.headers_added_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.footer_count_ = from._impl_.footer_count_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.footers_added_ = from._impl_.footers_added_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.before_ = from._impl_.before_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.allow_horizontal_autosize_ = from._impl_.allow_horizontal_autosize_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.inherit_styles_ = from._impl_.inherit_styles_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.inherit_formats_ = from._impl_.inherit_formats_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.width_factor_ = from._impl_.width_factor_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.height_factor_ = from._impl_.height_factor_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.inherit_formulas_ = from._impl_.inherit_formulas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandInsertColumnsOrRowsArchive::CopyFrom(const CommandInsertColumnsOrRowsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandInsertColumnsOrRowsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInsertColumnsOrRowsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.cell_style_index_pairs_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.text_style_index_pairs_))
    return false;
  if (_internal_has_row_column_style()) {
    if (!_impl_.row_column_style_->IsInitialized()) return false;
  }
  if (_internal_has_cell_style_redo()) {
    if (!_impl_.cell_style_redo_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_formula_rewrite_command()) {
    if (!_impl_.formula_rewrite_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandInsertColumnsOrRowsArchive::InternalSwap(CommandInsertColumnsOrRowsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cell_style_index_pairs_.InternalSwap(&other->_impl_.cell_style_index_pairs_);
  _impl_.text_style_index_pairs_.InternalSwap(&other->_impl_.text_style_index_pairs_);
  _impl_.sizes_.InternalSwap(&other->_impl_.sizes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandInsertColumnsOrRowsArchive, _impl_.inherit_formulas_)
      + sizeof(CommandInsertColumnsOrRowsArchive::_impl_.inherit_formulas_)
      - PROTOBUF_FIELD_OFFSET(CommandInsertColumnsOrRowsArchive, _impl_.row_column_style_)>(
          reinterpret_cast<char*>(&_impl_.row_column_style_),
          reinterpret_cast<char*>(&other->_impl_.row_column_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandInsertColumnsOrRowsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[12]);
}

// ===================================================================

class CommandPasteArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPasteArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& user_selection(const CommandPasteArchive* msg);
  static void set_has_user_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& final_selection(const CommandPasteArchive* msg);
  static void set_has_final_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandPasteArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandPasteArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& command_undo(const CommandPasteArchive* msg);
  static void set_has_command_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_invalidate_comments(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::TableCommandArchive& super(const CommandPasteArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000006f) ^ 0x0000006f) != 0;
  }
};

const ::TST::SelectionArchive&
CommandPasteArchive::_Internal::user_selection(const CommandPasteArchive* msg) {
  return *msg->_impl_.user_selection_;
}
const ::TST::SelectionArchive&
CommandPasteArchive::_Internal::final_selection(const CommandPasteArchive* msg) {
  return *msg->_impl_.final_selection_;
}
const ::TST::CellMapArchive&
CommandPasteArchive::_Internal::undo_cell_map(const CommandPasteArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandPasteArchive::_Internal::redo_cell_map(const CommandPasteArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandPasteArchive::_Internal::command_undo(const CommandPasteArchive* msg) {
  return *msg->_impl_.command_undo_;
}
const ::TST::TableCommandArchive&
CommandPasteArchive::_Internal::super(const CommandPasteArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandPasteArchive::clear_user_selection() {
  if (_impl_.user_selection_ != nullptr) _impl_.user_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandPasteArchive::clear_final_selection() {
  if (_impl_.final_selection_ != nullptr) _impl_.final_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandPasteArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandPasteArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandPasteArchive::clear_command_undo() {
  if (_impl_.command_undo_ != nullptr) _impl_.command_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandPasteArchive::clear_formula_rewrite_commands() {
  _impl_.formula_rewrite_commands_.Clear();
}
CommandPasteArchive::CommandPasteArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandPasteArchive)
}
CommandPasteArchive::CommandPasteArchive(const CommandPasteArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandPasteArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.formula_rewrite_commands_){from._impl_.formula_rewrite_commands_}
    , decltype(_impl_.user_selection_){nullptr}
    , decltype(_impl_.final_selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.command_undo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.invalidate_comments_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user_selection()) {
    _this->_impl_.user_selection_ = new ::TST::SelectionArchive(*from._impl_.user_selection_);
  }
  if (from._internal_has_final_selection()) {
    _this->_impl_.final_selection_ = new ::TST::SelectionArchive(*from._impl_.final_selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_command_undo()) {
    _this->_impl_.command_undo_ = new ::TSP::Reference(*from._impl_.command_undo_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandPasteArchive)
}

inline void CommandPasteArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.formula_rewrite_commands_){arena}
    , decltype(_impl_.user_selection_){nullptr}
    , decltype(_impl_.final_selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.command_undo_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.invalidate_comments_){false}
  };
}

CommandPasteArchive::~CommandPasteArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandPasteArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandPasteArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.formula_rewrite_commands_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.user_selection_;
  if (this != internal_default_instance()) delete _impl_.final_selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.command_undo_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandPasteArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandPasteArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandPasteArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.formula_rewrite_commands_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.user_selection_ != nullptr);
      _impl_.user_selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.final_selection_ != nullptr);
      _impl_.final_selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.command_undo_ != nullptr);
      _impl_.command_undo_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.invalidate_comments_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandPasteArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.SelectionArchive user_selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive final_selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_final_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference command_undo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool invalidate_comments = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_invalidate_comments(&has_bits);
          _impl_.invalidate_comments_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference formula_rewrite_commands = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_formula_rewrite_commands(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandPasteArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandPasteArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.SelectionArchive user_selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::user_selection(this),
        _Internal::user_selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive final_selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::final_selection(this),
        _Internal::final_selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference command_undo = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::command_undo(this),
        _Internal::command_undo(this).GetCachedSize(), target, stream);
  }

  // required bool invalidate_comments = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_invalidate_comments(), target);
  }

  // required .TST.TableCommandArchive super = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference formula_rewrite_commands = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_formula_rewrite_commands_size()); i < n; i++) {
    const auto& repfield = this->_internal_formula_rewrite_commands(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandPasteArchive)
  return target;
}

size_t CommandPasteArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandPasteArchive)
  size_t total_size = 0;

  if (_internal_has_user_selection()) {
    // required .TST.SelectionArchive user_selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_selection_);
  }

  if (_internal_has_final_selection()) {
    // required .TST.SelectionArchive final_selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.final_selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_invalidate_comments()) {
    // required bool invalidate_comments = 7;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandPasteArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandPasteArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000006f) ^ 0x0000006f) == 0) {  // All required fields are present.
    // required .TST.SelectionArchive user_selection = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.user_selection_);

    // required .TST.SelectionArchive final_selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.final_selection_);

    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.TableCommandArchive super = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool invalidate_comments = 7;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TSP.Reference formula_rewrite_commands = 15;
  total_size += 1UL * this->_internal_formula_rewrite_commands_size();
  for (const auto& msg : this->_impl_.formula_rewrite_commands_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TSP.Reference command_undo = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.command_undo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandPasteArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandPasteArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandPasteArchive::GetClassData() const { return &_class_data_; }


void CommandPasteArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandPasteArchive*>(&to_msg);
  auto& from = static_cast<const CommandPasteArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandPasteArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.formula_rewrite_commands_.MergeFrom(from._impl_.formula_rewrite_commands_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_user_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_user_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_final_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_final_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_command_undo()->::TSP::Reference::MergeFrom(
          from._internal_command_undo());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.invalidate_comments_ = from._impl_.invalidate_comments_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandPasteArchive::CopyFrom(const CommandPasteArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandPasteArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPasteArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.formula_rewrite_commands_))
    return false;
  if (_internal_has_user_selection()) {
    if (!_impl_.user_selection_->IsInitialized()) return false;
  }
  if (_internal_has_final_selection()) {
    if (!_impl_.final_selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_command_undo()) {
    if (!_impl_.command_undo_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandPasteArchive::InternalSwap(CommandPasteArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.formula_rewrite_commands_.InternalSwap(&other->_impl_.formula_rewrite_commands_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandPasteArchive, _impl_.invalidate_comments_)
      + sizeof(CommandPasteArchive::_impl_.invalidate_comments_)
      - PROTOBUF_FIELD_OFFSET(CommandPasteArchive, _impl_.user_selection_)>(
          reinterpret_cast<char*>(&_impl_.user_selection_),
          reinterpret_cast<char*>(&other->_impl_.user_selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandPasteArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[13]);
}

// ===================================================================

class CommandRemoveColumnsOrRowsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRemoveColumnsOrRowsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TSP::IndexSet& indices_to_remove(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_indices_to_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& cellmap(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_cellmap(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::GeometryArchive& oldgeom(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_oldgeom(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::GeometryArchive& newgeom(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_newgeom(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& formula_rewrite_command(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_width_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_height_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_allow_horizontal_autosize(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::TSP::Reference& undo_merge_map(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_undo_merge_map(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& redo_merge_map(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_redo_merge_map(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& orig_filter_set(const CommandRemoveColumnsOrRowsArchive* msg);
  static void set_has_orig_filter_set(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000e1b) ^ 0x00000e1b) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRemoveColumnsOrRowsArchive::_Internal::super(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::IndexSet&
CommandRemoveColumnsOrRowsArchive::_Internal::indices_to_remove(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.indices_to_remove_;
}
const ::TST::CellMapArchive&
CommandRemoveColumnsOrRowsArchive::_Internal::cellmap(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.cellmap_;
}
const ::TSD::GeometryArchive&
CommandRemoveColumnsOrRowsArchive::_Internal::oldgeom(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.oldgeom_;
}
const ::TSD::GeometryArchive&
CommandRemoveColumnsOrRowsArchive::_Internal::newgeom(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.newgeom_;
}
const ::TSP::Reference&
CommandRemoveColumnsOrRowsArchive::_Internal::formula_rewrite_command(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.formula_rewrite_command_;
}
const ::TSP::Reference&
CommandRemoveColumnsOrRowsArchive::_Internal::undo_merge_map(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.undo_merge_map_;
}
const ::TSP::Reference&
CommandRemoveColumnsOrRowsArchive::_Internal::redo_merge_map(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.redo_merge_map_;
}
const ::TSP::Reference&
CommandRemoveColumnsOrRowsArchive::_Internal::orig_filter_set(const CommandRemoveColumnsOrRowsArchive* msg) {
  return *msg->_impl_.orig_filter_set_;
}
void CommandRemoveColumnsOrRowsArchive::clear_indices_to_remove() {
  if (_impl_.indices_to_remove_ != nullptr) _impl_.indices_to_remove_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRemoveColumnsOrRowsArchive::clear_cellmap() {
  if (_impl_.cellmap_ != nullptr) _impl_.cellmap_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRemoveColumnsOrRowsArchive::clear_oldgeom() {
  if (_impl_.oldgeom_ != nullptr) _impl_.oldgeom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandRemoveColumnsOrRowsArchive::clear_newgeom() {
  if (_impl_.newgeom_ != nullptr) _impl_.newgeom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandRemoveColumnsOrRowsArchive::clear_formula_rewrite_command() {
  if (_impl_.formula_rewrite_command_ != nullptr) _impl_.formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CommandRemoveColumnsOrRowsArchive::clear_undo_merge_map() {
  if (_impl_.undo_merge_map_ != nullptr) _impl_.undo_merge_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void CommandRemoveColumnsOrRowsArchive::clear_redo_merge_map() {
  if (_impl_.redo_merge_map_ != nullptr) _impl_.redo_merge_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void CommandRemoveColumnsOrRowsArchive::clear_orig_filter_set() {
  if (_impl_.orig_filter_set_ != nullptr) _impl_.orig_filter_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
void CommandRemoveColumnsOrRowsArchive::clear_undo_command_collector() {
  _impl_.undo_command_collector_.Clear();
}
CommandRemoveColumnsOrRowsArchive::CommandRemoveColumnsOrRowsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRemoveColumnsOrRowsArchive)
}
CommandRemoveColumnsOrRowsArchive::CommandRemoveColumnsOrRowsArchive(const CommandRemoveColumnsOrRowsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRemoveColumnsOrRowsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsizes_){from._impl_.subsizes_}
    , decltype(_impl_.hiding_actions_){from._impl_.hiding_actions_}
    , decltype(_impl_.undo_command_collector_){from._impl_.undo_command_collector_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.indices_to_remove_){nullptr}
    , decltype(_impl_.cellmap_){nullptr}
    , decltype(_impl_.oldgeom_){nullptr}
    , decltype(_impl_.newgeom_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.undo_merge_map_){nullptr}
    , decltype(_impl_.redo_merge_map_){nullptr}
    , decltype(_impl_.orig_filter_set_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.width_factor_){}
    , decltype(_impl_.height_factor_){}
    , decltype(_impl_.allow_horizontal_autosize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_indices_to_remove()) {
    _this->_impl_.indices_to_remove_ = new ::TSP::IndexSet(*from._impl_.indices_to_remove_);
  }
  if (from._internal_has_cellmap()) {
    _this->_impl_.cellmap_ = new ::TST::CellMapArchive(*from._impl_.cellmap_);
  }
  if (from._internal_has_oldgeom()) {
    _this->_impl_.oldgeom_ = new ::TSD::GeometryArchive(*from._impl_.oldgeom_);
  }
  if (from._internal_has_newgeom()) {
    _this->_impl_.newgeom_ = new ::TSD::GeometryArchive(*from._impl_.newgeom_);
  }
  if (from._internal_has_formula_rewrite_command()) {
    _this->_impl_.formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.formula_rewrite_command_);
  }
  if (from._internal_has_undo_merge_map()) {
    _this->_impl_.undo_merge_map_ = new ::TSP::Reference(*from._impl_.undo_merge_map_);
  }
  if (from._internal_has_redo_merge_map()) {
    _this->_impl_.redo_merge_map_ = new ::TSP::Reference(*from._impl_.redo_merge_map_);
  }
  if (from._internal_has_orig_filter_set()) {
    _this->_impl_.orig_filter_set_ = new ::TSP::Reference(*from._impl_.orig_filter_set_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.allow_horizontal_autosize_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.allow_horizontal_autosize_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandRemoveColumnsOrRowsArchive)
}

inline void CommandRemoveColumnsOrRowsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsizes_){arena}
    , decltype(_impl_.hiding_actions_){arena}
    , decltype(_impl_.undo_command_collector_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.indices_to_remove_){nullptr}
    , decltype(_impl_.cellmap_){nullptr}
    , decltype(_impl_.oldgeom_){nullptr}
    , decltype(_impl_.newgeom_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.undo_merge_map_){nullptr}
    , decltype(_impl_.redo_merge_map_){nullptr}
    , decltype(_impl_.orig_filter_set_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.width_factor_){0}
    , decltype(_impl_.height_factor_){0}
    , decltype(_impl_.allow_horizontal_autosize_){false}
  };
}

CommandRemoveColumnsOrRowsArchive::~CommandRemoveColumnsOrRowsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRemoveColumnsOrRowsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRemoveColumnsOrRowsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subsizes_.~RepeatedField();
  _impl_.hiding_actions_.~RepeatedField();
  _impl_.undo_command_collector_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.indices_to_remove_;
  if (this != internal_default_instance()) delete _impl_.cellmap_;
  if (this != internal_default_instance()) delete _impl_.oldgeom_;
  if (this != internal_default_instance()) delete _impl_.newgeom_;
  if (this != internal_default_instance()) delete _impl_.formula_rewrite_command_;
  if (this != internal_default_instance()) delete _impl_.undo_merge_map_;
  if (this != internal_default_instance()) delete _impl_.redo_merge_map_;
  if (this != internal_default_instance()) delete _impl_.orig_filter_set_;
}

void CommandRemoveColumnsOrRowsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRemoveColumnsOrRowsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRemoveColumnsOrRowsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subsizes_.Clear();
  _impl_.hiding_actions_.Clear();
  _impl_.undo_command_collector_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.indices_to_remove_ != nullptr);
      _impl_.indices_to_remove_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cellmap_ != nullptr);
      _impl_.cellmap_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.oldgeom_ != nullptr);
      _impl_.oldgeom_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.newgeom_ != nullptr);
      _impl_.newgeom_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.formula_rewrite_command_ != nullptr);
      _impl_.formula_rewrite_command_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.undo_merge_map_ != nullptr);
      _impl_.undo_merge_map_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.redo_merge_map_ != nullptr);
      _impl_.redo_merge_map_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.orig_filter_set_ != nullptr);
    _impl_.orig_filter_set_->Clear();
  }
  if (cached_has_bits & 0x00001e00u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.allow_horizontal_autosize_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.allow_horizontal_autosize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRemoveColumnsOrRowsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CommandDirectionArchive direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TSP.IndexSet indices_to_remove = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_indices_to_remove(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive cellMap = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellmap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.GeometryArchive oldgeom = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldgeom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSD.GeometryArchive newgeom = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_newgeom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float subsizes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_subsizes(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_subsizes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formula_rewrite_command = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float width_factor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_width_factor(&has_bits);
          _impl_.width_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // required float height_factor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_height_factor(&has_bits);
          _impl_.height_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_horizontal_autosize = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_allow_horizontal_autosize(&has_bits);
          _impl_.allow_horizontal_autosize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_merge_map = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_merge_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference redo_merge_map = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_merge_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 hiding_actions = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hiding_actions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_hiding_actions(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference orig_filter_set = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_orig_filter_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TSP.Reference undo_command_collector = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_undo_command_collector(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRemoveColumnsOrRowsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRemoveColumnsOrRowsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CommandDirectionArchive direction = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_direction(), target);
  }

  // required .TSP.IndexSet indices_to_remove = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::indices_to_remove(this),
        _Internal::indices_to_remove(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive cellMap = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cellmap(this),
        _Internal::cellmap(this).GetCachedSize(), target, stream);
  }

  // required .TSD.GeometryArchive oldgeom = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::oldgeom(this),
        _Internal::oldgeom(this).GetCachedSize(), target, stream);
  }

  // required .TSD.GeometryArchive newgeom = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::newgeom(this),
        _Internal::newgeom(this).GetCachedSize(), target, stream);
  }

  // repeated float subsizes = 7;
  for (int i = 0, n = this->_internal_subsizes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_subsizes(i), target);
  }

  // optional .TSP.Reference formula_rewrite_command = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::formula_rewrite_command(this),
        _Internal::formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  // required float width_factor = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_width_factor(), target);
  }

  // required float height_factor = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_height_factor(), target);
  }

  // optional bool allow_horizontal_autosize = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_allow_horizontal_autosize(), target);
  }

  // optional .TSP.Reference undo_merge_map = 12;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::undo_merge_map(this),
        _Internal::undo_merge_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference redo_merge_map = 13;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::redo_merge_map(this),
        _Internal::redo_merge_map(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 hiding_actions = 14;
  for (int i = 0, n = this->_internal_hiding_actions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_hiding_actions(i), target);
  }

  // optional .TSP.Reference orig_filter_set = 15;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::orig_filter_set(this),
        _Internal::orig_filter_set(this).GetCachedSize(), target, stream);
  }

  // repeated .TSP.Reference undo_command_collector = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_undo_command_collector_size()); i < n; i++) {
    const auto& repfield = this->_internal_undo_command_collector(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRemoveColumnsOrRowsArchive)
  return target;
}

size_t CommandRemoveColumnsOrRowsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRemoveColumnsOrRowsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_indices_to_remove()) {
    // required .TSP.IndexSet indices_to_remove = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.indices_to_remove_);
  }

  if (_internal_has_oldgeom()) {
    // required .TSD.GeometryArchive oldgeom = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.oldgeom_);
  }

  if (_internal_has_newgeom()) {
    // required .TSD.GeometryArchive newgeom = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newgeom_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_width_factor()) {
    // required float width_factor = 9;
    total_size += 1 + 4;
  }

  if (_internal_has_height_factor()) {
    // required float height_factor = 10;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t CommandRemoveColumnsOrRowsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRemoveColumnsOrRowsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000e1b) ^ 0x00000e1b) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.IndexSet indices_to_remove = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.indices_to_remove_);

    // required .TSD.GeometryArchive oldgeom = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.oldgeom_);

    // required .TSD.GeometryArchive newgeom = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newgeom_);

    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required float width_factor = 9;
    total_size += 1 + 4;

    // required float height_factor = 10;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float subsizes = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_subsizes_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_subsizes_size());
    total_size += data_size;
  }

  // repeated uint32 hiding_actions = 14;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.hiding_actions_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hiding_actions_size());
    total_size += data_size;
  }

  // repeated .TSP.Reference undo_command_collector = 16;
  total_size += 2UL * this->_internal_undo_command_collector_size();
  for (const auto& msg : this->_impl_.undo_command_collector_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .TST.CellMapArchive cellMap = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellmap_);
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional .TSP.Reference formula_rewrite_command = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formula_rewrite_command_);
    }

    // optional .TSP.Reference undo_merge_map = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_merge_map_);
    }

    // optional .TSP.Reference redo_merge_map = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.redo_merge_map_);
    }

  }
  // optional .TSP.Reference orig_filter_set = 15;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.orig_filter_set_);
  }

  // optional bool allow_horizontal_autosize = 11;
  if (cached_has_bits & 0x00001000u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRemoveColumnsOrRowsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRemoveColumnsOrRowsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRemoveColumnsOrRowsArchive::GetClassData() const { return &_class_data_; }


void CommandRemoveColumnsOrRowsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRemoveColumnsOrRowsArchive*>(&to_msg);
  auto& from = static_cast<const CommandRemoveColumnsOrRowsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRemoveColumnsOrRowsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subsizes_.MergeFrom(from._impl_.subsizes_);
  _this->_impl_.hiding_actions_.MergeFrom(from._impl_.hiding_actions_);
  _this->_impl_.undo_command_collector_.MergeFrom(from._impl_.undo_command_collector_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_indices_to_remove()->::TSP::IndexSet::MergeFrom(
          from._internal_indices_to_remove());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cellmap()->::TST::CellMapArchive::MergeFrom(
          from._internal_cellmap());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_oldgeom()->::TSD::GeometryArchive::MergeFrom(
          from._internal_oldgeom());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_newgeom()->::TSD::GeometryArchive::MergeFrom(
          from._internal_newgeom());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_formula_rewrite_command());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_undo_merge_map()->::TSP::Reference::MergeFrom(
          from._internal_undo_merge_map());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_redo_merge_map()->::TSP::Reference::MergeFrom(
          from._internal_redo_merge_map());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_orig_filter_set()->::TSP::Reference::MergeFrom(
          from._internal_orig_filter_set());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.width_factor_ = from._impl_.width_factor_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.height_factor_ = from._impl_.height_factor_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.allow_horizontal_autosize_ = from._impl_.allow_horizontal_autosize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRemoveColumnsOrRowsArchive::CopyFrom(const CommandRemoveColumnsOrRowsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRemoveColumnsOrRowsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRemoveColumnsOrRowsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.undo_command_collector_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_indices_to_remove()) {
    if (!_impl_.indices_to_remove_->IsInitialized()) return false;
  }
  if (_internal_has_cellmap()) {
    if (!_impl_.cellmap_->IsInitialized()) return false;
  }
  if (_internal_has_oldgeom()) {
    if (!_impl_.oldgeom_->IsInitialized()) return false;
  }
  if (_internal_has_newgeom()) {
    if (!_impl_.newgeom_->IsInitialized()) return false;
  }
  if (_internal_has_formula_rewrite_command()) {
    if (!_impl_.formula_rewrite_command_->IsInitialized()) return false;
  }
  if (_internal_has_undo_merge_map()) {
    if (!_impl_.undo_merge_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_merge_map()) {
    if (!_impl_.redo_merge_map_->IsInitialized()) return false;
  }
  if (_internal_has_orig_filter_set()) {
    if (!_impl_.orig_filter_set_->IsInitialized()) return false;
  }
  return true;
}

void CommandRemoveColumnsOrRowsArchive::InternalSwap(CommandRemoveColumnsOrRowsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subsizes_.InternalSwap(&other->_impl_.subsizes_);
  _impl_.hiding_actions_.InternalSwap(&other->_impl_.hiding_actions_);
  _impl_.undo_command_collector_.InternalSwap(&other->_impl_.undo_command_collector_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRemoveColumnsOrRowsArchive, _impl_.allow_horizontal_autosize_)
      + sizeof(CommandRemoveColumnsOrRowsArchive::_impl_.allow_horizontal_autosize_)
      - PROTOBUF_FIELD_OFFSET(CommandRemoveColumnsOrRowsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRemoveColumnsOrRowsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[14]);
}

// ===================================================================

class CommandResizeColumnOrRowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandResizeColumnOrRowArchive>()._impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_newsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSD::GeometryArchive& oldgeom(const CommandResizeColumnOrRowArchive* msg);
  static void set_has_oldgeom(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSD::GeometryArchive& newgeom(const CommandResizeColumnOrRowArchive* msg);
  static void set_has_newgeom(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_old_default(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_uniformsizes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_resizemode(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TST::TableCommandArchive& super(const CommandResizeColumnOrRowArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007c) ^ 0x0000007c) != 0;
  }
};

const ::TSD::GeometryArchive&
CommandResizeColumnOrRowArchive::_Internal::oldgeom(const CommandResizeColumnOrRowArchive* msg) {
  return *msg->_impl_.oldgeom_;
}
const ::TSD::GeometryArchive&
CommandResizeColumnOrRowArchive::_Internal::newgeom(const CommandResizeColumnOrRowArchive* msg) {
  return *msg->_impl_.newgeom_;
}
const ::TST::TableCommandArchive&
CommandResizeColumnOrRowArchive::_Internal::super(const CommandResizeColumnOrRowArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandResizeColumnOrRowArchive::clear_oldgeom() {
  if (_impl_.oldgeom_ != nullptr) _impl_.oldgeom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandResizeColumnOrRowArchive::clear_newgeom() {
  if (_impl_.newgeom_ != nullptr) _impl_.newgeom_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandResizeColumnOrRowArchive::CommandResizeColumnOrRowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandResizeColumnOrRowArchive)
}
CommandResizeColumnOrRowArchive::CommandResizeColumnOrRowArchive(const CommandResizeColumnOrRowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandResizeColumnOrRowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsizes_){from._impl_.subsizes_}
    , decltype(_impl_.oldgeom_){nullptr}
    , decltype(_impl_.newgeom_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.newsize_){}
    , decltype(_impl_.old_default_){}
    , decltype(_impl_.uniformsizes_){}
    , decltype(_impl_.resizemode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_oldgeom()) {
    _this->_impl_.oldgeom_ = new ::TSD::GeometryArchive(*from._impl_.oldgeom_);
  }
  if (from._internal_has_newgeom()) {
    _this->_impl_.newgeom_ = new ::TSD::GeometryArchive(*from._impl_.newgeom_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resizemode_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.resizemode_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandResizeColumnOrRowArchive)
}

inline void CommandResizeColumnOrRowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subsizes_){arena}
    , decltype(_impl_.oldgeom_){nullptr}
    , decltype(_impl_.newgeom_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.newsize_){0}
    , decltype(_impl_.old_default_){0}
    , decltype(_impl_.uniformsizes_){false}
    , decltype(_impl_.resizemode_){0u}
  };
}

CommandResizeColumnOrRowArchive::~CommandResizeColumnOrRowArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandResizeColumnOrRowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandResizeColumnOrRowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subsizes_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.oldgeom_;
  if (this != internal_default_instance()) delete _impl_.newgeom_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandResizeColumnOrRowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandResizeColumnOrRowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandResizeColumnOrRowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subsizes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.oldgeom_ != nullptr);
      _impl_.oldgeom_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.newgeom_ != nullptr);
      _impl_.newgeom_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.old_default_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.old_default_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.uniformsizes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.resizemode_) -
        reinterpret_cast<char*>(&_impl_.uniformsizes_)) + sizeof(_impl_.resizemode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandResizeColumnOrRowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandDirectionArchive direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float newsize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_newsize(&has_bits);
          _impl_.newsize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive oldgeom = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldgeom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive newgeom = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_newgeom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float subsizes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_subsizes(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_subsizes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float old_default = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_old_default(&has_bits);
          _impl_.old_default_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool uniformsizes = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_uniformsizes(&has_bits);
          _impl_.uniformsizes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 resizemode = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_resizemode(&has_bits);
          _impl_.resizemode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandResizeColumnOrRowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandResizeColumnOrRowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandDirectionArchive direction = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_direction(), target);
  }

  // required uint32 index = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // required uint32 count = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  // required float newsize = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_newsize(), target);
  }

  // optional .TSD.GeometryArchive oldgeom = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::oldgeom(this),
        _Internal::oldgeom(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive newgeom = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::newgeom(this),
        _Internal::newgeom(this).GetCachedSize(), target, stream);
  }

  // repeated float subsizes = 7;
  for (int i = 0, n = this->_internal_subsizes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_subsizes(i), target);
  }

  // optional float old_default = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_old_default(), target);
  }

  // optional bool uniformsizes = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_uniformsizes(), target);
  }

  // optional uint32 resizemode = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_resizemode(), target);
  }

  // required .TST.TableCommandArchive super = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandResizeColumnOrRowArchive)
  return target;
}

size_t CommandResizeColumnOrRowArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandResizeColumnOrRowArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_index()) {
    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  if (_internal_has_count()) {
    // required uint32 count = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  if (_internal_has_newsize()) {
    // required float newsize = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t CommandResizeColumnOrRowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandResizeColumnOrRowArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007c) ^ 0x0000007c) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

    // required uint32 count = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

    // required float newsize = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float subsizes = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_subsizes_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_subsizes_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSD.GeometryArchive oldgeom = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldgeom_);
    }

    // optional .TSD.GeometryArchive newgeom = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newgeom_);
    }

  }
  // optional float old_default = 8;
  if (cached_has_bits & 0x00000080u) {
    total_size += 1 + 4;
  }

  if (cached_has_bits & 0x00000300u) {
    // optional bool uniformsizes = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 resizemode = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_resizemode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandResizeColumnOrRowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandResizeColumnOrRowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandResizeColumnOrRowArchive::GetClassData() const { return &_class_data_; }


void CommandResizeColumnOrRowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandResizeColumnOrRowArchive*>(&to_msg);
  auto& from = static_cast<const CommandResizeColumnOrRowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandResizeColumnOrRowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subsizes_.MergeFrom(from._impl_.subsizes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_oldgeom()->::TSD::GeometryArchive::MergeFrom(
          from._internal_oldgeom());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_newgeom()->::TSD::GeometryArchive::MergeFrom(
          from._internal_newgeom());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.newsize_ = from._impl_.newsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.old_default_ = from._impl_.old_default_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.uniformsizes_ = from._impl_.uniformsizes_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.resizemode_ = from._impl_.resizemode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandResizeColumnOrRowArchive::CopyFrom(const CommandResizeColumnOrRowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandResizeColumnOrRowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandResizeColumnOrRowArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_oldgeom()) {
    if (!_impl_.oldgeom_->IsInitialized()) return false;
  }
  if (_internal_has_newgeom()) {
    if (!_impl_.newgeom_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandResizeColumnOrRowArchive::InternalSwap(CommandResizeColumnOrRowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subsizes_.InternalSwap(&other->_impl_.subsizes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandResizeColumnOrRowArchive, _impl_.resizemode_)
      + sizeof(CommandResizeColumnOrRowArchive::_impl_.resizemode_)
      - PROTOBUF_FIELD_OFFSET(CommandResizeColumnOrRowArchive, _impl_.oldgeom_)>(
          reinterpret_cast<char*>(&_impl_.oldgeom_),
          reinterpret_cast<char*>(&other->_impl_.oldgeom_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandResizeColumnOrRowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[15]);
}

// ===================================================================

class CommandSetCellArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetCellArchive>()._impl_._has_bits_);
  static const ::TST::CellID& cellid(const CommandSetCellArchive* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::Cell& newcell(const CommandSetCellArchive* msg);
  static void set_has_newcell(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::Cell& oldcell(const CommandSetCellArchive* msg);
  static void set_has_oldcell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetCellArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_post_undo_redo_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

const ::TST::CellID&
CommandSetCellArchive::_Internal::cellid(const CommandSetCellArchive* msg) {
  return *msg->_impl_.cellid_;
}
const ::TST::Cell&
CommandSetCellArchive::_Internal::newcell(const CommandSetCellArchive* msg) {
  return *msg->_impl_.newcell_;
}
const ::TST::Cell&
CommandSetCellArchive::_Internal::oldcell(const CommandSetCellArchive* msg) {
  return *msg->_impl_.oldcell_;
}
const ::TST::TableCommandArchive&
CommandSetCellArchive::_Internal::super(const CommandSetCellArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetCellArchive::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandSetCellArchive::clear_newcell() {
  if (_impl_.newcell_ != nullptr) _impl_.newcell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetCellArchive::clear_oldcell() {
  if (_impl_.oldcell_ != nullptr) _impl_.oldcell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetCellArchive::CommandSetCellArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetCellArchive)
}
CommandSetCellArchive::CommandSetCellArchive(const CommandSetCellArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetCellArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.newcell_){nullptr}
    , decltype(_impl_.oldcell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.post_undo_redo_selection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  if (from._internal_has_newcell()) {
    _this->_impl_.newcell_ = new ::TST::Cell(*from._impl_.newcell_);
  }
  if (from._internal_has_oldcell()) {
    _this->_impl_.oldcell_ = new ::TST::Cell(*from._impl_.oldcell_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.post_undo_redo_selection_ = from._impl_.post_undo_redo_selection_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetCellArchive)
}

inline void CommandSetCellArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.newcell_){nullptr}
    , decltype(_impl_.oldcell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.post_undo_redo_selection_){false}
  };
}

CommandSetCellArchive::~CommandSetCellArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetCellArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetCellArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellid_;
  if (this != internal_default_instance()) delete _impl_.newcell_;
  if (this != internal_default_instance()) delete _impl_.oldcell_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetCellArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetCellArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetCellArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
      _impl_.cellid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.newcell_ != nullptr);
      _impl_.newcell_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.oldcell_ != nullptr);
      _impl_.oldcell_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_.post_undo_redo_selection_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetCellArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID cellID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.Cell newcell = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newcell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.Cell oldcell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldcell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool post_undo_redo_selection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_post_undo_redo_selection(&has_bits);
          _impl_.post_undo_redo_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetCellArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetCellArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID cellID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  // optional .TST.Cell newcell = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newcell(this),
        _Internal::newcell(this).GetCachedSize(), target, stream);
  }

  // optional .TST.Cell oldcell = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::oldcell(this),
        _Internal::oldcell(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional bool post_undo_redo_selection = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_post_undo_redo_selection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetCellArchive)
  return target;
}

size_t CommandSetCellArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetCellArchive)
  size_t total_size = 0;

  if (_internal_has_cellid()) {
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetCellArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetCellArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);

    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .TST.Cell newcell = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newcell_);
    }

    // optional .TST.Cell oldcell = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldcell_);
    }

  }
  // optional bool post_undo_redo_selection = 6;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetCellArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetCellArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetCellArchive::GetClassData() const { return &_class_data_; }


void CommandSetCellArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetCellArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetCellArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetCellArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_newcell()->::TST::Cell::MergeFrom(
          from._internal_newcell());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_oldcell()->::TST::Cell::MergeFrom(
          from._internal_oldcell());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.post_undo_redo_selection_ = from._impl_.post_undo_redo_selection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetCellArchive::CopyFrom(const CommandSetCellArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetCellArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetCellArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  if (_internal_has_newcell()) {
    if (!_impl_.newcell_->IsInitialized()) return false;
  }
  if (_internal_has_oldcell()) {
    if (!_impl_.oldcell_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetCellArchive::InternalSwap(CommandSetCellArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetCellArchive, _impl_.post_undo_redo_selection_)
      + sizeof(CommandSetCellArchive::_impl_.post_undo_redo_selection_)
      - PROTOBUF_FIELD_OFFSET(CommandSetCellArchive, _impl_.cellid_)>(
          reinterpret_cast<char*>(&_impl_.cellid_),
          reinterpret_cast<char*>(&other->_impl_.cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetCellArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[16]);
}

// ===================================================================

class CommandTextPreflightInsertCellArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandTextPreflightInsertCellArchive>()._impl_._has_bits_);
  static const ::TST::CellID& editing_cellid(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_editing_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::TableCommandArchive& super(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& coalesced_textcommand(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_coalesced_textcommand(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& postflightcommand(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_postflightcommand(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_grouped_with_postflight(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::Cell& editing_cell(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_editing_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& editing_storage(const CommandTextPreflightInsertCellArchive* msg);
  static void set_has_editing_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_column_hit_by_tap(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000033) ^ 0x00000033) != 0;
  }
};

const ::TST::CellID&
CommandTextPreflightInsertCellArchive::_Internal::editing_cellid(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.editing_cellid_;
}
const ::TST::TableCommandArchive&
CommandTextPreflightInsertCellArchive::_Internal::super(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandTextPreflightInsertCellArchive::_Internal::coalesced_textcommand(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.coalesced_textcommand_;
}
const ::TSP::Reference&
CommandTextPreflightInsertCellArchive::_Internal::postflightcommand(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.postflightcommand_;
}
const ::TST::Cell&
CommandTextPreflightInsertCellArchive::_Internal::editing_cell(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.editing_cell_;
}
const ::TSP::Reference&
CommandTextPreflightInsertCellArchive::_Internal::editing_storage(const CommandTextPreflightInsertCellArchive* msg) {
  return *msg->_impl_.editing_storage_;
}
void CommandTextPreflightInsertCellArchive::clear_editing_cellid() {
  if (_impl_.editing_cellid_ != nullptr) _impl_.editing_cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandTextPreflightInsertCellArchive::clear_coalesced_textcommand() {
  if (_impl_.coalesced_textcommand_ != nullptr) _impl_.coalesced_textcommand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandTextPreflightInsertCellArchive::clear_postflightcommand() {
  if (_impl_.postflightcommand_ != nullptr) _impl_.postflightcommand_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandTextPreflightInsertCellArchive::clear_editing_cell() {
  if (_impl_.editing_cell_ != nullptr) _impl_.editing_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandTextPreflightInsertCellArchive::clear_editing_storage() {
  if (_impl_.editing_storage_ != nullptr) _impl_.editing_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CommandTextPreflightInsertCellArchive::CommandTextPreflightInsertCellArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandTextPreflightInsertCellArchive)
}
CommandTextPreflightInsertCellArchive::CommandTextPreflightInsertCellArchive(const CommandTextPreflightInsertCellArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandTextPreflightInsertCellArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.editing_cellid_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.coalesced_textcommand_){nullptr}
    , decltype(_impl_.postflightcommand_){nullptr}
    , decltype(_impl_.editing_cell_){nullptr}
    , decltype(_impl_.editing_storage_){nullptr}
    , decltype(_impl_.grouped_with_postflight_){}
    , decltype(_impl_.last_column_hit_by_tap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_editing_cellid()) {
    _this->_impl_.editing_cellid_ = new ::TST::CellID(*from._impl_.editing_cellid_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_coalesced_textcommand()) {
    _this->_impl_.coalesced_textcommand_ = new ::TSP::Reference(*from._impl_.coalesced_textcommand_);
  }
  if (from._internal_has_postflightcommand()) {
    _this->_impl_.postflightcommand_ = new ::TSP::Reference(*from._impl_.postflightcommand_);
  }
  if (from._internal_has_editing_cell()) {
    _this->_impl_.editing_cell_ = new ::TST::Cell(*from._impl_.editing_cell_);
  }
  if (from._internal_has_editing_storage()) {
    _this->_impl_.editing_storage_ = new ::TSP::Reference(*from._impl_.editing_storage_);
  }
  ::memcpy(&_impl_.grouped_with_postflight_, &from._impl_.grouped_with_postflight_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_column_hit_by_tap_) -
    reinterpret_cast<char*>(&_impl_.grouped_with_postflight_)) + sizeof(_impl_.last_column_hit_by_tap_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandTextPreflightInsertCellArchive)
}

inline void CommandTextPreflightInsertCellArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.editing_cellid_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.coalesced_textcommand_){nullptr}
    , decltype(_impl_.postflightcommand_){nullptr}
    , decltype(_impl_.editing_cell_){nullptr}
    , decltype(_impl_.editing_storage_){nullptr}
    , decltype(_impl_.grouped_with_postflight_){false}
    , decltype(_impl_.last_column_hit_by_tap_){0u}
  };
}

CommandTextPreflightInsertCellArchive::~CommandTextPreflightInsertCellArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandTextPreflightInsertCellArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandTextPreflightInsertCellArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.editing_cellid_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.coalesced_textcommand_;
  if (this != internal_default_instance()) delete _impl_.postflightcommand_;
  if (this != internal_default_instance()) delete _impl_.editing_cell_;
  if (this != internal_default_instance()) delete _impl_.editing_storage_;
}

void CommandTextPreflightInsertCellArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandTextPreflightInsertCellArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandTextPreflightInsertCellArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.editing_cellid_ != nullptr);
      _impl_.editing_cellid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.coalesced_textcommand_ != nullptr);
      _impl_.coalesced_textcommand_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.postflightcommand_ != nullptr);
      _impl_.postflightcommand_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.editing_cell_ != nullptr);
      _impl_.editing_cell_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.editing_storage_ != nullptr);
      _impl_.editing_storage_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.grouped_with_postflight_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_column_hit_by_tap_) -
        reinterpret_cast<char*>(&_impl_.grouped_with_postflight_)) + sizeof(_impl_.last_column_hit_by_tap_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandTextPreflightInsertCellArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID editing_cellID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_editing_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference coalesced_textcommand = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_coalesced_textcommand(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference postflightcommand = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_postflightcommand(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool grouped_with_postflight = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_grouped_with_postflight(&has_bits);
          _impl_.grouped_with_postflight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell editing_cell = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_editing_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference editing_storage = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_editing_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_column_hit_by_tap = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_last_column_hit_by_tap(&has_bits);
          _impl_.last_column_hit_by_tap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandTextPreflightInsertCellArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandTextPreflightInsertCellArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID editing_cellID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::editing_cellid(this),
        _Internal::editing_cellid(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference coalesced_textcommand = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::coalesced_textcommand(this),
        _Internal::coalesced_textcommand(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference postflightcommand = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::postflightcommand(this),
        _Internal::postflightcommand(this).GetCachedSize(), target, stream);
  }

  // optional bool grouped_with_postflight = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_grouped_with_postflight(), target);
  }

  // required .TST.Cell editing_cell = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::editing_cell(this),
        _Internal::editing_cell(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference editing_storage = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::editing_storage(this),
        _Internal::editing_storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 last_column_hit_by_tap = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_last_column_hit_by_tap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandTextPreflightInsertCellArchive)
  return target;
}

size_t CommandTextPreflightInsertCellArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandTextPreflightInsertCellArchive)
  size_t total_size = 0;

  if (_internal_has_editing_cellid()) {
    // required .TST.CellID editing_cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cellid_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_editing_cell()) {
    // required .TST.Cell editing_cell = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cell_);
  }

  if (_internal_has_editing_storage()) {
    // required .TSP.Reference editing_storage = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_storage_);
  }

  return total_size;
}
size_t CommandTextPreflightInsertCellArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandTextPreflightInsertCellArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000033) ^ 0x00000033) == 0) {  // All required fields are present.
    // required .TST.CellID editing_cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cellid_);

    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.Cell editing_cell = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cell_);

    // required .TSP.Reference editing_storage = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_storage_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional .TSP.Reference coalesced_textcommand = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.coalesced_textcommand_);
    }

    // optional .TSP.Reference postflightcommand = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.postflightcommand_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional bool grouped_with_postflight = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 last_column_hit_by_tap = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_column_hit_by_tap());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandTextPreflightInsertCellArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandTextPreflightInsertCellArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandTextPreflightInsertCellArchive::GetClassData() const { return &_class_data_; }


void CommandTextPreflightInsertCellArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandTextPreflightInsertCellArchive*>(&to_msg);
  auto& from = static_cast<const CommandTextPreflightInsertCellArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandTextPreflightInsertCellArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_editing_cellid()->::TST::CellID::MergeFrom(
          from._internal_editing_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_coalesced_textcommand()->::TSP::Reference::MergeFrom(
          from._internal_coalesced_textcommand());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_postflightcommand()->::TSP::Reference::MergeFrom(
          from._internal_postflightcommand());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_editing_cell()->::TST::Cell::MergeFrom(
          from._internal_editing_cell());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_editing_storage()->::TSP::Reference::MergeFrom(
          from._internal_editing_storage());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.grouped_with_postflight_ = from._impl_.grouped_with_postflight_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.last_column_hit_by_tap_ = from._impl_.last_column_hit_by_tap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandTextPreflightInsertCellArchive::CopyFrom(const CommandTextPreflightInsertCellArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandTextPreflightInsertCellArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandTextPreflightInsertCellArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_editing_cellid()) {
    if (!_impl_.editing_cellid_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_coalesced_textcommand()) {
    if (!_impl_.coalesced_textcommand_->IsInitialized()) return false;
  }
  if (_internal_has_postflightcommand()) {
    if (!_impl_.postflightcommand_->IsInitialized()) return false;
  }
  if (_internal_has_editing_cell()) {
    if (!_impl_.editing_cell_->IsInitialized()) return false;
  }
  if (_internal_has_editing_storage()) {
    if (!_impl_.editing_storage_->IsInitialized()) return false;
  }
  return true;
}

void CommandTextPreflightInsertCellArchive::InternalSwap(CommandTextPreflightInsertCellArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandTextPreflightInsertCellArchive, _impl_.last_column_hit_by_tap_)
      + sizeof(CommandTextPreflightInsertCellArchive::_impl_.last_column_hit_by_tap_)
      - PROTOBUF_FIELD_OFFSET(CommandTextPreflightInsertCellArchive, _impl_.editing_cellid_)>(
          reinterpret_cast<char*>(&_impl_.editing_cellid_),
          reinterpret_cast<char*>(&other->_impl_.editing_cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandTextPreflightInsertCellArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[17]);
}

// ===================================================================

class CommandPostflightSetCellArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandPostflightSetCellArchive>()._impl_._has_bits_);
  static const ::TST::CellID& cellid(const CommandPostflightSetCellArchive* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::TableCommandArchive& super(const CommandPostflightSetCellArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& childcommandundo(const CommandPostflightSetCellArchive* msg);
  static void set_has_childcommandundo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::Cell& editing_cell(const CommandPostflightSetCellArchive* msg);
  static void set_has_editing_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::Cell& new_cell(const CommandPostflightSetCellArchive* msg);
  static void set_has_new_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& editing_storage(const CommandPostflightSetCellArchive* msg);
  static void set_has_editing_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_column_hit_by_tap(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003b) ^ 0x0000003b) != 0;
  }
};

const ::TST::CellID&
CommandPostflightSetCellArchive::_Internal::cellid(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.cellid_;
}
const ::TST::TableCommandArchive&
CommandPostflightSetCellArchive::_Internal::super(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandPostflightSetCellArchive::_Internal::childcommandundo(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.childcommandundo_;
}
const ::TST::Cell&
CommandPostflightSetCellArchive::_Internal::editing_cell(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.editing_cell_;
}
const ::TST::Cell&
CommandPostflightSetCellArchive::_Internal::new_cell(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.new_cell_;
}
const ::TSP::Reference&
CommandPostflightSetCellArchive::_Internal::editing_storage(const CommandPostflightSetCellArchive* msg) {
  return *msg->_impl_.editing_storage_;
}
void CommandPostflightSetCellArchive::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandPostflightSetCellArchive::clear_childcommandundo() {
  if (_impl_.childcommandundo_ != nullptr) _impl_.childcommandundo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandPostflightSetCellArchive::clear_editing_cell() {
  if (_impl_.editing_cell_ != nullptr) _impl_.editing_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandPostflightSetCellArchive::clear_new_cell() {
  if (_impl_.new_cell_ != nullptr) _impl_.new_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandPostflightSetCellArchive::clear_editing_storage() {
  if (_impl_.editing_storage_ != nullptr) _impl_.editing_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CommandPostflightSetCellArchive::CommandPostflightSetCellArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandPostflightSetCellArchive)
}
CommandPostflightSetCellArchive::CommandPostflightSetCellArchive(const CommandPostflightSetCellArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandPostflightSetCellArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.childcommandundo_){nullptr}
    , decltype(_impl_.editing_cell_){nullptr}
    , decltype(_impl_.new_cell_){nullptr}
    , decltype(_impl_.editing_storage_){nullptr}
    , decltype(_impl_.last_column_hit_by_tap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_childcommandundo()) {
    _this->_impl_.childcommandundo_ = new ::TSP::Reference(*from._impl_.childcommandundo_);
  }
  if (from._internal_has_editing_cell()) {
    _this->_impl_.editing_cell_ = new ::TST::Cell(*from._impl_.editing_cell_);
  }
  if (from._internal_has_new_cell()) {
    _this->_impl_.new_cell_ = new ::TST::Cell(*from._impl_.new_cell_);
  }
  if (from._internal_has_editing_storage()) {
    _this->_impl_.editing_storage_ = new ::TSP::Reference(*from._impl_.editing_storage_);
  }
  _this->_impl_.last_column_hit_by_tap_ = from._impl_.last_column_hit_by_tap_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandPostflightSetCellArchive)
}

inline void CommandPostflightSetCellArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.childcommandundo_){nullptr}
    , decltype(_impl_.editing_cell_){nullptr}
    , decltype(_impl_.new_cell_){nullptr}
    , decltype(_impl_.editing_storage_){nullptr}
    , decltype(_impl_.last_column_hit_by_tap_){0u}
  };
}

CommandPostflightSetCellArchive::~CommandPostflightSetCellArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandPostflightSetCellArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandPostflightSetCellArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellid_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.childcommandundo_;
  if (this != internal_default_instance()) delete _impl_.editing_cell_;
  if (this != internal_default_instance()) delete _impl_.new_cell_;
  if (this != internal_default_instance()) delete _impl_.editing_storage_;
}

void CommandPostflightSetCellArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandPostflightSetCellArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandPostflightSetCellArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
      _impl_.cellid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.childcommandundo_ != nullptr);
      _impl_.childcommandundo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.editing_cell_ != nullptr);
      _impl_.editing_cell_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.new_cell_ != nullptr);
      _impl_.new_cell_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.editing_storage_ != nullptr);
      _impl_.editing_storage_->Clear();
    }
  }
  _impl_.last_column_hit_by_tap_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandPostflightSetCellArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID cellID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference childcommandundo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_childcommandundo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell editing_cell = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_editing_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell new_cell = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference editing_storage = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_editing_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_column_hit_by_tap = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_last_column_hit_by_tap(&has_bits);
          _impl_.last_column_hit_by_tap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandPostflightSetCellArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandPostflightSetCellArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID cellID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference childcommandundo = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::childcommandundo(this),
        _Internal::childcommandundo(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell editing_cell = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::editing_cell(this),
        _Internal::editing_cell(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell new_cell = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::new_cell(this),
        _Internal::new_cell(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference editing_storage = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::editing_storage(this),
        _Internal::editing_storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 last_column_hit_by_tap = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_last_column_hit_by_tap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandPostflightSetCellArchive)
  return target;
}

size_t CommandPostflightSetCellArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandPostflightSetCellArchive)
  size_t total_size = 0;

  if (_internal_has_cellid()) {
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_editing_cell()) {
    // required .TST.Cell editing_cell = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cell_);
  }

  if (_internal_has_new_cell()) {
    // required .TST.Cell new_cell = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_cell_);
  }

  if (_internal_has_editing_storage()) {
    // required .TSP.Reference editing_storage = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_storage_);
  }

  return total_size;
}
size_t CommandPostflightSetCellArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandPostflightSetCellArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003b) ^ 0x0000003b) == 0) {  // All required fields are present.
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);

    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.Cell editing_cell = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_cell_);

    // required .TST.Cell new_cell = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_cell_);

    // required .TSP.Reference editing_storage = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.editing_storage_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference childcommandundo = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.childcommandundo_);
  }

  // optional uint32 last_column_hit_by_tap = 9;
  if (cached_has_bits & 0x00000040u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_column_hit_by_tap());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandPostflightSetCellArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandPostflightSetCellArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandPostflightSetCellArchive::GetClassData() const { return &_class_data_; }


void CommandPostflightSetCellArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandPostflightSetCellArchive*>(&to_msg);
  auto& from = static_cast<const CommandPostflightSetCellArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandPostflightSetCellArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_childcommandundo()->::TSP::Reference::MergeFrom(
          from._internal_childcommandundo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_editing_cell()->::TST::Cell::MergeFrom(
          from._internal_editing_cell());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_new_cell()->::TST::Cell::MergeFrom(
          from._internal_new_cell());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_editing_storage()->::TSP::Reference::MergeFrom(
          from._internal_editing_storage());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.last_column_hit_by_tap_ = from._impl_.last_column_hit_by_tap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandPostflightSetCellArchive::CopyFrom(const CommandPostflightSetCellArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandPostflightSetCellArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandPostflightSetCellArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_childcommandundo()) {
    if (!_impl_.childcommandundo_->IsInitialized()) return false;
  }
  if (_internal_has_editing_cell()) {
    if (!_impl_.editing_cell_->IsInitialized()) return false;
  }
  if (_internal_has_new_cell()) {
    if (!_impl_.new_cell_->IsInitialized()) return false;
  }
  if (_internal_has_editing_storage()) {
    if (!_impl_.editing_storage_->IsInitialized()) return false;
  }
  return true;
}

void CommandPostflightSetCellArchive::InternalSwap(CommandPostflightSetCellArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandPostflightSetCellArchive, _impl_.last_column_hit_by_tap_)
      + sizeof(CommandPostflightSetCellArchive::_impl_.last_column_hit_by_tap_)
      - PROTOBUF_FIELD_OFFSET(CommandPostflightSetCellArchive, _impl_.cellid_)>(
          reinterpret_cast<char*>(&_impl_.cellid_),
          reinterpret_cast<char*>(&other->_impl_.cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandPostflightSetCellArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[18]);
}

// ===================================================================

class CommandSetNumberOfHeadersOrFootersArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetNumberOfHeadersOrFootersArchive>()._impl_._has_bits_);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_oldcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetNumberOfHeadersOrFootersArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetNumberOfHeadersOrFootersArchive::_Internal::super(const CommandSetNumberOfHeadersOrFootersArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetNumberOfHeadersOrFootersArchive::CommandSetNumberOfHeadersOrFootersArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetNumberOfHeadersOrFootersArchive)
}
CommandSetNumberOfHeadersOrFootersArchive::CommandSetNumberOfHeadersOrFootersArchive(const CommandSetNumberOfHeadersOrFootersArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetNumberOfHeadersOrFootersArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.region_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.oldcount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.region_, &from._impl_.region_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.oldcount_) -
    reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.oldcount_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetNumberOfHeadersOrFootersArchive)
}

inline void CommandSetNumberOfHeadersOrFootersArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.oldcount_){0u}
  };
}

CommandSetNumberOfHeadersOrFootersArchive::~CommandSetNumberOfHeadersOrFootersArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetNumberOfHeadersOrFootersArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetNumberOfHeadersOrFootersArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetNumberOfHeadersOrFootersArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetNumberOfHeadersOrFootersArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.region_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.oldcount_) -
        reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.oldcount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetNumberOfHeadersOrFootersArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandRegionArchive region = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandRegionArchive_IsValid(val))) {
            _internal_set_region(static_cast<::TST::CommandRegionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 oldcount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_oldcount(&has_bits);
          _impl_.oldcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetNumberOfHeadersOrFootersArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandRegionArchive region = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_region(), target);
  }

  // required uint32 count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // required uint32 oldcount = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_oldcount(), target);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetNumberOfHeadersOrFootersArchive)
  return target;
}

size_t CommandSetNumberOfHeadersOrFootersArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_region()) {
    // required .TST.CommandRegionArchive region = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
  }

  if (_internal_has_count()) {
    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  if (_internal_has_oldcount()) {
    // required uint32 oldcount = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_oldcount());
  }

  return total_size;
}
size_t CommandSetNumberOfHeadersOrFootersArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandRegionArchive region = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_region());

    // required uint32 count = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());

    // required uint32 oldcount = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_oldcount());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetNumberOfHeadersOrFootersArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetNumberOfHeadersOrFootersArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetNumberOfHeadersOrFootersArchive::GetClassData() const { return &_class_data_; }


void CommandSetNumberOfHeadersOrFootersArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetNumberOfHeadersOrFootersArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetNumberOfHeadersOrFootersArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.oldcount_ = from._impl_.oldcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetNumberOfHeadersOrFootersArchive::CopyFrom(const CommandSetNumberOfHeadersOrFootersArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetNumberOfHeadersOrFootersArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetNumberOfHeadersOrFootersArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetNumberOfHeadersOrFootersArchive::InternalSwap(CommandSetNumberOfHeadersOrFootersArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetNumberOfHeadersOrFootersArchive, _impl_.oldcount_)
      + sizeof(CommandSetNumberOfHeadersOrFootersArchive::_impl_.oldcount_)
      - PROTOBUF_FIELD_OFFSET(CommandSetNumberOfHeadersOrFootersArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetNumberOfHeadersOrFootersArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[19]);
}

// ===================================================================

class CommandFixWPStylesInRowsOrColumnsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandFixWPStylesInRowsOrColumnsArchive>()._impl_._has_bits_);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandFixWPStylesInRowsOrColumnsArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandFixWPStylesInRowsOrColumnsArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandFixWPStylesInRowsOrColumnsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reference_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_inherit_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007f) ^ 0x0000007f) != 0;
  }
};

const ::TST::CellMapArchive&
CommandFixWPStylesInRowsOrColumnsArchive::_Internal::undo_cell_map(const CommandFixWPStylesInRowsOrColumnsArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandFixWPStylesInRowsOrColumnsArchive::_Internal::redo_cell_map(const CommandFixWPStylesInRowsOrColumnsArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::TableCommandArchive&
CommandFixWPStylesInRowsOrColumnsArchive::_Internal::super(const CommandFixWPStylesInRowsOrColumnsArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandFixWPStylesInRowsOrColumnsArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandFixWPStylesInRowsOrColumnsArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandFixWPStylesInRowsOrColumnsArchive::CommandFixWPStylesInRowsOrColumnsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandFixWPStylesInRowsOrColumnsArchive)
}
CommandFixWPStylesInRowsOrColumnsArchive::CommandFixWPStylesInRowsOrColumnsArchive(const CommandFixWPStylesInRowsOrColumnsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandFixWPStylesInRowsOrColumnsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.reference_index_){}
    , decltype(_impl_.inherit_styles_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandFixWPStylesInRowsOrColumnsArchive)
}

inline void CommandFixWPStylesInRowsOrColumnsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.reference_index_){0u}
    , decltype(_impl_.inherit_styles_){false}
    , decltype(_impl_.count_){0u}
  };
}

CommandFixWPStylesInRowsOrColumnsArchive::~CommandFixWPStylesInRowsOrColumnsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandFixWPStylesInRowsOrColumnsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandFixWPStylesInRowsOrColumnsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandFixWPStylesInRowsOrColumnsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandFixWPStylesInRowsOrColumnsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandDirectionArchive direction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 reference_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_reference_index(&has_bits);
          _impl_.reference_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool inherit_styles = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_inherit_styles(&has_bits);
          _impl_.inherit_styles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandFixWPStylesInRowsOrColumnsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandDirectionArchive direction = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_direction(), target);
  }

  // required uint32 index = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_index(), target);
  }

  // required .TST.CellMapArchive undo_cell_map = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 reference_index = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_reference_index(), target);
  }

  // required bool inherit_styles = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_inherit_styles(), target);
  }

  // optional uint32 count = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  return target;
}

size_t CommandFixWPStylesInRowsOrColumnsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  size_t total_size = 0;

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_index()) {
    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }

  if (_internal_has_reference_index()) {
    // required uint32 reference_index = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reference_index());
  }

  if (_internal_has_inherit_styles()) {
    // required bool inherit_styles = 8;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandFixWPStylesInRowsOrColumnsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000007f) ^ 0x0000007f) == 0) {  // All required fields are present.
    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandDirectionArchive direction = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required uint32 index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());

    // required uint32 reference_index = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reference_index());

    // required bool inherit_styles = 8;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 count = 9;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000080u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandFixWPStylesInRowsOrColumnsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandFixWPStylesInRowsOrColumnsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandFixWPStylesInRowsOrColumnsArchive::GetClassData() const { return &_class_data_; }


void CommandFixWPStylesInRowsOrColumnsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandFixWPStylesInRowsOrColumnsArchive*>(&to_msg);
  auto& from = static_cast<const CommandFixWPStylesInRowsOrColumnsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.reference_index_ = from._impl_.reference_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.inherit_styles_ = from._impl_.inherit_styles_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandFixWPStylesInRowsOrColumnsArchive::CopyFrom(const CommandFixWPStylesInRowsOrColumnsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandFixWPStylesInRowsOrColumnsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandFixWPStylesInRowsOrColumnsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandFixWPStylesInRowsOrColumnsArchive::InternalSwap(CommandFixWPStylesInRowsOrColumnsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandFixWPStylesInRowsOrColumnsArchive, _impl_.count_)
      + sizeof(CommandFixWPStylesInRowsOrColumnsArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(CommandFixWPStylesInRowsOrColumnsArchive, _impl_.undo_cell_map_)>(
          reinterpret_cast<char*>(&_impl_.undo_cell_map_),
          reinterpret_cast<char*>(&other->_impl_.undo_cell_map_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandFixWPStylesInRowsOrColumnsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[20]);
}

// ===================================================================

class CommandFixStylesInHeadersOrFootersArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandFixStylesInHeadersOrFootersArchive>()._impl_._has_bits_);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_old_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_new_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandFixStylesInHeadersOrFootersArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandFixStylesInHeadersOrFootersArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandFixStylesInHeadersOrFootersArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& textundo(const CommandFixStylesInHeadersOrFootersArchive* msg);
  static void set_has_textundo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000077) ^ 0x00000077) != 0;
  }
};

const ::TST::CellMapArchive&
CommandFixStylesInHeadersOrFootersArchive::_Internal::redo_cell_map(const CommandFixStylesInHeadersOrFootersArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::CellMapArchive&
CommandFixStylesInHeadersOrFootersArchive::_Internal::undo_cell_map(const CommandFixStylesInHeadersOrFootersArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::TableCommandArchive&
CommandFixStylesInHeadersOrFootersArchive::_Internal::super(const CommandFixStylesInHeadersOrFootersArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandFixStylesInHeadersOrFootersArchive::_Internal::textundo(const CommandFixStylesInHeadersOrFootersArchive* msg) {
  return *msg->_impl_.textundo_;
}
void CommandFixStylesInHeadersOrFootersArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandFixStylesInHeadersOrFootersArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandFixStylesInHeadersOrFootersArchive::clear_textundo() {
  if (_impl_.textundo_ != nullptr) _impl_.textundo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandFixStylesInHeadersOrFootersArchive::CommandFixStylesInHeadersOrFootersArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandFixStylesInHeadersOrFootersArchive)
}
CommandFixStylesInHeadersOrFootersArchive::CommandFixStylesInHeadersOrFootersArchive(const CommandFixStylesInHeadersOrFootersArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandFixStylesInHeadersOrFootersArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.textundo_){nullptr}
    , decltype(_impl_.region_){}
    , decltype(_impl_.old_number_){}
    , decltype(_impl_.new_number_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_textundo()) {
    _this->_impl_.textundo_ = new ::TSP::Reference(*from._impl_.textundo_);
  }
  ::memcpy(&_impl_.region_, &from._impl_.region_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_number_) -
    reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.new_number_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandFixStylesInHeadersOrFootersArchive)
}

inline void CommandFixStylesInHeadersOrFootersArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.textundo_){nullptr}
    , decltype(_impl_.region_){0}
    , decltype(_impl_.old_number_){0u}
    , decltype(_impl_.new_number_){0u}
  };
}

CommandFixStylesInHeadersOrFootersArchive::~CommandFixStylesInHeadersOrFootersArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandFixStylesInHeadersOrFootersArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandFixStylesInHeadersOrFootersArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.textundo_;
}

void CommandFixStylesInHeadersOrFootersArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandFixStylesInHeadersOrFootersArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.textundo_ != nullptr);
      _impl_.textundo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.region_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_number_) -
        reinterpret_cast<char*>(&_impl_.region_)) + sizeof(_impl_.new_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandFixStylesInHeadersOrFootersArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandRegionArchive region = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandRegionArchive_IsValid(val))) {
            _internal_set_region(static_cast<::TST::CommandRegionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 old_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_number(&has_bits);
          _impl_.old_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 new_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_number(&has_bits);
          _impl_.new_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference textundo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_textundo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandFixStylesInHeadersOrFootersArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandRegionArchive region = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_region(), target);
  }

  // required uint32 old_number = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_number(), target);
  }

  // required uint32 new_number = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_new_number(), target);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference textundo = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::textundo(this),
        _Internal::textundo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandFixStylesInHeadersOrFootersArchive)
  return target;
}

size_t CommandFixStylesInHeadersOrFootersArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  size_t total_size = 0;

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_region()) {
    // required .TST.CommandRegionArchive region = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_region());
  }

  if (_internal_has_old_number()) {
    // required uint32 old_number = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_number());
  }

  if (_internal_has_new_number()) {
    // required uint32 new_number = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_number());
  }

  return total_size;
}
size_t CommandFixStylesInHeadersOrFootersArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000077) ^ 0x00000077) == 0) {  // All required fields are present.
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.CellMapArchive undo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.TableCommandArchive super = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CommandRegionArchive region = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_region());

    // required uint32 old_number = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_number());

    // required uint32 new_number = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_number());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference textundo = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.textundo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandFixStylesInHeadersOrFootersArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandFixStylesInHeadersOrFootersArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandFixStylesInHeadersOrFootersArchive::GetClassData() const { return &_class_data_; }


void CommandFixStylesInHeadersOrFootersArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandFixStylesInHeadersOrFootersArchive*>(&to_msg);
  auto& from = static_cast<const CommandFixStylesInHeadersOrFootersArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_textundo()->::TSP::Reference::MergeFrom(
          from._internal_textundo());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.region_ = from._impl_.region_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.old_number_ = from._impl_.old_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.new_number_ = from._impl_.new_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandFixStylesInHeadersOrFootersArchive::CopyFrom(const CommandFixStylesInHeadersOrFootersArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandFixStylesInHeadersOrFootersArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandFixStylesInHeadersOrFootersArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_textundo()) {
    if (!_impl_.textundo_->IsInitialized()) return false;
  }
  return true;
}

void CommandFixStylesInHeadersOrFootersArchive::InternalSwap(CommandFixStylesInHeadersOrFootersArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandFixStylesInHeadersOrFootersArchive, _impl_.new_number_)
      + sizeof(CommandFixStylesInHeadersOrFootersArchive::_impl_.new_number_)
      - PROTOBUF_FIELD_OFFSET(CommandFixStylesInHeadersOrFootersArchive, _impl_.redo_cell_map_)>(
          reinterpret_cast<char*>(&_impl_.redo_cell_map_),
          reinterpret_cast<char*>(&other->_impl_.redo_cell_map_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandFixStylesInHeadersOrFootersArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[21]);
}

// ===================================================================

class CommandSetTableNameArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTableNameArchive>()._impl_._has_bits_);
  static void set_has_newtablename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_oldtablename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& newstyle(const CommandSetTableNameArchive* msg);
  static void set_has_newstyle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& oldstyle(const CommandSetTableNameArchive* msg);
  static void set_has_oldstyle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetTableNameArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& old_shape_style(const CommandSetTableNameArchive* msg);
  static void set_has_old_shape_style(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& new_shape_style(const CommandSetTableNameArchive* msg);
  static void set_has_new_shape_style(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_old_table_name_border_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_new_table_name_border_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000013) ^ 0x00000013) != 0;
  }
};

const ::TSP::Reference&
CommandSetTableNameArchive::_Internal::newstyle(const CommandSetTableNameArchive* msg) {
  return *msg->_impl_.newstyle_;
}
const ::TSP::Reference&
CommandSetTableNameArchive::_Internal::oldstyle(const CommandSetTableNameArchive* msg) {
  return *msg->_impl_.oldstyle_;
}
const ::TST::TableCommandArchive&
CommandSetTableNameArchive::_Internal::super(const CommandSetTableNameArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandSetTableNameArchive::_Internal::old_shape_style(const CommandSetTableNameArchive* msg) {
  return *msg->_impl_.old_shape_style_;
}
const ::TSP::Reference&
CommandSetTableNameArchive::_Internal::new_shape_style(const CommandSetTableNameArchive* msg) {
  return *msg->_impl_.new_shape_style_;
}
void CommandSetTableNameArchive::clear_newstyle() {
  if (_impl_.newstyle_ != nullptr) _impl_.newstyle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetTableNameArchive::clear_oldstyle() {
  if (_impl_.oldstyle_ != nullptr) _impl_.oldstyle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandSetTableNameArchive::clear_old_shape_style() {
  if (_impl_.old_shape_style_ != nullptr) _impl_.old_shape_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CommandSetTableNameArchive::clear_new_shape_style() {
  if (_impl_.new_shape_style_ != nullptr) _impl_.new_shape_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
CommandSetTableNameArchive::CommandSetTableNameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTableNameArchive)
}
CommandSetTableNameArchive::CommandSetTableNameArchive(const CommandSetTableNameArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTableNameArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newtablename_){}
    , decltype(_impl_.oldtablename_){}
    , decltype(_impl_.newstyle_){nullptr}
    , decltype(_impl_.oldstyle_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_shape_style_){nullptr}
    , decltype(_impl_.new_shape_style_){nullptr}
    , decltype(_impl_.old_table_name_border_enabled_){}
    , decltype(_impl_.new_table_name_border_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newtablename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newtablename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newtablename()) {
    _this->_impl_.newtablename_.Set(from._internal_newtablename(), 
      _this->GetArenaForAllocation());
  }
  _impl_.oldtablename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldtablename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_oldtablename()) {
    _this->_impl_.oldtablename_.Set(from._internal_oldtablename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_newstyle()) {
    _this->_impl_.newstyle_ = new ::TSP::Reference(*from._impl_.newstyle_);
  }
  if (from._internal_has_oldstyle()) {
    _this->_impl_.oldstyle_ = new ::TSP::Reference(*from._impl_.oldstyle_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_shape_style()) {
    _this->_impl_.old_shape_style_ = new ::TSP::Reference(*from._impl_.old_shape_style_);
  }
  if (from._internal_has_new_shape_style()) {
    _this->_impl_.new_shape_style_ = new ::TSP::Reference(*from._impl_.new_shape_style_);
  }
  ::memcpy(&_impl_.old_table_name_border_enabled_, &from._impl_.old_table_name_border_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_table_name_border_enabled_) -
    reinterpret_cast<char*>(&_impl_.old_table_name_border_enabled_)) + sizeof(_impl_.new_table_name_border_enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTableNameArchive)
}

inline void CommandSetTableNameArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newtablename_){}
    , decltype(_impl_.oldtablename_){}
    , decltype(_impl_.newstyle_){nullptr}
    , decltype(_impl_.oldstyle_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_shape_style_){nullptr}
    , decltype(_impl_.new_shape_style_){nullptr}
    , decltype(_impl_.old_table_name_border_enabled_){false}
    , decltype(_impl_.new_table_name_border_enabled_){false}
  };
  _impl_.newtablename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newtablename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oldtablename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oldtablename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommandSetTableNameArchive::~CommandSetTableNameArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTableNameArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTableNameArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newtablename_.Destroy();
  _impl_.oldtablename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.newstyle_;
  if (this != internal_default_instance()) delete _impl_.oldstyle_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_shape_style_;
  if (this != internal_default_instance()) delete _impl_.new_shape_style_;
}

void CommandSetTableNameArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTableNameArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTableNameArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.newtablename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.oldtablename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.newstyle_ != nullptr);
      _impl_.newstyle_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.oldstyle_ != nullptr);
      _impl_.oldstyle_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.old_shape_style_ != nullptr);
      _impl_.old_shape_style_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.new_shape_style_ != nullptr);
      _impl_.new_shape_style_->Clear();
    }
  }
  _impl_.old_table_name_border_enabled_ = false;
  _impl_.new_table_name_border_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTableNameArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string newtablename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newtablename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetTableNameArchive.newtablename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string oldtablename = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_oldtablename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetTableNameArchive.oldtablename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference newstyle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_newstyle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference oldstyle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldstyle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_shape_style = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_shape_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_shape_style = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_shape_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool old_table_name_border_enabled = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_old_table_name_border_enabled(&has_bits);
          _impl_.old_table_name_border_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool new_table_name_border_enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_new_table_name_border_enabled(&has_bits);
          _impl_.new_table_name_border_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTableNameArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTableNameArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string newtablename = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_newtablename().data(), static_cast<int>(this->_internal_newtablename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetTableNameArchive.newtablename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newtablename(), target);
  }

  // required string oldtablename = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_oldtablename().data(), static_cast<int>(this->_internal_oldtablename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetTableNameArchive.oldtablename");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_oldtablename(), target);
  }

  // optional .TSP.Reference newstyle = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::newstyle(this),
        _Internal::newstyle(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference oldstyle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::oldstyle(this),
        _Internal::oldstyle(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_shape_style = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::old_shape_style(this),
        _Internal::old_shape_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_shape_style = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::new_shape_style(this),
        _Internal::new_shape_style(this).GetCachedSize(), target, stream);
  }

  // optional bool old_table_name_border_enabled = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_old_table_name_border_enabled(), target);
  }

  // optional bool new_table_name_border_enabled = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_new_table_name_border_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTableNameArchive)
  return target;
}

size_t CommandSetTableNameArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTableNameArchive)
  size_t total_size = 0;

  if (_internal_has_newtablename()) {
    // required string newtablename = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newtablename());
  }

  if (_internal_has_oldtablename()) {
    // required string oldtablename = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_oldtablename());
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetTableNameArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTableNameArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000013) ^ 0x00000013) == 0) {  // All required fields are present.
    // required string newtablename = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newtablename());

    // required string oldtablename = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_oldtablename());

    // required .TST.TableCommandArchive super = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional .TSP.Reference newstyle = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newstyle_);
    }

    // optional .TSP.Reference oldstyle = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oldstyle_);
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .TSP.Reference old_shape_style = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_shape_style_);
    }

    // optional .TSP.Reference new_shape_style = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_shape_style_);
    }

    // optional bool old_table_name_border_enabled = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  // optional bool new_table_name_border_enabled = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTableNameArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTableNameArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTableNameArchive::GetClassData() const { return &_class_data_; }


void CommandSetTableNameArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTableNameArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTableNameArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTableNameArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_newtablename(from._internal_newtablename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_oldtablename(from._internal_oldtablename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_newstyle()->::TSP::Reference::MergeFrom(
          from._internal_newstyle());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_oldstyle()->::TSP::Reference::MergeFrom(
          from._internal_oldstyle());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_old_shape_style()->::TSP::Reference::MergeFrom(
          from._internal_old_shape_style());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_new_shape_style()->::TSP::Reference::MergeFrom(
          from._internal_new_shape_style());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.old_table_name_border_enabled_ = from._impl_.old_table_name_border_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_new_table_name_border_enabled(from._internal_new_table_name_border_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTableNameArchive::CopyFrom(const CommandSetTableNameArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTableNameArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTableNameArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_newstyle()) {
    if (!_impl_.newstyle_->IsInitialized()) return false;
  }
  if (_internal_has_oldstyle()) {
    if (!_impl_.oldstyle_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_old_shape_style()) {
    if (!_impl_.old_shape_style_->IsInitialized()) return false;
  }
  if (_internal_has_new_shape_style()) {
    if (!_impl_.new_shape_style_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTableNameArchive::InternalSwap(CommandSetTableNameArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newtablename_, lhs_arena,
      &other->_impl_.newtablename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.oldtablename_, lhs_arena,
      &other->_impl_.oldtablename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTableNameArchive, _impl_.new_table_name_border_enabled_)
      + sizeof(CommandSetTableNameArchive::_impl_.new_table_name_border_enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTableNameArchive, _impl_.newstyle_)>(
          reinterpret_cast<char*>(&_impl_.newstyle_),
          reinterpret_cast<char*>(&other->_impl_.newstyle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTableNameArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[22]);
}

// ===================================================================

class CommandSetTableNameEnabledArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTableNameEnabledArchive>()._impl_._has_bits_);
  static void set_has_table_name_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetTableNameEnabledArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetTableNameEnabledArchive::_Internal::super(const CommandSetTableNameEnabledArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetTableNameEnabledArchive::CommandSetTableNameEnabledArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTableNameEnabledArchive)
}
CommandSetTableNameEnabledArchive::CommandSetTableNameEnabledArchive(const CommandSetTableNameEnabledArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTableNameEnabledArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.table_name_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.table_name_enabled_ = from._impl_.table_name_enabled_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTableNameEnabledArchive)
}

inline void CommandSetTableNameEnabledArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.table_name_enabled_){false}
  };
}

CommandSetTableNameEnabledArchive::~CommandSetTableNameEnabledArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTableNameEnabledArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTableNameEnabledArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetTableNameEnabledArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTableNameEnabledArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTableNameEnabledArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.table_name_enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTableNameEnabledArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool table_name_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_table_name_enabled(&has_bits);
          _impl_.table_name_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTableNameEnabledArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTableNameEnabledArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool table_name_enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_table_name_enabled(), target);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTableNameEnabledArchive)
  return target;
}

size_t CommandSetTableNameEnabledArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTableNameEnabledArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_table_name_enabled()) {
    // required bool table_name_enabled = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetTableNameEnabledArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTableNameEnabledArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool table_name_enabled = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTableNameEnabledArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTableNameEnabledArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTableNameEnabledArchive::GetClassData() const { return &_class_data_; }


void CommandSetTableNameEnabledArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTableNameEnabledArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTableNameEnabledArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTableNameEnabledArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.table_name_enabled_ = from._impl_.table_name_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTableNameEnabledArchive::CopyFrom(const CommandSetTableNameEnabledArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTableNameEnabledArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTableNameEnabledArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTableNameEnabledArchive::InternalSwap(CommandSetTableNameEnabledArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTableNameEnabledArchive, _impl_.table_name_enabled_)
      + sizeof(CommandSetTableNameEnabledArchive::_impl_.table_name_enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTableNameEnabledArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTableNameEnabledArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[23]);
}

// ===================================================================

class CommandSetTableFontSizeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTableFontSizeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetTableFontSizeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandSetTableFontSizeArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandSetTableFontSizeArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resize_default_cells(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& text_undo(const CommandSetTableFontSizeArchive* msg);
  static void set_has_text_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000021) ^ 0x00000021) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetTableFontSizeArchive::_Internal::super(const CommandSetTableFontSizeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandSetTableFontSizeArchive::_Internal::undo_cell_map(const CommandSetTableFontSizeArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandSetTableFontSizeArchive::_Internal::redo_cell_map(const CommandSetTableFontSizeArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandSetTableFontSizeArchive::_Internal::text_undo(const CommandSetTableFontSizeArchive* msg) {
  return *msg->_impl_.text_undo_;
}
void CommandSetTableFontSizeArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetTableFontSizeArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetTableFontSizeArchive::clear_text_undo() {
  if (_impl_.text_undo_ != nullptr) _impl_.text_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandSetTableFontSizeArchive::CommandSetTableFontSizeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTableFontSizeArchive)
}
CommandSetTableFontSizeArchive::CommandSetTableFontSizeArchive(const CommandSetTableFontSizeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTableFontSizeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.resize_default_cells_){}
    , decltype(_impl_.scale_factor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_text_undo()) {
    _this->_impl_.text_undo_ = new ::TSP::Reference(*from._impl_.text_undo_);
  }
  ::memcpy(&_impl_.resize_default_cells_, &from._impl_.resize_default_cells_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.scale_factor_) -
    reinterpret_cast<char*>(&_impl_.resize_default_cells_)) + sizeof(_impl_.scale_factor_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTableFontSizeArchive)
}

inline void CommandSetTableFontSizeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.resize_default_cells_){false}
    , decltype(_impl_.scale_factor_){0}
  };
}

CommandSetTableFontSizeArchive::~CommandSetTableFontSizeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTableFontSizeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTableFontSizeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.text_undo_;
}

void CommandSetTableFontSizeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTableFontSizeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTableFontSizeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.text_undo_ != nullptr);
      _impl_.text_undo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.resize_default_cells_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.scale_factor_) -
        reinterpret_cast<char*>(&_impl_.resize_default_cells_)) + sizeof(_impl_.scale_factor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTableFontSizeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive undo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive redo_cell_map = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool resize_default_cells = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_resize_default_cells(&has_bits);
          _impl_.resize_default_cells_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_undo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float scale_factor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_scale_factor(&has_bits);
          _impl_.scale_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTableFontSizeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTableFontSizeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive undo_cell_map = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive redo_cell_map = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional bool resize_default_cells = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_resize_default_cells(), target);
  }

  // optional .TSP.Reference text_undo = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::text_undo(this),
        _Internal::text_undo(this).GetCachedSize(), target, stream);
  }

  // required float scale_factor = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_scale_factor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTableFontSizeArchive)
  return target;
}

size_t CommandSetTableFontSizeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTableFontSizeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_scale_factor()) {
    // required float scale_factor = 9;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t CommandSetTableFontSizeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTableFontSizeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000021) ^ 0x00000021) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required float scale_factor = 9;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TST.CellMapArchive undo_cell_map = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_cell_map_);
    }

    // optional .TST.CellMapArchive redo_cell_map = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.redo_cell_map_);
    }

    // optional .TSP.Reference text_undo = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_undo_);
    }

    // optional bool resize_default_cells = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTableFontSizeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTableFontSizeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTableFontSizeArchive::GetClassData() const { return &_class_data_; }


void CommandSetTableFontSizeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTableFontSizeArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTableFontSizeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTableFontSizeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_text_undo()->::TSP::Reference::MergeFrom(
          from._internal_text_undo());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.resize_default_cells_ = from._impl_.resize_default_cells_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.scale_factor_ = from._impl_.scale_factor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTableFontSizeArchive::CopyFrom(const CommandSetTableFontSizeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTableFontSizeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTableFontSizeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_text_undo()) {
    if (!_impl_.text_undo_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTableFontSizeArchive::InternalSwap(CommandSetTableFontSizeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTableFontSizeArchive, _impl_.scale_factor_)
      + sizeof(CommandSetTableFontSizeArchive::_impl_.scale_factor_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTableFontSizeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTableFontSizeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[24]);
}

// ===================================================================

class CommandSetTableFontNameArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTableFontNameArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetTableFontNameArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_font_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_font_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_preserve_face(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandSetTableFontNameArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandSetTableFontNameArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& text_undo(const CommandSetTableFontNameArchive* msg);
  static void set_has_text_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetTableFontNameArchive::_Internal::super(const CommandSetTableFontNameArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandSetTableFontNameArchive::_Internal::undo_cell_map(const CommandSetTableFontNameArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandSetTableFontNameArchive::_Internal::redo_cell_map(const CommandSetTableFontNameArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandSetTableFontNameArchive::_Internal::text_undo(const CommandSetTableFontNameArchive* msg) {
  return *msg->_impl_.text_undo_;
}
void CommandSetTableFontNameArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandSetTableFontNameArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandSetTableFontNameArchive::clear_text_undo() {
  if (_impl_.text_undo_ != nullptr) _impl_.text_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CommandSetTableFontNameArchive::CommandSetTableFontNameArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTableFontNameArchive)
}
CommandSetTableFontNameArchive::CommandSetTableFontNameArchive(const CommandSetTableFontNameArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTableFontNameArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.font_name_){}
    , decltype(_impl_.old_font_name_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.preserve_face_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.font_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.font_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_font_name()) {
    _this->_impl_.font_name_.Set(from._internal_font_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_font_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_font_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_old_font_name()) {
    _this->_impl_.old_font_name_.Set(from._internal_old_font_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_text_undo()) {
    _this->_impl_.text_undo_ = new ::TSP::Reference(*from._impl_.text_undo_);
  }
  _this->_impl_.preserve_face_ = from._impl_.preserve_face_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTableFontNameArchive)
}

inline void CommandSetTableFontNameArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.font_name_){}
    , decltype(_impl_.old_font_name_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.preserve_face_){false}
  };
  _impl_.font_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.font_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_font_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_font_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommandSetTableFontNameArchive::~CommandSetTableFontNameArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTableFontNameArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTableFontNameArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.font_name_.Destroy();
  _impl_.old_font_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.text_undo_;
}

void CommandSetTableFontNameArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTableFontNameArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTableFontNameArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.font_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.old_font_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.text_undo_ != nullptr);
      _impl_.text_undo_->Clear();
    }
  }
  _impl_.preserve_face_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTableFontNameArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string font_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_font_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetTableFontNameArchive.font_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string old_font_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_old_font_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetTableFontNameArchive.old_font_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool preserve_face = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_preserve_face(&has_bits);
          _impl_.preserve_face_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive undo_cell_map = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive redo_cell_map = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_undo = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTableFontNameArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTableFontNameArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required string font_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_font_name().data(), static_cast<int>(this->_internal_font_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetTableFontNameArchive.font_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_font_name(), target);
  }

  // required string old_font_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_old_font_name().data(), static_cast<int>(this->_internal_old_font_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetTableFontNameArchive.old_font_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_old_font_name(), target);
  }

  // optional bool preserve_face = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_preserve_face(), target);
  }

  // optional .TST.CellMapArchive undo_cell_map = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive redo_cell_map = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_undo = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::text_undo(this),
        _Internal::text_undo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTableFontNameArchive)
  return target;
}

size_t CommandSetTableFontNameArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTableFontNameArchive)
  size_t total_size = 0;

  if (_internal_has_font_name()) {
    // required string font_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_font_name());
  }

  if (_internal_has_old_font_name()) {
    // required string old_font_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_font_name());
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetTableFontNameArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTableFontNameArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string font_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_font_name());

    // required string old_font_name = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_old_font_name());

    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000078u) {
    // optional .TST.CellMapArchive undo_cell_map = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_cell_map_);
    }

    // optional .TST.CellMapArchive redo_cell_map = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.redo_cell_map_);
    }

    // optional .TSP.Reference text_undo = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_undo_);
    }

    // optional bool preserve_face = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTableFontNameArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTableFontNameArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTableFontNameArchive::GetClassData() const { return &_class_data_; }


void CommandSetTableFontNameArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTableFontNameArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTableFontNameArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTableFontNameArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_font_name(from._internal_font_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_old_font_name(from._internal_old_font_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_text_undo()->::TSP::Reference::MergeFrom(
          from._internal_text_undo());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.preserve_face_ = from._impl_.preserve_face_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTableFontNameArchive::CopyFrom(const CommandSetTableFontNameArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTableFontNameArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTableFontNameArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_text_undo()) {
    if (!_impl_.text_undo_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTableFontNameArchive::InternalSwap(CommandSetTableFontNameArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.font_name_, lhs_arena,
      &other->_impl_.font_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_font_name_, lhs_arena,
      &other->_impl_.old_font_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTableFontNameArchive, _impl_.preserve_face_)
      + sizeof(CommandSetTableFontNameArchive::_impl_.preserve_face_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTableFontNameArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTableFontNameArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[25]);
}

// ===================================================================

class CommandSetTableNameHeightArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTableNameHeightArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetTableNameHeightArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_table_name_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_table_name_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetTableNameHeightArchive::_Internal::super(const CommandSetTableNameHeightArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetTableNameHeightArchive::CommandSetTableNameHeightArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTableNameHeightArchive)
}
CommandSetTableNameHeightArchive::CommandSetTableNameHeightArchive(const CommandSetTableNameHeightArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTableNameHeightArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_table_name_height_){}
    , decltype(_impl_.new_table_name_height_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.old_table_name_height_, &from._impl_.old_table_name_height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_table_name_height_) -
    reinterpret_cast<char*>(&_impl_.old_table_name_height_)) + sizeof(_impl_.new_table_name_height_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTableNameHeightArchive)
}

inline void CommandSetTableNameHeightArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_table_name_height_){0}
    , decltype(_impl_.new_table_name_height_){0}
  };
}

CommandSetTableNameHeightArchive::~CommandSetTableNameHeightArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTableNameHeightArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTableNameHeightArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetTableNameHeightArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTableNameHeightArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTableNameHeightArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.old_table_name_height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_table_name_height_) -
        reinterpret_cast<char*>(&_impl_.old_table_name_height_)) + sizeof(_impl_.new_table_name_height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTableNameHeightArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double old_table_name_height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_old_table_name_height(&has_bits);
          _impl_.old_table_name_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required double new_table_name_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_new_table_name_height(&has_bits);
          _impl_.new_table_name_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTableNameHeightArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTableNameHeightArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double old_table_name_height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_old_table_name_height(), target);
  }

  // required double new_table_name_height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_new_table_name_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTableNameHeightArchive)
  return target;
}

size_t CommandSetTableNameHeightArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTableNameHeightArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_old_table_name_height()) {
    // required double old_table_name_height = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_new_table_name_height()) {
    // required double new_table_name_height = 3;
    total_size += 1 + 8;
  }

  return total_size;
}
size_t CommandSetTableNameHeightArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTableNameHeightArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double old_table_name_height = 2;
    total_size += 1 + 8;

    // required double new_table_name_height = 3;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTableNameHeightArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTableNameHeightArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTableNameHeightArchive::GetClassData() const { return &_class_data_; }


void CommandSetTableNameHeightArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTableNameHeightArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTableNameHeightArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTableNameHeightArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_table_name_height_ = from._impl_.old_table_name_height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_table_name_height_ = from._impl_.new_table_name_height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTableNameHeightArchive::CopyFrom(const CommandSetTableNameHeightArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTableNameHeightArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTableNameHeightArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTableNameHeightArchive::InternalSwap(CommandSetTableNameHeightArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTableNameHeightArchive, _impl_.new_table_name_height_)
      + sizeof(CommandSetTableNameHeightArchive::_impl_.new_table_name_height_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTableNameHeightArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTableNameHeightArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[26]);
}

// ===================================================================

class CommandStyleCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandStyleCellsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandStyleCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::ReferenceDictionary& format_properties(const CommandStyleCellsArchive* msg);
  static void set_has_format_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::SelectionArchive& selection(const CommandStyleCellsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandStyleCellsArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandStyleCellsArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& text_undo(const CommandStyleCellsArchive* msg);
  static void set_has_text_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001d) ^ 0x0000001d) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandStyleCellsArchive::_Internal::super(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::ReferenceDictionary&
CommandStyleCellsArchive::_Internal::format_properties(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.format_properties_;
}
const ::TST::SelectionArchive&
CommandStyleCellsArchive::_Internal::selection(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandStyleCellsArchive::_Internal::undo_cell_map(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandStyleCellsArchive::_Internal::redo_cell_map(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandStyleCellsArchive::_Internal::text_undo(const CommandStyleCellsArchive* msg) {
  return *msg->_impl_.text_undo_;
}
void CommandStyleCellsArchive::clear_format_properties() {
  if (_impl_.format_properties_ != nullptr) _impl_.format_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandStyleCellsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandStyleCellsArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandStyleCellsArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandStyleCellsArchive::clear_text_undo() {
  if (_impl_.text_undo_ != nullptr) _impl_.text_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CommandStyleCellsArchive::CommandStyleCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandStyleCellsArchive)
}
CommandStyleCellsArchive::CommandStyleCellsArchive(const CommandStyleCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandStyleCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_properties_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_format_properties()) {
    _this->_impl_.format_properties_ = new ::TSP::ReferenceDictionary(*from._impl_.format_properties_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_text_undo()) {
    _this->_impl_.text_undo_ = new ::TSP::Reference(*from._impl_.text_undo_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandStyleCellsArchive)
}

inline void CommandStyleCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_properties_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
  };
}

CommandStyleCellsArchive::~CommandStyleCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandStyleCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandStyleCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.format_properties_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.text_undo_;
}

void CommandStyleCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandStyleCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandStyleCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.format_properties_ != nullptr);
      _impl_.format_properties_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.text_undo_ != nullptr);
      _impl_.text_undo_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandStyleCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.ReferenceDictionary format_properties = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_format_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_undo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandStyleCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandStyleCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.ReferenceDictionary format_properties = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::format_properties(this),
        _Internal::format_properties(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_undo = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::text_undo(this),
        _Internal::text_undo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandStyleCellsArchive)
  return target;
}

size_t CommandStyleCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandStyleCellsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandStyleCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandStyleCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001d) ^ 0x0000001d) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.ReferenceDictionary format_properties = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.format_properties_);
  }

  // optional .TSP.Reference text_undo = 6;
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.text_undo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandStyleCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandStyleCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandStyleCellsArchive::GetClassData() const { return &_class_data_; }


void CommandStyleCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandStyleCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandStyleCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandStyleCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_format_properties()->::TSP::ReferenceDictionary::MergeFrom(
          from._internal_format_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_text_undo()->::TSP::Reference::MergeFrom(
          from._internal_text_undo());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandStyleCellsArchive::CopyFrom(const CommandStyleCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandStyleCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandStyleCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_format_properties()) {
    if (!_impl_.format_properties_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_text_undo()) {
    if (!_impl_.text_undo_->IsInitialized()) return false;
  }
  return true;
}

void CommandStyleCellsArchive::InternalSwap(CommandStyleCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandStyleCellsArchive, _impl_.text_undo_)
      + sizeof(CommandStyleCellsArchive::_impl_.text_undo_)
      - PROTOBUF_FIELD_OFFSET(CommandStyleCellsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandStyleCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[27]);
}

// ===================================================================

class CommandStyleTableArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandStyleTableArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandStyleTableArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::ReferenceDictionary& format_properties(const CommandStyleTableArchive* msg);
  static void set_has_format_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& old_style(const CommandStyleTableArchive* msg);
  static void set_has_old_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& new_style(const CommandStyleTableArchive* msg);
  static void set_has_new_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandStyleTableArchive::_Internal::super(const CommandStyleTableArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::ReferenceDictionary&
CommandStyleTableArchive::_Internal::format_properties(const CommandStyleTableArchive* msg) {
  return *msg->_impl_.format_properties_;
}
const ::TSP::Reference&
CommandStyleTableArchive::_Internal::old_style(const CommandStyleTableArchive* msg) {
  return *msg->_impl_.old_style_;
}
const ::TSP::Reference&
CommandStyleTableArchive::_Internal::new_style(const CommandStyleTableArchive* msg) {
  return *msg->_impl_.new_style_;
}
void CommandStyleTableArchive::clear_format_properties() {
  if (_impl_.format_properties_ != nullptr) _impl_.format_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandStyleTableArchive::clear_old_style() {
  if (_impl_.old_style_ != nullptr) _impl_.old_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandStyleTableArchive::clear_new_style() {
  if (_impl_.new_style_ != nullptr) _impl_.new_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandStyleTableArchive::CommandStyleTableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandStyleTableArchive)
}
CommandStyleTableArchive::CommandStyleTableArchive(const CommandStyleTableArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandStyleTableArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_properties_){nullptr}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_format_properties()) {
    _this->_impl_.format_properties_ = new ::TSP::ReferenceDictionary(*from._impl_.format_properties_);
  }
  if (from._internal_has_old_style()) {
    _this->_impl_.old_style_ = new ::TSP::Reference(*from._impl_.old_style_);
  }
  if (from._internal_has_new_style()) {
    _this->_impl_.new_style_ = new ::TSP::Reference(*from._impl_.new_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandStyleTableArchive)
}

inline void CommandStyleTableArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.format_properties_){nullptr}
    , decltype(_impl_.old_style_){nullptr}
    , decltype(_impl_.new_style_){nullptr}
  };
}

CommandStyleTableArchive::~CommandStyleTableArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandStyleTableArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandStyleTableArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.format_properties_;
  if (this != internal_default_instance()) delete _impl_.old_style_;
  if (this != internal_default_instance()) delete _impl_.new_style_;
}

void CommandStyleTableArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandStyleTableArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandStyleTableArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.format_properties_ != nullptr);
      _impl_.format_properties_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.old_style_ != nullptr);
      _impl_.old_style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.new_style_ != nullptr);
      _impl_.new_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandStyleTableArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.ReferenceDictionary format_properties = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_format_properties(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandStyleTableArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandStyleTableArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.ReferenceDictionary format_properties = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::format_properties(this),
        _Internal::format_properties(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::old_style(this),
        _Internal::old_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::new_style(this),
        _Internal::new_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandStyleTableArchive)
  return target;
}

size_t CommandStyleTableArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandStyleTableArchive)
  size_t total_size = 0;

  // required .TST.TableCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.ReferenceDictionary format_properties = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.format_properties_);
    }

    // optional .TSP.Reference old_style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_style_);
    }

    // optional .TSP.Reference new_style = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandStyleTableArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandStyleTableArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandStyleTableArchive::GetClassData() const { return &_class_data_; }


void CommandStyleTableArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandStyleTableArchive*>(&to_msg);
  auto& from = static_cast<const CommandStyleTableArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandStyleTableArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_format_properties()->::TSP::ReferenceDictionary::MergeFrom(
          from._internal_format_properties());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_old_style()->::TSP::Reference::MergeFrom(
          from._internal_old_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_new_style()->::TSP::Reference::MergeFrom(
          from._internal_new_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandStyleTableArchive::CopyFrom(const CommandStyleTableArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandStyleTableArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandStyleTableArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_format_properties()) {
    if (!_impl_.format_properties_->IsInitialized()) return false;
  }
  if (_internal_has_old_style()) {
    if (!_impl_.old_style_->IsInitialized()) return false;
  }
  if (_internal_has_new_style()) {
    if (!_impl_.new_style_->IsInitialized()) return false;
  }
  return true;
}

void CommandStyleTableArchive::InternalSwap(CommandStyleTableArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandStyleTableArchive, _impl_.new_style_)
      + sizeof(CommandStyleTableArchive::_impl_.new_style_)
      - PROTOBUF_FIELD_OFFSET(CommandStyleTableArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandStyleTableArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[28]);
}

// ===================================================================

class CommandFillCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandFillCellsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandFillCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& sourceselection(const CommandFillCellsArchive* msg);
  static void set_has_sourceselection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellRange& sourcecellrange(const CommandFillCellsArchive* msg);
  static void set_has_sourcecellrange(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellRange& targetcellrange(const CommandFillCellsArchive* msg);
  static void set_has_targetcellrange(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandFillCellsArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_filldirection(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TST::SelectionArchive& targetselection(const CommandFillCellsArchive* msg);
  static void set_has_targetselection(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandFillCellsArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000ff) ^ 0x000000ff) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandFillCellsArchive::_Internal::super(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandFillCellsArchive::_Internal::sourceselection(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.sourceselection_;
}
const ::TST::CellRange&
CommandFillCellsArchive::_Internal::sourcecellrange(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.sourcecellrange_;
}
const ::TST::CellRange&
CommandFillCellsArchive::_Internal::targetcellrange(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.targetcellrange_;
}
const ::TST::CellMapArchive&
CommandFillCellsArchive::_Internal::undo_cell_map(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::SelectionArchive&
CommandFillCellsArchive::_Internal::targetselection(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.targetselection_;
}
const ::TST::CellMapArchive&
CommandFillCellsArchive::_Internal::redo_cell_map(const CommandFillCellsArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandFillCellsArchive::clear_sourceselection() {
  if (_impl_.sourceselection_ != nullptr) _impl_.sourceselection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandFillCellsArchive::clear_sourcecellrange() {
  if (_impl_.sourcecellrange_ != nullptr) _impl_.sourcecellrange_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandFillCellsArchive::clear_targetcellrange() {
  if (_impl_.targetcellrange_ != nullptr) _impl_.targetcellrange_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandFillCellsArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandFillCellsArchive::clear_targetselection() {
  if (_impl_.targetselection_ != nullptr) _impl_.targetselection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CommandFillCellsArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
CommandFillCellsArchive::CommandFillCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandFillCellsArchive)
}
CommandFillCellsArchive::CommandFillCellsArchive(const CommandFillCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandFillCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.sourceselection_){nullptr}
    , decltype(_impl_.sourcecellrange_){nullptr}
    , decltype(_impl_.targetcellrange_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.targetselection_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.filldirection_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_sourceselection()) {
    _this->_impl_.sourceselection_ = new ::TST::SelectionArchive(*from._impl_.sourceselection_);
  }
  if (from._internal_has_sourcecellrange()) {
    _this->_impl_.sourcecellrange_ = new ::TST::CellRange(*from._impl_.sourcecellrange_);
  }
  if (from._internal_has_targetcellrange()) {
    _this->_impl_.targetcellrange_ = new ::TST::CellRange(*from._impl_.targetcellrange_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_targetselection()) {
    _this->_impl_.targetselection_ = new ::TST::SelectionArchive(*from._impl_.targetselection_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  _this->_impl_.filldirection_ = from._impl_.filldirection_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandFillCellsArchive)
}

inline void CommandFillCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.sourceselection_){nullptr}
    , decltype(_impl_.sourcecellrange_){nullptr}
    , decltype(_impl_.targetcellrange_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.targetselection_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.filldirection_){1}
  };
}

CommandFillCellsArchive::~CommandFillCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandFillCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandFillCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.sourceselection_;
  if (this != internal_default_instance()) delete _impl_.sourcecellrange_;
  if (this != internal_default_instance()) delete _impl_.targetcellrange_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.targetselection_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandFillCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandFillCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandFillCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sourceselection_ != nullptr);
      _impl_.sourceselection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.sourcecellrange_ != nullptr);
      _impl_.sourcecellrange_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.targetcellrange_ != nullptr);
      _impl_.targetcellrange_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.targetselection_ != nullptr);
      _impl_.targetselection_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    _impl_.filldirection_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandFillCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive sourceselection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sourceselection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellRange sourcecellrange = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sourcecellrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellRange targetcellrange = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetcellrange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.FillDirectionArchive fillDirection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FillDirectionArchive_IsValid(val))) {
            _internal_set_filldirection(static_cast<::TST::FillDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive targetselection = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetselection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandFillCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandFillCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive sourceselection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sourceselection(this),
        _Internal::sourceselection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellRange sourcecellrange = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sourcecellrange(this),
        _Internal::sourcecellrange(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellRange targetcellrange = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::targetcellrange(this),
        _Internal::targetcellrange(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.FillDirectionArchive fillDirection = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_filldirection(), target);
  }

  // required .TST.SelectionArchive targetselection = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::targetselection(this),
        _Internal::targetselection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandFillCellsArchive)
  return target;
}

size_t CommandFillCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandFillCellsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_sourceselection()) {
    // required .TST.SelectionArchive sourceselection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sourceselection_);
  }

  if (_internal_has_sourcecellrange()) {
    // required .TST.CellRange sourcecellrange = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sourcecellrange_);
  }

  if (_internal_has_targetcellrange()) {
    // required .TST.CellRange targetcellrange = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetcellrange_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_targetselection()) {
    // required .TST.SelectionArchive targetselection = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetselection_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_filldirection()) {
    // required .TST.FillDirectionArchive fillDirection = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filldirection());
  }

  return total_size;
}
size_t CommandFillCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandFillCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000000ff) ^ 0x000000ff) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive sourceselection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sourceselection_);

    // required .TST.CellRange sourcecellrange = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sourcecellrange_);

    // required .TST.CellRange targetcellrange = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetcellrange_);

    // required .TST.CellMapArchive undo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.SelectionArchive targetselection = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetselection_);

    // required .TST.CellMapArchive redo_cell_map = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.FillDirectionArchive fillDirection = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filldirection());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandFillCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandFillCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandFillCellsArchive::GetClassData() const { return &_class_data_; }


void CommandFillCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandFillCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandFillCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandFillCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sourceselection()->::TST::SelectionArchive::MergeFrom(
          from._internal_sourceselection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sourcecellrange()->::TST::CellRange::MergeFrom(
          from._internal_sourcecellrange());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_targetcellrange()->::TST::CellRange::MergeFrom(
          from._internal_targetcellrange());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_targetselection()->::TST::SelectionArchive::MergeFrom(
          from._internal_targetselection());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.filldirection_ = from._impl_.filldirection_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandFillCellsArchive::CopyFrom(const CommandFillCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandFillCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandFillCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_sourceselection()) {
    if (!_impl_.sourceselection_->IsInitialized()) return false;
  }
  if (_internal_has_sourcecellrange()) {
    if (!_impl_.sourcecellrange_->IsInitialized()) return false;
  }
  if (_internal_has_targetcellrange()) {
    if (!_impl_.targetcellrange_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_targetselection()) {
    if (!_impl_.targetselection_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandFillCellsArchive::InternalSwap(CommandFillCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandFillCellsArchive, _impl_.redo_cell_map_)
      + sizeof(CommandFillCellsArchive::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandFillCellsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
  swap(_impl_.filldirection_, other->_impl_.filldirection_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandFillCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[29]);
}

// ===================================================================

class CommandReplaceTextArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandReplaceTextArchive>()._impl_._has_bits_);
  static const ::TST::CellID& cellid(const CommandReplaceTextArchive* msg);
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::Cell& newcell(const CommandReplaceTextArchive* msg);
  static void set_has_newcell(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::Cell& oldcell(const CommandReplaceTextArchive* msg);
  static void set_has_oldcell(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandReplaceTextArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& child_command_undo(const CommandReplaceTextArchive* msg);
  static void set_has_child_command_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::CellID&
CommandReplaceTextArchive::_Internal::cellid(const CommandReplaceTextArchive* msg) {
  return *msg->_impl_.cellid_;
}
const ::TST::Cell&
CommandReplaceTextArchive::_Internal::newcell(const CommandReplaceTextArchive* msg) {
  return *msg->_impl_.newcell_;
}
const ::TST::Cell&
CommandReplaceTextArchive::_Internal::oldcell(const CommandReplaceTextArchive* msg) {
  return *msg->_impl_.oldcell_;
}
const ::TST::TableCommandArchive&
CommandReplaceTextArchive::_Internal::super(const CommandReplaceTextArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandReplaceTextArchive::_Internal::child_command_undo(const CommandReplaceTextArchive* msg) {
  return *msg->_impl_.child_command_undo_;
}
void CommandReplaceTextArchive::clear_cellid() {
  if (_impl_.cellid_ != nullptr) _impl_.cellid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandReplaceTextArchive::clear_newcell() {
  if (_impl_.newcell_ != nullptr) _impl_.newcell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandReplaceTextArchive::clear_oldcell() {
  if (_impl_.oldcell_ != nullptr) _impl_.oldcell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandReplaceTextArchive::clear_child_command_undo() {
  if (_impl_.child_command_undo_ != nullptr) _impl_.child_command_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandReplaceTextArchive::CommandReplaceTextArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandReplaceTextArchive)
}
CommandReplaceTextArchive::CommandReplaceTextArchive(const CommandReplaceTextArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandReplaceTextArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.newcell_){nullptr}
    , decltype(_impl_.oldcell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.child_command_undo_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cellid()) {
    _this->_impl_.cellid_ = new ::TST::CellID(*from._impl_.cellid_);
  }
  if (from._internal_has_newcell()) {
    _this->_impl_.newcell_ = new ::TST::Cell(*from._impl_.newcell_);
  }
  if (from._internal_has_oldcell()) {
    _this->_impl_.oldcell_ = new ::TST::Cell(*from._impl_.oldcell_);
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_child_command_undo()) {
    _this->_impl_.child_command_undo_ = new ::TSP::Reference(*from._impl_.child_command_undo_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandReplaceTextArchive)
}

inline void CommandReplaceTextArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cellid_){nullptr}
    , decltype(_impl_.newcell_){nullptr}
    , decltype(_impl_.oldcell_){nullptr}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.child_command_undo_){nullptr}
  };
}

CommandReplaceTextArchive::~CommandReplaceTextArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandReplaceTextArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandReplaceTextArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cellid_;
  if (this != internal_default_instance()) delete _impl_.newcell_;
  if (this != internal_default_instance()) delete _impl_.oldcell_;
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.child_command_undo_;
}

void CommandReplaceTextArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandReplaceTextArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandReplaceTextArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cellid_ != nullptr);
      _impl_.cellid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.newcell_ != nullptr);
      _impl_.newcell_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.oldcell_ != nullptr);
      _impl_.oldcell_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.child_command_undo_ != nullptr);
      _impl_.child_command_undo_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandReplaceTextArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CellID cellID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cellid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell newcell = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newcell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell oldcell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_oldcell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference child_command_undo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_child_command_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandReplaceTextArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandReplaceTextArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CellID cellID = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cellid(this),
        _Internal::cellid(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell newcell = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newcell(this),
        _Internal::newcell(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell oldcell = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::oldcell(this),
        _Internal::oldcell(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableCommandArchive super = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference child_command_undo = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::child_command_undo(this),
        _Internal::child_command_undo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandReplaceTextArchive)
  return target;
}

size_t CommandReplaceTextArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandReplaceTextArchive)
  size_t total_size = 0;

  if (_internal_has_cellid()) {
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);
  }

  if (_internal_has_newcell()) {
    // required .TST.Cell newcell = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newcell_);
  }

  if (_internal_has_oldcell()) {
    // required .TST.Cell oldcell = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.oldcell_);
  }

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandReplaceTextArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandReplaceTextArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.CellID cellID = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cellid_);

    // required .TST.Cell newcell = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newcell_);

    // required .TST.Cell oldcell = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.oldcell_);

    // required .TST.TableCommandArchive super = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference child_command_undo = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.child_command_undo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandReplaceTextArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandReplaceTextArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandReplaceTextArchive::GetClassData() const { return &_class_data_; }


void CommandReplaceTextArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandReplaceTextArchive*>(&to_msg);
  auto& from = static_cast<const CommandReplaceTextArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandReplaceTextArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cellid()->::TST::CellID::MergeFrom(
          from._internal_cellid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_newcell()->::TST::Cell::MergeFrom(
          from._internal_newcell());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_oldcell()->::TST::Cell::MergeFrom(
          from._internal_oldcell());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_child_command_undo()->::TSP::Reference::MergeFrom(
          from._internal_child_command_undo());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandReplaceTextArchive::CopyFrom(const CommandReplaceTextArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandReplaceTextArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandReplaceTextArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cellid()) {
    if (!_impl_.cellid_->IsInitialized()) return false;
  }
  if (_internal_has_newcell()) {
    if (!_impl_.newcell_->IsInitialized()) return false;
  }
  if (_internal_has_oldcell()) {
    if (!_impl_.oldcell_->IsInitialized()) return false;
  }
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_child_command_undo()) {
    if (!_impl_.child_command_undo_->IsInitialized()) return false;
  }
  return true;
}

void CommandReplaceTextArchive::InternalSwap(CommandReplaceTextArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandReplaceTextArchive, _impl_.child_command_undo_)
      + sizeof(CommandReplaceTextArchive::_impl_.child_command_undo_)
      - PROTOBUF_FIELD_OFFSET(CommandReplaceTextArchive, _impl_.cellid_)>(
          reinterpret_cast<char*>(&_impl_.cellid_),
          reinterpret_cast<char*>(&other->_impl_.cellid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandReplaceTextArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[30]);
}

// ===================================================================

class CommandReplaceAllTextArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandReplaceAllTextArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& tableinfo(const CommandReplaceAllTextArchive* msg);
  static void set_has_tableinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandReplaceAllTextArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandReplaceAllTextArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TSP::Reference&
CommandReplaceAllTextArchive::_Internal::tableinfo(const CommandReplaceAllTextArchive* msg) {
  return *msg->_impl_.tableinfo_;
}
const ::TST::CellMapArchive&
CommandReplaceAllTextArchive::_Internal::undo_cell_map(const CommandReplaceAllTextArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandReplaceAllTextArchive::_Internal::redo_cell_map(const CommandReplaceAllTextArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandReplaceAllTextArchive::clear_tableinfo() {
  if (_impl_.tableinfo_ != nullptr) _impl_.tableinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandReplaceAllTextArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandReplaceAllTextArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandReplaceAllTextArchive::CommandReplaceAllTextArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandReplaceAllTextArchive)
}
CommandReplaceAllTextArchive::CommandReplaceAllTextArchive(const CommandReplaceAllTextArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandReplaceAllTextArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tableinfo_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tableinfo()) {
    _this->_impl_.tableinfo_ = new ::TSP::Reference(*from._impl_.tableinfo_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandReplaceAllTextArchive)
}

inline void CommandReplaceAllTextArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tableinfo_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
  };
}

CommandReplaceAllTextArchive::~CommandReplaceAllTextArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandReplaceAllTextArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandReplaceAllTextArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tableinfo_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandReplaceAllTextArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandReplaceAllTextArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandReplaceAllTextArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.tableinfo_ != nullptr);
      _impl_.tableinfo_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandReplaceAllTextArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSP.Reference tableInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tableinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandReplaceAllTextArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandReplaceAllTextArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSP.Reference tableInfo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tableinfo(this),
        _Internal::tableinfo(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandReplaceAllTextArchive)
  return target;
}

size_t CommandReplaceAllTextArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandReplaceAllTextArchive)
  size_t total_size = 0;

  if (_internal_has_tableinfo()) {
    // required .TSP.Reference tableInfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tableinfo_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandReplaceAllTextArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandReplaceAllTextArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TSP.Reference tableInfo = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tableinfo_);

    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandReplaceAllTextArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandReplaceAllTextArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandReplaceAllTextArchive::GetClassData() const { return &_class_data_; }


void CommandReplaceAllTextArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandReplaceAllTextArchive*>(&to_msg);
  auto& from = static_cast<const CommandReplaceAllTextArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandReplaceAllTextArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tableinfo()->::TSP::Reference::MergeFrom(
          from._internal_tableinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandReplaceAllTextArchive::CopyFrom(const CommandReplaceAllTextArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandReplaceAllTextArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandReplaceAllTextArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_tableinfo()) {
    if (!_impl_.tableinfo_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandReplaceAllTextArchive::InternalSwap(CommandReplaceAllTextArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandReplaceAllTextArchive, _impl_.redo_cell_map_)
      + sizeof(CommandReplaceAllTextArchive::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandReplaceAllTextArchive, _impl_.tableinfo_)>(
          reinterpret_cast<char*>(&_impl_.tableinfo_),
          reinterpret_cast<char*>(&other->_impl_.tableinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandReplaceAllTextArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[31]);
}

// ===================================================================

class CommandSetRepeatingHeaderEnabledArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetRepeatingHeaderEnabledArchive>()._impl_._has_bits_);
  static void set_has_repeating_header_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetRepeatingHeaderEnabledArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetRepeatingHeaderEnabledArchive::_Internal::super(const CommandSetRepeatingHeaderEnabledArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetRepeatingHeaderEnabledArchive::CommandSetRepeatingHeaderEnabledArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetRepeatingHeaderEnabledArchive)
}
CommandSetRepeatingHeaderEnabledArchive::CommandSetRepeatingHeaderEnabledArchive(const CommandSetRepeatingHeaderEnabledArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetRepeatingHeaderEnabledArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.repeating_header_enabled_){}
    , decltype(_impl_.direction_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.repeating_header_enabled_, &from._impl_.repeating_header_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.direction_) -
    reinterpret_cast<char*>(&_impl_.repeating_header_enabled_)) + sizeof(_impl_.direction_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetRepeatingHeaderEnabledArchive)
}

inline void CommandSetRepeatingHeaderEnabledArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.repeating_header_enabled_){false}
    , decltype(_impl_.direction_){0}
  };
}

CommandSetRepeatingHeaderEnabledArchive::~CommandSetRepeatingHeaderEnabledArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetRepeatingHeaderEnabledArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetRepeatingHeaderEnabledArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetRepeatingHeaderEnabledArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetRepeatingHeaderEnabledArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.repeating_header_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.direction_) -
        reinterpret_cast<char*>(&_impl_.repeating_header_enabled_)) + sizeof(_impl_.direction_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetRepeatingHeaderEnabledArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool repeating_header_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_repeating_header_enabled(&has_bits);
          _impl_.repeating_header_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CommandDirectionArchive direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetRepeatingHeaderEnabledArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool repeating_header_enabled = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_repeating_header_enabled(), target);
  }

  // required .TST.CommandDirectionArchive direction = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_direction(), target);
  }

  // required .TST.TableCommandArchive super = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetRepeatingHeaderEnabledArchive)
  return target;
}

size_t CommandSetRepeatingHeaderEnabledArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_repeating_header_enabled()) {
    // required bool repeating_header_enabled = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  return total_size;
}
size_t CommandSetRepeatingHeaderEnabledArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool repeating_header_enabled = 1;
    total_size += 1 + 1;

    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetRepeatingHeaderEnabledArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetRepeatingHeaderEnabledArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetRepeatingHeaderEnabledArchive::GetClassData() const { return &_class_data_; }


void CommandSetRepeatingHeaderEnabledArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetRepeatingHeaderEnabledArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetRepeatingHeaderEnabledArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.repeating_header_enabled_ = from._impl_.repeating_header_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetRepeatingHeaderEnabledArchive::CopyFrom(const CommandSetRepeatingHeaderEnabledArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetRepeatingHeaderEnabledArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetRepeatingHeaderEnabledArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetRepeatingHeaderEnabledArchive::InternalSwap(CommandSetRepeatingHeaderEnabledArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetRepeatingHeaderEnabledArchive, _impl_.direction_)
      + sizeof(CommandSetRepeatingHeaderEnabledArchive::_impl_.direction_)
      - PROTOBUF_FIELD_OFFSET(CommandSetRepeatingHeaderEnabledArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetRepeatingHeaderEnabledArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[32]);
}

// ===================================================================

class CommandSetFiltersEnabledArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFiltersEnabledArchive>()._impl_._has_bits_);
  static void set_has_enable_filters(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableCommandArchive& super(const CommandSetFiltersEnabledArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetFiltersEnabledArchive::_Internal::super(const CommandSetFiltersEnabledArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetFiltersEnabledArchive::CommandSetFiltersEnabledArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFiltersEnabledArchive)
}
CommandSetFiltersEnabledArchive::CommandSetFiltersEnabledArchive(const CommandSetFiltersEnabledArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFiltersEnabledArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.enable_filters_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.enable_filters_ = from._impl_.enable_filters_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFiltersEnabledArchive)
}

inline void CommandSetFiltersEnabledArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.enable_filters_){false}
  };
}

CommandSetFiltersEnabledArchive::~CommandSetFiltersEnabledArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFiltersEnabledArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFiltersEnabledArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFiltersEnabledArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFiltersEnabledArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFiltersEnabledArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.enable_filters_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFiltersEnabledArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enable_filters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_filters(&has_bits);
          _impl_.enable_filters_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableCommandArchive super = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFiltersEnabledArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFiltersEnabledArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool enable_filters = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_filters(), target);
  }

  // required .TST.TableCommandArchive super = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFiltersEnabledArchive)
  return target;
}

size_t CommandSetFiltersEnabledArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFiltersEnabledArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_enable_filters()) {
    // required bool enable_filters = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetFiltersEnabledArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFiltersEnabledArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool enable_filters = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFiltersEnabledArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFiltersEnabledArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFiltersEnabledArchive::GetClassData() const { return &_class_data_; }


void CommandSetFiltersEnabledArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFiltersEnabledArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFiltersEnabledArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFiltersEnabledArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.enable_filters_ = from._impl_.enable_filters_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFiltersEnabledArchive::CopyFrom(const CommandSetFiltersEnabledArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFiltersEnabledArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFiltersEnabledArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFiltersEnabledArchive::InternalSwap(CommandSetFiltersEnabledArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFiltersEnabledArchive, _impl_.enable_filters_)
      + sizeof(CommandSetFiltersEnabledArchive::_impl_.enable_filters_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFiltersEnabledArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFiltersEnabledArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[33]);
}

// ===================================================================

class CommandAddQuickFilterRulesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandAddQuickFilterRulesArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandAddQuickFilterRulesArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filter_set_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandAddQuickFilterRulesArchive::_Internal::super(const CommandAddQuickFilterRulesArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandAddQuickFilterRulesArchive::clear_rules() {
  _impl_.rules_.Clear();
}
CommandAddQuickFilterRulesArchive::CommandAddQuickFilterRulesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandAddQuickFilterRulesArchive)
}
CommandAddQuickFilterRulesArchive::CommandAddQuickFilterRulesArchive(const CommandAddQuickFilterRulesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandAddQuickFilterRulesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rules_){from._impl_.rules_}
    , decltype(_impl_.rule_indices_){from._impl_.rule_indices_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){}
    , decltype(_impl_.filter_set_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.filter_index_, &from._impl_.filter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.filter_set_enabled_) -
    reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.filter_set_enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandAddQuickFilterRulesArchive)
}

inline void CommandAddQuickFilterRulesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rules_){arena}
    , decltype(_impl_.rule_indices_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){0u}
    , decltype(_impl_.filter_set_enabled_){false}
  };
}

CommandAddQuickFilterRulesArchive::~CommandAddQuickFilterRulesArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandAddQuickFilterRulesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandAddQuickFilterRulesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rules_.~RepeatedPtrField();
  _impl_.rule_indices_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandAddQuickFilterRulesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandAddQuickFilterRulesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandAddQuickFilterRulesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rules_.Clear();
  _impl_.rule_indices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.filter_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.filter_set_enabled_) -
        reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.filter_set_enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandAddQuickFilterRulesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.FilterRuleArchive rules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required uint32 filter_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_filter_index(&has_bits);
          _impl_.filter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 rule_indices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_rule_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_rule_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool filter_set_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_filter_set_enabled(&has_bits);
          _impl_.filter_set_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandAddQuickFilterRulesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandAddQuickFilterRulesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TST.FilterRuleArchive rules = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required uint32 filter_index = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_filter_index(), target);
  }

  // repeated uint32 rule_indices = 4;
  for (int i = 0, n = this->_internal_rule_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rule_indices(i), target);
  }

  // required bool filter_set_enabled = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_filter_set_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandAddQuickFilterRulesArchive)
  return target;
}

size_t CommandAddQuickFilterRulesArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandAddQuickFilterRulesArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_index()) {
    // required uint32 filter_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());
  }

  if (_internal_has_filter_set_enabled()) {
    // required bool filter_set_enabled = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandAddQuickFilterRulesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandAddQuickFilterRulesArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 filter_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());

    // required bool filter_set_enabled = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.FilterRuleArchive rules = 2;
  total_size += 1UL * this->_internal_rules_size();
  for (const auto& msg : this->_impl_.rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 rule_indices = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.rule_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_rule_indices_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandAddQuickFilterRulesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandAddQuickFilterRulesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandAddQuickFilterRulesArchive::GetClassData() const { return &_class_data_; }


void CommandAddQuickFilterRulesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandAddQuickFilterRulesArchive*>(&to_msg);
  auto& from = static_cast<const CommandAddQuickFilterRulesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandAddQuickFilterRulesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rules_.MergeFrom(from._impl_.rules_);
  _this->_impl_.rule_indices_.MergeFrom(from._impl_.rule_indices_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.filter_index_ = from._impl_.filter_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filter_set_enabled_ = from._impl_.filter_set_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandAddQuickFilterRulesArchive::CopyFrom(const CommandAddQuickFilterRulesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandAddQuickFilterRulesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandAddQuickFilterRulesArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.rules_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandAddQuickFilterRulesArchive::InternalSwap(CommandAddQuickFilterRulesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rules_.InternalSwap(&other->_impl_.rules_);
  _impl_.rule_indices_.InternalSwap(&other->_impl_.rule_indices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandAddQuickFilterRulesArchive, _impl_.filter_set_enabled_)
      + sizeof(CommandAddQuickFilterRulesArchive::_impl_.filter_set_enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandAddQuickFilterRulesArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandAddQuickFilterRulesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[34]);
}

// ===================================================================

class CommandDeleteFilterRulesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandDeleteFilterRulesArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandDeleteFilterRulesArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filter_removed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_filter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filter_set_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandDeleteFilterRulesArchive::_Internal::super(const CommandDeleteFilterRulesArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandDeleteFilterRulesArchive::clear_undo_rules() {
  _impl_.undo_rules_.Clear();
}
CommandDeleteFilterRulesArchive::CommandDeleteFilterRulesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandDeleteFilterRulesArchive)
}
CommandDeleteFilterRulesArchive::CommandDeleteFilterRulesArchive(const CommandDeleteFilterRulesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandDeleteFilterRulesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_rules_){from._impl_.undo_rules_}
    , decltype(_impl_.rule_indices_){from._impl_.rule_indices_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){}
    , decltype(_impl_.filter_removed_){}
    , decltype(_impl_.filter_set_enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.filter_index_, &from._impl_.filter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.filter_set_enabled_) -
    reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.filter_set_enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandDeleteFilterRulesArchive)
}

inline void CommandDeleteFilterRulesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.undo_rules_){arena}
    , decltype(_impl_.rule_indices_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){0u}
    , decltype(_impl_.filter_removed_){false}
    , decltype(_impl_.filter_set_enabled_){false}
  };
}

CommandDeleteFilterRulesArchive::~CommandDeleteFilterRulesArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandDeleteFilterRulesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandDeleteFilterRulesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.undo_rules_.~RepeatedPtrField();
  _impl_.rule_indices_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandDeleteFilterRulesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandDeleteFilterRulesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandDeleteFilterRulesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.undo_rules_.Clear();
  _impl_.rule_indices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.filter_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.filter_set_enabled_) -
        reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.filter_set_enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandDeleteFilterRulesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.FilterRuleArchive undo_rules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_undo_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 rule_indices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_rule_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_rule_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool filter_removed = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_filter_removed(&has_bits);
          _impl_.filter_removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 filter_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_filter_index(&has_bits);
          _impl_.filter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool filter_set_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_filter_set_enabled(&has_bits);
          _impl_.filter_set_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandDeleteFilterRulesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandDeleteFilterRulesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // repeated .TST.FilterRuleArchive undo_rules = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_undo_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_undo_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 rule_indices = 3;
  for (int i = 0, n = this->_internal_rule_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rule_indices(i), target);
  }

  // required bool filter_removed = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_filter_removed(), target);
  }

  // required uint32 filter_index = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_filter_index(), target);
  }

  // required bool filter_set_enabled = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_filter_set_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandDeleteFilterRulesArchive)
  return target;
}

size_t CommandDeleteFilterRulesArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandDeleteFilterRulesArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_index()) {
    // required uint32 filter_index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());
  }

  if (_internal_has_filter_removed()) {
    // required bool filter_removed = 4;
    total_size += 1 + 1;
  }

  if (_internal_has_filter_set_enabled()) {
    // required bool filter_set_enabled = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandDeleteFilterRulesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandDeleteFilterRulesArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 filter_index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());

    // required bool filter_removed = 4;
    total_size += 1 + 1;

    // required bool filter_set_enabled = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.FilterRuleArchive undo_rules = 2;
  total_size += 1UL * this->_internal_undo_rules_size();
  for (const auto& msg : this->_impl_.undo_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 rule_indices = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.rule_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_rule_indices_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandDeleteFilterRulesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandDeleteFilterRulesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandDeleteFilterRulesArchive::GetClassData() const { return &_class_data_; }


void CommandDeleteFilterRulesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandDeleteFilterRulesArchive*>(&to_msg);
  auto& from = static_cast<const CommandDeleteFilterRulesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandDeleteFilterRulesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.undo_rules_.MergeFrom(from._impl_.undo_rules_);
  _this->_impl_.rule_indices_.MergeFrom(from._impl_.rule_indices_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.filter_index_ = from._impl_.filter_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.filter_removed_ = from._impl_.filter_removed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.filter_set_enabled_ = from._impl_.filter_set_enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandDeleteFilterRulesArchive::CopyFrom(const CommandDeleteFilterRulesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandDeleteFilterRulesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandDeleteFilterRulesArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.undo_rules_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandDeleteFilterRulesArchive::InternalSwap(CommandDeleteFilterRulesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.undo_rules_.InternalSwap(&other->_impl_.undo_rules_);
  _impl_.rule_indices_.InternalSwap(&other->_impl_.rule_indices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandDeleteFilterRulesArchive, _impl_.filter_set_enabled_)
      + sizeof(CommandDeleteFilterRulesArchive::_impl_.filter_set_enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandDeleteFilterRulesArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandDeleteFilterRulesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[35]);
}

// ===================================================================

class CommandModifyFilterRuleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandModifyFilterRuleArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandModifyFilterRuleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::FilterRuleArchive& undo_rule(const CommandModifyFilterRuleArchive* msg);
  static void set_has_undo_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::FilterRuleArchive& redo_rule(const CommandModifyFilterRuleArchive* msg);
  static void set_has_redo_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rule_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandModifyFilterRuleArchive::_Internal::super(const CommandModifyFilterRuleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::FilterRuleArchive&
CommandModifyFilterRuleArchive::_Internal::undo_rule(const CommandModifyFilterRuleArchive* msg) {
  return *msg->_impl_.undo_rule_;
}
const ::TST::FilterRuleArchive&
CommandModifyFilterRuleArchive::_Internal::redo_rule(const CommandModifyFilterRuleArchive* msg) {
  return *msg->_impl_.redo_rule_;
}
void CommandModifyFilterRuleArchive::clear_undo_rule() {
  if (_impl_.undo_rule_ != nullptr) _impl_.undo_rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandModifyFilterRuleArchive::clear_redo_rule() {
  if (_impl_.redo_rule_ != nullptr) _impl_.redo_rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandModifyFilterRuleArchive::CommandModifyFilterRuleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandModifyFilterRuleArchive)
}
CommandModifyFilterRuleArchive::CommandModifyFilterRuleArchive(const CommandModifyFilterRuleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandModifyFilterRuleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_rule_){nullptr}
    , decltype(_impl_.redo_rule_){nullptr}
    , decltype(_impl_.rule_index_){}
    , decltype(_impl_.filter_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_rule()) {
    _this->_impl_.undo_rule_ = new ::TST::FilterRuleArchive(*from._impl_.undo_rule_);
  }
  if (from._internal_has_redo_rule()) {
    _this->_impl_.redo_rule_ = new ::TST::FilterRuleArchive(*from._impl_.redo_rule_);
  }
  ::memcpy(&_impl_.rule_index_, &from._impl_.rule_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.filter_index_) -
    reinterpret_cast<char*>(&_impl_.rule_index_)) + sizeof(_impl_.filter_index_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandModifyFilterRuleArchive)
}

inline void CommandModifyFilterRuleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_rule_){nullptr}
    , decltype(_impl_.redo_rule_){nullptr}
    , decltype(_impl_.rule_index_){0u}
    , decltype(_impl_.filter_index_){0u}
  };
}

CommandModifyFilterRuleArchive::~CommandModifyFilterRuleArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandModifyFilterRuleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandModifyFilterRuleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_rule_;
  if (this != internal_default_instance()) delete _impl_.redo_rule_;
}

void CommandModifyFilterRuleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandModifyFilterRuleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandModifyFilterRuleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_rule_ != nullptr);
      _impl_.undo_rule_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_rule_ != nullptr);
      _impl_.redo_rule_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.rule_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.filter_index_) -
        reinterpret_cast<char*>(&_impl_.rule_index_)) + sizeof(_impl_.filter_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandModifyFilterRuleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.FilterRuleArchive undo_rule = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.FilterRuleArchive redo_rule = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 rule_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rule_index(&has_bits);
          _impl_.rule_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 filter_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_filter_index(&has_bits);
          _impl_.filter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandModifyFilterRuleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandModifyFilterRuleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.FilterRuleArchive undo_rule = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_rule(this),
        _Internal::undo_rule(this).GetCachedSize(), target, stream);
  }

  // required .TST.FilterRuleArchive redo_rule = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_rule(this),
        _Internal::redo_rule(this).GetCachedSize(), target, stream);
  }

  // required uint32 rule_index = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rule_index(), target);
  }

  // required uint32 filter_index = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_filter_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandModifyFilterRuleArchive)
  return target;
}

size_t CommandModifyFilterRuleArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandModifyFilterRuleArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undo_rule()) {
    // required .TST.FilterRuleArchive undo_rule = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_rule_);
  }

  if (_internal_has_redo_rule()) {
    // required .TST.FilterRuleArchive redo_rule = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_rule_);
  }

  if (_internal_has_rule_index()) {
    // required uint32 rule_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_index());
  }

  if (_internal_has_filter_index()) {
    // required uint32 filter_index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());
  }

  return total_size;
}
size_t CommandModifyFilterRuleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandModifyFilterRuleArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.FilterRuleArchive undo_rule = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_rule_);

    // required .TST.FilterRuleArchive redo_rule = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_rule_);

    // required uint32 rule_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_index());

    // required uint32 filter_index = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandModifyFilterRuleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandModifyFilterRuleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandModifyFilterRuleArchive::GetClassData() const { return &_class_data_; }


void CommandModifyFilterRuleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandModifyFilterRuleArchive*>(&to_msg);
  auto& from = static_cast<const CommandModifyFilterRuleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandModifyFilterRuleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_rule()->::TST::FilterRuleArchive::MergeFrom(
          from._internal_undo_rule());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_rule()->::TST::FilterRuleArchive::MergeFrom(
          from._internal_redo_rule());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rule_index_ = from._impl_.rule_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.filter_index_ = from._impl_.filter_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandModifyFilterRuleArchive::CopyFrom(const CommandModifyFilterRuleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandModifyFilterRuleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandModifyFilterRuleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_rule()) {
    if (!_impl_.undo_rule_->IsInitialized()) return false;
  }
  if (_internal_has_redo_rule()) {
    if (!_impl_.redo_rule_->IsInitialized()) return false;
  }
  return true;
}

void CommandModifyFilterRuleArchive::InternalSwap(CommandModifyFilterRuleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandModifyFilterRuleArchive, _impl_.filter_index_)
      + sizeof(CommandModifyFilterRuleArchive::_impl_.filter_index_)
      - PROTOBUF_FIELD_OFFSET(CommandModifyFilterRuleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandModifyFilterRuleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[36]);
}

// ===================================================================

class CommandApplyStrokePresetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyStrokePresetArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandApplyStrokePresetArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandApplyStrokePresetArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandApplyStrokePresetArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::SelectionArchive& selection(const CommandApplyStrokePresetArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::SelectionArchive& expanded_selection(const CommandApplyStrokePresetArchive* msg);
  static void set_has_expanded_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000002f) ^ 0x0000002f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandApplyStrokePresetArchive::_Internal::super(const CommandApplyStrokePresetArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandApplyStrokePresetArchive::_Internal::undo_cell_map(const CommandApplyStrokePresetArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandApplyStrokePresetArchive::_Internal::redo_cell_map(const CommandApplyStrokePresetArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::SelectionArchive&
CommandApplyStrokePresetArchive::_Internal::selection(const CommandApplyStrokePresetArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::SelectionArchive&
CommandApplyStrokePresetArchive::_Internal::expanded_selection(const CommandApplyStrokePresetArchive* msg) {
  return *msg->_impl_.expanded_selection_;
}
void CommandApplyStrokePresetArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandApplyStrokePresetArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandApplyStrokePresetArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandApplyStrokePresetArchive::clear_expanded_selection() {
  if (_impl_.expanded_selection_ != nullptr) _impl_.expanded_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandApplyStrokePresetArchive::CommandApplyStrokePresetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyStrokePresetArchive)
}
CommandApplyStrokePresetArchive::CommandApplyStrokePresetArchive(const CommandApplyStrokePresetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyStrokePresetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.expanded_selection_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_expanded_selection()) {
    _this->_impl_.expanded_selection_ = new ::TST::SelectionArchive(*from._impl_.expanded_selection_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyStrokePresetArchive)
}

inline void CommandApplyStrokePresetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.expanded_selection_){nullptr}
    , decltype(_impl_.preset_index_){0}
  };
}

CommandApplyStrokePresetArchive::~CommandApplyStrokePresetArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyStrokePresetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyStrokePresetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.expanded_selection_;
}

void CommandApplyStrokePresetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyStrokePresetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyStrokePresetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.expanded_selection_ != nullptr);
      _impl_.expanded_selection_->Clear();
    }
  }
  _impl_.preset_index_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyStrokePresetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 preset_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive expanded_selection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_expanded_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyStrokePresetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyStrokePresetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required int32 preset_index = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_preset_index(), target);
  }

  // optional .TST.SelectionArchive expanded_selection = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::expanded_selection(this),
        _Internal::expanded_selection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyStrokePresetArchive)
  return target;
}

size_t CommandApplyStrokePresetArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyStrokePresetArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_preset_index()) {
    // required int32 preset_index = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preset_index());
  }

  return total_size;
}
size_t CommandApplyStrokePresetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyStrokePresetArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000002f) ^ 0x0000002f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required int32 preset_index = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preset_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TST.SelectionArchive expanded_selection = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.expanded_selection_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyStrokePresetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyStrokePresetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyStrokePresetArchive::GetClassData() const { return &_class_data_; }


void CommandApplyStrokePresetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyStrokePresetArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyStrokePresetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyStrokePresetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_expanded_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_expanded_selection());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyStrokePresetArchive::CopyFrom(const CommandApplyStrokePresetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyStrokePresetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyStrokePresetArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_expanded_selection()) {
    if (!_impl_.expanded_selection_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyStrokePresetArchive::InternalSwap(CommandApplyStrokePresetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyStrokePresetArchive, _impl_.preset_index_)
      + sizeof(CommandApplyStrokePresetArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyStrokePresetArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyStrokePresetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[37]);
}

// ===================================================================

class CommandApplyTableStylePresetArchive_StyleIndexTuple::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyTableStylePresetArchive_StyleIndexTuple>()._impl_._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& cell_style(const CommandApplyTableStylePresetArchive_StyleIndexTuple* msg);
  static void set_has_cell_style(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& text_style(const CommandApplyTableStylePresetArchive_StyleIndexTuple* msg);
  static void set_has_text_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::TSP::Reference&
CommandApplyTableStylePresetArchive_StyleIndexTuple::_Internal::cell_style(const CommandApplyTableStylePresetArchive_StyleIndexTuple* msg) {
  return *msg->_impl_.cell_style_;
}
const ::TSP::Reference&
CommandApplyTableStylePresetArchive_StyleIndexTuple::_Internal::text_style(const CommandApplyTableStylePresetArchive_StyleIndexTuple* msg) {
  return *msg->_impl_.text_style_;
}
void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_cell_style() {
  if (_impl_.cell_style_ != nullptr) _impl_.cell_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandApplyTableStylePresetArchive_StyleIndexTuple::clear_text_style() {
  if (_impl_.text_style_ != nullptr) _impl_.text_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandApplyTableStylePresetArchive_StyleIndexTuple::CommandApplyTableStylePresetArchive_StyleIndexTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
}
CommandApplyTableStylePresetArchive_StyleIndexTuple::CommandApplyTableStylePresetArchive_StyleIndexTuple(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyTableStylePresetArchive_StyleIndexTuple* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cell_style()) {
    _this->_impl_.cell_style_ = new ::TSP::Reference(*from._impl_.cell_style_);
  }
  if (from._internal_has_text_style()) {
    _this->_impl_.text_style_ = new ::TSP::Reference(*from._impl_.text_style_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
}

inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cell_style_){nullptr}
    , decltype(_impl_.text_style_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

CommandApplyTableStylePresetArchive_StyleIndexTuple::~CommandApplyTableStylePresetArchive_StyleIndexTuple() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyTableStylePresetArchive_StyleIndexTuple::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cell_style_;
  if (this != internal_default_instance()) delete _impl_.text_style_;
}

void CommandApplyTableStylePresetArchive_StyleIndexTuple::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyTableStylePresetArchive_StyleIndexTuple::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.cell_style_ != nullptr);
      _impl_.cell_style_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.text_style_ != nullptr);
      _impl_.text_style_->Clear();
    }
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyTableStylePresetArchive_StyleIndexTuple::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference cell_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_style = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyTableStylePresetArchive_StyleIndexTuple::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 index = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_index(), target);
  }

  // optional .TSP.Reference cell_style = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cell_style(this),
        _Internal::cell_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_style = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::text_style(this),
        _Internal::text_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  return target;
}

size_t CommandApplyTableStylePresetArchive_StyleIndexTuple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  size_t total_size = 0;

  // required uint32 index = 1;
  if (_internal_has_index()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSP.Reference cell_style = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cell_style_);
    }

    // optional .TSP.Reference text_style = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.text_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyTableStylePresetArchive_StyleIndexTuple::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyTableStylePresetArchive_StyleIndexTuple::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyTableStylePresetArchive_StyleIndexTuple::GetClassData() const { return &_class_data_; }


void CommandApplyTableStylePresetArchive_StyleIndexTuple::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyTableStylePresetArchive_StyleIndexTuple*>(&to_msg);
  auto& from = static_cast<const CommandApplyTableStylePresetArchive_StyleIndexTuple&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cell_style()->::TSP::Reference::MergeFrom(
          from._internal_cell_style());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_text_style()->::TSP::Reference::MergeFrom(
          from._internal_text_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyTableStylePresetArchive_StyleIndexTuple::CopyFrom(const CommandApplyTableStylePresetArchive_StyleIndexTuple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyTableStylePresetArchive.StyleIndexTuple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyTableStylePresetArchive_StyleIndexTuple::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cell_style()) {
    if (!_impl_.cell_style_->IsInitialized()) return false;
  }
  if (_internal_has_text_style()) {
    if (!_impl_.text_style_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyTableStylePresetArchive_StyleIndexTuple::InternalSwap(CommandApplyTableStylePresetArchive_StyleIndexTuple* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_.index_)
      + sizeof(CommandApplyTableStylePresetArchive_StyleIndexTuple::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyTableStylePresetArchive_StyleIndexTuple, _impl_.cell_style_)>(
          reinterpret_cast<char*>(&_impl_.cell_style_),
          reinterpret_cast<char*>(&other->_impl_.cell_style_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyTableStylePresetArchive_StyleIndexTuple::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[38]);
}

// ===================================================================

class CommandApplyTableStylePresetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyTableStylePresetArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TST::TableStyleNetworkArchive& old_table_styles(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_old_table_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::TableStyleNetworkArchive& new_table_styles(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_new_table_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_apply_clears_all(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& font_size_command(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_font_size_command(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& set_style_apply_clears_all_flag_command(const CommandApplyTableStylePresetArchive* msg);
  static void set_has_set_style_apply_clears_all_flag_command(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000009f) ^ 0x0000009f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandApplyTableStylePresetArchive::_Internal::super(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandApplyTableStylePresetArchive::_Internal::undo_cell_map(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandApplyTableStylePresetArchive::_Internal::redo_cell_map(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::TableStyleNetworkArchive&
CommandApplyTableStylePresetArchive::_Internal::old_table_styles(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.old_table_styles_;
}
const ::TST::TableStyleNetworkArchive&
CommandApplyTableStylePresetArchive::_Internal::new_table_styles(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.new_table_styles_;
}
const ::TSP::Reference&
CommandApplyTableStylePresetArchive::_Internal::font_size_command(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.font_size_command_;
}
const ::TSP::Reference&
CommandApplyTableStylePresetArchive::_Internal::set_style_apply_clears_all_flag_command(const CommandApplyTableStylePresetArchive* msg) {
  return *msg->_impl_.set_style_apply_clears_all_flag_command_;
}
void CommandApplyTableStylePresetArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandApplyTableStylePresetArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandApplyTableStylePresetArchive::clear_old_table_styles() {
  if (_impl_.old_table_styles_ != nullptr) _impl_.old_table_styles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandApplyTableStylePresetArchive::clear_new_table_styles() {
  if (_impl_.new_table_styles_ != nullptr) _impl_.new_table_styles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandApplyTableStylePresetArchive::clear_font_size_command() {
  if (_impl_.font_size_command_ != nullptr) _impl_.font_size_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CommandApplyTableStylePresetArchive::clear_set_style_apply_clears_all_flag_command() {
  if (_impl_.set_style_apply_clears_all_flag_command_ != nullptr) _impl_.set_style_apply_clears_all_flag_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
CommandApplyTableStylePresetArchive::CommandApplyTableStylePresetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyTableStylePresetArchive)
}
CommandApplyTableStylePresetArchive::CommandApplyTableStylePresetArchive(const CommandApplyTableStylePresetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyTableStylePresetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.row_style_index_tuples_){from._impl_.row_style_index_tuples_}
    , decltype(_impl_.col_style_index_tuples_){from._impl_.col_style_index_tuples_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_table_styles_){nullptr}
    , decltype(_impl_.new_table_styles_){nullptr}
    , decltype(_impl_.font_size_command_){nullptr}
    , decltype(_impl_.set_style_apply_clears_all_flag_command_){nullptr}
    , decltype(_impl_.preset_index_){}
    , decltype(_impl_.apply_clears_all_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_old_table_styles()) {
    _this->_impl_.old_table_styles_ = new ::TST::TableStyleNetworkArchive(*from._impl_.old_table_styles_);
  }
  if (from._internal_has_new_table_styles()) {
    _this->_impl_.new_table_styles_ = new ::TST::TableStyleNetworkArchive(*from._impl_.new_table_styles_);
  }
  if (from._internal_has_font_size_command()) {
    _this->_impl_.font_size_command_ = new ::TSP::Reference(*from._impl_.font_size_command_);
  }
  if (from._internal_has_set_style_apply_clears_all_flag_command()) {
    _this->_impl_.set_style_apply_clears_all_flag_command_ = new ::TSP::Reference(*from._impl_.set_style_apply_clears_all_flag_command_);
  }
  ::memcpy(&_impl_.preset_index_, &from._impl_.preset_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.apply_clears_all_) -
    reinterpret_cast<char*>(&_impl_.preset_index_)) + sizeof(_impl_.apply_clears_all_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyTableStylePresetArchive)
}

inline void CommandApplyTableStylePresetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.row_style_index_tuples_){arena}
    , decltype(_impl_.col_style_index_tuples_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_table_styles_){nullptr}
    , decltype(_impl_.new_table_styles_){nullptr}
    , decltype(_impl_.font_size_command_){nullptr}
    , decltype(_impl_.set_style_apply_clears_all_flag_command_){nullptr}
    , decltype(_impl_.preset_index_){0}
    , decltype(_impl_.apply_clears_all_){false}
  };
}

CommandApplyTableStylePresetArchive::~CommandApplyTableStylePresetArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyTableStylePresetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyTableStylePresetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.row_style_index_tuples_.~RepeatedPtrField();
  _impl_.col_style_index_tuples_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.old_table_styles_;
  if (this != internal_default_instance()) delete _impl_.new_table_styles_;
  if (this != internal_default_instance()) delete _impl_.font_size_command_;
  if (this != internal_default_instance()) delete _impl_.set_style_apply_clears_all_flag_command_;
}

void CommandApplyTableStylePresetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyTableStylePresetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyTableStylePresetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.row_style_index_tuples_.Clear();
  _impl_.col_style_index_tuples_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.old_table_styles_ != nullptr);
      _impl_.old_table_styles_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.new_table_styles_ != nullptr);
      _impl_.new_table_styles_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.font_size_command_ != nullptr);
      _impl_.font_size_command_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.set_style_apply_clears_all_flag_command_ != nullptr);
      _impl_.set_style_apply_clears_all_flag_command_->Clear();
    }
  }
  _impl_.preset_index_ = 0;
  _impl_.apply_clears_all_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyTableStylePresetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 preset_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive old_table_styles = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_table_styles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive new_table_styles = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_table_styles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool apply_clears_all = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_apply_clears_all(&has_bits);
          _impl_.apply_clears_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference font_size_command = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_font_size_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference set_style_apply_clears_all_flag_command = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_style_apply_clears_all_flag_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple row_style_index_tuples = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_row_style_index_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple col_style_index_tuples = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_col_style_index_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyTableStylePresetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyTableStylePresetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required int32 preset_index = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_preset_index(), target);
  }

  // required .TST.TableStyleNetworkArchive old_table_styles = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::old_table_styles(this),
        _Internal::old_table_styles(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableStyleNetworkArchive new_table_styles = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::new_table_styles(this),
        _Internal::new_table_styles(this).GetCachedSize(), target, stream);
  }

  // optional bool apply_clears_all = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_apply_clears_all(), target);
  }

  // optional .TSP.Reference font_size_command = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::font_size_command(this),
        _Internal::font_size_command(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference set_style_apply_clears_all_flag_command = 12;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::set_style_apply_clears_all_flag_command(this),
        _Internal::set_style_apply_clears_all_flag_command(this).GetCachedSize(), target, stream);
  }

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple row_style_index_tuples = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_row_style_index_tuples_size()); i < n; i++) {
    const auto& repfield = this->_internal_row_style_index_tuples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple col_style_index_tuples = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_col_style_index_tuples_size()); i < n; i++) {
    const auto& repfield = this->_internal_col_style_index_tuples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyTableStylePresetArchive)
  return target;
}

size_t CommandApplyTableStylePresetArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyTableStylePresetArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_old_table_styles()) {
    // required .TST.TableStyleNetworkArchive old_table_styles = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_table_styles_);
  }

  if (_internal_has_new_table_styles()) {
    // required .TST.TableStyleNetworkArchive new_table_styles = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_table_styles_);
  }

  if (_internal_has_preset_index()) {
    // required int32 preset_index = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preset_index());
  }

  return total_size;
}
size_t CommandApplyTableStylePresetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyTableStylePresetArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000009f) ^ 0x0000009f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.TableStyleNetworkArchive old_table_styles = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_table_styles_);

    // required .TST.TableStyleNetworkArchive new_table_styles = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_table_styles_);

    // required int32 preset_index = 5;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preset_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple row_style_index_tuples = 13;
  total_size += 1UL * this->_internal_row_style_index_tuples_size();
  for (const auto& msg : this->_impl_.row_style_index_tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .TST.CommandApplyTableStylePresetArchive.StyleIndexTuple col_style_index_tuples = 14;
  total_size += 1UL * this->_internal_col_style_index_tuples_size();
  for (const auto& msg : this->_impl_.col_style_index_tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000060u) {
    // optional .TSP.Reference font_size_command = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.font_size_command_);
    }

    // optional .TSP.Reference set_style_apply_clears_all_flag_command = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.set_style_apply_clears_all_flag_command_);
    }

  }
  // optional bool apply_clears_all = 10;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyTableStylePresetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyTableStylePresetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyTableStylePresetArchive::GetClassData() const { return &_class_data_; }


void CommandApplyTableStylePresetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyTableStylePresetArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyTableStylePresetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyTableStylePresetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.row_style_index_tuples_.MergeFrom(from._impl_.row_style_index_tuples_);
  _this->_impl_.col_style_index_tuples_.MergeFrom(from._impl_.col_style_index_tuples_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_old_table_styles()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_old_table_styles());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_new_table_styles()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_new_table_styles());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_font_size_command()->::TSP::Reference::MergeFrom(
          from._internal_font_size_command());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_set_style_apply_clears_all_flag_command()->::TSP::Reference::MergeFrom(
          from._internal_set_style_apply_clears_all_flag_command());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_apply_clears_all(from._internal_apply_clears_all());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyTableStylePresetArchive::CopyFrom(const CommandApplyTableStylePresetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyTableStylePresetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyTableStylePresetArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.row_style_index_tuples_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.col_style_index_tuples_))
    return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_old_table_styles()) {
    if (!_impl_.old_table_styles_->IsInitialized()) return false;
  }
  if (_internal_has_new_table_styles()) {
    if (!_impl_.new_table_styles_->IsInitialized()) return false;
  }
  if (_internal_has_font_size_command()) {
    if (!_impl_.font_size_command_->IsInitialized()) return false;
  }
  if (_internal_has_set_style_apply_clears_all_flag_command()) {
    if (!_impl_.set_style_apply_clears_all_flag_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyTableStylePresetArchive::InternalSwap(CommandApplyTableStylePresetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.row_style_index_tuples_.InternalSwap(&other->_impl_.row_style_index_tuples_);
  _impl_.col_style_index_tuples_.InternalSwap(&other->_impl_.col_style_index_tuples_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyTableStylePresetArchive, _impl_.apply_clears_all_)
      + sizeof(CommandApplyTableStylePresetArchive::_impl_.apply_clears_all_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyTableStylePresetArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyTableStylePresetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[39]);
}

// ===================================================================

class CommandSetStyleApplyClearsAllFlagArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetStyleApplyClearsAllFlagArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetStyleApplyClearsAllFlagArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_apply_clears_all(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetStyleApplyClearsAllFlagArchive::_Internal::super(const CommandSetStyleApplyClearsAllFlagArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetStyleApplyClearsAllFlagArchive::CommandSetStyleApplyClearsAllFlagArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetStyleApplyClearsAllFlagArchive)
}
CommandSetStyleApplyClearsAllFlagArchive::CommandSetStyleApplyClearsAllFlagArchive(const CommandSetStyleApplyClearsAllFlagArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetStyleApplyClearsAllFlagArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.apply_clears_all_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.apply_clears_all_ = from._impl_.apply_clears_all_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetStyleApplyClearsAllFlagArchive)
}

inline void CommandSetStyleApplyClearsAllFlagArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.apply_clears_all_){false}
  };
}

CommandSetStyleApplyClearsAllFlagArchive::~CommandSetStyleApplyClearsAllFlagArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetStyleApplyClearsAllFlagArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetStyleApplyClearsAllFlagArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetStyleApplyClearsAllFlagArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetStyleApplyClearsAllFlagArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.apply_clears_all_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetStyleApplyClearsAllFlagArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool apply_clears_all = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_apply_clears_all(&has_bits);
          _impl_.apply_clears_all_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetStyleApplyClearsAllFlagArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool apply_clears_all = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_apply_clears_all(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetStyleApplyClearsAllFlagArchive)
  return target;
}

size_t CommandSetStyleApplyClearsAllFlagArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_apply_clears_all()) {
    // required bool apply_clears_all = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetStyleApplyClearsAllFlagArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool apply_clears_all = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetStyleApplyClearsAllFlagArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetStyleApplyClearsAllFlagArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetStyleApplyClearsAllFlagArchive::GetClassData() const { return &_class_data_; }


void CommandSetStyleApplyClearsAllFlagArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetStyleApplyClearsAllFlagArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetStyleApplyClearsAllFlagArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.apply_clears_all_ = from._impl_.apply_clears_all_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetStyleApplyClearsAllFlagArchive::CopyFrom(const CommandSetStyleApplyClearsAllFlagArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetStyleApplyClearsAllFlagArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetStyleApplyClearsAllFlagArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetStyleApplyClearsAllFlagArchive::InternalSwap(CommandSetStyleApplyClearsAllFlagArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetStyleApplyClearsAllFlagArchive, _impl_.apply_clears_all_)
      + sizeof(CommandSetStyleApplyClearsAllFlagArchive::_impl_.apply_clears_all_)
      - PROTOBUF_FIELD_OFFSET(CommandSetStyleApplyClearsAllFlagArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetStyleApplyClearsAllFlagArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[40]);
}

// ===================================================================

class CommandApplyThemeToTableArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyThemeToTableArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandApplyThemeToTableArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandApplyThemeToTableArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandApplyThemeToTableArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::TableStyleNetworkArchive& old_table_styles(const CommandApplyThemeToTableArchive* msg);
  static void set_has_old_table_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::TableStyleNetworkArchive& new_table_styles(const CommandApplyThemeToTableArchive* msg);
  static void set_has_new_table_styles(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandApplyThemeToTableArchive::_Internal::super(const CommandApplyThemeToTableArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandApplyThemeToTableArchive::_Internal::undo_cell_map(const CommandApplyThemeToTableArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandApplyThemeToTableArchive::_Internal::redo_cell_map(const CommandApplyThemeToTableArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::TableStyleNetworkArchive&
CommandApplyThemeToTableArchive::_Internal::old_table_styles(const CommandApplyThemeToTableArchive* msg) {
  return *msg->_impl_.old_table_styles_;
}
const ::TST::TableStyleNetworkArchive&
CommandApplyThemeToTableArchive::_Internal::new_table_styles(const CommandApplyThemeToTableArchive* msg) {
  return *msg->_impl_.new_table_styles_;
}
void CommandApplyThemeToTableArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandApplyThemeToTableArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandApplyThemeToTableArchive::clear_old_table_styles() {
  if (_impl_.old_table_styles_ != nullptr) _impl_.old_table_styles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandApplyThemeToTableArchive::clear_new_table_styles() {
  if (_impl_.new_table_styles_ != nullptr) _impl_.new_table_styles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandApplyThemeToTableArchive::CommandApplyThemeToTableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyThemeToTableArchive)
}
CommandApplyThemeToTableArchive::CommandApplyThemeToTableArchive(const CommandApplyThemeToTableArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyThemeToTableArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_table_styles_){nullptr}
    , decltype(_impl_.new_table_styles_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_old_table_styles()) {
    _this->_impl_.old_table_styles_ = new ::TST::TableStyleNetworkArchive(*from._impl_.old_table_styles_);
  }
  if (from._internal_has_new_table_styles()) {
    _this->_impl_.new_table_styles_ = new ::TST::TableStyleNetworkArchive(*from._impl_.new_table_styles_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyThemeToTableArchive)
}

inline void CommandApplyThemeToTableArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_table_styles_){nullptr}
    , decltype(_impl_.new_table_styles_){nullptr}
  };
}

CommandApplyThemeToTableArchive::~CommandApplyThemeToTableArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyThemeToTableArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyThemeToTableArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.old_table_styles_;
  if (this != internal_default_instance()) delete _impl_.new_table_styles_;
}

void CommandApplyThemeToTableArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyThemeToTableArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyThemeToTableArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.old_table_styles_ != nullptr);
      _impl_.old_table_styles_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.new_table_styles_ != nullptr);
      _impl_.new_table_styles_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyThemeToTableArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive old_table_styles = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_table_styles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive new_table_styles = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_table_styles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyThemeToTableArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyThemeToTableArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableStyleNetworkArchive old_table_styles = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::old_table_styles(this),
        _Internal::old_table_styles(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableStyleNetworkArchive new_table_styles = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::new_table_styles(this),
        _Internal::new_table_styles(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyThemeToTableArchive)
  return target;
}

size_t CommandApplyThemeToTableArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyThemeToTableArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_old_table_styles()) {
    // required .TST.TableStyleNetworkArchive old_table_styles = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_table_styles_);
  }

  if (_internal_has_new_table_styles()) {
    // required .TST.TableStyleNetworkArchive new_table_styles = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_table_styles_);
  }

  return total_size;
}
size_t CommandApplyThemeToTableArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyThemeToTableArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.TableStyleNetworkArchive old_table_styles = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_table_styles_);

    // required .TST.TableStyleNetworkArchive new_table_styles = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_table_styles_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyThemeToTableArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyThemeToTableArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyThemeToTableArchive::GetClassData() const { return &_class_data_; }


void CommandApplyThemeToTableArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyThemeToTableArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyThemeToTableArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyThemeToTableArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_old_table_styles()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_old_table_styles());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_new_table_styles()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_new_table_styles());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyThemeToTableArchive::CopyFrom(const CommandApplyThemeToTableArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyThemeToTableArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyThemeToTableArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_old_table_styles()) {
    if (!_impl_.old_table_styles_->IsInitialized()) return false;
  }
  if (_internal_has_new_table_styles()) {
    if (!_impl_.new_table_styles_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyThemeToTableArchive::InternalSwap(CommandApplyThemeToTableArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyThemeToTableArchive, _impl_.new_table_styles_)
      + sizeof(CommandApplyThemeToTableArchive::_impl_.new_table_styles_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyThemeToTableArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyThemeToTableArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[41]);
}

// ===================================================================

class CommandApplyThemeChildForTableArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyThemeChildForTableArchive>()._impl_._has_bits_);
  static const ::TSS::ApplyThemeChildCommandArchive& super(const CommandApplyThemeChildForTableArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& apply_command(const CommandApplyThemeChildForTableArchive* msg);
  static void set_has_apply_command(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSS::ApplyThemeChildCommandArchive&
CommandApplyThemeChildForTableArchive::_Internal::super(const CommandApplyThemeChildForTableArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandApplyThemeChildForTableArchive::_Internal::apply_command(const CommandApplyThemeChildForTableArchive* msg) {
  return *msg->_impl_.apply_command_;
}
void CommandApplyThemeChildForTableArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CommandApplyThemeChildForTableArchive::clear_apply_command() {
  if (_impl_.apply_command_ != nullptr) _impl_.apply_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandApplyThemeChildForTableArchive::CommandApplyThemeChildForTableArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyThemeChildForTableArchive)
}
CommandApplyThemeChildForTableArchive::CommandApplyThemeChildForTableArchive(const CommandApplyThemeChildForTableArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyThemeChildForTableArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.apply_command_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::ApplyThemeChildCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_apply_command()) {
    _this->_impl_.apply_command_ = new ::TSP::Reference(*from._impl_.apply_command_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyThemeChildForTableArchive)
}

inline void CommandApplyThemeChildForTableArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.apply_command_){nullptr}
  };
}

CommandApplyThemeChildForTableArchive::~CommandApplyThemeChildForTableArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyThemeChildForTableArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyThemeChildForTableArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.apply_command_;
}

void CommandApplyThemeChildForTableArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyThemeChildForTableArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyThemeChildForTableArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.apply_command_ != nullptr);
      _impl_.apply_command_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyThemeChildForTableArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.ApplyThemeChildCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference apply_command = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_apply_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyThemeChildForTableArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyThemeChildForTableArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.ApplyThemeChildCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference apply_command = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::apply_command(this),
        _Internal::apply_command(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyThemeChildForTableArchive)
  return target;
}

size_t CommandApplyThemeChildForTableArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyThemeChildForTableArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSS.ApplyThemeChildCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_apply_command()) {
    // required .TSP.Reference apply_command = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.apply_command_);
  }

  return total_size;
}
size_t CommandApplyThemeChildForTableArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyThemeChildForTableArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSS.ApplyThemeChildCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference apply_command = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.apply_command_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyThemeChildForTableArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyThemeChildForTableArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyThemeChildForTableArchive::GetClassData() const { return &_class_data_; }


void CommandApplyThemeChildForTableArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyThemeChildForTableArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyThemeChildForTableArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyThemeChildForTableArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::ApplyThemeChildCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_apply_command()->::TSP::Reference::MergeFrom(
          from._internal_apply_command());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyThemeChildForTableArchive::CopyFrom(const CommandApplyThemeChildForTableArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyThemeChildForTableArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyThemeChildForTableArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_apply_command()) {
    if (!_impl_.apply_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyThemeChildForTableArchive::InternalSwap(CommandApplyThemeChildForTableArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyThemeChildForTableArchive, _impl_.apply_command_)
      + sizeof(CommandApplyThemeChildForTableArchive::_impl_.apply_command_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyThemeChildForTableArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyThemeChildForTableArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[42]);
}

// ===================================================================

class CommandToggleTextPropertyArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandToggleTextPropertyArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandToggleTextPropertyArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandToggleTextPropertyArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_property(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandToggleTextPropertyArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandToggleTextPropertyArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::Cell& default_body_cell(const CommandToggleTextPropertyArchive* msg);
  static void set_has_default_body_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TST::Cell& default_hr_cell(const CommandToggleTextPropertyArchive* msg);
  static void set_has_default_hr_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TST::Cell& default_hc_cell(const CommandToggleTextPropertyArchive* msg);
  static void set_has_default_hc_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::Cell& default_fr_cell(const CommandToggleTextPropertyArchive* msg);
  static void set_has_default_fr_cell(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& text_undo(const CommandToggleTextPropertyArchive* msg);
  static void set_has_text_undo(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000002ff) ^ 0x000002ff) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandToggleTextPropertyArchive::_Internal::super(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandToggleTextPropertyArchive::_Internal::selection(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandToggleTextPropertyArchive::_Internal::undo_cell_map(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandToggleTextPropertyArchive::_Internal::redo_cell_map(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::Cell&
CommandToggleTextPropertyArchive::_Internal::default_body_cell(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.default_body_cell_;
}
const ::TST::Cell&
CommandToggleTextPropertyArchive::_Internal::default_hr_cell(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.default_hr_cell_;
}
const ::TST::Cell&
CommandToggleTextPropertyArchive::_Internal::default_hc_cell(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.default_hc_cell_;
}
const ::TST::Cell&
CommandToggleTextPropertyArchive::_Internal::default_fr_cell(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.default_fr_cell_;
}
const ::TSP::Reference&
CommandToggleTextPropertyArchive::_Internal::text_undo(const CommandToggleTextPropertyArchive* msg) {
  return *msg->_impl_.text_undo_;
}
void CommandToggleTextPropertyArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandToggleTextPropertyArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandToggleTextPropertyArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandToggleTextPropertyArchive::clear_default_body_cell() {
  if (_impl_.default_body_cell_ != nullptr) _impl_.default_body_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandToggleTextPropertyArchive::clear_default_hr_cell() {
  if (_impl_.default_hr_cell_ != nullptr) _impl_.default_hr_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
void CommandToggleTextPropertyArchive::clear_default_hc_cell() {
  if (_impl_.default_hc_cell_ != nullptr) _impl_.default_hc_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
void CommandToggleTextPropertyArchive::clear_default_fr_cell() {
  if (_impl_.default_fr_cell_ != nullptr) _impl_.default_fr_cell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
void CommandToggleTextPropertyArchive::clear_text_undo() {
  if (_impl_.text_undo_ != nullptr) _impl_.text_undo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
CommandToggleTextPropertyArchive::CommandToggleTextPropertyArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandToggleTextPropertyArchive)
}
CommandToggleTextPropertyArchive::CommandToggleTextPropertyArchive(const CommandToggleTextPropertyArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandToggleTextPropertyArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.default_body_cell_){nullptr}
    , decltype(_impl_.default_hr_cell_){nullptr}
    , decltype(_impl_.default_hc_cell_){nullptr}
    , decltype(_impl_.default_fr_cell_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.property_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_default_body_cell()) {
    _this->_impl_.default_body_cell_ = new ::TST::Cell(*from._impl_.default_body_cell_);
  }
  if (from._internal_has_default_hr_cell()) {
    _this->_impl_.default_hr_cell_ = new ::TST::Cell(*from._impl_.default_hr_cell_);
  }
  if (from._internal_has_default_hc_cell()) {
    _this->_impl_.default_hc_cell_ = new ::TST::Cell(*from._impl_.default_hc_cell_);
  }
  if (from._internal_has_default_fr_cell()) {
    _this->_impl_.default_fr_cell_ = new ::TST::Cell(*from._impl_.default_fr_cell_);
  }
  if (from._internal_has_text_undo()) {
    _this->_impl_.text_undo_ = new ::TSP::Reference(*from._impl_.text_undo_);
  }
  _this->_impl_.property_ = from._impl_.property_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandToggleTextPropertyArchive)
}

inline void CommandToggleTextPropertyArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.default_body_cell_){nullptr}
    , decltype(_impl_.default_hr_cell_){nullptr}
    , decltype(_impl_.default_hc_cell_){nullptr}
    , decltype(_impl_.default_fr_cell_){nullptr}
    , decltype(_impl_.text_undo_){nullptr}
    , decltype(_impl_.property_){0u}
  };
}

CommandToggleTextPropertyArchive::~CommandToggleTextPropertyArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandToggleTextPropertyArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandToggleTextPropertyArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.default_body_cell_;
  if (this != internal_default_instance()) delete _impl_.default_hr_cell_;
  if (this != internal_default_instance()) delete _impl_.default_hc_cell_;
  if (this != internal_default_instance()) delete _impl_.default_fr_cell_;
  if (this != internal_default_instance()) delete _impl_.text_undo_;
}

void CommandToggleTextPropertyArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandToggleTextPropertyArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandToggleTextPropertyArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.default_body_cell_ != nullptr);
      _impl_.default_body_cell_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.default_hr_cell_ != nullptr);
      _impl_.default_hr_cell_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.default_hc_cell_ != nullptr);
      _impl_.default_hc_cell_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.default_fr_cell_ != nullptr);
      _impl_.default_fr_cell_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.text_undo_ != nullptr);
    _impl_.text_undo_->Clear();
  }
  _impl_.property_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandToggleTextPropertyArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 property = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_property(&has_bits);
          _impl_.property_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell default_body_cell = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_body_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell default_hr_cell = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_hr_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell default_hc_cell = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_hc_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.Cell default_fr_cell = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_fr_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference text_undo = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_undo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandToggleTextPropertyArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandToggleTextPropertyArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required uint32 property = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_property(), target);
  }

  // required .TST.CellMapArchive undo_cell_map = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell default_body_cell = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::default_body_cell(this),
        _Internal::default_body_cell(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell default_hr_cell = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::default_hr_cell(this),
        _Internal::default_hr_cell(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell default_hc_cell = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::default_hc_cell(this),
        _Internal::default_hc_cell(this).GetCachedSize(), target, stream);
  }

  // required .TST.Cell default_fr_cell = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::default_fr_cell(this),
        _Internal::default_fr_cell(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference text_undo = 10;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::text_undo(this),
        _Internal::text_undo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandToggleTextPropertyArchive)
  return target;
}

size_t CommandToggleTextPropertyArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandToggleTextPropertyArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_default_body_cell()) {
    // required .TST.Cell default_body_cell = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_body_cell_);
  }

  if (_internal_has_default_hr_cell()) {
    // required .TST.Cell default_hr_cell = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_hr_cell_);
  }

  if (_internal_has_default_hc_cell()) {
    // required .TST.Cell default_hc_cell = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_hc_cell_);
  }

  if (_internal_has_default_fr_cell()) {
    // required .TST.Cell default_fr_cell = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_fr_cell_);
  }

  if (_internal_has_property()) {
    // required uint32 property = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_property());
  }

  return total_size;
}
size_t CommandToggleTextPropertyArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandToggleTextPropertyArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000002ff) ^ 0x000002ff) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.Cell default_body_cell = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_body_cell_);

    // required .TST.Cell default_hr_cell = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_hr_cell_);

    // required .TST.Cell default_hc_cell = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_hc_cell_);

    // required .TST.Cell default_fr_cell = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.default_fr_cell_);

    // required uint32 property = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_property());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference text_undo = 10;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.text_undo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandToggleTextPropertyArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandToggleTextPropertyArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandToggleTextPropertyArchive::GetClassData() const { return &_class_data_; }


void CommandToggleTextPropertyArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandToggleTextPropertyArchive*>(&to_msg);
  auto& from = static_cast<const CommandToggleTextPropertyArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandToggleTextPropertyArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_default_body_cell()->::TST::Cell::MergeFrom(
          from._internal_default_body_cell());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_default_hr_cell()->::TST::Cell::MergeFrom(
          from._internal_default_hr_cell());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_default_hc_cell()->::TST::Cell::MergeFrom(
          from._internal_default_hc_cell());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_default_fr_cell()->::TST::Cell::MergeFrom(
          from._internal_default_fr_cell());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_text_undo()->::TSP::Reference::MergeFrom(
          from._internal_text_undo());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.property_ = from._impl_.property_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandToggleTextPropertyArchive::CopyFrom(const CommandToggleTextPropertyArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandToggleTextPropertyArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandToggleTextPropertyArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_default_body_cell()) {
    if (!_impl_.default_body_cell_->IsInitialized()) return false;
  }
  if (_internal_has_default_hr_cell()) {
    if (!_impl_.default_hr_cell_->IsInitialized()) return false;
  }
  if (_internal_has_default_hc_cell()) {
    if (!_impl_.default_hc_cell_->IsInitialized()) return false;
  }
  if (_internal_has_default_fr_cell()) {
    if (!_impl_.default_fr_cell_->IsInitialized()) return false;
  }
  if (_internal_has_text_undo()) {
    if (!_impl_.text_undo_->IsInitialized()) return false;
  }
  return true;
}

void CommandToggleTextPropertyArchive::InternalSwap(CommandToggleTextPropertyArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandToggleTextPropertyArchive, _impl_.property_)
      + sizeof(CommandToggleTextPropertyArchive::_impl_.property_)
      - PROTOBUF_FIELD_OFFSET(CommandToggleTextPropertyArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandToggleTextPropertyArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[43]);
}

// ===================================================================

class CommandResetFillPropertyToDefault::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandResetFillPropertyToDefault>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandResetFillPropertyToDefault* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandResetFillPropertyToDefault* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandResetFillPropertyToDefault* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandResetFillPropertyToDefault* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandResetFillPropertyToDefault::_Internal::super(const CommandResetFillPropertyToDefault* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandResetFillPropertyToDefault::_Internal::selection(const CommandResetFillPropertyToDefault* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandResetFillPropertyToDefault::_Internal::undo_cell_map(const CommandResetFillPropertyToDefault* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandResetFillPropertyToDefault::_Internal::redo_cell_map(const CommandResetFillPropertyToDefault* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandResetFillPropertyToDefault::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandResetFillPropertyToDefault::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandResetFillPropertyToDefault::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandResetFillPropertyToDefault::CommandResetFillPropertyToDefault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandResetFillPropertyToDefault)
}
CommandResetFillPropertyToDefault::CommandResetFillPropertyToDefault(const CommandResetFillPropertyToDefault& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandResetFillPropertyToDefault* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandResetFillPropertyToDefault)
}

inline void CommandResetFillPropertyToDefault::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
  };
}

CommandResetFillPropertyToDefault::~CommandResetFillPropertyToDefault() {
  // @@protoc_insertion_point(destructor:TST.CommandResetFillPropertyToDefault)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandResetFillPropertyToDefault::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandResetFillPropertyToDefault::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandResetFillPropertyToDefault::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandResetFillPropertyToDefault)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandResetFillPropertyToDefault::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandResetFillPropertyToDefault::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandResetFillPropertyToDefault)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandResetFillPropertyToDefault)
  return target;
}

size_t CommandResetFillPropertyToDefault::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandResetFillPropertyToDefault)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandResetFillPropertyToDefault::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandResetFillPropertyToDefault)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandResetFillPropertyToDefault::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandResetFillPropertyToDefault::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandResetFillPropertyToDefault::GetClassData() const { return &_class_data_; }


void CommandResetFillPropertyToDefault::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandResetFillPropertyToDefault*>(&to_msg);
  auto& from = static_cast<const CommandResetFillPropertyToDefault&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandResetFillPropertyToDefault)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandResetFillPropertyToDefault::CopyFrom(const CommandResetFillPropertyToDefault& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandResetFillPropertyToDefault)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandResetFillPropertyToDefault::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandResetFillPropertyToDefault::InternalSwap(CommandResetFillPropertyToDefault* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandResetFillPropertyToDefault, _impl_.redo_cell_map_)
      + sizeof(CommandResetFillPropertyToDefault::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandResetFillPropertyToDefault, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandResetFillPropertyToDefault::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[44]);
}

// ===================================================================

class CommandSetSingleNumberFormatParameterArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetSingleNumberFormatParameterArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetSingleNumberFormatParameterArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandSetSingleNumberFormatParameterArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandSetSingleNumberFormatParameterArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandSetSingleNumberFormatParameterArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetSingleNumberFormatParameterArchive::_Internal::super(const CommandSetSingleNumberFormatParameterArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandSetSingleNumberFormatParameterArchive::_Internal::selection(const CommandSetSingleNumberFormatParameterArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandSetSingleNumberFormatParameterArchive::_Internal::undo_cell_map(const CommandSetSingleNumberFormatParameterArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandSetSingleNumberFormatParameterArchive::_Internal::redo_cell_map(const CommandSetSingleNumberFormatParameterArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandSetSingleNumberFormatParameterArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetSingleNumberFormatParameterArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetSingleNumberFormatParameterArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandSetSingleNumberFormatParameterArchive::CommandSetSingleNumberFormatParameterArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetSingleNumberFormatParameterArchive)
}
CommandSetSingleNumberFormatParameterArchive::CommandSetSingleNumberFormatParameterArchive(const CommandSetSingleNumberFormatParameterArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetSingleNumberFormatParameterArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetSingleNumberFormatParameterArchive)
}

inline void CommandSetSingleNumberFormatParameterArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
  };
}

CommandSetSingleNumberFormatParameterArchive::~CommandSetSingleNumberFormatParameterArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetSingleNumberFormatParameterArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetSingleNumberFormatParameterArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandSetSingleNumberFormatParameterArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetSingleNumberFormatParameterArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetSingleNumberFormatParameterArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetSingleNumberFormatParameterArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetSingleNumberFormatParameterArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetSingleNumberFormatParameterArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetSingleNumberFormatParameterArchive)
  return target;
}

size_t CommandSetSingleNumberFormatParameterArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetSingleNumberFormatParameterArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandSetSingleNumberFormatParameterArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetSingleNumberFormatParameterArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetSingleNumberFormatParameterArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetSingleNumberFormatParameterArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetSingleNumberFormatParameterArchive::GetClassData() const { return &_class_data_; }


void CommandSetSingleNumberFormatParameterArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetSingleNumberFormatParameterArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetSingleNumberFormatParameterArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetSingleNumberFormatParameterArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetSingleNumberFormatParameterArchive::CopyFrom(const CommandSetSingleNumberFormatParameterArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetSingleNumberFormatParameterArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetSingleNumberFormatParameterArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetSingleNumberFormatParameterArchive::InternalSwap(CommandSetSingleNumberFormatParameterArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetSingleNumberFormatParameterArchive, _impl_.redo_cell_map_)
      + sizeof(CommandSetSingleNumberFormatParameterArchive::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandSetSingleNumberFormatParameterArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetSingleNumberFormatParameterArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[45]);
}

// ===================================================================

class CommandSetBaseArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetBaseArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetBaseArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetBaseArchive::_Internal::super(const CommandSetBaseArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetBaseArchive::CommandSetBaseArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetBaseArchive)
}
CommandSetBaseArchive::CommandSetBaseArchive(const CommandSetBaseArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetBaseArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.base_ = from._impl_.base_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetBaseArchive)
}

inline void CommandSetBaseArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_){0u}
  };
}

CommandSetBaseArchive::~CommandSetBaseArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetBaseArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetBaseArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetBaseArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetBaseArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetBaseArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.base_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetBaseArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 base = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_base(&has_bits);
          _impl_.base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetBaseArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetBaseArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 base = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_base(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetBaseArchive)
  return target;
}

size_t CommandSetBaseArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetBaseArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_base()) {
    // required uint32 base = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base());
  }

  return total_size;
}
size_t CommandSetBaseArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetBaseArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 base = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetBaseArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetBaseArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetBaseArchive::GetClassData() const { return &_class_data_; }


void CommandSetBaseArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetBaseArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetBaseArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetBaseArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.base_ = from._impl_.base_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetBaseArchive::CopyFrom(const CommandSetBaseArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetBaseArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetBaseArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetBaseArchive::InternalSwap(CommandSetBaseArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetBaseArchive, _impl_.base_)
      + sizeof(CommandSetBaseArchive::_impl_.base_)
      - PROTOBUF_FIELD_OFFSET(CommandSetBaseArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetBaseArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[46]);
}

// ===================================================================

class CommandSetBasePlacesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetBasePlacesArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetBasePlacesArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_places(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetBasePlacesArchive::_Internal::super(const CommandSetBasePlacesArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetBasePlacesArchive::CommandSetBasePlacesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetBasePlacesArchive)
}
CommandSetBasePlacesArchive::CommandSetBasePlacesArchive(const CommandSetBasePlacesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetBasePlacesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_places_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.base_places_ = from._impl_.base_places_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetBasePlacesArchive)
}

inline void CommandSetBasePlacesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_places_){0u}
  };
}

CommandSetBasePlacesArchive::~CommandSetBasePlacesArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetBasePlacesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetBasePlacesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetBasePlacesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetBasePlacesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetBasePlacesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.base_places_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetBasePlacesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 base_places = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_base_places(&has_bits);
          _impl_.base_places_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetBasePlacesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetBasePlacesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 base_places = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_base_places(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetBasePlacesArchive)
  return target;
}

size_t CommandSetBasePlacesArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetBasePlacesArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_base_places()) {
    // required uint32 base_places = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_places());
  }

  return total_size;
}
size_t CommandSetBasePlacesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetBasePlacesArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 base_places = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_base_places());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetBasePlacesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetBasePlacesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetBasePlacesArchive::GetClassData() const { return &_class_data_; }


void CommandSetBasePlacesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetBasePlacesArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetBasePlacesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetBasePlacesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.base_places_ = from._impl_.base_places_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetBasePlacesArchive::CopyFrom(const CommandSetBasePlacesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetBasePlacesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetBasePlacesArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetBasePlacesArchive::InternalSwap(CommandSetBasePlacesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetBasePlacesArchive, _impl_.base_places_)
      + sizeof(CommandSetBasePlacesArchive::_impl_.base_places_)
      - PROTOBUF_FIELD_OFFSET(CommandSetBasePlacesArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetBasePlacesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[47]);
}

// ===================================================================

class CommandSetBaseUseMinusSignArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetBaseUseMinusSignArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetBaseUseMinusSignArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_use_minus_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetBaseUseMinusSignArchive::_Internal::super(const CommandSetBaseUseMinusSignArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetBaseUseMinusSignArchive::CommandSetBaseUseMinusSignArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetBaseUseMinusSignArchive)
}
CommandSetBaseUseMinusSignArchive::CommandSetBaseUseMinusSignArchive(const CommandSetBaseUseMinusSignArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetBaseUseMinusSignArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_use_minus_sign_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.base_use_minus_sign_ = from._impl_.base_use_minus_sign_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetBaseUseMinusSignArchive)
}

inline void CommandSetBaseUseMinusSignArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.base_use_minus_sign_){false}
  };
}

CommandSetBaseUseMinusSignArchive::~CommandSetBaseUseMinusSignArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetBaseUseMinusSignArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetBaseUseMinusSignArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetBaseUseMinusSignArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetBaseUseMinusSignArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetBaseUseMinusSignArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.base_use_minus_sign_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetBaseUseMinusSignArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool base_use_minus_sign = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_base_use_minus_sign(&has_bits);
          _impl_.base_use_minus_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetBaseUseMinusSignArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetBaseUseMinusSignArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool base_use_minus_sign = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_base_use_minus_sign(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetBaseUseMinusSignArchive)
  return target;
}

size_t CommandSetBaseUseMinusSignArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetBaseUseMinusSignArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_base_use_minus_sign()) {
    // required bool base_use_minus_sign = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetBaseUseMinusSignArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetBaseUseMinusSignArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool base_use_minus_sign = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetBaseUseMinusSignArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetBaseUseMinusSignArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetBaseUseMinusSignArchive::GetClassData() const { return &_class_data_; }


void CommandSetBaseUseMinusSignArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetBaseUseMinusSignArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetBaseUseMinusSignArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetBaseUseMinusSignArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.base_use_minus_sign_ = from._impl_.base_use_minus_sign_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetBaseUseMinusSignArchive::CopyFrom(const CommandSetBaseUseMinusSignArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetBaseUseMinusSignArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetBaseUseMinusSignArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetBaseUseMinusSignArchive::InternalSwap(CommandSetBaseUseMinusSignArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetBaseUseMinusSignArchive, _impl_.base_use_minus_sign_)
      + sizeof(CommandSetBaseUseMinusSignArchive::_impl_.base_use_minus_sign_)
      - PROTOBUF_FIELD_OFFSET(CommandSetBaseUseMinusSignArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetBaseUseMinusSignArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[48]);
}

// ===================================================================

class CommandSetControlMinimumArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetControlMinimumArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetControlMinimumArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetControlMinimumArchive::_Internal::super(const CommandSetControlMinimumArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetControlMinimumArchive::CommandSetControlMinimumArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetControlMinimumArchive)
}
CommandSetControlMinimumArchive::CommandSetControlMinimumArchive(const CommandSetControlMinimumArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetControlMinimumArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.format_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.format_type_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.format_type_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetControlMinimumArchive)
}

inline void CommandSetControlMinimumArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.minimum_){0}
    , decltype(_impl_.format_type_){0u}
  };
}

CommandSetControlMinimumArchive::~CommandSetControlMinimumArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetControlMinimumArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetControlMinimumArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetControlMinimumArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetControlMinimumArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetControlMinimumArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.format_type_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.format_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetControlMinimumArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double minimum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 format_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_format_type(&has_bits);
          _impl_.format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetControlMinimumArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetControlMinimumArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double minimum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_minimum(), target);
  }

  // required uint32 format_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_format_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetControlMinimumArchive)
  return target;
}

size_t CommandSetControlMinimumArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetControlMinimumArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_minimum()) {
    // required double minimum = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_format_type()) {
    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());
  }

  return total_size;
}
size_t CommandSetControlMinimumArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetControlMinimumArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double minimum = 2;
    total_size += 1 + 8;

    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetControlMinimumArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetControlMinimumArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetControlMinimumArchive::GetClassData() const { return &_class_data_; }


void CommandSetControlMinimumArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetControlMinimumArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetControlMinimumArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetControlMinimumArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_type_ = from._impl_.format_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetControlMinimumArchive::CopyFrom(const CommandSetControlMinimumArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetControlMinimumArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetControlMinimumArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetControlMinimumArchive::InternalSwap(CommandSetControlMinimumArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetControlMinimumArchive, _impl_.format_type_)
      + sizeof(CommandSetControlMinimumArchive::_impl_.format_type_)
      - PROTOBUF_FIELD_OFFSET(CommandSetControlMinimumArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetControlMinimumArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[49]);
}

// ===================================================================

class CommandSetControlMaximumArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetControlMaximumArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetControlMaximumArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetControlMaximumArchive::_Internal::super(const CommandSetControlMaximumArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetControlMaximumArchive::CommandSetControlMaximumArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetControlMaximumArchive)
}
CommandSetControlMaximumArchive::CommandSetControlMaximumArchive(const CommandSetControlMaximumArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetControlMaximumArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.format_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.maximum_, &from._impl_.maximum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.format_type_) -
    reinterpret_cast<char*>(&_impl_.maximum_)) + sizeof(_impl_.format_type_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetControlMaximumArchive)
}

inline void CommandSetControlMaximumArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.maximum_){0}
    , decltype(_impl_.format_type_){0u}
  };
}

CommandSetControlMaximumArchive::~CommandSetControlMaximumArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetControlMaximumArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetControlMaximumArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetControlMaximumArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetControlMaximumArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetControlMaximumArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.maximum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.format_type_) -
        reinterpret_cast<char*>(&_impl_.maximum_)) + sizeof(_impl_.format_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetControlMaximumArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 format_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_format_type(&has_bits);
          _impl_.format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetControlMaximumArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetControlMaximumArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_maximum(), target);
  }

  // required uint32 format_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_format_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetControlMaximumArchive)
  return target;
}

size_t CommandSetControlMaximumArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetControlMaximumArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_maximum()) {
    // required double maximum = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_format_type()) {
    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());
  }

  return total_size;
}
size_t CommandSetControlMaximumArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetControlMaximumArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double maximum = 2;
    total_size += 1 + 8;

    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetControlMaximumArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetControlMaximumArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetControlMaximumArchive::GetClassData() const { return &_class_data_; }


void CommandSetControlMaximumArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetControlMaximumArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetControlMaximumArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetControlMaximumArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_type_ = from._impl_.format_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetControlMaximumArchive::CopyFrom(const CommandSetControlMaximumArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetControlMaximumArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetControlMaximumArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetControlMaximumArchive::InternalSwap(CommandSetControlMaximumArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetControlMaximumArchive, _impl_.format_type_)
      + sizeof(CommandSetControlMaximumArchive::_impl_.format_type_)
      - PROTOBUF_FIELD_OFFSET(CommandSetControlMaximumArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetControlMaximumArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[50]);
}

// ===================================================================

class CommandSetControlIncrementArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetControlIncrementArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetControlIncrementArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_increment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_format_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetControlIncrementArchive::_Internal::super(const CommandSetControlIncrementArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetControlIncrementArchive::CommandSetControlIncrementArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetControlIncrementArchive)
}
CommandSetControlIncrementArchive::CommandSetControlIncrementArchive(const CommandSetControlIncrementArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetControlIncrementArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.increment_){}
    , decltype(_impl_.format_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.increment_, &from._impl_.increment_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.format_type_) -
    reinterpret_cast<char*>(&_impl_.increment_)) + sizeof(_impl_.format_type_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetControlIncrementArchive)
}

inline void CommandSetControlIncrementArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.increment_){0}
    , decltype(_impl_.format_type_){0u}
  };
}

CommandSetControlIncrementArchive::~CommandSetControlIncrementArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetControlIncrementArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetControlIncrementArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetControlIncrementArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetControlIncrementArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetControlIncrementArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.increment_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.format_type_) -
        reinterpret_cast<char*>(&_impl_.increment_)) + sizeof(_impl_.format_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetControlIncrementArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required double increment = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_increment(&has_bits);
          _impl_.increment_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // required uint32 format_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_format_type(&has_bits);
          _impl_.format_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetControlIncrementArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetControlIncrementArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required double increment = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_increment(), target);
  }

  // required uint32 format_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_format_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetControlIncrementArchive)
  return target;
}

size_t CommandSetControlIncrementArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetControlIncrementArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_increment()) {
    // required double increment = 2;
    total_size += 1 + 8;
  }

  if (_internal_has_format_type()) {
    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());
  }

  return total_size;
}
size_t CommandSetControlIncrementArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetControlIncrementArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required double increment = 2;
    total_size += 1 + 8;

    // required uint32 format_type = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetControlIncrementArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetControlIncrementArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetControlIncrementArchive::GetClassData() const { return &_class_data_; }


void CommandSetControlIncrementArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetControlIncrementArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetControlIncrementArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetControlIncrementArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.increment_ = from._impl_.increment_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.format_type_ = from._impl_.format_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetControlIncrementArchive::CopyFrom(const CommandSetControlIncrementArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetControlIncrementArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetControlIncrementArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetControlIncrementArchive::InternalSwap(CommandSetControlIncrementArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetControlIncrementArchive, _impl_.format_type_)
      + sizeof(CommandSetControlIncrementArchive::_impl_.format_type_)
      - PROTOBUF_FIELD_OFFSET(CommandSetControlIncrementArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetControlIncrementArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[51]);
}

// ===================================================================

class CommandSetCurrencyCodeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetCurrencyCodeArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetCurrencyCodeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_currency_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetCurrencyCodeArchive::_Internal::super(const CommandSetCurrencyCodeArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetCurrencyCodeArchive::CommandSetCurrencyCodeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetCurrencyCodeArchive)
}
CommandSetCurrencyCodeArchive::CommandSetCurrencyCodeArchive(const CommandSetCurrencyCodeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetCurrencyCodeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currency_code()) {
    _this->_impl_.currency_code_.Set(from._internal_currency_code(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetCurrencyCodeArchive)
}

inline void CommandSetCurrencyCodeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currency_code_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.currency_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommandSetCurrencyCodeArchive::~CommandSetCurrencyCodeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetCurrencyCodeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetCurrencyCodeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.currency_code_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetCurrencyCodeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetCurrencyCodeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetCurrencyCodeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currency_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetCurrencyCodeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string currency_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_currency_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetCurrencyCodeArchive.currency_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetCurrencyCodeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetCurrencyCodeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required string currency_code = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_currency_code().data(), static_cast<int>(this->_internal_currency_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetCurrencyCodeArchive.currency_code");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_currency_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetCurrencyCodeArchive)
  return target;
}

size_t CommandSetCurrencyCodeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetCurrencyCodeArchive)
  size_t total_size = 0;

  if (_internal_has_currency_code()) {
    // required string currency_code = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_currency_code());
  }

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  return total_size;
}
size_t CommandSetCurrencyCodeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetCurrencyCodeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string currency_code = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_currency_code());

    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetCurrencyCodeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetCurrencyCodeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetCurrencyCodeArchive::GetClassData() const { return &_class_data_; }


void CommandSetCurrencyCodeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetCurrencyCodeArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetCurrencyCodeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetCurrencyCodeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currency_code(from._internal_currency_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetCurrencyCodeArchive::CopyFrom(const CommandSetCurrencyCodeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetCurrencyCodeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetCurrencyCodeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetCurrencyCodeArchive::InternalSwap(CommandSetCurrencyCodeArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currency_code_, lhs_arena,
      &other->_impl_.currency_code_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetCurrencyCodeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[52]);
}

// ===================================================================

class CommandSetFractionAccuracyArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFractionAccuracyArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetFractionAccuracyArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fraction_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetFractionAccuracyArchive::_Internal::super(const CommandSetFractionAccuracyArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetFractionAccuracyArchive::CommandSetFractionAccuracyArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFractionAccuracyArchive)
}
CommandSetFractionAccuracyArchive::CommandSetFractionAccuracyArchive(const CommandSetFractionAccuracyArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFractionAccuracyArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.fraction_accuracy_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.fraction_accuracy_ = from._impl_.fraction_accuracy_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFractionAccuracyArchive)
}

inline void CommandSetFractionAccuracyArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.fraction_accuracy_){0u}
  };
}

CommandSetFractionAccuracyArchive::~CommandSetFractionAccuracyArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFractionAccuracyArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFractionAccuracyArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFractionAccuracyArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFractionAccuracyArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFractionAccuracyArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.fraction_accuracy_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFractionAccuracyArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 fraction_accuracy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fraction_accuracy(&has_bits);
          _impl_.fraction_accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFractionAccuracyArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFractionAccuracyArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 fraction_accuracy = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fraction_accuracy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFractionAccuracyArchive)
  return target;
}

size_t CommandSetFractionAccuracyArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFractionAccuracyArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_fraction_accuracy()) {
    // required uint32 fraction_accuracy = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fraction_accuracy());
  }

  return total_size;
}
size_t CommandSetFractionAccuracyArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFractionAccuracyArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 fraction_accuracy = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fraction_accuracy());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFractionAccuracyArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFractionAccuracyArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFractionAccuracyArchive::GetClassData() const { return &_class_data_; }


void CommandSetFractionAccuracyArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFractionAccuracyArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFractionAccuracyArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFractionAccuracyArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.fraction_accuracy_ = from._impl_.fraction_accuracy_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFractionAccuracyArchive::CopyFrom(const CommandSetFractionAccuracyArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFractionAccuracyArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFractionAccuracyArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFractionAccuracyArchive::InternalSwap(CommandSetFractionAccuracyArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFractionAccuracyArchive, _impl_.fraction_accuracy_)
      + sizeof(CommandSetFractionAccuracyArchive::_impl_.fraction_accuracy_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFractionAccuracyArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFractionAccuracyArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[53]);
}

// ===================================================================

class CommandSetMultipleChoiceListFormatForEditedItemArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleChoiceListFormatForEditedItemArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetMultipleChoiceListFormatForEditedItemArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetMultipleChoiceListFormatForEditedItemArchive::_Internal::super(const CommandSetMultipleChoiceListFormatForEditedItemArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetMultipleChoiceListFormatForEditedItemArchive::CommandSetMultipleChoiceListFormatForEditedItemArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
}
CommandSetMultipleChoiceListFormatForEditedItemArchive::CommandSetMultipleChoiceListFormatForEditedItemArchive(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleChoiceListFormatForEditedItemArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
}

inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleChoiceListFormatForEditedItemArchive::~CommandSetMultipleChoiceListFormatForEditedItemArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleChoiceListFormatForEditedItemArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleChoiceListFormatForEditedItemArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleChoiceListFormatForEditedItemArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleChoiceListFormatForEditedItemArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleChoiceListFormatForEditedItemArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  return target;
}

size_t CommandSetMultipleChoiceListFormatForEditedItemArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  size_t total_size = 0;

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleChoiceListFormatForEditedItemArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleChoiceListFormatForEditedItemArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleChoiceListFormatForEditedItemArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleChoiceListFormatForEditedItemArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleChoiceListFormatForEditedItemArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleChoiceListFormatForEditedItemArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleChoiceListFormatForEditedItemArchive::CopyFrom(const CommandSetMultipleChoiceListFormatForEditedItemArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleChoiceListFormatForEditedItemArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleChoiceListFormatForEditedItemArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleChoiceListFormatForEditedItemArchive::InternalSwap(CommandSetMultipleChoiceListFormatForEditedItemArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleChoiceListFormatForEditedItemArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[54]);
}

// ===================================================================

class CommandSetMultipleChoiceListFormatForDeleteItemArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleChoiceListFormatForDeleteItemArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetMultipleChoiceListFormatForDeleteItemArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetMultipleChoiceListFormatForDeleteItemArchive::_Internal::super(const CommandSetMultipleChoiceListFormatForDeleteItemArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetMultipleChoiceListFormatForDeleteItemArchive::CommandSetMultipleChoiceListFormatForDeleteItemArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
}
CommandSetMultipleChoiceListFormatForDeleteItemArchive::CommandSetMultipleChoiceListFormatForDeleteItemArchive(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleChoiceListFormatForDeleteItemArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
}

inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleChoiceListFormatForDeleteItemArchive::~CommandSetMultipleChoiceListFormatForDeleteItemArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleChoiceListFormatForDeleteItemArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleChoiceListFormatForDeleteItemArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleChoiceListFormatForDeleteItemArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleChoiceListFormatForDeleteItemArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleChoiceListFormatForDeleteItemArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  return target;
}

size_t CommandSetMultipleChoiceListFormatForDeleteItemArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  size_t total_size = 0;

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleChoiceListFormatForDeleteItemArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleChoiceListFormatForDeleteItemArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleChoiceListFormatForDeleteItemArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleChoiceListFormatForDeleteItemArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleChoiceListFormatForDeleteItemArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleChoiceListFormatForDeleteItemArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleChoiceListFormatForDeleteItemArchive::CopyFrom(const CommandSetMultipleChoiceListFormatForDeleteItemArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleChoiceListFormatForDeleteItemArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleChoiceListFormatForDeleteItemArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleChoiceListFormatForDeleteItemArchive::InternalSwap(CommandSetMultipleChoiceListFormatForDeleteItemArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleChoiceListFormatForDeleteItemArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[55]);
}

// ===================================================================

class CommandSetMultipleChoiceListFormatForReorderItemArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleChoiceListFormatForReorderItemArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetMultipleChoiceListFormatForReorderItemArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetMultipleChoiceListFormatForReorderItemArchive::_Internal::super(const CommandSetMultipleChoiceListFormatForReorderItemArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetMultipleChoiceListFormatForReorderItemArchive::CommandSetMultipleChoiceListFormatForReorderItemArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
}
CommandSetMultipleChoiceListFormatForReorderItemArchive::CommandSetMultipleChoiceListFormatForReorderItemArchive(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleChoiceListFormatForReorderItemArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
}

inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleChoiceListFormatForReorderItemArchive::~CommandSetMultipleChoiceListFormatForReorderItemArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleChoiceListFormatForReorderItemArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleChoiceListFormatForReorderItemArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleChoiceListFormatForReorderItemArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleChoiceListFormatForReorderItemArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleChoiceListFormatForReorderItemArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  return target;
}

size_t CommandSetMultipleChoiceListFormatForReorderItemArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  size_t total_size = 0;

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleChoiceListFormatForReorderItemArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleChoiceListFormatForReorderItemArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleChoiceListFormatForReorderItemArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleChoiceListFormatForReorderItemArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleChoiceListFormatForReorderItemArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleChoiceListFormatForReorderItemArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleChoiceListFormatForReorderItemArchive::CopyFrom(const CommandSetMultipleChoiceListFormatForReorderItemArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleChoiceListFormatForReorderItemArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleChoiceListFormatForReorderItemArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleChoiceListFormatForReorderItemArchive::InternalSwap(CommandSetMultipleChoiceListFormatForReorderItemArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleChoiceListFormatForReorderItemArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[56]);
}

// ===================================================================

class CommandSetMultipleChoiceListFormatForInitialValueArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetMultipleChoiceListFormatForInitialValueArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetMultipleChoiceListFormatForInitialValueArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetMultipleChoiceListFormatForInitialValueArchive::_Internal::super(const CommandSetMultipleChoiceListFormatForInitialValueArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetMultipleChoiceListFormatForInitialValueArchive::CommandSetMultipleChoiceListFormatForInitialValueArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
}
CommandSetMultipleChoiceListFormatForInitialValueArchive::CommandSetMultipleChoiceListFormatForInitialValueArchive(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetMultipleChoiceListFormatForInitialValueArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
}

inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetMultipleChoiceListFormatForInitialValueArchive::~CommandSetMultipleChoiceListFormatForInitialValueArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetMultipleChoiceListFormatForInitialValueArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetMultipleChoiceListFormatForInitialValueArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetMultipleChoiceListFormatForInitialValueArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetMultipleChoiceListFormatForInitialValueArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetMultipleChoiceListFormatForInitialValueArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  return target;
}

size_t CommandSetMultipleChoiceListFormatForInitialValueArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  size_t total_size = 0;

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetMultipleChoiceListFormatForInitialValueArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetMultipleChoiceListFormatForInitialValueArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetMultipleChoiceListFormatForInitialValueArchive::GetClassData() const { return &_class_data_; }


void CommandSetMultipleChoiceListFormatForInitialValueArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetMultipleChoiceListFormatForInitialValueArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetMultipleChoiceListFormatForInitialValueArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetMultipleChoiceListFormatForInitialValueArchive::CopyFrom(const CommandSetMultipleChoiceListFormatForInitialValueArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetMultipleChoiceListFormatForInitialValueArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetMultipleChoiceListFormatForInitialValueArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetMultipleChoiceListFormatForInitialValueArchive::InternalSwap(CommandSetMultipleChoiceListFormatForInitialValueArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetMultipleChoiceListFormatForInitialValueArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[57]);
}

// ===================================================================

class CommandSetNegativeNumberStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetNegativeNumberStyleArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetNegativeNumberStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_negative_number_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetNegativeNumberStyleArchive::_Internal::super(const CommandSetNegativeNumberStyleArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetNegativeNumberStyleArchive::CommandSetNegativeNumberStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetNegativeNumberStyleArchive)
}
CommandSetNegativeNumberStyleArchive::CommandSetNegativeNumberStyleArchive(const CommandSetNegativeNumberStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetNegativeNumberStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.negative_number_style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.negative_number_style_ = from._impl_.negative_number_style_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetNegativeNumberStyleArchive)
}

inline void CommandSetNegativeNumberStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.negative_number_style_){0u}
  };
}

CommandSetNegativeNumberStyleArchive::~CommandSetNegativeNumberStyleArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetNegativeNumberStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetNegativeNumberStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetNegativeNumberStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetNegativeNumberStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetNegativeNumberStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.negative_number_style_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetNegativeNumberStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 negative_number_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_negative_number_style(&has_bits);
          _impl_.negative_number_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetNegativeNumberStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetNegativeNumberStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 negative_number_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_negative_number_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetNegativeNumberStyleArchive)
  return target;
}

size_t CommandSetNegativeNumberStyleArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetNegativeNumberStyleArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_negative_number_style()) {
    // required uint32 negative_number_style = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_negative_number_style());
  }

  return total_size;
}
size_t CommandSetNegativeNumberStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetNegativeNumberStyleArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 negative_number_style = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_negative_number_style());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetNegativeNumberStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetNegativeNumberStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetNegativeNumberStyleArchive::GetClassData() const { return &_class_data_; }


void CommandSetNegativeNumberStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetNegativeNumberStyleArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetNegativeNumberStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetNegativeNumberStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.negative_number_style_ = from._impl_.negative_number_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetNegativeNumberStyleArchive::CopyFrom(const CommandSetNegativeNumberStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetNegativeNumberStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetNegativeNumberStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetNegativeNumberStyleArchive::InternalSwap(CommandSetNegativeNumberStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetNegativeNumberStyleArchive, _impl_.negative_number_style_)
      + sizeof(CommandSetNegativeNumberStyleArchive::_impl_.negative_number_style_)
      - PROTOBUF_FIELD_OFFSET(CommandSetNegativeNumberStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetNegativeNumberStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[58]);
}

// ===================================================================

class CommandSetExplicitFormatArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetExplicitFormatArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetExplicitFormatArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandSetExplicitFormatArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSK::FormatStructArchive& cell_format(const CommandSetExplicitFormatArchive* msg);
  static void set_has_cell_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandSetExplicitFormatArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandSetExplicitFormatArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetExplicitFormatArchive::_Internal::super(const CommandSetExplicitFormatArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandSetExplicitFormatArchive::_Internal::selection(const CommandSetExplicitFormatArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TSK::FormatStructArchive&
CommandSetExplicitFormatArchive::_Internal::cell_format(const CommandSetExplicitFormatArchive* msg) {
  return *msg->_impl_.cell_format_;
}
const ::TST::CellMapArchive&
CommandSetExplicitFormatArchive::_Internal::undo_cell_map(const CommandSetExplicitFormatArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandSetExplicitFormatArchive::_Internal::redo_cell_map(const CommandSetExplicitFormatArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandSetExplicitFormatArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetExplicitFormatArchive::clear_cell_format() {
  if (_impl_.cell_format_ != nullptr) _impl_.cell_format_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetExplicitFormatArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandSetExplicitFormatArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandSetExplicitFormatArchive::CommandSetExplicitFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetExplicitFormatArchive)
}
CommandSetExplicitFormatArchive::CommandSetExplicitFormatArchive(const CommandSetExplicitFormatArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetExplicitFormatArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.cell_format_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_cell_format()) {
    _this->_impl_.cell_format_ = new ::TSK::FormatStructArchive(*from._impl_.cell_format_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetExplicitFormatArchive)
}

inline void CommandSetExplicitFormatArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.cell_format_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
  };
}

CommandSetExplicitFormatArchive::~CommandSetExplicitFormatArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetExplicitFormatArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetExplicitFormatArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.cell_format_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandSetExplicitFormatArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetExplicitFormatArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetExplicitFormatArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cell_format_ != nullptr);
      _impl_.cell_format_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetExplicitFormatArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.FormatStructArchive cell_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetExplicitFormatArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetExplicitFormatArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TSK.FormatStructArchive cell_format = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cell_format(this),
        _Internal::cell_format(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetExplicitFormatArchive)
  return target;
}

size_t CommandSetExplicitFormatArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetExplicitFormatArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_cell_format()) {
    // required .TSK.FormatStructArchive cell_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_format_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandSetExplicitFormatArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetExplicitFormatArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TSK.FormatStructArchive cell_format = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_format_);

    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetExplicitFormatArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetExplicitFormatArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetExplicitFormatArchive::GetClassData() const { return &_class_data_; }


void CommandSetExplicitFormatArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetExplicitFormatArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetExplicitFormatArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetExplicitFormatArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cell_format()->::TSK::FormatStructArchive::MergeFrom(
          from._internal_cell_format());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetExplicitFormatArchive::CopyFrom(const CommandSetExplicitFormatArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetExplicitFormatArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetExplicitFormatArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_cell_format()) {
    if (!_impl_.cell_format_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetExplicitFormatArchive::InternalSwap(CommandSetExplicitFormatArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetExplicitFormatArchive, _impl_.redo_cell_map_)
      + sizeof(CommandSetExplicitFormatArchive::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandSetExplicitFormatArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetExplicitFormatArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[59]);
}

// ===================================================================

class CommandSetNumberOfDecimalPlacesArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetNumberOfDecimalPlacesArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetNumberOfDecimalPlacesArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_decimal_places(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetNumberOfDecimalPlacesArchive::_Internal::super(const CommandSetNumberOfDecimalPlacesArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetNumberOfDecimalPlacesArchive::CommandSetNumberOfDecimalPlacesArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetNumberOfDecimalPlacesArchive)
}
CommandSetNumberOfDecimalPlacesArchive::CommandSetNumberOfDecimalPlacesArchive(const CommandSetNumberOfDecimalPlacesArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetNumberOfDecimalPlacesArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.decimal_places_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.decimal_places_ = from._impl_.decimal_places_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetNumberOfDecimalPlacesArchive)
}

inline void CommandSetNumberOfDecimalPlacesArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.decimal_places_){0u}
  };
}

CommandSetNumberOfDecimalPlacesArchive::~CommandSetNumberOfDecimalPlacesArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetNumberOfDecimalPlacesArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetNumberOfDecimalPlacesArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetNumberOfDecimalPlacesArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetNumberOfDecimalPlacesArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.decimal_places_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetNumberOfDecimalPlacesArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 decimal_places = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_decimal_places(&has_bits);
          _impl_.decimal_places_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetNumberOfDecimalPlacesArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 decimal_places = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_decimal_places(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetNumberOfDecimalPlacesArchive)
  return target;
}

size_t CommandSetNumberOfDecimalPlacesArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_decimal_places()) {
    // required uint32 decimal_places = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_decimal_places());
  }

  return total_size;
}
size_t CommandSetNumberOfDecimalPlacesArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 decimal_places = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_decimal_places());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetNumberOfDecimalPlacesArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetNumberOfDecimalPlacesArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetNumberOfDecimalPlacesArchive::GetClassData() const { return &_class_data_; }


void CommandSetNumberOfDecimalPlacesArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetNumberOfDecimalPlacesArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetNumberOfDecimalPlacesArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.decimal_places_ = from._impl_.decimal_places_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetNumberOfDecimalPlacesArchive::CopyFrom(const CommandSetNumberOfDecimalPlacesArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetNumberOfDecimalPlacesArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetNumberOfDecimalPlacesArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetNumberOfDecimalPlacesArchive::InternalSwap(CommandSetNumberOfDecimalPlacesArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetNumberOfDecimalPlacesArchive, _impl_.decimal_places_)
      + sizeof(CommandSetNumberOfDecimalPlacesArchive::_impl_.decimal_places_)
      - PROTOBUF_FIELD_OFFSET(CommandSetNumberOfDecimalPlacesArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetNumberOfDecimalPlacesArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[60]);
}

// ===================================================================

class CommandSetDateTimeFormatArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetDateTimeFormatArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetDateTimeFormatArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetDateTimeFormatArchive::_Internal::super(const CommandSetDateTimeFormatArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetDateTimeFormatArchive::CommandSetDateTimeFormatArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetDateTimeFormatArchive)
}
CommandSetDateTimeFormatArchive::CommandSetDateTimeFormatArchive(const CommandSetDateTimeFormatArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetDateTimeFormatArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetDateTimeFormatArchive)
}

inline void CommandSetDateTimeFormatArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandSetDateTimeFormatArchive::~CommandSetDateTimeFormatArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetDateTimeFormatArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetDateTimeFormatArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetDateTimeFormatArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetDateTimeFormatArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetDateTimeFormatArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetDateTimeFormatArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetDateTimeFormatArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetDateTimeFormatArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetDateTimeFormatArchive)
  return target;
}

size_t CommandSetDateTimeFormatArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetDateTimeFormatArchive)
  size_t total_size = 0;

  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetDateTimeFormatArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetDateTimeFormatArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetDateTimeFormatArchive::GetClassData() const { return &_class_data_; }


void CommandSetDateTimeFormatArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetDateTimeFormatArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetDateTimeFormatArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetDateTimeFormatArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetDateTimeFormatArchive::CopyFrom(const CommandSetDateTimeFormatArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetDateTimeFormatArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetDateTimeFormatArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetDateTimeFormatArchive::InternalSwap(CommandSetDateTimeFormatArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetDateTimeFormatArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[61]);
}

// ===================================================================

class CommandSetShowThousandsSeparatorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetShowThousandsSeparatorArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetShowThousandsSeparatorArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_show_thousands_separator(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetShowThousandsSeparatorArchive::_Internal::super(const CommandSetShowThousandsSeparatorArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetShowThousandsSeparatorArchive::CommandSetShowThousandsSeparatorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetShowThousandsSeparatorArchive)
}
CommandSetShowThousandsSeparatorArchive::CommandSetShowThousandsSeparatorArchive(const CommandSetShowThousandsSeparatorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetShowThousandsSeparatorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.show_thousands_separator_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.show_thousands_separator_ = from._impl_.show_thousands_separator_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetShowThousandsSeparatorArchive)
}

inline void CommandSetShowThousandsSeparatorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.show_thousands_separator_){false}
  };
}

CommandSetShowThousandsSeparatorArchive::~CommandSetShowThousandsSeparatorArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetShowThousandsSeparatorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetShowThousandsSeparatorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetShowThousandsSeparatorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetShowThousandsSeparatorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetShowThousandsSeparatorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.show_thousands_separator_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetShowThousandsSeparatorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool show_thousands_separator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_thousands_separator(&has_bits);
          _impl_.show_thousands_separator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetShowThousandsSeparatorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetShowThousandsSeparatorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool show_thousands_separator = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_thousands_separator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetShowThousandsSeparatorArchive)
  return target;
}

size_t CommandSetShowThousandsSeparatorArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetShowThousandsSeparatorArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_show_thousands_separator()) {
    // required bool show_thousands_separator = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetShowThousandsSeparatorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetShowThousandsSeparatorArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool show_thousands_separator = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetShowThousandsSeparatorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetShowThousandsSeparatorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetShowThousandsSeparatorArchive::GetClassData() const { return &_class_data_; }


void CommandSetShowThousandsSeparatorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetShowThousandsSeparatorArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetShowThousandsSeparatorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetShowThousandsSeparatorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.show_thousands_separator_ = from._impl_.show_thousands_separator_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetShowThousandsSeparatorArchive::CopyFrom(const CommandSetShowThousandsSeparatorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetShowThousandsSeparatorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetShowThousandsSeparatorArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetShowThousandsSeparatorArchive::InternalSwap(CommandSetShowThousandsSeparatorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetShowThousandsSeparatorArchive, _impl_.show_thousands_separator_)
      + sizeof(CommandSetShowThousandsSeparatorArchive::_impl_.show_thousands_separator_)
      - PROTOBUF_FIELD_OFFSET(CommandSetShowThousandsSeparatorArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetShowThousandsSeparatorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[62]);
}

// ===================================================================

class CommandSetUseAccountingStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetUseAccountingStyleArchive>()._impl_._has_bits_);
  static const ::TST::CommandSetSingleNumberFormatParameterArchive& super(const CommandSetUseAccountingStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_accounting_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::CommandSetSingleNumberFormatParameterArchive&
CommandSetUseAccountingStyleArchive::_Internal::super(const CommandSetUseAccountingStyleArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetUseAccountingStyleArchive::CommandSetUseAccountingStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetUseAccountingStyleArchive)
}
CommandSetUseAccountingStyleArchive::CommandSetUseAccountingStyleArchive(const CommandSetUseAccountingStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetUseAccountingStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.use_accounting_style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::CommandSetSingleNumberFormatParameterArchive(*from._impl_.super_);
  }
  _this->_impl_.use_accounting_style_ = from._impl_.use_accounting_style_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetUseAccountingStyleArchive)
}

inline void CommandSetUseAccountingStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.use_accounting_style_){false}
  };
}

CommandSetUseAccountingStyleArchive::~CommandSetUseAccountingStyleArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetUseAccountingStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetUseAccountingStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetUseAccountingStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetUseAccountingStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetUseAccountingStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.use_accounting_style_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetUseAccountingStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool use_accounting_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_use_accounting_style(&has_bits);
          _impl_.use_accounting_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetUseAccountingStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetUseAccountingStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool use_accounting_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_use_accounting_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetUseAccountingStyleArchive)
  return target;
}

size_t CommandSetUseAccountingStyleArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetUseAccountingStyleArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_use_accounting_style()) {
    // required bool use_accounting_style = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetUseAccountingStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetUseAccountingStyleArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.CommandSetSingleNumberFormatParameterArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool use_accounting_style = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetUseAccountingStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetUseAccountingStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetUseAccountingStyleArchive::GetClassData() const { return &_class_data_; }


void CommandSetUseAccountingStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetUseAccountingStyleArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetUseAccountingStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetUseAccountingStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::CommandSetSingleNumberFormatParameterArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.use_accounting_style_ = from._impl_.use_accounting_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetUseAccountingStyleArchive::CopyFrom(const CommandSetUseAccountingStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetUseAccountingStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetUseAccountingStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetUseAccountingStyleArchive::InternalSwap(CommandSetUseAccountingStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetUseAccountingStyleArchive, _impl_.use_accounting_style_)
      + sizeof(CommandSetUseAccountingStyleArchive::_impl_.use_accounting_style_)
      - PROTOBUF_FIELD_OFFSET(CommandSetUseAccountingStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetUseAccountingStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[63]);
}

// ===================================================================

class CommandMoveRowsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMoveRowsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandMoveRowsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandMoveRowsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_dest_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_number_of_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSP::Reference& formula_rewrite_command(const CommandMoveRowsArchive* msg);
  static void set_has_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& show_command(const CommandMoveRowsArchive* msg);
  static void set_has_show_command(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& unmerge_invalid_ranges_command(const CommandMoveRowsArchive* msg);
  static void set_has_unmerge_invalid_ranges_command(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000000e1) ^ 0x000000e1) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandMoveRowsArchive::_Internal::super(const CommandMoveRowsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandMoveRowsArchive::_Internal::selection(const CommandMoveRowsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TSP::Reference&
CommandMoveRowsArchive::_Internal::formula_rewrite_command(const CommandMoveRowsArchive* msg) {
  return *msg->_impl_.formula_rewrite_command_;
}
const ::TSP::Reference&
CommandMoveRowsArchive::_Internal::show_command(const CommandMoveRowsArchive* msg) {
  return *msg->_impl_.show_command_;
}
const ::TSP::Reference&
CommandMoveRowsArchive::_Internal::unmerge_invalid_ranges_command(const CommandMoveRowsArchive* msg) {
  return *msg->_impl_.unmerge_invalid_ranges_command_;
}
void CommandMoveRowsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandMoveRowsArchive::clear_formula_rewrite_command() {
  if (_impl_.formula_rewrite_command_ != nullptr) _impl_.formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandMoveRowsArchive::clear_show_command() {
  if (_impl_.show_command_ != nullptr) _impl_.show_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandMoveRowsArchive::clear_unmerge_invalid_ranges_command() {
  if (_impl_.unmerge_invalid_ranges_command_ != nullptr) _impl_.unmerge_invalid_ranges_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandMoveRowsArchive::CommandMoveRowsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandMoveRowsArchive)
}
CommandMoveRowsArchive::CommandMoveRowsArchive(const CommandMoveRowsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandMoveRowsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.show_command_){nullptr}
    , decltype(_impl_.unmerge_invalid_ranges_command_){nullptr}
    , decltype(_impl_.start_row_index_){}
    , decltype(_impl_.dest_row_index_){}
    , decltype(_impl_.number_of_rows_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_formula_rewrite_command()) {
    _this->_impl_.formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.formula_rewrite_command_);
  }
  if (from._internal_has_show_command()) {
    _this->_impl_.show_command_ = new ::TSP::Reference(*from._impl_.show_command_);
  }
  if (from._internal_has_unmerge_invalid_ranges_command()) {
    _this->_impl_.unmerge_invalid_ranges_command_ = new ::TSP::Reference(*from._impl_.unmerge_invalid_ranges_command_);
  }
  ::memcpy(&_impl_.start_row_index_, &from._impl_.start_row_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_rows_) -
    reinterpret_cast<char*>(&_impl_.start_row_index_)) + sizeof(_impl_.number_of_rows_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandMoveRowsArchive)
}

inline void CommandMoveRowsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.show_command_){nullptr}
    , decltype(_impl_.unmerge_invalid_ranges_command_){nullptr}
    , decltype(_impl_.start_row_index_){0u}
    , decltype(_impl_.dest_row_index_){0u}
    , decltype(_impl_.number_of_rows_){0u}
  };
}

CommandMoveRowsArchive::~CommandMoveRowsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandMoveRowsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandMoveRowsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.formula_rewrite_command_;
  if (this != internal_default_instance()) delete _impl_.show_command_;
  if (this != internal_default_instance()) delete _impl_.unmerge_invalid_ranges_command_;
}

void CommandMoveRowsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandMoveRowsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandMoveRowsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.formula_rewrite_command_ != nullptr);
      _impl_.formula_rewrite_command_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.show_command_ != nullptr);
      _impl_.show_command_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.unmerge_invalid_ranges_command_ != nullptr);
      _impl_.unmerge_invalid_ranges_command_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.start_row_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_rows_) -
        reinterpret_cast<char*>(&_impl_.start_row_index_)) + sizeof(_impl_.number_of_rows_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandMoveRowsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 start_row_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start_row_index(&has_bits);
          _impl_.start_row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 dest_row_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dest_row_index(&has_bits);
          _impl_.dest_row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_of_rows = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_number_of_rows(&has_bits);
          _impl_.number_of_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formula_rewrite_command = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference show_command = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference unmerge_invalid_ranges_command = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_unmerge_invalid_ranges_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandMoveRowsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandMoveRowsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required uint32 start_row_index = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_start_row_index(), target);
  }

  // required uint32 dest_row_index = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dest_row_index(), target);
  }

  // required uint32 number_of_rows = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_number_of_rows(), target);
  }

  // optional .TSP.Reference formula_rewrite_command = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::formula_rewrite_command(this),
        _Internal::formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference show_command = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::show_command(this),
        _Internal::show_command(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference unmerge_invalid_ranges_command = 9;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::unmerge_invalid_ranges_command(this),
        _Internal::unmerge_invalid_ranges_command(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandMoveRowsArchive)
  return target;
}

size_t CommandMoveRowsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandMoveRowsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_start_row_index()) {
    // required uint32 start_row_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_row_index());
  }

  if (_internal_has_dest_row_index()) {
    // required uint32 dest_row_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dest_row_index());
  }

  if (_internal_has_number_of_rows()) {
    // required uint32 number_of_rows = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_rows());
  }

  return total_size;
}
size_t CommandMoveRowsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandMoveRowsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000000e1) ^ 0x000000e1) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 start_row_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_row_index());

    // required uint32 dest_row_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dest_row_index());

    // required uint32 number_of_rows = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_rows());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TST.SelectionArchive selection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selection_);
    }

    // optional .TSP.Reference formula_rewrite_command = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formula_rewrite_command_);
    }

    // optional .TSP.Reference show_command = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.show_command_);
    }

    // optional .TSP.Reference unmerge_invalid_ranges_command = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.unmerge_invalid_ranges_command_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandMoveRowsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandMoveRowsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandMoveRowsArchive::GetClassData() const { return &_class_data_; }


void CommandMoveRowsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandMoveRowsArchive*>(&to_msg);
  auto& from = static_cast<const CommandMoveRowsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandMoveRowsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_formula_rewrite_command());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_show_command()->::TSP::Reference::MergeFrom(
          from._internal_show_command());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_unmerge_invalid_ranges_command()->::TSP::Reference::MergeFrom(
          from._internal_unmerge_invalid_ranges_command());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.start_row_index_ = from._impl_.start_row_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.dest_row_index_ = from._impl_.dest_row_index_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.number_of_rows_ = from._impl_.number_of_rows_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandMoveRowsArchive::CopyFrom(const CommandMoveRowsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandMoveRowsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMoveRowsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_formula_rewrite_command()) {
    if (!_impl_.formula_rewrite_command_->IsInitialized()) return false;
  }
  if (_internal_has_show_command()) {
    if (!_impl_.show_command_->IsInitialized()) return false;
  }
  if (_internal_has_unmerge_invalid_ranges_command()) {
    if (!_impl_.unmerge_invalid_ranges_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandMoveRowsArchive::InternalSwap(CommandMoveRowsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMoveRowsArchive, _impl_.number_of_rows_)
      + sizeof(CommandMoveRowsArchive::_impl_.number_of_rows_)
      - PROTOBUF_FIELD_OFFSET(CommandMoveRowsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandMoveRowsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[64]);
}

// ===================================================================

class CommandMoveColumnsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMoveColumnsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandMoveColumnsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandMoveColumnsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dest_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_columns(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSP::Reference& formula_rewrite_command(const CommandMoveColumnsArchive* msg);
  static void set_has_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& show_command(const CommandMoveColumnsArchive* msg);
  static void set_has_show_command(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000071) ^ 0x00000071) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandMoveColumnsArchive::_Internal::super(const CommandMoveColumnsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandMoveColumnsArchive::_Internal::selection(const CommandMoveColumnsArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TSP::Reference&
CommandMoveColumnsArchive::_Internal::formula_rewrite_command(const CommandMoveColumnsArchive* msg) {
  return *msg->_impl_.formula_rewrite_command_;
}
const ::TSP::Reference&
CommandMoveColumnsArchive::_Internal::show_command(const CommandMoveColumnsArchive* msg) {
  return *msg->_impl_.show_command_;
}
void CommandMoveColumnsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandMoveColumnsArchive::clear_formula_rewrite_command() {
  if (_impl_.formula_rewrite_command_ != nullptr) _impl_.formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandMoveColumnsArchive::clear_show_command() {
  if (_impl_.show_command_ != nullptr) _impl_.show_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandMoveColumnsArchive::CommandMoveColumnsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandMoveColumnsArchive)
}
CommandMoveColumnsArchive::CommandMoveColumnsArchive(const CommandMoveColumnsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandMoveColumnsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.show_command_){nullptr}
    , decltype(_impl_.start_column_index_){}
    , decltype(_impl_.dest_column_index_){}
    , decltype(_impl_.number_of_columns_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_formula_rewrite_command()) {
    _this->_impl_.formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.formula_rewrite_command_);
  }
  if (from._internal_has_show_command()) {
    _this->_impl_.show_command_ = new ::TSP::Reference(*from._impl_.show_command_);
  }
  ::memcpy(&_impl_.start_column_index_, &from._impl_.start_column_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_columns_) -
    reinterpret_cast<char*>(&_impl_.start_column_index_)) + sizeof(_impl_.number_of_columns_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandMoveColumnsArchive)
}

inline void CommandMoveColumnsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
    , decltype(_impl_.show_command_){nullptr}
    , decltype(_impl_.start_column_index_){0u}
    , decltype(_impl_.dest_column_index_){0u}
    , decltype(_impl_.number_of_columns_){0u}
  };
}

CommandMoveColumnsArchive::~CommandMoveColumnsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandMoveColumnsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandMoveColumnsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.formula_rewrite_command_;
  if (this != internal_default_instance()) delete _impl_.show_command_;
}

void CommandMoveColumnsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandMoveColumnsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandMoveColumnsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.formula_rewrite_command_ != nullptr);
      _impl_.formula_rewrite_command_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.show_command_ != nullptr);
      _impl_.show_command_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.start_column_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_columns_) -
        reinterpret_cast<char*>(&_impl_.start_column_index_)) + sizeof(_impl_.number_of_columns_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandMoveColumnsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 start_column_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_start_column_index(&has_bits);
          _impl_.start_column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 dest_column_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dest_column_index(&has_bits);
          _impl_.dest_column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 number_of_columns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_number_of_columns(&has_bits);
          _impl_.number_of_columns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formula_rewrite_command = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference show_command = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandMoveColumnsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandMoveColumnsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required uint32 start_column_index = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_start_column_index(), target);
  }

  // required uint32 dest_column_index = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dest_column_index(), target);
  }

  // required uint32 number_of_columns = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_number_of_columns(), target);
  }

  // optional .TSP.Reference formula_rewrite_command = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::formula_rewrite_command(this),
        _Internal::formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference show_command = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::show_command(this),
        _Internal::show_command(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandMoveColumnsArchive)
  return target;
}

size_t CommandMoveColumnsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandMoveColumnsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_start_column_index()) {
    // required uint32 start_column_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_column_index());
  }

  if (_internal_has_dest_column_index()) {
    // required uint32 dest_column_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dest_column_index());
  }

  if (_internal_has_number_of_columns()) {
    // required uint32 number_of_columns = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_columns());
  }

  return total_size;
}
size_t CommandMoveColumnsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandMoveColumnsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000071) ^ 0x00000071) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 start_column_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_start_column_index());

    // required uint32 dest_column_index = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dest_column_index());

    // required uint32 number_of_columns = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_number_of_columns());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TST.SelectionArchive selection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.selection_);
    }

    // optional .TSP.Reference formula_rewrite_command = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.formula_rewrite_command_);
    }

    // optional .TSP.Reference show_command = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.show_command_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandMoveColumnsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandMoveColumnsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandMoveColumnsArchive::GetClassData() const { return &_class_data_; }


void CommandMoveColumnsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandMoveColumnsArchive*>(&to_msg);
  auto& from = static_cast<const CommandMoveColumnsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandMoveColumnsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_formula_rewrite_command());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_show_command()->::TSP::Reference::MergeFrom(
          from._internal_show_command());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_column_index_ = from._impl_.start_column_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dest_column_index_ = from._impl_.dest_column_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_columns_ = from._impl_.number_of_columns_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandMoveColumnsArchive::CopyFrom(const CommandMoveColumnsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandMoveColumnsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMoveColumnsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_formula_rewrite_command()) {
    if (!_impl_.formula_rewrite_command_->IsInitialized()) return false;
  }
  if (_internal_has_show_command()) {
    if (!_impl_.show_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandMoveColumnsArchive::InternalSwap(CommandMoveColumnsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMoveColumnsArchive, _impl_.number_of_columns_)
      + sizeof(CommandMoveColumnsArchive::_impl_.number_of_columns_)
      - PROTOBUF_FIELD_OFFSET(CommandMoveColumnsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandMoveColumnsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[65]);
}

// ===================================================================

class CommandSortArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSortArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSortArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSK::ShuffleMappingArchive& mapping(const CommandSortArchive* msg);
  static void set_has_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& formula_rewrite_command(const CommandSortArchive* msg);
  static void set_has_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSortArchive::_Internal::super(const CommandSortArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSK::ShuffleMappingArchive&
CommandSortArchive::_Internal::mapping(const CommandSortArchive* msg) {
  return *msg->_impl_.mapping_;
}
const ::TSP::Reference&
CommandSortArchive::_Internal::formula_rewrite_command(const CommandSortArchive* msg) {
  return *msg->_impl_.formula_rewrite_command_;
}
void CommandSortArchive::clear_mapping() {
  if (_impl_.mapping_ != nullptr) _impl_.mapping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSortArchive::clear_formula_rewrite_command() {
  if (_impl_.formula_rewrite_command_ != nullptr) _impl_.formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSortArchive::CommandSortArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSortArchive)
}
CommandSortArchive::CommandSortArchive(const CommandSortArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSortArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.mapping_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_mapping()) {
    _this->_impl_.mapping_ = new ::TSK::ShuffleMappingArchive(*from._impl_.mapping_);
  }
  if (from._internal_has_formula_rewrite_command()) {
    _this->_impl_.formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.formula_rewrite_command_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSortArchive)
}

inline void CommandSortArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.mapping_){nullptr}
    , decltype(_impl_.formula_rewrite_command_){nullptr}
  };
}

CommandSortArchive::~CommandSortArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSortArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSortArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.mapping_;
  if (this != internal_default_instance()) delete _impl_.formula_rewrite_command_;
}

void CommandSortArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSortArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSortArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.mapping_ != nullptr);
      _impl_.mapping_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.formula_rewrite_command_ != nullptr);
      _impl_.formula_rewrite_command_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSortArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.ShuffleMappingArchive mapping = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference formula_rewrite_command = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSortArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSortArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSK.ShuffleMappingArchive mapping = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::mapping(this),
        _Internal::mapping(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference formula_rewrite_command = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::formula_rewrite_command(this),
        _Internal::formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSortArchive)
  return target;
}

size_t CommandSortArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSortArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_mapping()) {
    // required .TSK.ShuffleMappingArchive mapping = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mapping_);
  }

  return total_size;
}
size_t CommandSortArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSortArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSK.ShuffleMappingArchive mapping = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.mapping_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSP.Reference formula_rewrite_command = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_rewrite_command_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSortArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSortArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSortArchive::GetClassData() const { return &_class_data_; }


void CommandSortArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSortArchive*>(&to_msg);
  auto& from = static_cast<const CommandSortArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSortArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_mapping()->::TSK::ShuffleMappingArchive::MergeFrom(
          from._internal_mapping());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_formula_rewrite_command());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSortArchive::CopyFrom(const CommandSortArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSortArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSortArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_mapping()) {
    if (!_impl_.mapping_->IsInitialized()) return false;
  }
  if (_internal_has_formula_rewrite_command()) {
    if (!_impl_.formula_rewrite_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandSortArchive::InternalSwap(CommandSortArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSortArchive, _impl_.formula_rewrite_command_)
      + sizeof(CommandSortArchive::_impl_.formula_rewrite_command_)
      - PROTOBUF_FIELD_OFFSET(CommandSortArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSortArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[66]);
}

// ===================================================================

class CommandRewriteFormulasForSortArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFormulasForSortArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFormulasForSortArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::OwnerFormulaMapArchive& formula_map(const CommandRewriteFormulasForSortArchive* msg);
  static void set_has_formula_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSK::ShuffleMappingArchive& sort_mapping(const CommandRewriteFormulasForSortArchive* msg);
  static void set_has_sort_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CFUUIDArchive& sorted_table_id(const CommandRewriteFormulasForSortArchive* msg);
  static void set_has_sorted_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_explode_ranges(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFormulasForSortArchive::_Internal::super(const CommandRewriteFormulasForSortArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::OwnerFormulaMapArchive&
CommandRewriteFormulasForSortArchive::_Internal::formula_map(const CommandRewriteFormulasForSortArchive* msg) {
  return *msg->_impl_.formula_map_;
}
const ::TSK::ShuffleMappingArchive&
CommandRewriteFormulasForSortArchive::_Internal::sort_mapping(const CommandRewriteFormulasForSortArchive* msg) {
  return *msg->_impl_.sort_mapping_;
}
const ::TSCE::CFUUIDArchive&
CommandRewriteFormulasForSortArchive::_Internal::sorted_table_id(const CommandRewriteFormulasForSortArchive* msg) {
  return *msg->_impl_.sorted_table_id_;
}
void CommandRewriteFormulasForSortArchive::clear_formula_map() {
  if (_impl_.formula_map_ != nullptr) _impl_.formula_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFormulasForSortArchive::clear_sort_mapping() {
  if (_impl_.sort_mapping_ != nullptr) _impl_.sort_mapping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteFormulasForSortArchive::clear_sorted_table_id() {
  if (_impl_.sorted_table_id_ != nullptr) _impl_.sorted_table_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandRewriteFormulasForSortArchive::CommandRewriteFormulasForSortArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFormulasForSortArchive)
}
CommandRewriteFormulasForSortArchive::CommandRewriteFormulasForSortArchive(const CommandRewriteFormulasForSortArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFormulasForSortArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}
    , decltype(_impl_.explode_ranges_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_formula_map()) {
    _this->_impl_.formula_map_ = new ::TSCE::OwnerFormulaMapArchive(*from._impl_.formula_map_);
  }
  if (from._internal_has_sort_mapping()) {
    _this->_impl_.sort_mapping_ = new ::TSK::ShuffleMappingArchive(*from._impl_.sort_mapping_);
  }
  if (from._internal_has_sorted_table_id()) {
    _this->_impl_.sorted_table_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.sorted_table_id_);
  }
  _this->_impl_.explode_ranges_ = from._impl_.explode_ranges_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFormulasForSortArchive)
}

inline void CommandRewriteFormulasForSortArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}
    , decltype(_impl_.explode_ranges_){false}
  };
}

CommandRewriteFormulasForSortArchive::~CommandRewriteFormulasForSortArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFormulasForSortArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFormulasForSortArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.formula_map_;
  if (this != internal_default_instance()) delete _impl_.sort_mapping_;
  if (this != internal_default_instance()) delete _impl_.sorted_table_id_;
}

void CommandRewriteFormulasForSortArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFormulasForSortArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFormulasForSortArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.formula_map_ != nullptr);
      _impl_.formula_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.sort_mapping_ != nullptr);
      _impl_.sort_mapping_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.sorted_table_id_ != nullptr);
      _impl_.sorted_table_id_->Clear();
    }
  }
  _impl_.explode_ranges_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFormulasForSortArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.ShuffleMappingArchive sort_mapping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sort_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.CFUUIDArchive sorted_table_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sorted_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool explode_ranges = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_explode_ranges(&has_bits);
          _impl_.explode_ranges_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFormulasForSortArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFormulasForSortArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::formula_map(this),
        _Internal::formula_map(this).GetCachedSize(), target, stream);
  }

  // required .TSK.ShuffleMappingArchive sort_mapping = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sort_mapping(this),
        _Internal::sort_mapping(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.CFUUIDArchive sorted_table_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::sorted_table_id(this),
        _Internal::sorted_table_id(this).GetCachedSize(), target, stream);
  }

  // required bool explode_ranges = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_explode_ranges(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFormulasForSortArchive)
  return target;
}

size_t CommandRewriteFormulasForSortArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFormulasForSortArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_formula_map()) {
    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);
  }

  if (_internal_has_sort_mapping()) {
    // required .TSK.ShuffleMappingArchive sort_mapping = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);
  }

  if (_internal_has_sorted_table_id()) {
    // required .TSCE.CFUUIDArchive sorted_table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);
  }

  if (_internal_has_explode_ranges()) {
    // required bool explode_ranges = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandRewriteFormulasForSortArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFormulasForSortArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);

    // required .TSK.ShuffleMappingArchive sort_mapping = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);

    // required .TSCE.CFUUIDArchive sorted_table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);

    // required bool explode_ranges = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFormulasForSortArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFormulasForSortArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFormulasForSortArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFormulasForSortArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFormulasForSortArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFormulasForSortArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFormulasForSortArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_formula_map()->::TSCE::OwnerFormulaMapArchive::MergeFrom(
          from._internal_formula_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sort_mapping()->::TSK::ShuffleMappingArchive::MergeFrom(
          from._internal_sort_mapping());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_sorted_table_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_sorted_table_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.explode_ranges_ = from._impl_.explode_ranges_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFormulasForSortArchive::CopyFrom(const CommandRewriteFormulasForSortArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFormulasForSortArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFormulasForSortArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_formula_map()) {
    if (!_impl_.formula_map_->IsInitialized()) return false;
  }
  if (_internal_has_sort_mapping()) {
    if (!_impl_.sort_mapping_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFormulasForSortArchive::InternalSwap(CommandRewriteFormulasForSortArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForSortArchive, _impl_.explode_ranges_)
      + sizeof(CommandRewriteFormulasForSortArchive::_impl_.explode_ranges_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForSortArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFormulasForSortArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[67]);
}

// ===================================================================

class CommandRewriteFormulasForTectonicShiftArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFormulasForTectonicShiftArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFormulasForTectonicShiftArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::OwnerFormulaMapArchive& formula_map(const CommandRewriteFormulasForTectonicShiftArchive* msg);
  static void set_has_formula_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::TectonicShiftArchive& tectonic_shift(const CommandRewriteFormulasForTectonicShiftArchive* msg);
  static void set_has_tectonic_shift(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFormulasForTectonicShiftArchive::_Internal::super(const CommandRewriteFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::OwnerFormulaMapArchive&
CommandRewriteFormulasForTectonicShiftArchive::_Internal::formula_map(const CommandRewriteFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.formula_map_;
}
const ::TSCE::TectonicShiftArchive&
CommandRewriteFormulasForTectonicShiftArchive::_Internal::tectonic_shift(const CommandRewriteFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.tectonic_shift_;
}
void CommandRewriteFormulasForTectonicShiftArchive::clear_formula_map() {
  if (_impl_.formula_map_ != nullptr) _impl_.formula_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFormulasForTectonicShiftArchive::clear_tectonic_shift() {
  if (_impl_.tectonic_shift_ != nullptr) _impl_.tectonic_shift_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandRewriteFormulasForTectonicShiftArchive::CommandRewriteFormulasForTectonicShiftArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFormulasForTectonicShiftArchive)
}
CommandRewriteFormulasForTectonicShiftArchive::CommandRewriteFormulasForTectonicShiftArchive(const CommandRewriteFormulasForTectonicShiftArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFormulasForTectonicShiftArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_formula_map()) {
    _this->_impl_.formula_map_ = new ::TSCE::OwnerFormulaMapArchive(*from._impl_.formula_map_);
  }
  if (from._internal_has_tectonic_shift()) {
    _this->_impl_.tectonic_shift_ = new ::TSCE::TectonicShiftArchive(*from._impl_.tectonic_shift_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFormulasForTectonicShiftArchive)
}

inline void CommandRewriteFormulasForTectonicShiftArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}
  };
}

CommandRewriteFormulasForTectonicShiftArchive::~CommandRewriteFormulasForTectonicShiftArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFormulasForTectonicShiftArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFormulasForTectonicShiftArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.formula_map_;
  if (this != internal_default_instance()) delete _impl_.tectonic_shift_;
}

void CommandRewriteFormulasForTectonicShiftArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFormulasForTectonicShiftArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.formula_map_ != nullptr);
      _impl_.formula_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.tectonic_shift_ != nullptr);
      _impl_.tectonic_shift_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFormulasForTectonicShiftArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tectonic_shift(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFormulasForTectonicShiftArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::formula_map(this),
        _Internal::formula_map(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tectonic_shift(this),
        _Internal::tectonic_shift(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFormulasForTectonicShiftArchive)
  return target;
}

size_t CommandRewriteFormulasForTectonicShiftArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_formula_map()) {
    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);
  }

  if (_internal_has_tectonic_shift()) {
    // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);
  }

  return total_size;
}
size_t CommandRewriteFormulasForTectonicShiftArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);

    // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFormulasForTectonicShiftArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFormulasForTectonicShiftArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFormulasForTectonicShiftArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFormulasForTectonicShiftArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFormulasForTectonicShiftArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFormulasForTectonicShiftArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_formula_map()->::TSCE::OwnerFormulaMapArchive::MergeFrom(
          from._internal_formula_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_tectonic_shift()->::TSCE::TectonicShiftArchive::MergeFrom(
          from._internal_tectonic_shift());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFormulasForTectonicShiftArchive::CopyFrom(const CommandRewriteFormulasForTectonicShiftArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFormulasForTectonicShiftArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFormulasForTectonicShiftArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_formula_map()) {
    if (!_impl_.formula_map_->IsInitialized()) return false;
  }
  if (_internal_has_tectonic_shift()) {
    if (!_impl_.tectonic_shift_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFormulasForTectonicShiftArchive::InternalSwap(CommandRewriteFormulasForTectonicShiftArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForTectonicShiftArchive, _impl_.tectonic_shift_)
      + sizeof(CommandRewriteFormulasForTectonicShiftArchive::_impl_.tectonic_shift_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForTectonicShiftArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFormulasForTectonicShiftArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[68]);
}

// ===================================================================

class CommandRewriteFormulasForMoveArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFormulasForMoveArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFormulasForMoveArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::OwnerFormulaMapArchive& formula_map(const CommandRewriteFormulasForMoveArchive* msg);
  static void set_has_formula_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::RangeReferenceArchive& from_reference(const CommandRewriteFormulasForMoveArchive* msg);
  static void set_has_from_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::RangeReferenceArchive& to_reference(const CommandRewriteFormulasForMoveArchive* msg);
  static void set_has_to_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFormulasForMoveArchive::_Internal::super(const CommandRewriteFormulasForMoveArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::OwnerFormulaMapArchive&
CommandRewriteFormulasForMoveArchive::_Internal::formula_map(const CommandRewriteFormulasForMoveArchive* msg) {
  return *msg->_impl_.formula_map_;
}
const ::TSCE::RangeReferenceArchive&
CommandRewriteFormulasForMoveArchive::_Internal::from_reference(const CommandRewriteFormulasForMoveArchive* msg) {
  return *msg->_impl_.from_reference_;
}
const ::TSCE::RangeReferenceArchive&
CommandRewriteFormulasForMoveArchive::_Internal::to_reference(const CommandRewriteFormulasForMoveArchive* msg) {
  return *msg->_impl_.to_reference_;
}
void CommandRewriteFormulasForMoveArchive::clear_formula_map() {
  if (_impl_.formula_map_ != nullptr) _impl_.formula_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFormulasForMoveArchive::clear_from_reference() {
  if (_impl_.from_reference_ != nullptr) _impl_.from_reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteFormulasForMoveArchive::clear_to_reference() {
  if (_impl_.to_reference_ != nullptr) _impl_.to_reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandRewriteFormulasForMoveArchive::CommandRewriteFormulasForMoveArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFormulasForMoveArchive)
}
CommandRewriteFormulasForMoveArchive::CommandRewriteFormulasForMoveArchive(const CommandRewriteFormulasForMoveArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFormulasForMoveArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.from_reference_){nullptr}
    , decltype(_impl_.to_reference_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_formula_map()) {
    _this->_impl_.formula_map_ = new ::TSCE::OwnerFormulaMapArchive(*from._impl_.formula_map_);
  }
  if (from._internal_has_from_reference()) {
    _this->_impl_.from_reference_ = new ::TSCE::RangeReferenceArchive(*from._impl_.from_reference_);
  }
  if (from._internal_has_to_reference()) {
    _this->_impl_.to_reference_ = new ::TSCE::RangeReferenceArchive(*from._impl_.to_reference_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFormulasForMoveArchive)
}

inline void CommandRewriteFormulasForMoveArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.from_reference_){nullptr}
    , decltype(_impl_.to_reference_){nullptr}
  };
}

CommandRewriteFormulasForMoveArchive::~CommandRewriteFormulasForMoveArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFormulasForMoveArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFormulasForMoveArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.formula_map_;
  if (this != internal_default_instance()) delete _impl_.from_reference_;
  if (this != internal_default_instance()) delete _impl_.to_reference_;
}

void CommandRewriteFormulasForMoveArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFormulasForMoveArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFormulasForMoveArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.formula_map_ != nullptr);
      _impl_.formula_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.from_reference_ != nullptr);
      _impl_.from_reference_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.to_reference_ != nullptr);
      _impl_.to_reference_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFormulasForMoveArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.RangeReferenceArchive from_reference = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_from_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.RangeReferenceArchive to_reference = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFormulasForMoveArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFormulasForMoveArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::formula_map(this),
        _Internal::formula_map(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.RangeReferenceArchive from_reference = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::from_reference(this),
        _Internal::from_reference(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.RangeReferenceArchive to_reference = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::to_reference(this),
        _Internal::to_reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFormulasForMoveArchive)
  return target;
}

size_t CommandRewriteFormulasForMoveArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFormulasForMoveArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_formula_map()) {
    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);
  }

  if (_internal_has_from_reference()) {
    // required .TSCE.RangeReferenceArchive from_reference = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.from_reference_);
  }

  if (_internal_has_to_reference()) {
    // required .TSCE.RangeReferenceArchive to_reference = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_reference_);
  }

  return total_size;
}
size_t CommandRewriteFormulasForMoveArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFormulasForMoveArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);

    // required .TSCE.RangeReferenceArchive from_reference = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.from_reference_);

    // required .TSCE.RangeReferenceArchive to_reference = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_reference_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFormulasForMoveArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFormulasForMoveArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFormulasForMoveArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFormulasForMoveArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFormulasForMoveArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFormulasForMoveArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFormulasForMoveArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_formula_map()->::TSCE::OwnerFormulaMapArchive::MergeFrom(
          from._internal_formula_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_from_reference()->::TSCE::RangeReferenceArchive::MergeFrom(
          from._internal_from_reference());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_to_reference()->::TSCE::RangeReferenceArchive::MergeFrom(
          from._internal_to_reference());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFormulasForMoveArchive::CopyFrom(const CommandRewriteFormulasForMoveArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFormulasForMoveArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFormulasForMoveArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_formula_map()) {
    if (!_impl_.formula_map_->IsInitialized()) return false;
  }
  if (_internal_has_from_reference()) {
    if (!_impl_.from_reference_->IsInitialized()) return false;
  }
  if (_internal_has_to_reference()) {
    if (!_impl_.to_reference_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFormulasForMoveArchive::InternalSwap(CommandRewriteFormulasForMoveArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForMoveArchive, _impl_.to_reference_)
      + sizeof(CommandRewriteFormulasForMoveArchive::_impl_.to_reference_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForMoveArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFormulasForMoveArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[69]);
}

// ===================================================================

class CommandRewriteFormulasForCellMergeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFormulasForCellMergeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFormulasForCellMergeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::OwnerFormulaMapArchive& formula_map(const CommandRewriteFormulasForCellMergeArchive* msg);
  static void set_has_formula_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::RangeCoordinateArchive& merged_range(const CommandRewriteFormulasForCellMergeArchive* msg);
  static void set_has_merged_range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CFUUIDArchive& table_id(const CommandRewriteFormulasForCellMergeArchive* msg);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFormulasForCellMergeArchive::_Internal::super(const CommandRewriteFormulasForCellMergeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::OwnerFormulaMapArchive&
CommandRewriteFormulasForCellMergeArchive::_Internal::formula_map(const CommandRewriteFormulasForCellMergeArchive* msg) {
  return *msg->_impl_.formula_map_;
}
const ::TSCE::RangeCoordinateArchive&
CommandRewriteFormulasForCellMergeArchive::_Internal::merged_range(const CommandRewriteFormulasForCellMergeArchive* msg) {
  return *msg->_impl_.merged_range_;
}
const ::TSCE::CFUUIDArchive&
CommandRewriteFormulasForCellMergeArchive::_Internal::table_id(const CommandRewriteFormulasForCellMergeArchive* msg) {
  return *msg->_impl_.table_id_;
}
void CommandRewriteFormulasForCellMergeArchive::clear_formula_map() {
  if (_impl_.formula_map_ != nullptr) _impl_.formula_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFormulasForCellMergeArchive::clear_merged_range() {
  if (_impl_.merged_range_ != nullptr) _impl_.merged_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteFormulasForCellMergeArchive::clear_table_id() {
  if (_impl_.table_id_ != nullptr) _impl_.table_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandRewriteFormulasForCellMergeArchive::CommandRewriteFormulasForCellMergeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFormulasForCellMergeArchive)
}
CommandRewriteFormulasForCellMergeArchive::CommandRewriteFormulasForCellMergeArchive(const CommandRewriteFormulasForCellMergeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFormulasForCellMergeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.merged_range_){nullptr}
    , decltype(_impl_.table_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_formula_map()) {
    _this->_impl_.formula_map_ = new ::TSCE::OwnerFormulaMapArchive(*from._impl_.formula_map_);
  }
  if (from._internal_has_merged_range()) {
    _this->_impl_.merged_range_ = new ::TSCE::RangeCoordinateArchive(*from._impl_.merged_range_);
  }
  if (from._internal_has_table_id()) {
    _this->_impl_.table_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.table_id_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFormulasForCellMergeArchive)
}

inline void CommandRewriteFormulasForCellMergeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.formula_map_){nullptr}
    , decltype(_impl_.merged_range_){nullptr}
    , decltype(_impl_.table_id_){nullptr}
  };
}

CommandRewriteFormulasForCellMergeArchive::~CommandRewriteFormulasForCellMergeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFormulasForCellMergeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFormulasForCellMergeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.formula_map_;
  if (this != internal_default_instance()) delete _impl_.merged_range_;
  if (this != internal_default_instance()) delete _impl_.table_id_;
}

void CommandRewriteFormulasForCellMergeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFormulasForCellMergeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFormulasForCellMergeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.formula_map_ != nullptr);
      _impl_.formula_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.merged_range_ != nullptr);
      _impl_.merged_range_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.table_id_ != nullptr);
      _impl_.table_id_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFormulasForCellMergeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_formula_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.RangeCoordinateArchive merged_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_merged_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.CFUUIDArchive table_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFormulasForCellMergeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFormulasForCellMergeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::formula_map(this),
        _Internal::formula_map(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.RangeCoordinateArchive merged_range = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::merged_range(this),
        _Internal::merged_range(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.CFUUIDArchive table_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::table_id(this),
        _Internal::table_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFormulasForCellMergeArchive)
  return target;
}

size_t CommandRewriteFormulasForCellMergeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFormulasForCellMergeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_formula_map()) {
    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);
  }

  if (_internal_has_merged_range()) {
    // required .TSCE.RangeCoordinateArchive merged_range = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_range_);
  }

  if (_internal_has_table_id()) {
    // required .TSCE.CFUUIDArchive table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_id_);
  }

  return total_size;
}
size_t CommandRewriteFormulasForCellMergeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFormulasForCellMergeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.OwnerFormulaMapArchive formula_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.formula_map_);

    // required .TSCE.RangeCoordinateArchive merged_range = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_range_);

    // required .TSCE.CFUUIDArchive table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.table_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFormulasForCellMergeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFormulasForCellMergeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFormulasForCellMergeArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFormulasForCellMergeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFormulasForCellMergeArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFormulasForCellMergeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFormulasForCellMergeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_formula_map()->::TSCE::OwnerFormulaMapArchive::MergeFrom(
          from._internal_formula_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_merged_range()->::TSCE::RangeCoordinateArchive::MergeFrom(
          from._internal_merged_range());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_table_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_table_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFormulasForCellMergeArchive::CopyFrom(const CommandRewriteFormulasForCellMergeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFormulasForCellMergeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFormulasForCellMergeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_formula_map()) {
    if (!_impl_.formula_map_->IsInitialized()) return false;
  }
  if (_internal_has_merged_range()) {
    if (!_impl_.merged_range_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFormulasForCellMergeArchive::InternalSwap(CommandRewriteFormulasForCellMergeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForCellMergeArchive, _impl_.table_id_)
      + sizeof(CommandRewriteFormulasForCellMergeArchive::_impl_.table_id_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFormulasForCellMergeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFormulasForCellMergeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[70]);
}

// ===================================================================

class CommandRewriteFilterFormulasForTableResizeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFilterFormulasForTableResizeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFilterFormulasForTableResizeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFilterFormulasForTableResizeArchive::_Internal::super(const CommandRewriteFilterFormulasForTableResizeArchive* msg) {
  return *msg->_impl_.super_;
}
CommandRewriteFilterFormulasForTableResizeArchive::CommandRewriteFilterFormulasForTableResizeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFilterFormulasForTableResizeArchive)
}
CommandRewriteFilterFormulasForTableResizeArchive::CommandRewriteFilterFormulasForTableResizeArchive(const CommandRewriteFilterFormulasForTableResizeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFilterFormulasForTableResizeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFilterFormulasForTableResizeArchive)
}

inline void CommandRewriteFilterFormulasForTableResizeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandRewriteFilterFormulasForTableResizeArchive::~CommandRewriteFilterFormulasForTableResizeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFilterFormulasForTableResizeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandRewriteFilterFormulasForTableResizeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFilterFormulasForTableResizeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFilterFormulasForTableResizeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFilterFormulasForTableResizeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  return target;
}

size_t CommandRewriteFilterFormulasForTableResizeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  size_t total_size = 0;

  // required .TST.TableCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFilterFormulasForTableResizeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFilterFormulasForTableResizeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFilterFormulasForTableResizeArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFilterFormulasForTableResizeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFilterFormulasForTableResizeArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFilterFormulasForTableResizeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFilterFormulasForTableResizeArchive::CopyFrom(const CommandRewriteFilterFormulasForTableResizeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFilterFormulasForTableResizeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFilterFormulasForTableResizeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFilterFormulasForTableResizeArchive::InternalSwap(CommandRewriteFilterFormulasForTableResizeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFilterFormulasForTableResizeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[71]);
}

// ===================================================================

class CommandRewriteFilterFormulasForTectonicShiftArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFilterFormulasForTectonicShiftArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& filter_set(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg);
  static void set_has_filter_set(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::TectonicShiftArchive& tectonic_shift(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg);
  static void set_has_tectonic_shift(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFilterFormulasForTectonicShiftArchive::_Internal::super(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandRewriteFilterFormulasForTectonicShiftArchive::_Internal::filter_set(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.filter_set_;
}
const ::TSCE::TectonicShiftArchive&
CommandRewriteFilterFormulasForTectonicShiftArchive::_Internal::tectonic_shift(const CommandRewriteFilterFormulasForTectonicShiftArchive* msg) {
  return *msg->_impl_.tectonic_shift_;
}
void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_filter_set() {
  if (_impl_.filter_set_ != nullptr) _impl_.filter_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFilterFormulasForTectonicShiftArchive::clear_tectonic_shift() {
  if (_impl_.tectonic_shift_ != nullptr) _impl_.tectonic_shift_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandRewriteFilterFormulasForTectonicShiftArchive::CommandRewriteFilterFormulasForTectonicShiftArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
}
CommandRewriteFilterFormulasForTectonicShiftArchive::CommandRewriteFilterFormulasForTectonicShiftArchive(const CommandRewriteFilterFormulasForTectonicShiftArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFilterFormulasForTectonicShiftArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_filter_set()) {
    _this->_impl_.filter_set_ = new ::TSP::Reference(*from._impl_.filter_set_);
  }
  if (from._internal_has_tectonic_shift()) {
    _this->_impl_.tectonic_shift_ = new ::TSCE::TectonicShiftArchive(*from._impl_.tectonic_shift_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
}

inline void CommandRewriteFilterFormulasForTectonicShiftArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}
  };
}

CommandRewriteFilterFormulasForTectonicShiftArchive::~CommandRewriteFilterFormulasForTectonicShiftArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFilterFormulasForTectonicShiftArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.filter_set_;
  if (this != internal_default_instance()) delete _impl_.tectonic_shift_;
}

void CommandRewriteFilterFormulasForTectonicShiftArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFilterFormulasForTectonicShiftArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.filter_set_ != nullptr);
      _impl_.filter_set_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.tectonic_shift_ != nullptr);
      _impl_.tectonic_shift_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFilterFormulasForTectonicShiftArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference filter_set = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tectonic_shift(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFilterFormulasForTectonicShiftArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference filter_set = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::filter_set(this),
        _Internal::filter_set(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tectonic_shift(this),
        _Internal::tectonic_shift(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  return target;
}

size_t CommandRewriteFilterFormulasForTectonicShiftArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_set()) {
    // required .TSP.Reference filter_set = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.filter_set_);
  }

  if (_internal_has_tectonic_shift()) {
    // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);
  }

  return total_size;
}
size_t CommandRewriteFilterFormulasForTectonicShiftArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference filter_set = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.filter_set_);

    // required .TSCE.TectonicShiftArchive tectonic_shift = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFilterFormulasForTectonicShiftArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFilterFormulasForTectonicShiftArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFilterFormulasForTectonicShiftArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFilterFormulasForTectonicShiftArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFilterFormulasForTectonicShiftArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFilterFormulasForTectonicShiftArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_filter_set()->::TSP::Reference::MergeFrom(
          from._internal_filter_set());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_tectonic_shift()->::TSCE::TectonicShiftArchive::MergeFrom(
          from._internal_tectonic_shift());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFilterFormulasForTectonicShiftArchive::CopyFrom(const CommandRewriteFilterFormulasForTectonicShiftArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFilterFormulasForTectonicShiftArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFilterFormulasForTectonicShiftArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_filter_set()) {
    if (!_impl_.filter_set_->IsInitialized()) return false;
  }
  if (_internal_has_tectonic_shift()) {
    if (!_impl_.tectonic_shift_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFilterFormulasForTectonicShiftArchive::InternalSwap(CommandRewriteFilterFormulasForTectonicShiftArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_.tectonic_shift_)
      + sizeof(CommandRewriteFilterFormulasForTectonicShiftArchive::_impl_.tectonic_shift_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFilterFormulasForTectonicShiftArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFilterFormulasForTectonicShiftArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[72]);
}

// ===================================================================

class CommandRewriteFilterFormulasForSortArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteFilterFormulasForSortArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteFilterFormulasForSortArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& filter_set(const CommandRewriteFilterFormulasForSortArchive* msg);
  static void set_has_filter_set(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSK::ShuffleMappingArchive& sort_mapping(const CommandRewriteFilterFormulasForSortArchive* msg);
  static void set_has_sort_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CFUUIDArchive& sorted_table_id(const CommandRewriteFilterFormulasForSortArchive* msg);
  static void set_has_sorted_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteFilterFormulasForSortArchive::_Internal::super(const CommandRewriteFilterFormulasForSortArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandRewriteFilterFormulasForSortArchive::_Internal::filter_set(const CommandRewriteFilterFormulasForSortArchive* msg) {
  return *msg->_impl_.filter_set_;
}
const ::TSK::ShuffleMappingArchive&
CommandRewriteFilterFormulasForSortArchive::_Internal::sort_mapping(const CommandRewriteFilterFormulasForSortArchive* msg) {
  return *msg->_impl_.sort_mapping_;
}
const ::TSCE::CFUUIDArchive&
CommandRewriteFilterFormulasForSortArchive::_Internal::sorted_table_id(const CommandRewriteFilterFormulasForSortArchive* msg) {
  return *msg->_impl_.sorted_table_id_;
}
void CommandRewriteFilterFormulasForSortArchive::clear_filter_set() {
  if (_impl_.filter_set_ != nullptr) _impl_.filter_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteFilterFormulasForSortArchive::clear_sort_mapping() {
  if (_impl_.sort_mapping_ != nullptr) _impl_.sort_mapping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteFilterFormulasForSortArchive::clear_sorted_table_id() {
  if (_impl_.sorted_table_id_ != nullptr) _impl_.sorted_table_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandRewriteFilterFormulasForSortArchive::CommandRewriteFilterFormulasForSortArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteFilterFormulasForSortArchive)
}
CommandRewriteFilterFormulasForSortArchive::CommandRewriteFilterFormulasForSortArchive(const CommandRewriteFilterFormulasForSortArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteFilterFormulasForSortArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_filter_set()) {
    _this->_impl_.filter_set_ = new ::TSP::Reference(*from._impl_.filter_set_);
  }
  if (from._internal_has_sort_mapping()) {
    _this->_impl_.sort_mapping_ = new ::TSK::ShuffleMappingArchive(*from._impl_.sort_mapping_);
  }
  if (from._internal_has_sorted_table_id()) {
    _this->_impl_.sorted_table_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.sorted_table_id_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteFilterFormulasForSortArchive)
}

inline void CommandRewriteFilterFormulasForSortArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_set_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}
  };
}

CommandRewriteFilterFormulasForSortArchive::~CommandRewriteFilterFormulasForSortArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteFilterFormulasForSortArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteFilterFormulasForSortArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.filter_set_;
  if (this != internal_default_instance()) delete _impl_.sort_mapping_;
  if (this != internal_default_instance()) delete _impl_.sorted_table_id_;
}

void CommandRewriteFilterFormulasForSortArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteFilterFormulasForSortArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteFilterFormulasForSortArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.filter_set_ != nullptr);
      _impl_.filter_set_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.sort_mapping_ != nullptr);
      _impl_.sort_mapping_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.sorted_table_id_ != nullptr);
      _impl_.sorted_table_id_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteFilterFormulasForSortArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference filter_set = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter_set(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.ShuffleMappingArchive sort_mapping = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sort_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.CFUUIDArchive sorted_table_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sorted_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteFilterFormulasForSortArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteFilterFormulasForSortArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference filter_set = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::filter_set(this),
        _Internal::filter_set(this).GetCachedSize(), target, stream);
  }

  // required .TSK.ShuffleMappingArchive sort_mapping = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sort_mapping(this),
        _Internal::sort_mapping(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.CFUUIDArchive sorted_table_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::sorted_table_id(this),
        _Internal::sorted_table_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteFilterFormulasForSortArchive)
  return target;
}

size_t CommandRewriteFilterFormulasForSortArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteFilterFormulasForSortArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_set()) {
    // required .TSP.Reference filter_set = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.filter_set_);
  }

  if (_internal_has_sort_mapping()) {
    // required .TSK.ShuffleMappingArchive sort_mapping = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);
  }

  if (_internal_has_sorted_table_id()) {
    // required .TSCE.CFUUIDArchive sorted_table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);
  }

  return total_size;
}
size_t CommandRewriteFilterFormulasForSortArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteFilterFormulasForSortArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference filter_set = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.filter_set_);

    // required .TSK.ShuffleMappingArchive sort_mapping = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);

    // required .TSCE.CFUUIDArchive sorted_table_id = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteFilterFormulasForSortArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteFilterFormulasForSortArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteFilterFormulasForSortArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteFilterFormulasForSortArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteFilterFormulasForSortArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteFilterFormulasForSortArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteFilterFormulasForSortArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_filter_set()->::TSP::Reference::MergeFrom(
          from._internal_filter_set());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sort_mapping()->::TSK::ShuffleMappingArchive::MergeFrom(
          from._internal_sort_mapping());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_sorted_table_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_sorted_table_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteFilterFormulasForSortArchive::CopyFrom(const CommandRewriteFilterFormulasForSortArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteFilterFormulasForSortArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteFilterFormulasForSortArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_filter_set()) {
    if (!_impl_.filter_set_->IsInitialized()) return false;
  }
  if (_internal_has_sort_mapping()) {
    if (!_impl_.sort_mapping_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteFilterFormulasForSortArchive::InternalSwap(CommandRewriteFilterFormulasForSortArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteFilterFormulasForSortArchive, _impl_.sorted_table_id_)
      + sizeof(CommandRewriteFilterFormulasForSortArchive::_impl_.sorted_table_id_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteFilterFormulasForSortArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteFilterFormulasForSortArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[73]);
}

// ===================================================================

class CommandRewriteConditionalStylesForTectonicShiftArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteConditionalStylesForTectonicShiftArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::TectonicShiftArchive& tectonic_shift(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg);
  static void set_has_tectonic_shift(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg);
  static void set_has_cells_to_rewrite(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg);
  static void set_has_conditional_style_sets(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteConditionalStylesForTectonicShiftArchive::_Internal::super(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::TectonicShiftArchive&
CommandRewriteConditionalStylesForTectonicShiftArchive::_Internal::tectonic_shift(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg) {
  return *msg->_impl_.tectonic_shift_;
}
const ::TSCE::CellCoordinateVectorArchive&
CommandRewriteConditionalStylesForTectonicShiftArchive::_Internal::cells_to_rewrite(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg) {
  return *msg->_impl_.cells_to_rewrite_;
}
const ::TSCE::CellCoordinateObjectMapArchive&
CommandRewriteConditionalStylesForTectonicShiftArchive::_Internal::conditional_style_sets(const CommandRewriteConditionalStylesForTectonicShiftArchive* msg) {
  return *msg->_impl_.conditional_style_sets_;
}
void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_tectonic_shift() {
  if (_impl_.tectonic_shift_ != nullptr) _impl_.tectonic_shift_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_cells_to_rewrite() {
  if (_impl_.cells_to_rewrite_ != nullptr) _impl_.cells_to_rewrite_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteConditionalStylesForTectonicShiftArchive::clear_conditional_style_sets() {
  if (_impl_.conditional_style_sets_ != nullptr) _impl_.conditional_style_sets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandRewriteConditionalStylesForTectonicShiftArchive::CommandRewriteConditionalStylesForTectonicShiftArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
}
CommandRewriteConditionalStylesForTectonicShiftArchive::CommandRewriteConditionalStylesForTectonicShiftArchive(const CommandRewriteConditionalStylesForTectonicShiftArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteConditionalStylesForTectonicShiftArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_tectonic_shift()) {
    _this->_impl_.tectonic_shift_ = new ::TSCE::TectonicShiftArchive(*from._impl_.tectonic_shift_);
  }
  if (from._internal_has_cells_to_rewrite()) {
    _this->_impl_.cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive(*from._impl_.cells_to_rewrite_);
  }
  if (from._internal_has_conditional_style_sets()) {
    _this->_impl_.conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive(*from._impl_.conditional_style_sets_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
}

inline void CommandRewriteConditionalStylesForTectonicShiftArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tectonic_shift_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}
  };
}

CommandRewriteConditionalStylesForTectonicShiftArchive::~CommandRewriteConditionalStylesForTectonicShiftArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteConditionalStylesForTectonicShiftArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.tectonic_shift_;
  if (this != internal_default_instance()) delete _impl_.cells_to_rewrite_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_sets_;
}

void CommandRewriteConditionalStylesForTectonicShiftArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteConditionalStylesForTectonicShiftArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tectonic_shift_ != nullptr);
      _impl_.tectonic_shift_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.cells_to_rewrite_ != nullptr);
      _impl_.cells_to_rewrite_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.conditional_style_sets_ != nullptr);
      _impl_.conditional_style_sets_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteConditionalStylesForTectonicShiftArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tectonic_shift(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cells_to_rewrite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style_sets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteConditionalStylesForTectonicShiftArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tectonic_shift(this),
        _Internal::tectonic_shift(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cells_to_rewrite(this),
        _Internal::cells_to_rewrite(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::conditional_style_sets(this),
        _Internal::conditional_style_sets(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  return target;
}

size_t CommandRewriteConditionalStylesForTectonicShiftArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_tectonic_shift()) {
    // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);
  }

  return total_size;
}
size_t CommandRewriteConditionalStylesForTectonicShiftArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.TectonicShiftArchive tectonic_shift = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tectonic_shift_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cells_to_rewrite_);
    }

    // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_sets_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteConditionalStylesForTectonicShiftArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteConditionalStylesForTectonicShiftArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteConditionalStylesForTectonicShiftArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteConditionalStylesForTectonicShiftArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteConditionalStylesForTectonicShiftArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteConditionalStylesForTectonicShiftArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tectonic_shift()->::TSCE::TectonicShiftArchive::MergeFrom(
          from._internal_tectonic_shift());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_cells_to_rewrite()->::TSCE::CellCoordinateVectorArchive::MergeFrom(
          from._internal_cells_to_rewrite());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_conditional_style_sets()->::TSCE::CellCoordinateObjectMapArchive::MergeFrom(
          from._internal_conditional_style_sets());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteConditionalStylesForTectonicShiftArchive::CopyFrom(const CommandRewriteConditionalStylesForTectonicShiftArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteConditionalStylesForTectonicShiftArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteConditionalStylesForTectonicShiftArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_tectonic_shift()) {
    if (!_impl_.tectonic_shift_->IsInitialized()) return false;
  }
  if (_internal_has_conditional_style_sets()) {
    if (!_impl_.conditional_style_sets_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteConditionalStylesForTectonicShiftArchive::InternalSwap(CommandRewriteConditionalStylesForTectonicShiftArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.conditional_style_sets_)
      + sizeof(CommandRewriteConditionalStylesForTectonicShiftArchive::_impl_.conditional_style_sets_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForTectonicShiftArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteConditionalStylesForTectonicShiftArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[74]);
}

// ===================================================================

class CommandRewriteConditionalStylesForSortArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteConditionalStylesForSortArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteConditionalStylesForSortArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSK::ShuffleMappingArchive& sort_mapping(const CommandRewriteConditionalStylesForSortArchive* msg);
  static void set_has_sort_mapping(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::CFUUIDArchive& sorted_table_id(const CommandRewriteConditionalStylesForSortArchive* msg);
  static void set_has_sorted_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite(const CommandRewriteConditionalStylesForSortArchive* msg);
  static void set_has_cells_to_rewrite(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets(const CommandRewriteConditionalStylesForSortArchive* msg);
  static void set_has_conditional_style_sets(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteConditionalStylesForSortArchive::_Internal::super(const CommandRewriteConditionalStylesForSortArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSK::ShuffleMappingArchive&
CommandRewriteConditionalStylesForSortArchive::_Internal::sort_mapping(const CommandRewriteConditionalStylesForSortArchive* msg) {
  return *msg->_impl_.sort_mapping_;
}
const ::TSCE::CFUUIDArchive&
CommandRewriteConditionalStylesForSortArchive::_Internal::sorted_table_id(const CommandRewriteConditionalStylesForSortArchive* msg) {
  return *msg->_impl_.sorted_table_id_;
}
const ::TSCE::CellCoordinateVectorArchive&
CommandRewriteConditionalStylesForSortArchive::_Internal::cells_to_rewrite(const CommandRewriteConditionalStylesForSortArchive* msg) {
  return *msg->_impl_.cells_to_rewrite_;
}
const ::TSCE::CellCoordinateObjectMapArchive&
CommandRewriteConditionalStylesForSortArchive::_Internal::conditional_style_sets(const CommandRewriteConditionalStylesForSortArchive* msg) {
  return *msg->_impl_.conditional_style_sets_;
}
void CommandRewriteConditionalStylesForSortArchive::clear_sort_mapping() {
  if (_impl_.sort_mapping_ != nullptr) _impl_.sort_mapping_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteConditionalStylesForSortArchive::clear_sorted_table_id() {
  if (_impl_.sorted_table_id_ != nullptr) _impl_.sorted_table_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteConditionalStylesForSortArchive::clear_cells_to_rewrite() {
  if (_impl_.cells_to_rewrite_ != nullptr) _impl_.cells_to_rewrite_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandRewriteConditionalStylesForSortArchive::clear_conditional_style_sets() {
  if (_impl_.conditional_style_sets_ != nullptr) _impl_.conditional_style_sets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandRewriteConditionalStylesForSortArchive::CommandRewriteConditionalStylesForSortArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteConditionalStylesForSortArchive)
}
CommandRewriteConditionalStylesForSortArchive::CommandRewriteConditionalStylesForSortArchive(const CommandRewriteConditionalStylesForSortArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteConditionalStylesForSortArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_sort_mapping()) {
    _this->_impl_.sort_mapping_ = new ::TSK::ShuffleMappingArchive(*from._impl_.sort_mapping_);
  }
  if (from._internal_has_sorted_table_id()) {
    _this->_impl_.sorted_table_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.sorted_table_id_);
  }
  if (from._internal_has_cells_to_rewrite()) {
    _this->_impl_.cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive(*from._impl_.cells_to_rewrite_);
  }
  if (from._internal_has_conditional_style_sets()) {
    _this->_impl_.conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive(*from._impl_.conditional_style_sets_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteConditionalStylesForSortArchive)
}

inline void CommandRewriteConditionalStylesForSortArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.sort_mapping_){nullptr}
    , decltype(_impl_.sorted_table_id_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}
  };
}

CommandRewriteConditionalStylesForSortArchive::~CommandRewriteConditionalStylesForSortArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteConditionalStylesForSortArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteConditionalStylesForSortArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.sort_mapping_;
  if (this != internal_default_instance()) delete _impl_.sorted_table_id_;
  if (this != internal_default_instance()) delete _impl_.cells_to_rewrite_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_sets_;
}

void CommandRewriteConditionalStylesForSortArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteConditionalStylesForSortArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteConditionalStylesForSortArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sort_mapping_ != nullptr);
      _impl_.sort_mapping_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.sorted_table_id_ != nullptr);
      _impl_.sorted_table_id_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cells_to_rewrite_ != nullptr);
      _impl_.cells_to_rewrite_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.conditional_style_sets_ != nullptr);
      _impl_.conditional_style_sets_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteConditionalStylesForSortArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSK.ShuffleMappingArchive sort_mapping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sort_mapping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.CFUUIDArchive sorted_table_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sorted_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cells_to_rewrite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style_sets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteConditionalStylesForSortArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteConditionalStylesForSortArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSK.ShuffleMappingArchive sort_mapping = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::sort_mapping(this),
        _Internal::sort_mapping(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.CFUUIDArchive sorted_table_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sorted_table_id(this),
        _Internal::sorted_table_id(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cells_to_rewrite(this),
        _Internal::cells_to_rewrite(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::conditional_style_sets(this),
        _Internal::conditional_style_sets(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteConditionalStylesForSortArchive)
  return target;
}

size_t CommandRewriteConditionalStylesForSortArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteConditionalStylesForSortArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_sort_mapping()) {
    // required .TSK.ShuffleMappingArchive sort_mapping = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);
  }

  if (_internal_has_sorted_table_id()) {
    // required .TSCE.CFUUIDArchive sorted_table_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);
  }

  return total_size;
}
size_t CommandRewriteConditionalStylesForSortArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteConditionalStylesForSortArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSK.ShuffleMappingArchive sort_mapping = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sort_mapping_);

    // required .TSCE.CFUUIDArchive sorted_table_id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sorted_table_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cells_to_rewrite_);
    }

    // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_sets_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteConditionalStylesForSortArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteConditionalStylesForSortArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteConditionalStylesForSortArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteConditionalStylesForSortArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteConditionalStylesForSortArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteConditionalStylesForSortArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteConditionalStylesForSortArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sort_mapping()->::TSK::ShuffleMappingArchive::MergeFrom(
          from._internal_sort_mapping());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_sorted_table_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_sorted_table_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cells_to_rewrite()->::TSCE::CellCoordinateVectorArchive::MergeFrom(
          from._internal_cells_to_rewrite());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_conditional_style_sets()->::TSCE::CellCoordinateObjectMapArchive::MergeFrom(
          from._internal_conditional_style_sets());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteConditionalStylesForSortArchive::CopyFrom(const CommandRewriteConditionalStylesForSortArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteConditionalStylesForSortArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteConditionalStylesForSortArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_sort_mapping()) {
    if (!_impl_.sort_mapping_->IsInitialized()) return false;
  }
  if (_internal_has_conditional_style_sets()) {
    if (!_impl_.conditional_style_sets_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteConditionalStylesForSortArchive::InternalSwap(CommandRewriteConditionalStylesForSortArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForSortArchive, _impl_.conditional_style_sets_)
      + sizeof(CommandRewriteConditionalStylesForSortArchive::_impl_.conditional_style_sets_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForSortArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteConditionalStylesForSortArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[75]);
}

// ===================================================================

class CommandRewriteConditionalStylesForRangeMoveArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteConditionalStylesForRangeMoveArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteConditionalStylesForRangeMoveArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::RangeReferenceArchive& from_range_reference(const CommandRewriteConditionalStylesForRangeMoveArchive* msg);
  static void set_has_from_range_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSCE::RangeReferenceArchive& to_range_reference(const CommandRewriteConditionalStylesForRangeMoveArchive* msg);
  static void set_has_to_range_reference(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite(const CommandRewriteConditionalStylesForRangeMoveArchive* msg);
  static void set_has_cells_to_rewrite(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets(const CommandRewriteConditionalStylesForRangeMoveArchive* msg);
  static void set_has_conditional_style_sets(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteConditionalStylesForRangeMoveArchive::_Internal::super(const CommandRewriteConditionalStylesForRangeMoveArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::RangeReferenceArchive&
CommandRewriteConditionalStylesForRangeMoveArchive::_Internal::from_range_reference(const CommandRewriteConditionalStylesForRangeMoveArchive* msg) {
  return *msg->_impl_.from_range_reference_;
}
const ::TSCE::RangeReferenceArchive&
CommandRewriteConditionalStylesForRangeMoveArchive::_Internal::to_range_reference(const CommandRewriteConditionalStylesForRangeMoveArchive* msg) {
  return *msg->_impl_.to_range_reference_;
}
const ::TSCE::CellCoordinateVectorArchive&
CommandRewriteConditionalStylesForRangeMoveArchive::_Internal::cells_to_rewrite(const CommandRewriteConditionalStylesForRangeMoveArchive* msg) {
  return *msg->_impl_.cells_to_rewrite_;
}
const ::TSCE::CellCoordinateObjectMapArchive&
CommandRewriteConditionalStylesForRangeMoveArchive::_Internal::conditional_style_sets(const CommandRewriteConditionalStylesForRangeMoveArchive* msg) {
  return *msg->_impl_.conditional_style_sets_;
}
void CommandRewriteConditionalStylesForRangeMoveArchive::clear_from_range_reference() {
  if (_impl_.from_range_reference_ != nullptr) _impl_.from_range_reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandRewriteConditionalStylesForRangeMoveArchive::clear_to_range_reference() {
  if (_impl_.to_range_reference_ != nullptr) _impl_.to_range_reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandRewriteConditionalStylesForRangeMoveArchive::clear_cells_to_rewrite() {
  if (_impl_.cells_to_rewrite_ != nullptr) _impl_.cells_to_rewrite_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteConditionalStylesForRangeMoveArchive::clear_conditional_style_sets() {
  if (_impl_.conditional_style_sets_ != nullptr) _impl_.conditional_style_sets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandRewriteConditionalStylesForRangeMoveArchive::CommandRewriteConditionalStylesForRangeMoveArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
}
CommandRewriteConditionalStylesForRangeMoveArchive::CommandRewriteConditionalStylesForRangeMoveArchive(const CommandRewriteConditionalStylesForRangeMoveArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteConditionalStylesForRangeMoveArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}
    , decltype(_impl_.from_range_reference_){nullptr}
    , decltype(_impl_.to_range_reference_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_cells_to_rewrite()) {
    _this->_impl_.cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive(*from._impl_.cells_to_rewrite_);
  }
  if (from._internal_has_conditional_style_sets()) {
    _this->_impl_.conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive(*from._impl_.conditional_style_sets_);
  }
  if (from._internal_has_from_range_reference()) {
    _this->_impl_.from_range_reference_ = new ::TSCE::RangeReferenceArchive(*from._impl_.from_range_reference_);
  }
  if (from._internal_has_to_range_reference()) {
    _this->_impl_.to_range_reference_ = new ::TSCE::RangeReferenceArchive(*from._impl_.to_range_reference_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
}

inline void CommandRewriteConditionalStylesForRangeMoveArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}
    , decltype(_impl_.from_range_reference_){nullptr}
    , decltype(_impl_.to_range_reference_){nullptr}
  };
}

CommandRewriteConditionalStylesForRangeMoveArchive::~CommandRewriteConditionalStylesForRangeMoveArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteConditionalStylesForRangeMoveArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.cells_to_rewrite_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_sets_;
  if (this != internal_default_instance()) delete _impl_.from_range_reference_;
  if (this != internal_default_instance()) delete _impl_.to_range_reference_;
}

void CommandRewriteConditionalStylesForRangeMoveArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteConditionalStylesForRangeMoveArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cells_to_rewrite_ != nullptr);
      _impl_.cells_to_rewrite_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.conditional_style_sets_ != nullptr);
      _impl_.conditional_style_sets_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.from_range_reference_ != nullptr);
      _impl_.from_range_reference_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.to_range_reference_ != nullptr);
      _impl_.to_range_reference_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteConditionalStylesForRangeMoveArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cells_to_rewrite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style_sets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.RangeReferenceArchive from_range_reference = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_from_range_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.RangeReferenceArchive to_range_reference = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_range_reference(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteConditionalStylesForRangeMoveArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cells_to_rewrite(this),
        _Internal::cells_to_rewrite(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::conditional_style_sets(this),
        _Internal::conditional_style_sets(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.RangeReferenceArchive from_range_reference = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::from_range_reference(this),
        _Internal::from_range_reference(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.RangeReferenceArchive to_range_reference = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::to_range_reference(this),
        _Internal::to_range_reference(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  return target;
}

size_t CommandRewriteConditionalStylesForRangeMoveArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  size_t total_size = 0;

  // required .TST.TableCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cells_to_rewrite_);
    }

    // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_sets_);
    }

    // optional .TSCE.RangeReferenceArchive from_range_reference = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.from_range_reference_);
    }

    // optional .TSCE.RangeReferenceArchive to_range_reference = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.to_range_reference_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteConditionalStylesForRangeMoveArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteConditionalStylesForRangeMoveArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteConditionalStylesForRangeMoveArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteConditionalStylesForRangeMoveArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteConditionalStylesForRangeMoveArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteConditionalStylesForRangeMoveArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cells_to_rewrite()->::TSCE::CellCoordinateVectorArchive::MergeFrom(
          from._internal_cells_to_rewrite());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_conditional_style_sets()->::TSCE::CellCoordinateObjectMapArchive::MergeFrom(
          from._internal_conditional_style_sets());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_from_range_reference()->::TSCE::RangeReferenceArchive::MergeFrom(
          from._internal_from_range_reference());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_to_range_reference()->::TSCE::RangeReferenceArchive::MergeFrom(
          from._internal_to_range_reference());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteConditionalStylesForRangeMoveArchive::CopyFrom(const CommandRewriteConditionalStylesForRangeMoveArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteConditionalStylesForRangeMoveArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteConditionalStylesForRangeMoveArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_conditional_style_sets()) {
    if (!_impl_.conditional_style_sets_->IsInitialized()) return false;
  }
  if (_internal_has_from_range_reference()) {
    if (!_impl_.from_range_reference_->IsInitialized()) return false;
  }
  if (_internal_has_to_range_reference()) {
    if (!_impl_.to_range_reference_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteConditionalStylesForRangeMoveArchive::InternalSwap(CommandRewriteConditionalStylesForRangeMoveArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.to_range_reference_)
      + sizeof(CommandRewriteConditionalStylesForRangeMoveArchive::_impl_.to_range_reference_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForRangeMoveArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteConditionalStylesForRangeMoveArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[76]);
}

// ===================================================================

class CommandRewriteConditionalStylesForCellMergeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandRewriteConditionalStylesForCellMergeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandRewriteConditionalStylesForCellMergeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSCE::CFUUIDArchive& merged_table_id(const CommandRewriteConditionalStylesForCellMergeArchive* msg);
  static void set_has_merged_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSCE::RangeCoordinateArchive& merged_range(const CommandRewriteConditionalStylesForCellMergeArchive* msg);
  static void set_has_merged_range(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSCE::CellCoordinateVectorArchive& cells_to_rewrite(const CommandRewriteConditionalStylesForCellMergeArchive* msg);
  static void set_has_cells_to_rewrite(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSCE::CellCoordinateObjectMapArchive& conditional_style_sets(const CommandRewriteConditionalStylesForCellMergeArchive* msg);
  static void set_has_conditional_style_sets(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandRewriteConditionalStylesForCellMergeArchive::_Internal::super(const CommandRewriteConditionalStylesForCellMergeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSCE::CFUUIDArchive&
CommandRewriteConditionalStylesForCellMergeArchive::_Internal::merged_table_id(const CommandRewriteConditionalStylesForCellMergeArchive* msg) {
  return *msg->_impl_.merged_table_id_;
}
const ::TSCE::RangeCoordinateArchive&
CommandRewriteConditionalStylesForCellMergeArchive::_Internal::merged_range(const CommandRewriteConditionalStylesForCellMergeArchive* msg) {
  return *msg->_impl_.merged_range_;
}
const ::TSCE::CellCoordinateVectorArchive&
CommandRewriteConditionalStylesForCellMergeArchive::_Internal::cells_to_rewrite(const CommandRewriteConditionalStylesForCellMergeArchive* msg) {
  return *msg->_impl_.cells_to_rewrite_;
}
const ::TSCE::CellCoordinateObjectMapArchive&
CommandRewriteConditionalStylesForCellMergeArchive::_Internal::conditional_style_sets(const CommandRewriteConditionalStylesForCellMergeArchive* msg) {
  return *msg->_impl_.conditional_style_sets_;
}
void CommandRewriteConditionalStylesForCellMergeArchive::clear_merged_table_id() {
  if (_impl_.merged_table_id_ != nullptr) _impl_.merged_table_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandRewriteConditionalStylesForCellMergeArchive::clear_merged_range() {
  if (_impl_.merged_range_ != nullptr) _impl_.merged_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandRewriteConditionalStylesForCellMergeArchive::clear_cells_to_rewrite() {
  if (_impl_.cells_to_rewrite_ != nullptr) _impl_.cells_to_rewrite_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandRewriteConditionalStylesForCellMergeArchive::clear_conditional_style_sets() {
  if (_impl_.conditional_style_sets_ != nullptr) _impl_.conditional_style_sets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandRewriteConditionalStylesForCellMergeArchive::CommandRewriteConditionalStylesForCellMergeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandRewriteConditionalStylesForCellMergeArchive)
}
CommandRewriteConditionalStylesForCellMergeArchive::CommandRewriteConditionalStylesForCellMergeArchive(const CommandRewriteConditionalStylesForCellMergeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandRewriteConditionalStylesForCellMergeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.merged_table_id_){nullptr}
    , decltype(_impl_.merged_range_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_merged_table_id()) {
    _this->_impl_.merged_table_id_ = new ::TSCE::CFUUIDArchive(*from._impl_.merged_table_id_);
  }
  if (from._internal_has_merged_range()) {
    _this->_impl_.merged_range_ = new ::TSCE::RangeCoordinateArchive(*from._impl_.merged_range_);
  }
  if (from._internal_has_cells_to_rewrite()) {
    _this->_impl_.cells_to_rewrite_ = new ::TSCE::CellCoordinateVectorArchive(*from._impl_.cells_to_rewrite_);
  }
  if (from._internal_has_conditional_style_sets()) {
    _this->_impl_.conditional_style_sets_ = new ::TSCE::CellCoordinateObjectMapArchive(*from._impl_.conditional_style_sets_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandRewriteConditionalStylesForCellMergeArchive)
}

inline void CommandRewriteConditionalStylesForCellMergeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.merged_table_id_){nullptr}
    , decltype(_impl_.merged_range_){nullptr}
    , decltype(_impl_.cells_to_rewrite_){nullptr}
    , decltype(_impl_.conditional_style_sets_){nullptr}
  };
}

CommandRewriteConditionalStylesForCellMergeArchive::~CommandRewriteConditionalStylesForCellMergeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandRewriteConditionalStylesForCellMergeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.merged_table_id_;
  if (this != internal_default_instance()) delete _impl_.merged_range_;
  if (this != internal_default_instance()) delete _impl_.cells_to_rewrite_;
  if (this != internal_default_instance()) delete _impl_.conditional_style_sets_;
}

void CommandRewriteConditionalStylesForCellMergeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandRewriteConditionalStylesForCellMergeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.merged_table_id_ != nullptr);
      _impl_.merged_table_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.merged_range_ != nullptr);
      _impl_.merged_range_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.cells_to_rewrite_ != nullptr);
      _impl_.cells_to_rewrite_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.conditional_style_sets_ != nullptr);
      _impl_.conditional_style_sets_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandRewriteConditionalStylesForCellMergeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.CFUUIDArchive merged_table_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_merged_table_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSCE.RangeCoordinateArchive merged_range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_merged_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cells_to_rewrite(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditional_style_sets(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandRewriteConditionalStylesForCellMergeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.CFUUIDArchive merged_table_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::merged_table_id(this),
        _Internal::merged_table_id(this).GetCachedSize(), target, stream);
  }

  // required .TSCE.RangeCoordinateArchive merged_range = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::merged_range(this),
        _Internal::merged_range(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cells_to_rewrite(this),
        _Internal::cells_to_rewrite(this).GetCachedSize(), target, stream);
  }

  // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::conditional_style_sets(this),
        _Internal::conditional_style_sets(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  return target;
}

size_t CommandRewriteConditionalStylesForCellMergeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_merged_table_id()) {
    // required .TSCE.CFUUIDArchive merged_table_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_table_id_);
  }

  if (_internal_has_merged_range()) {
    // required .TSCE.RangeCoordinateArchive merged_range = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_range_);
  }

  return total_size;
}
size_t CommandRewriteConditionalStylesForCellMergeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSCE.CFUUIDArchive merged_table_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_table_id_);

    // required .TSCE.RangeCoordinateArchive merged_range = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.merged_range_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional .TSCE.CellCoordinateVectorArchive cells_to_rewrite = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cells_to_rewrite_);
    }

    // optional .TSCE.CellCoordinateObjectMapArchive conditional_style_sets = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.conditional_style_sets_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandRewriteConditionalStylesForCellMergeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandRewriteConditionalStylesForCellMergeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandRewriteConditionalStylesForCellMergeArchive::GetClassData() const { return &_class_data_; }


void CommandRewriteConditionalStylesForCellMergeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandRewriteConditionalStylesForCellMergeArchive*>(&to_msg);
  auto& from = static_cast<const CommandRewriteConditionalStylesForCellMergeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_merged_table_id()->::TSCE::CFUUIDArchive::MergeFrom(
          from._internal_merged_table_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_merged_range()->::TSCE::RangeCoordinateArchive::MergeFrom(
          from._internal_merged_range());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_cells_to_rewrite()->::TSCE::CellCoordinateVectorArchive::MergeFrom(
          from._internal_cells_to_rewrite());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_conditional_style_sets()->::TSCE::CellCoordinateObjectMapArchive::MergeFrom(
          from._internal_conditional_style_sets());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandRewriteConditionalStylesForCellMergeArchive::CopyFrom(const CommandRewriteConditionalStylesForCellMergeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandRewriteConditionalStylesForCellMergeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandRewriteConditionalStylesForCellMergeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_merged_range()) {
    if (!_impl_.merged_range_->IsInitialized()) return false;
  }
  if (_internal_has_conditional_style_sets()) {
    if (!_impl_.conditional_style_sets_->IsInitialized()) return false;
  }
  return true;
}

void CommandRewriteConditionalStylesForCellMergeArchive::InternalSwap(CommandRewriteConditionalStylesForCellMergeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForCellMergeArchive, _impl_.conditional_style_sets_)
      + sizeof(CommandRewriteConditionalStylesForCellMergeArchive::_impl_.conditional_style_sets_)
      - PROTOBUF_FIELD_OFFSET(CommandRewriteConditionalStylesForCellMergeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandRewriteConditionalStylesForCellMergeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[77]);
}

// ===================================================================

class CommandMergeUnmergeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMergeUnmergeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandMergeUnmergeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_merge_action(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TST::SelectionArchive& selection(const CommandMergeUnmergeArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandMergeUnmergeArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandMergeUnmergeArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& old_merge_ranges(const CommandMergeUnmergeArchive* msg);
  static void set_has_old_merge_ranges(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::Reference& undo_formula_rewrite_command(const CommandMergeUnmergeArchive* msg);
  static void set_has_undo_formula_rewrite_command(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000004f) ^ 0x0000004f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandMergeUnmergeArchive::_Internal::super(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandMergeUnmergeArchive::_Internal::selection(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandMergeUnmergeArchive::_Internal::undo_cell_map(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandMergeUnmergeArchive::_Internal::redo_cell_map(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandMergeUnmergeArchive::_Internal::old_merge_ranges(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.old_merge_ranges_;
}
const ::TSP::Reference&
CommandMergeUnmergeArchive::_Internal::undo_formula_rewrite_command(const CommandMergeUnmergeArchive* msg) {
  return *msg->_impl_.undo_formula_rewrite_command_;
}
void CommandMergeUnmergeArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandMergeUnmergeArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandMergeUnmergeArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandMergeUnmergeArchive::clear_old_merge_ranges() {
  if (_impl_.old_merge_ranges_ != nullptr) _impl_.old_merge_ranges_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
void CommandMergeUnmergeArchive::clear_undo_formula_rewrite_command() {
  if (_impl_.undo_formula_rewrite_command_ != nullptr) _impl_.undo_formula_rewrite_command_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
CommandMergeUnmergeArchive::CommandMergeUnmergeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandMergeUnmergeArchive)
}
CommandMergeUnmergeArchive::CommandMergeUnmergeArchive(const CommandMergeUnmergeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandMergeUnmergeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_merge_ranges_){nullptr}
    , decltype(_impl_.undo_formula_rewrite_command_){nullptr}
    , decltype(_impl_.merge_action_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_old_merge_ranges()) {
    _this->_impl_.old_merge_ranges_ = new ::TSP::Reference(*from._impl_.old_merge_ranges_);
  }
  if (from._internal_has_undo_formula_rewrite_command()) {
    _this->_impl_.undo_formula_rewrite_command_ = new ::TSP::Reference(*from._impl_.undo_formula_rewrite_command_);
  }
  _this->_impl_.merge_action_ = from._impl_.merge_action_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandMergeUnmergeArchive)
}

inline void CommandMergeUnmergeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.old_merge_ranges_){nullptr}
    , decltype(_impl_.undo_formula_rewrite_command_){nullptr}
    , decltype(_impl_.merge_action_){0}
  };
}

CommandMergeUnmergeArchive::~CommandMergeUnmergeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandMergeUnmergeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandMergeUnmergeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.old_merge_ranges_;
  if (this != internal_default_instance()) delete _impl_.undo_formula_rewrite_command_;
}

void CommandMergeUnmergeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandMergeUnmergeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandMergeUnmergeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.old_merge_ranges_ != nullptr);
      _impl_.old_merge_ranges_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.undo_formula_rewrite_command_ != nullptr);
      _impl_.undo_formula_rewrite_command_->Clear();
    }
  }
  _impl_.merge_action_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandMergeUnmergeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.MergeActionArchive merge_action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::MergeActionArchive_IsValid(val))) {
            _internal_set_merge_action(static_cast<::TST::MergeActionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_merge_ranges = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_merge_ranges(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference undo_formula_rewrite_command = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_formula_rewrite_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandMergeUnmergeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandMergeUnmergeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.MergeActionArchive merge_action = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_merge_action(), target);
  }

  // required .TST.SelectionArchive selection = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_merge_ranges = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::old_merge_ranges(this),
        _Internal::old_merge_ranges(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference undo_formula_rewrite_command = 9;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::undo_formula_rewrite_command(this),
        _Internal::undo_formula_rewrite_command(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandMergeUnmergeArchive)
  return target;
}

size_t CommandMergeUnmergeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandMergeUnmergeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  if (_internal_has_merge_action()) {
    // required .TST.MergeActionArchive merge_action = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_merge_action());
  }

  return total_size;
}
size_t CommandMergeUnmergeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandMergeUnmergeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000004f) ^ 0x0000004f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

    // required .TST.MergeActionArchive merge_action = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_merge_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000030u) {
    // optional .TSP.Reference old_merge_ranges = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_merge_ranges_);
    }

    // optional .TSP.Reference undo_formula_rewrite_command = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_formula_rewrite_command_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandMergeUnmergeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandMergeUnmergeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandMergeUnmergeArchive::GetClassData() const { return &_class_data_; }


void CommandMergeUnmergeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandMergeUnmergeArchive*>(&to_msg);
  auto& from = static_cast<const CommandMergeUnmergeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandMergeUnmergeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_old_merge_ranges()->::TSP::Reference::MergeFrom(
          from._internal_old_merge_ranges());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_undo_formula_rewrite_command()->::TSP::Reference::MergeFrom(
          from._internal_undo_formula_rewrite_command());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.merge_action_ = from._impl_.merge_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandMergeUnmergeArchive::CopyFrom(const CommandMergeUnmergeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandMergeUnmergeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMergeUnmergeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_old_merge_ranges()) {
    if (!_impl_.old_merge_ranges_->IsInitialized()) return false;
  }
  if (_internal_has_undo_formula_rewrite_command()) {
    if (!_impl_.undo_formula_rewrite_command_->IsInitialized()) return false;
  }
  return true;
}

void CommandMergeUnmergeArchive::InternalSwap(CommandMergeUnmergeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMergeUnmergeArchive, _impl_.merge_action_)
      + sizeof(CommandMergeUnmergeArchive::_impl_.merge_action_)
      - PROTOBUF_FIELD_OFFSET(CommandMergeUnmergeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandMergeUnmergeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[78]);
}

// ===================================================================

class CommandHideShowArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandHideShowArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandHideShowArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hide_show_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hiding_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSP::IndexSet& elements_affected(const CommandHideShowArchive* msg);
  static void set_has_elements_affected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandHideShowArchive::_Internal::super(const CommandHideShowArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::IndexSet&
CommandHideShowArchive::_Internal::elements_affected(const CommandHideShowArchive* msg) {
  return *msg->_impl_.elements_affected_;
}
void CommandHideShowArchive::clear_elements_affected() {
  if (_impl_.elements_affected_ != nullptr) _impl_.elements_affected_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CommandHideShowArchive::CommandHideShowArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandHideShowArchive)
}
CommandHideShowArchive::CommandHideShowArchive(const CommandHideShowArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandHideShowArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.old_hiding_states_){from._impl_.old_hiding_states_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.elements_affected_){nullptr}
    , decltype(_impl_.direction_){}
    , decltype(_impl_.hide_show_action_){}
    , decltype(_impl_.hiding_action_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_elements_affected()) {
    _this->_impl_.elements_affected_ = new ::TSP::IndexSet(*from._impl_.elements_affected_);
  }
  ::memcpy(&_impl_.direction_, &from._impl_.direction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hiding_action_) -
    reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.hiding_action_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandHideShowArchive)
}

inline void CommandHideShowArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.old_hiding_states_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.elements_affected_){nullptr}
    , decltype(_impl_.direction_){0}
    , decltype(_impl_.hide_show_action_){0}
    , decltype(_impl_.hiding_action_){0u}
  };
}

CommandHideShowArchive::~CommandHideShowArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandHideShowArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandHideShowArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.old_hiding_states_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.elements_affected_;
}

void CommandHideShowArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandHideShowArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandHideShowArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.old_hiding_states_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.elements_affected_ != nullptr);
      _impl_.elements_affected_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.direction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hiding_action_) -
        reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.hiding_action_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandHideShowArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CommandDirectionArchive direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::CommandDirectionArchive_IsValid(val))) {
            _internal_set_direction(static_cast<::TST::CommandDirectionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.HideShowActionArchive hide_show_action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::HideShowActionArchive_IsValid(val))) {
            _internal_set_hide_show_action(static_cast<::TST::HideShowActionArchive>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 hiding_action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hiding_action(&has_bits);
          _impl_.hiding_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.IndexSet elements_affected = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_elements_affected(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 old_hiding_states = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_old_hiding_states(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_old_hiding_states(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandHideShowArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandHideShowArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CommandDirectionArchive direction = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_direction(), target);
  }

  // required .TST.HideShowActionArchive hide_show_action = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_hide_show_action(), target);
  }

  // required uint32 hiding_action = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hiding_action(), target);
  }

  // required .TSP.IndexSet elements_affected = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::elements_affected(this),
        _Internal::elements_affected(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 old_hiding_states = 7;
  for (int i = 0, n = this->_internal_old_hiding_states_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_old_hiding_states(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandHideShowArchive)
  return target;
}

size_t CommandHideShowArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandHideShowArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_elements_affected()) {
    // required .TSP.IndexSet elements_affected = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.elements_affected_);
  }

  if (_internal_has_direction()) {
    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  if (_internal_has_hide_show_action()) {
    // required .TST.HideShowActionArchive hide_show_action = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hide_show_action());
  }

  if (_internal_has_hiding_action()) {
    // required uint32 hiding_action = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hiding_action());
  }

  return total_size;
}
size_t CommandHideShowArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandHideShowArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.IndexSet elements_affected = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.elements_affected_);

    // required .TST.CommandDirectionArchive direction = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());

    // required .TST.HideShowActionArchive hide_show_action = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_hide_show_action());

    // required uint32 hiding_action = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hiding_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 old_hiding_states = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.old_hiding_states_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_old_hiding_states_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandHideShowArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandHideShowArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandHideShowArchive::GetClassData() const { return &_class_data_; }


void CommandHideShowArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandHideShowArchive*>(&to_msg);
  auto& from = static_cast<const CommandHideShowArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandHideShowArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.old_hiding_states_.MergeFrom(from._impl_.old_hiding_states_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_elements_affected()->::TSP::IndexSet::MergeFrom(
          from._internal_elements_affected());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.direction_ = from._impl_.direction_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.hide_show_action_ = from._impl_.hide_show_action_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hiding_action_ = from._impl_.hiding_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandHideShowArchive::CopyFrom(const CommandHideShowArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandHideShowArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandHideShowArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_elements_affected()) {
    if (!_impl_.elements_affected_->IsInitialized()) return false;
  }
  return true;
}

void CommandHideShowArchive::InternalSwap(CommandHideShowArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.old_hiding_states_.InternalSwap(&other->_impl_.old_hiding_states_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandHideShowArchive, _impl_.hiding_action_)
      + sizeof(CommandHideShowArchive::_impl_.hiding_action_)
      - PROTOBUF_FIELD_OFFSET(CommandHideShowArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandHideShowArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[79]);
}

// ===================================================================

class TableInfoGeometryCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableInfoGeometryCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const TableInfoGeometryCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Size& scale_factor(const TableInfoGeometryCommandArchive* msg);
  static void set_has_scale_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& table_info(const TableInfoGeometryCommandArchive* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSD::GeometryArchive& new_geometry(const TableInfoGeometryCommandArchive* msg);
  static void set_has_new_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSD::GeometryArchive& old_geometry(const TableInfoGeometryCommandArchive* msg);
  static void set_has_old_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_turn_off_auto_resize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_should_clear_object_placeholder_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_did_match_object_placeholder_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSK::CommandArchive&
TableInfoGeometryCommandArchive::_Internal::super(const TableInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Size&
TableInfoGeometryCommandArchive::_Internal::scale_factor(const TableInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.scale_factor_;
}
const ::TSP::Reference&
TableInfoGeometryCommandArchive::_Internal::table_info(const TableInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.table_info_;
}
const ::TSD::GeometryArchive&
TableInfoGeometryCommandArchive::_Internal::new_geometry(const TableInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.new_geometry_;
}
const ::TSD::GeometryArchive&
TableInfoGeometryCommandArchive::_Internal::old_geometry(const TableInfoGeometryCommandArchive* msg) {
  return *msg->_impl_.old_geometry_;
}
void TableInfoGeometryCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TableInfoGeometryCommandArchive::clear_scale_factor() {
  if (_impl_.scale_factor_ != nullptr) _impl_.scale_factor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableInfoGeometryCommandArchive::clear_table_info() {
  if (_impl_.table_info_ != nullptr) _impl_.table_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void TableInfoGeometryCommandArchive::clear_new_geometry() {
  if (_impl_.new_geometry_ != nullptr) _impl_.new_geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void TableInfoGeometryCommandArchive::clear_old_geometry() {
  if (_impl_.old_geometry_ != nullptr) _impl_.old_geometry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
TableInfoGeometryCommandArchive::TableInfoGeometryCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableInfoGeometryCommandArchive)
}
TableInfoGeometryCommandArchive::TableInfoGeometryCommandArchive(const TableInfoGeometryCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableInfoGeometryCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.scale_factor_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.new_geometry_){nullptr}
    , decltype(_impl_.old_geometry_){nullptr}
    , decltype(_impl_.turn_off_auto_resize_){}
    , decltype(_impl_.should_clear_object_placeholder_flag_){}
    , decltype(_impl_.did_match_object_placeholder_geometry_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_scale_factor()) {
    _this->_impl_.scale_factor_ = new ::TSP::Size(*from._impl_.scale_factor_);
  }
  if (from._internal_has_table_info()) {
    _this->_impl_.table_info_ = new ::TSP::Reference(*from._impl_.table_info_);
  }
  if (from._internal_has_new_geometry()) {
    _this->_impl_.new_geometry_ = new ::TSD::GeometryArchive(*from._impl_.new_geometry_);
  }
  if (from._internal_has_old_geometry()) {
    _this->_impl_.old_geometry_ = new ::TSD::GeometryArchive(*from._impl_.old_geometry_);
  }
  ::memcpy(&_impl_.turn_off_auto_resize_, &from._impl_.turn_off_auto_resize_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.did_match_object_placeholder_geometry_) -
    reinterpret_cast<char*>(&_impl_.turn_off_auto_resize_)) + sizeof(_impl_.did_match_object_placeholder_geometry_));
  // @@protoc_insertion_point(copy_constructor:TST.TableInfoGeometryCommandArchive)
}

inline void TableInfoGeometryCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.scale_factor_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.new_geometry_){nullptr}
    , decltype(_impl_.old_geometry_){nullptr}
    , decltype(_impl_.turn_off_auto_resize_){false}
    , decltype(_impl_.should_clear_object_placeholder_flag_){false}
    , decltype(_impl_.did_match_object_placeholder_geometry_){false}
  };
}

TableInfoGeometryCommandArchive::~TableInfoGeometryCommandArchive() {
  // @@protoc_insertion_point(destructor:TST.TableInfoGeometryCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableInfoGeometryCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.scale_factor_;
  if (this != internal_default_instance()) delete _impl_.table_info_;
  if (this != internal_default_instance()) delete _impl_.new_geometry_;
  if (this != internal_default_instance()) delete _impl_.old_geometry_;
}

void TableInfoGeometryCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableInfoGeometryCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableInfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.scale_factor_ != nullptr);
      _impl_.scale_factor_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.table_info_ != nullptr);
      _impl_.table_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.new_geometry_ != nullptr);
      _impl_.new_geometry_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.old_geometry_ != nullptr);
      _impl_.old_geometry_->Clear();
    }
  }
  ::memset(&_impl_.turn_off_auto_resize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.did_match_object_placeholder_geometry_) -
      reinterpret_cast<char*>(&_impl_.turn_off_auto_resize_)) + sizeof(_impl_.did_match_object_placeholder_geometry_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableInfoGeometryCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Size scale_factor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale_factor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive new_geometry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSD.GeometryArchive old_geometry = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_geometry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool turn_off_auto_resize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_turn_off_auto_resize(&has_bits);
          _impl_.turn_off_auto_resize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_clear_object_placeholder_flag = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_should_clear_object_placeholder_flag(&has_bits);
          _impl_.should_clear_object_placeholder_flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool did_match_object_placeholder_geometry = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_did_match_object_placeholder_geometry(&has_bits);
          _impl_.did_match_object_placeholder_geometry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableInfoGeometryCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableInfoGeometryCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Size scale_factor = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::scale_factor(this),
        _Internal::scale_factor(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_info = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::table_info(this),
        _Internal::table_info(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive new_geometry = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::new_geometry(this),
        _Internal::new_geometry(this).GetCachedSize(), target, stream);
  }

  // optional .TSD.GeometryArchive old_geometry = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::old_geometry(this),
        _Internal::old_geometry(this).GetCachedSize(), target, stream);
  }

  // optional bool turn_off_auto_resize = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_turn_off_auto_resize(), target);
  }

  // optional bool should_clear_object_placeholder_flag = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_should_clear_object_placeholder_flag(), target);
  }

  // optional bool did_match_object_placeholder_geometry = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_did_match_object_placeholder_geometry(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableInfoGeometryCommandArchive)
  return target;
}

size_t TableInfoGeometryCommandArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.TableInfoGeometryCommandArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_scale_factor()) {
    // required .TSP.Size scale_factor = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scale_factor_);
  }

  return total_size;
}
size_t TableInfoGeometryCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableInfoGeometryCommandArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Size scale_factor = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.scale_factor_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000fcu) {
    // optional .TSP.Reference table_info = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_info_);
    }

    // optional .TSD.GeometryArchive new_geometry = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_geometry_);
    }

    // optional .TSD.GeometryArchive old_geometry = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_geometry_);
    }

    // optional bool turn_off_auto_resize = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool should_clear_object_placeholder_flag = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool did_match_object_placeholder_geometry = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableInfoGeometryCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableInfoGeometryCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableInfoGeometryCommandArchive::GetClassData() const { return &_class_data_; }


void TableInfoGeometryCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableInfoGeometryCommandArchive*>(&to_msg);
  auto& from = static_cast<const TableInfoGeometryCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableInfoGeometryCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_scale_factor()->::TSP::Size::MergeFrom(
          from._internal_scale_factor());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_table_info()->::TSP::Reference::MergeFrom(
          from._internal_table_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_new_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_new_geometry());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_old_geometry()->::TSD::GeometryArchive::MergeFrom(
          from._internal_old_geometry());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.turn_off_auto_resize_ = from._impl_.turn_off_auto_resize_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.should_clear_object_placeholder_flag_ = from._impl_.should_clear_object_placeholder_flag_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.did_match_object_placeholder_geometry_ = from._impl_.did_match_object_placeholder_geometry_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableInfoGeometryCommandArchive::CopyFrom(const TableInfoGeometryCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableInfoGeometryCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableInfoGeometryCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_scale_factor()) {
    if (!_impl_.scale_factor_->IsInitialized()) return false;
  }
  if (_internal_has_table_info()) {
    if (!_impl_.table_info_->IsInitialized()) return false;
  }
  if (_internal_has_new_geometry()) {
    if (!_impl_.new_geometry_->IsInitialized()) return false;
  }
  if (_internal_has_old_geometry()) {
    if (!_impl_.old_geometry_->IsInitialized()) return false;
  }
  return true;
}

void TableInfoGeometryCommandArchive::InternalSwap(TableInfoGeometryCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableInfoGeometryCommandArchive, _impl_.did_match_object_placeholder_geometry_)
      + sizeof(TableInfoGeometryCommandArchive::_impl_.did_match_object_placeholder_geometry_)
      - PROTOBUF_FIELD_OFFSET(TableInfoGeometryCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableInfoGeometryCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[80]);
}

// ===================================================================

class FormulaEditingCommandGroupArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormulaEditingCommandGroupArchive>()._impl_._has_bits_);
  static const ::TSK::ProgressiveCommandGroupArchive& super(const FormulaEditingCommandGroupArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_undoselectionvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_undoselectionstart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_undoselectionlength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_undoactivetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_redoselectionvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_redoselectionstart(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_redoselectionlength(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_redoactivetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000001ff) ^ 0x000001ff) != 0;
  }
};

const ::TSK::ProgressiveCommandGroupArchive&
FormulaEditingCommandGroupArchive::_Internal::super(const FormulaEditingCommandGroupArchive* msg) {
  return *msg->_impl_.super_;
}
void FormulaEditingCommandGroupArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FormulaEditingCommandGroupArchive::FormulaEditingCommandGroupArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FormulaEditingCommandGroupArchive)
}
FormulaEditingCommandGroupArchive::FormulaEditingCommandGroupArchive(const FormulaEditingCommandGroupArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormulaEditingCommandGroupArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undoselectionstart_){}
    , decltype(_impl_.undoselectionlength_){}
    , decltype(_impl_.undoselectionvalid_){}
    , decltype(_impl_.redoselectionvalid_){}
    , decltype(_impl_.undoactivetoken_){}
    , decltype(_impl_.redoselectionstart_){}
    , decltype(_impl_.redoselectionlength_){}
    , decltype(_impl_.redoactivetoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::ProgressiveCommandGroupArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.undoselectionstart_, &from._impl_.undoselectionstart_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.redoactivetoken_) -
    reinterpret_cast<char*>(&_impl_.undoselectionstart_)) + sizeof(_impl_.redoactivetoken_));
  // @@protoc_insertion_point(copy_constructor:TST.FormulaEditingCommandGroupArchive)
}

inline void FormulaEditingCommandGroupArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undoselectionstart_){0u}
    , decltype(_impl_.undoselectionlength_){0u}
    , decltype(_impl_.undoselectionvalid_){false}
    , decltype(_impl_.redoselectionvalid_){false}
    , decltype(_impl_.undoactivetoken_){0u}
    , decltype(_impl_.redoselectionstart_){0u}
    , decltype(_impl_.redoselectionlength_){0u}
    , decltype(_impl_.redoactivetoken_){0u}
  };
}

FormulaEditingCommandGroupArchive::~FormulaEditingCommandGroupArchive() {
  // @@protoc_insertion_point(destructor:TST.FormulaEditingCommandGroupArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormulaEditingCommandGroupArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void FormulaEditingCommandGroupArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormulaEditingCommandGroupArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FormulaEditingCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.undoselectionstart_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.redoselectionlength_) -
        reinterpret_cast<char*>(&_impl_.undoselectionstart_)) + sizeof(_impl_.redoselectionlength_));
  }
  _impl_.redoactivetoken_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormulaEditingCommandGroupArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.ProgressiveCommandGroupArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool undoSelectionValid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_undoselectionvalid(&has_bits);
          _impl_.undoselectionvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 undoSelectionStart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_undoselectionstart(&has_bits);
          _impl_.undoselectionstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 undoSelectionLength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_undoselectionlength(&has_bits);
          _impl_.undoselectionlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 undoActiveToken = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_undoactivetoken(&has_bits);
          _impl_.undoactivetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool redoSelectionValid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_redoselectionvalid(&has_bits);
          _impl_.redoselectionvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 redoSelectionStart = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_redoselectionstart(&has_bits);
          _impl_.redoselectionstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 redoSelectionLength = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_redoselectionlength(&has_bits);
          _impl_.redoselectionlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 redoActiveToken = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_redoactivetoken(&has_bits);
          _impl_.redoactivetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormulaEditingCommandGroupArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FormulaEditingCommandGroupArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.ProgressiveCommandGroupArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool undoSelectionValid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_undoselectionvalid(), target);
  }

  // required uint32 undoSelectionStart = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_undoselectionstart(), target);
  }

  // required uint32 undoSelectionLength = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_undoselectionlength(), target);
  }

  // required uint32 undoActiveToken = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_undoactivetoken(), target);
  }

  // required bool redoSelectionValid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_redoselectionvalid(), target);
  }

  // required uint32 redoSelectionStart = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_redoselectionstart(), target);
  }

  // required uint32 redoSelectionLength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_redoselectionlength(), target);
  }

  // required uint32 redoActiveToken = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_redoactivetoken(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FormulaEditingCommandGroupArchive)
  return target;
}

size_t FormulaEditingCommandGroupArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.FormulaEditingCommandGroupArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.ProgressiveCommandGroupArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undoselectionstart()) {
    // required uint32 undoSelectionStart = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionstart());
  }

  if (_internal_has_undoselectionlength()) {
    // required uint32 undoSelectionLength = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionlength());
  }

  if (_internal_has_undoselectionvalid()) {
    // required bool undoSelectionValid = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_redoselectionvalid()) {
    // required bool redoSelectionValid = 6;
    total_size += 1 + 1;
  }

  if (_internal_has_undoactivetoken()) {
    // required uint32 undoActiveToken = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoactivetoken());
  }

  if (_internal_has_redoselectionstart()) {
    // required uint32 redoSelectionStart = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionstart());
  }

  if (_internal_has_redoselectionlength()) {
    // required uint32 redoSelectionLength = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionlength());
  }

  if (_internal_has_redoactivetoken()) {
    // required uint32 redoActiveToken = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoactivetoken());
  }

  return total_size;
}
size_t FormulaEditingCommandGroupArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FormulaEditingCommandGroupArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000001ff) ^ 0x000001ff) == 0) {  // All required fields are present.
    // required .TSK.ProgressiveCommandGroupArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 undoSelectionStart = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionstart());

    // required uint32 undoSelectionLength = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionlength());

    // required bool undoSelectionValid = 2;
    total_size += 1 + 1;

    // required bool redoSelectionValid = 6;
    total_size += 1 + 1;

    // required uint32 undoActiveToken = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoactivetoken());

    // required uint32 redoSelectionStart = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionstart());

    // required uint32 redoSelectionLength = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionlength());

    // required uint32 redoActiveToken = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoactivetoken());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormulaEditingCommandGroupArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormulaEditingCommandGroupArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormulaEditingCommandGroupArchive::GetClassData() const { return &_class_data_; }


void FormulaEditingCommandGroupArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormulaEditingCommandGroupArchive*>(&to_msg);
  auto& from = static_cast<const FormulaEditingCommandGroupArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FormulaEditingCommandGroupArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::ProgressiveCommandGroupArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.undoselectionstart_ = from._impl_.undoselectionstart_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.undoselectionlength_ = from._impl_.undoselectionlength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.undoselectionvalid_ = from._impl_.undoselectionvalid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.redoselectionvalid_ = from._impl_.redoselectionvalid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.undoactivetoken_ = from._impl_.undoactivetoken_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.redoselectionstart_ = from._impl_.redoselectionstart_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.redoselectionlength_ = from._impl_.redoselectionlength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_redoactivetoken(from._internal_redoactivetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormulaEditingCommandGroupArchive::CopyFrom(const FormulaEditingCommandGroupArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FormulaEditingCommandGroupArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormulaEditingCommandGroupArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void FormulaEditingCommandGroupArchive::InternalSwap(FormulaEditingCommandGroupArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FormulaEditingCommandGroupArchive, _impl_.redoactivetoken_)
      + sizeof(FormulaEditingCommandGroupArchive::_impl_.redoactivetoken_)
      - PROTOBUF_FIELD_OFFSET(FormulaEditingCommandGroupArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FormulaEditingCommandGroupArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[81]);
}

// ===================================================================

class FormulaEditingCommandSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormulaEditingCommandSelectionBehaviorArchive>()._impl_._has_bits_);
  static void set_has_undoselectionvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_undoselectionstart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_undoselectionlength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_undoactivetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_redoselectionvalid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_redoselectionstart(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_redoselectionlength(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_redoactivetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::TSP::Reference& storage(const FormulaEditingCommandSelectionBehaviorArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::TSP::Reference&
FormulaEditingCommandSelectionBehaviorArchive::_Internal::storage(const FormulaEditingCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.storage_;
}
void FormulaEditingCommandSelectionBehaviorArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
FormulaEditingCommandSelectionBehaviorArchive::FormulaEditingCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.FormulaEditingCommandSelectionBehaviorArchive)
}
FormulaEditingCommandSelectionBehaviorArchive::FormulaEditingCommandSelectionBehaviorArchive(const FormulaEditingCommandSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormulaEditingCommandSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undoselectionstart_){}
    , decltype(_impl_.undoselectionlength_){}
    , decltype(_impl_.undoselectionvalid_){}
    , decltype(_impl_.redoselectionvalid_){}
    , decltype(_impl_.undoactivetoken_){}
    , decltype(_impl_.redoselectionstart_){}
    , decltype(_impl_.redoselectionlength_){}
    , decltype(_impl_.redoactivetoken_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  ::memcpy(&_impl_.undoselectionstart_, &from._impl_.undoselectionstart_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.redoactivetoken_) -
    reinterpret_cast<char*>(&_impl_.undoselectionstart_)) + sizeof(_impl_.redoactivetoken_));
  // @@protoc_insertion_point(copy_constructor:TST.FormulaEditingCommandSelectionBehaviorArchive)
}

inline void FormulaEditingCommandSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undoselectionstart_){0u}
    , decltype(_impl_.undoselectionlength_){0u}
    , decltype(_impl_.undoselectionvalid_){false}
    , decltype(_impl_.redoselectionvalid_){false}
    , decltype(_impl_.undoactivetoken_){0u}
    , decltype(_impl_.redoselectionstart_){0u}
    , decltype(_impl_.redoselectionlength_){0u}
    , decltype(_impl_.redoactivetoken_){0u}
  };
}

FormulaEditingCommandSelectionBehaviorArchive::~FormulaEditingCommandSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TST.FormulaEditingCommandSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormulaEditingCommandSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.storage_;
}

void FormulaEditingCommandSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormulaEditingCommandSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.FormulaEditingCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.storage_ != nullptr);
    _impl_.storage_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.undoselectionstart_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.redoselectionlength_) -
        reinterpret_cast<char*>(&_impl_.undoselectionstart_)) + sizeof(_impl_.redoselectionlength_));
  }
  _impl_.redoactivetoken_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormulaEditingCommandSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool undoSelectionValid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_undoselectionvalid(&has_bits);
          _impl_.undoselectionvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undoSelectionStart = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_undoselectionstart(&has_bits);
          _impl_.undoselectionstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undoSelectionLength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_undoselectionlength(&has_bits);
          _impl_.undoselectionlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 undoActiveToken = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_undoactivetoken(&has_bits);
          _impl_.undoactivetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool redoSelectionValid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_redoselectionvalid(&has_bits);
          _impl_.redoselectionvalid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redoSelectionStart = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_redoselectionstart(&has_bits);
          _impl_.redoselectionstart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redoSelectionLength = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_redoselectionlength(&has_bits);
          _impl_.redoselectionlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redoActiveToken = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_redoactivetoken(&has_bits);
          _impl_.redoactivetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormulaEditingCommandSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.FormulaEditingCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool undoSelectionValid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_undoselectionvalid(), target);
  }

  // optional uint32 undoSelectionStart = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_undoselectionstart(), target);
  }

  // optional uint32 undoSelectionLength = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_undoselectionlength(), target);
  }

  // optional uint32 undoActiveToken = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_undoactivetoken(), target);
  }

  // optional bool redoSelectionValid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_redoselectionvalid(), target);
  }

  // optional uint32 redoSelectionStart = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_redoselectionstart(), target);
  }

  // optional uint32 redoSelectionLength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_redoselectionlength(), target);
  }

  // optional uint32 redoActiveToken = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_redoactivetoken(), target);
  }

  // optional .TSP.Reference storage = 10;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.FormulaEditingCommandSelectionBehaviorArchive)
  return target;
}

size_t FormulaEditingCommandSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.FormulaEditingCommandSelectionBehaviorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSP.Reference storage = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional uint32 undoSelectionStart = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionstart());
    }

    // optional uint32 undoSelectionLength = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoselectionlength());
    }

    // optional bool undoSelectionValid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool redoSelectionValid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 undoActiveToken = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_undoactivetoken());
    }

    // optional uint32 redoSelectionStart = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionstart());
    }

    // optional uint32 redoSelectionLength = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoselectionlength());
    }

  }
  // optional uint32 redoActiveToken = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redoactivetoken());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormulaEditingCommandSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormulaEditingCommandSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormulaEditingCommandSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void FormulaEditingCommandSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormulaEditingCommandSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const FormulaEditingCommandSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.FormulaEditingCommandSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.undoselectionstart_ = from._impl_.undoselectionstart_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.undoselectionlength_ = from._impl_.undoselectionlength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.undoselectionvalid_ = from._impl_.undoselectionvalid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.redoselectionvalid_ = from._impl_.redoselectionvalid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.undoactivetoken_ = from._impl_.undoactivetoken_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.redoselectionstart_ = from._impl_.redoselectionstart_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.redoselectionlength_ = from._impl_.redoselectionlength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_redoactivetoken(from._internal_redoactivetoken());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormulaEditingCommandSelectionBehaviorArchive::CopyFrom(const FormulaEditingCommandSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.FormulaEditingCommandSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormulaEditingCommandSelectionBehaviorArchive::IsInitialized() const {
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  return true;
}

void FormulaEditingCommandSelectionBehaviorArchive::InternalSwap(FormulaEditingCommandSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FormulaEditingCommandSelectionBehaviorArchive, _impl_.redoactivetoken_)
      + sizeof(FormulaEditingCommandSelectionBehaviorArchive::_impl_.redoactivetoken_)
      - PROTOBUF_FIELD_OFFSET(FormulaEditingCommandSelectionBehaviorArchive, _impl_.storage_)>(
          reinterpret_cast<char*>(&_impl_.storage_),
          reinterpret_cast<char*>(&other->_impl_.storage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FormulaEditingCommandSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[82]);
}

// ===================================================================

class UndoRedoStateCommandSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UndoRedoStateCommandSelectionBehaviorArchive>()._impl_._has_bits_);
  static const ::TSP::Reference& before_undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_before_undo_redo_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& after_undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_after_undo_redo_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& table_info(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::SelectionArchive& before_table_selection(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_before_table_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TST::SelectionArchive& after_table_selection(const UndoRedoStateCommandSelectionBehaviorArchive* msg);
  static void set_has_after_table_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSP::Reference&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::before_undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.before_undo_redo_state_;
}
const ::TSP::Reference&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::after_undo_redo_state(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.after_undo_redo_state_;
}
const ::TSP::Reference&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::table_info(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.table_info_;
}
const ::TST::SelectionArchive&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::before_table_selection(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.before_table_selection_;
}
const ::TST::SelectionArchive&
UndoRedoStateCommandSelectionBehaviorArchive::_Internal::after_table_selection(const UndoRedoStateCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.after_table_selection_;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_before_undo_redo_state() {
  if (_impl_.before_undo_redo_state_ != nullptr) _impl_.before_undo_redo_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_after_undo_redo_state() {
  if (_impl_.after_undo_redo_state_ != nullptr) _impl_.after_undo_redo_state_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_table_info() {
  if (_impl_.table_info_ != nullptr) _impl_.table_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_before_table_selection() {
  if (_impl_.before_table_selection_ != nullptr) _impl_.before_table_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void UndoRedoStateCommandSelectionBehaviorArchive::clear_after_table_selection() {
  if (_impl_.after_table_selection_ != nullptr) _impl_.after_table_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.UndoRedoStateCommandSelectionBehaviorArchive)
}
UndoRedoStateCommandSelectionBehaviorArchive::UndoRedoStateCommandSelectionBehaviorArchive(const UndoRedoStateCommandSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UndoRedoStateCommandSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.before_undo_redo_state_){nullptr}
    , decltype(_impl_.after_undo_redo_state_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.before_table_selection_){nullptr}
    , decltype(_impl_.after_table_selection_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_before_undo_redo_state()) {
    _this->_impl_.before_undo_redo_state_ = new ::TSP::Reference(*from._impl_.before_undo_redo_state_);
  }
  if (from._internal_has_after_undo_redo_state()) {
    _this->_impl_.after_undo_redo_state_ = new ::TSP::Reference(*from._impl_.after_undo_redo_state_);
  }
  if (from._internal_has_table_info()) {
    _this->_impl_.table_info_ = new ::TSP::Reference(*from._impl_.table_info_);
  }
  if (from._internal_has_before_table_selection()) {
    _this->_impl_.before_table_selection_ = new ::TST::SelectionArchive(*from._impl_.before_table_selection_);
  }
  if (from._internal_has_after_table_selection()) {
    _this->_impl_.after_table_selection_ = new ::TST::SelectionArchive(*from._impl_.after_table_selection_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.UndoRedoStateCommandSelectionBehaviorArchive)
}

inline void UndoRedoStateCommandSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.before_undo_redo_state_){nullptr}
    , decltype(_impl_.after_undo_redo_state_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.before_table_selection_){nullptr}
    , decltype(_impl_.after_table_selection_){nullptr}
  };
}

UndoRedoStateCommandSelectionBehaviorArchive::~UndoRedoStateCommandSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UndoRedoStateCommandSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.before_undo_redo_state_;
  if (this != internal_default_instance()) delete _impl_.after_undo_redo_state_;
  if (this != internal_default_instance()) delete _impl_.table_info_;
  if (this != internal_default_instance()) delete _impl_.before_table_selection_;
  if (this != internal_default_instance()) delete _impl_.after_table_selection_;
}

void UndoRedoStateCommandSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UndoRedoStateCommandSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.before_undo_redo_state_ != nullptr);
      _impl_.before_undo_redo_state_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.after_undo_redo_state_ != nullptr);
      _impl_.after_undo_redo_state_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.table_info_ != nullptr);
      _impl_.table_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.before_table_selection_ != nullptr);
      _impl_.before_table_selection_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.after_table_selection_ != nullptr);
      _impl_.after_table_selection_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UndoRedoStateCommandSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSP.Reference before_undo_redo_state = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_before_undo_redo_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference after_undo_redo_state = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_after_undo_redo_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive before_table_selection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_before_table_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive after_table_selection = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_after_table_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UndoRedoStateCommandSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSP.Reference before_undo_redo_state = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::before_undo_redo_state(this),
        _Internal::before_undo_redo_state(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference after_undo_redo_state = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::after_undo_redo_state(this),
        _Internal::after_undo_redo_state(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_info = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::table_info(this),
        _Internal::table_info(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive before_table_selection = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::before_table_selection(this),
        _Internal::before_table_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive after_table_selection = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::after_table_selection(this),
        _Internal::after_table_selection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  return target;
}

size_t UndoRedoStateCommandSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSP.Reference before_undo_redo_state = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.before_undo_redo_state_);
    }

    // optional .TSP.Reference after_undo_redo_state = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.after_undo_redo_state_);
    }

    // optional .TSP.Reference table_info = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_info_);
    }

    // optional .TST.SelectionArchive before_table_selection = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.before_table_selection_);
    }

    // optional .TST.SelectionArchive after_table_selection = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.after_table_selection_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UndoRedoStateCommandSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UndoRedoStateCommandSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UndoRedoStateCommandSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void UndoRedoStateCommandSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UndoRedoStateCommandSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const UndoRedoStateCommandSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_before_undo_redo_state()->::TSP::Reference::MergeFrom(
          from._internal_before_undo_redo_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_after_undo_redo_state()->::TSP::Reference::MergeFrom(
          from._internal_after_undo_redo_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_table_info()->::TSP::Reference::MergeFrom(
          from._internal_table_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_before_table_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_before_table_selection());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_after_table_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_after_table_selection());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UndoRedoStateCommandSelectionBehaviorArchive::CopyFrom(const UndoRedoStateCommandSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.UndoRedoStateCommandSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UndoRedoStateCommandSelectionBehaviorArchive::IsInitialized() const {
  if (_internal_has_before_undo_redo_state()) {
    if (!_impl_.before_undo_redo_state_->IsInitialized()) return false;
  }
  if (_internal_has_after_undo_redo_state()) {
    if (!_impl_.after_undo_redo_state_->IsInitialized()) return false;
  }
  if (_internal_has_table_info()) {
    if (!_impl_.table_info_->IsInitialized()) return false;
  }
  if (_internal_has_before_table_selection()) {
    if (!_impl_.before_table_selection_->IsInitialized()) return false;
  }
  if (_internal_has_after_table_selection()) {
    if (!_impl_.after_table_selection_->IsInitialized()) return false;
  }
  return true;
}

void UndoRedoStateCommandSelectionBehaviorArchive::InternalSwap(UndoRedoStateCommandSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UndoRedoStateCommandSelectionBehaviorArchive, _impl_.after_table_selection_)
      + sizeof(UndoRedoStateCommandSelectionBehaviorArchive::_impl_.after_table_selection_)
      - PROTOBUF_FIELD_OFFSET(UndoRedoStateCommandSelectionBehaviorArchive, _impl_.before_undo_redo_state_)>(
          reinterpret_cast<char*>(&_impl_.before_undo_redo_state_),
          reinterpret_cast<char*>(&other->_impl_.before_undo_redo_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UndoRedoStateCommandSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[83]);
}

// ===================================================================

class TableCommandSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TableCommandSelectionBehaviorArchive>()._impl_._has_bits_);
  static const ::TST::SelectionArchive& before_table_selection(const TableCommandSelectionBehaviorArchive* msg);
  static void set_has_before_table_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& after_table_selection(const TableCommandSelectionBehaviorArchive* msg);
  static void set_has_after_table_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& table_info(const TableCommandSelectionBehaviorArchive* msg);
  static void set_has_table_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_column_hit_by_tap(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TST::SelectionArchive&
TableCommandSelectionBehaviorArchive::_Internal::before_table_selection(const TableCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.before_table_selection_;
}
const ::TST::SelectionArchive&
TableCommandSelectionBehaviorArchive::_Internal::after_table_selection(const TableCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.after_table_selection_;
}
const ::TSP::Reference&
TableCommandSelectionBehaviorArchive::_Internal::table_info(const TableCommandSelectionBehaviorArchive* msg) {
  return *msg->_impl_.table_info_;
}
void TableCommandSelectionBehaviorArchive::clear_before_table_selection() {
  if (_impl_.before_table_selection_ != nullptr) _impl_.before_table_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TableCommandSelectionBehaviorArchive::clear_after_table_selection() {
  if (_impl_.after_table_selection_ != nullptr) _impl_.after_table_selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TableCommandSelectionBehaviorArchive::clear_table_info() {
  if (_impl_.table_info_ != nullptr) _impl_.table_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TableCommandSelectionBehaviorArchive::TableCommandSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.TableCommandSelectionBehaviorArchive)
}
TableCommandSelectionBehaviorArchive::TableCommandSelectionBehaviorArchive(const TableCommandSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TableCommandSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.before_table_selection_){nullptr}
    , decltype(_impl_.after_table_selection_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.last_column_hit_by_tap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_before_table_selection()) {
    _this->_impl_.before_table_selection_ = new ::TST::SelectionArchive(*from._impl_.before_table_selection_);
  }
  if (from._internal_has_after_table_selection()) {
    _this->_impl_.after_table_selection_ = new ::TST::SelectionArchive(*from._impl_.after_table_selection_);
  }
  if (from._internal_has_table_info()) {
    _this->_impl_.table_info_ = new ::TSP::Reference(*from._impl_.table_info_);
  }
  _this->_impl_.last_column_hit_by_tap_ = from._impl_.last_column_hit_by_tap_;
  // @@protoc_insertion_point(copy_constructor:TST.TableCommandSelectionBehaviorArchive)
}

inline void TableCommandSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.before_table_selection_){nullptr}
    , decltype(_impl_.after_table_selection_){nullptr}
    , decltype(_impl_.table_info_){nullptr}
    , decltype(_impl_.last_column_hit_by_tap_){0u}
  };
}

TableCommandSelectionBehaviorArchive::~TableCommandSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TST.TableCommandSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TableCommandSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.before_table_selection_;
  if (this != internal_default_instance()) delete _impl_.after_table_selection_;
  if (this != internal_default_instance()) delete _impl_.table_info_;
}

void TableCommandSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TableCommandSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.TableCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.before_table_selection_ != nullptr);
      _impl_.before_table_selection_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.after_table_selection_ != nullptr);
      _impl_.after_table_selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.table_info_ != nullptr);
      _impl_.table_info_->Clear();
    }
  }
  _impl_.last_column_hit_by_tap_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TableCommandSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TST.SelectionArchive before_table_selection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_before_table_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive after_table_selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_after_table_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference table_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_table_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_column_hit_by_tap = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_last_column_hit_by_tap(&has_bits);
          _impl_.last_column_hit_by_tap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TableCommandSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.TableCommandSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TST.SelectionArchive before_table_selection = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::before_table_selection(this),
        _Internal::before_table_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive after_table_selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::after_table_selection(this),
        _Internal::after_table_selection(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference table_info = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::table_info(this),
        _Internal::table_info(this).GetCachedSize(), target, stream);
  }

  // optional uint32 last_column_hit_by_tap = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_last_column_hit_by_tap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.TableCommandSelectionBehaviorArchive)
  return target;
}

size_t TableCommandSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.TableCommandSelectionBehaviorArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .TST.SelectionArchive before_table_selection = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.before_table_selection_);
    }

    // optional .TST.SelectionArchive after_table_selection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.after_table_selection_);
    }

    // optional .TSP.Reference table_info = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.table_info_);
    }

    // optional uint32 last_column_hit_by_tap = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_column_hit_by_tap());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TableCommandSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TableCommandSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TableCommandSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void TableCommandSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TableCommandSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const TableCommandSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.TableCommandSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_before_table_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_before_table_selection());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_after_table_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_after_table_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_table_info()->::TSP::Reference::MergeFrom(
          from._internal_table_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.last_column_hit_by_tap_ = from._impl_.last_column_hit_by_tap_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TableCommandSelectionBehaviorArchive::CopyFrom(const TableCommandSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.TableCommandSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableCommandSelectionBehaviorArchive::IsInitialized() const {
  if (_internal_has_before_table_selection()) {
    if (!_impl_.before_table_selection_->IsInitialized()) return false;
  }
  if (_internal_has_after_table_selection()) {
    if (!_impl_.after_table_selection_->IsInitialized()) return false;
  }
  if (_internal_has_table_info()) {
    if (!_impl_.table_info_->IsInitialized()) return false;
  }
  return true;
}

void TableCommandSelectionBehaviorArchive::InternalSwap(TableCommandSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TableCommandSelectionBehaviorArchive, _impl_.last_column_hit_by_tap_)
      + sizeof(TableCommandSelectionBehaviorArchive::_impl_.last_column_hit_by_tap_)
      - PROTOBUF_FIELD_OFFSET(TableCommandSelectionBehaviorArchive, _impl_.before_table_selection_)>(
          reinterpret_cast<char*>(&_impl_.before_table_selection_),
          reinterpret_cast<char*>(&other->_impl_.before_table_selection_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TableCommandSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[84]);
}

// ===================================================================

class DisableTableNameSelectionBehaviorArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DisableTableNameSelectionBehaviorArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandSelectionBehaviorArchive& super(const DisableTableNameSelectionBehaviorArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableCommandSelectionBehaviorArchive&
DisableTableNameSelectionBehaviorArchive::_Internal::super(const DisableTableNameSelectionBehaviorArchive* msg) {
  return *msg->_impl_.super_;
}
DisableTableNameSelectionBehaviorArchive::DisableTableNameSelectionBehaviorArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.DisableTableNameSelectionBehaviorArchive)
}
DisableTableNameSelectionBehaviorArchive::DisableTableNameSelectionBehaviorArchive(const DisableTableNameSelectionBehaviorArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DisableTableNameSelectionBehaviorArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandSelectionBehaviorArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.DisableTableNameSelectionBehaviorArchive)
}

inline void DisableTableNameSelectionBehaviorArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

DisableTableNameSelectionBehaviorArchive::~DisableTableNameSelectionBehaviorArchive() {
  // @@protoc_insertion_point(destructor:TST.DisableTableNameSelectionBehaviorArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DisableTableNameSelectionBehaviorArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void DisableTableNameSelectionBehaviorArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DisableTableNameSelectionBehaviorArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.DisableTableNameSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DisableTableNameSelectionBehaviorArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandSelectionBehaviorArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DisableTableNameSelectionBehaviorArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.DisableTableNameSelectionBehaviorArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandSelectionBehaviorArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.DisableTableNameSelectionBehaviorArchive)
  return target;
}

size_t DisableTableNameSelectionBehaviorArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.DisableTableNameSelectionBehaviorArchive)
  size_t total_size = 0;

  // required .TST.TableCommandSelectionBehaviorArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DisableTableNameSelectionBehaviorArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DisableTableNameSelectionBehaviorArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DisableTableNameSelectionBehaviorArchive::GetClassData() const { return &_class_data_; }


void DisableTableNameSelectionBehaviorArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DisableTableNameSelectionBehaviorArchive*>(&to_msg);
  auto& from = static_cast<const DisableTableNameSelectionBehaviorArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.DisableTableNameSelectionBehaviorArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::TableCommandSelectionBehaviorArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DisableTableNameSelectionBehaviorArchive::CopyFrom(const DisableTableNameSelectionBehaviorArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.DisableTableNameSelectionBehaviorArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisableTableNameSelectionBehaviorArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void DisableTableNameSelectionBehaviorArchive::InternalSwap(DisableTableNameSelectionBehaviorArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DisableTableNameSelectionBehaviorArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[85]);
}

// ===================================================================

class CommandApplyCellCommentArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyCellCommentArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandApplyCellCommentArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellID& cell_id(const CommandApplyCellCommentArchive* msg);
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& old_comment_storage(const CommandApplyCellCommentArchive* msg);
  static void set_has_old_comment_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& new_comment_storage(const CommandApplyCellCommentArchive* msg);
  static void set_has_new_comment_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandApplyCellCommentArchive::_Internal::super(const CommandApplyCellCommentArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellID&
CommandApplyCellCommentArchive::_Internal::cell_id(const CommandApplyCellCommentArchive* msg) {
  return *msg->_impl_.cell_id_;
}
const ::TSP::Reference&
CommandApplyCellCommentArchive::_Internal::old_comment_storage(const CommandApplyCellCommentArchive* msg) {
  return *msg->_impl_.old_comment_storage_;
}
const ::TSP::Reference&
CommandApplyCellCommentArchive::_Internal::new_comment_storage(const CommandApplyCellCommentArchive* msg) {
  return *msg->_impl_.new_comment_storage_;
}
void CommandApplyCellCommentArchive::clear_cell_id() {
  if (_impl_.cell_id_ != nullptr) _impl_.cell_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandApplyCellCommentArchive::clear_old_comment_storage() {
  if (_impl_.old_comment_storage_ != nullptr) _impl_.old_comment_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandApplyCellCommentArchive::clear_new_comment_storage() {
  if (_impl_.new_comment_storage_ != nullptr) _impl_.new_comment_storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandApplyCellCommentArchive::CommandApplyCellCommentArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyCellCommentArchive)
}
CommandApplyCellCommentArchive::CommandApplyCellCommentArchive(const CommandApplyCellCommentArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyCellCommentArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cell_id_){nullptr}
    , decltype(_impl_.old_comment_storage_){nullptr}
    , decltype(_impl_.new_comment_storage_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_cell_id()) {
    _this->_impl_.cell_id_ = new ::TST::CellID(*from._impl_.cell_id_);
  }
  if (from._internal_has_old_comment_storage()) {
    _this->_impl_.old_comment_storage_ = new ::TSP::Reference(*from._impl_.old_comment_storage_);
  }
  if (from._internal_has_new_comment_storage()) {
    _this->_impl_.new_comment_storage_ = new ::TSP::Reference(*from._impl_.new_comment_storage_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyCellCommentArchive)
}

inline void CommandApplyCellCommentArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.cell_id_){nullptr}
    , decltype(_impl_.old_comment_storage_){nullptr}
    , decltype(_impl_.new_comment_storage_){nullptr}
  };
}

CommandApplyCellCommentArchive::~CommandApplyCellCommentArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyCellCommentArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyCellCommentArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.cell_id_;
  if (this != internal_default_instance()) delete _impl_.old_comment_storage_;
  if (this != internal_default_instance()) delete _impl_.new_comment_storage_;
}

void CommandApplyCellCommentArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyCellCommentArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyCellCommentArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.cell_id_ != nullptr);
      _impl_.cell_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.old_comment_storage_ != nullptr);
      _impl_.old_comment_storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.new_comment_storage_ != nullptr);
      _impl_.new_comment_storage_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyCellCommentArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellID cell_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_comment_storage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_comment_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_comment_storage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_comment_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyCellCommentArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyCellCommentArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellID cell_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cell_id(this),
        _Internal::cell_id(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_comment_storage = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::old_comment_storage(this),
        _Internal::old_comment_storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_comment_storage = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::new_comment_storage(this),
        _Internal::new_comment_storage(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyCellCommentArchive)
  return target;
}

size_t CommandApplyCellCommentArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyCellCommentArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_cell_id()) {
    // required .TST.CellID cell_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_id_);
  }

  return total_size;
}
size_t CommandApplyCellCommentArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyCellCommentArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellID cell_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional .TSP.Reference old_comment_storage = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_comment_storage_);
    }

    // optional .TSP.Reference new_comment_storage = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_comment_storage_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyCellCommentArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyCellCommentArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyCellCommentArchive::GetClassData() const { return &_class_data_; }


void CommandApplyCellCommentArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyCellCommentArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyCellCommentArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyCellCommentArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_cell_id()->::TST::CellID::MergeFrom(
          from._internal_cell_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_old_comment_storage()->::TSP::Reference::MergeFrom(
          from._internal_old_comment_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_new_comment_storage()->::TSP::Reference::MergeFrom(
          from._internal_new_comment_storage());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyCellCommentArchive::CopyFrom(const CommandApplyCellCommentArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyCellCommentArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyCellCommentArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_cell_id()) {
    if (!_impl_.cell_id_->IsInitialized()) return false;
  }
  if (_internal_has_old_comment_storage()) {
    if (!_impl_.old_comment_storage_->IsInitialized()) return false;
  }
  if (_internal_has_new_comment_storage()) {
    if (!_impl_.new_comment_storage_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyCellCommentArchive::InternalSwap(CommandApplyCellCommentArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyCellCommentArchive, _impl_.new_comment_storage_)
      + sizeof(CommandApplyCellCommentArchive::_impl_.new_comment_storage_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyCellCommentArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyCellCommentArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[86]);
}

// ===================================================================

class CommandApplyConditionalStyleSetArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandApplyConditionalStyleSetArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandApplyConditionalStyleSetArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::SelectionArchive& selection(const CommandApplyConditionalStyleSetArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandApplyConditionalStyleSetArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandApplyConditionalStyleSetArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandApplyConditionalStyleSetArchive::_Internal::super(const CommandApplyConditionalStyleSetArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::SelectionArchive&
CommandApplyConditionalStyleSetArchive::_Internal::selection(const CommandApplyConditionalStyleSetArchive* msg) {
  return *msg->_impl_.selection_;
}
const ::TST::CellMapArchive&
CommandApplyConditionalStyleSetArchive::_Internal::undo_cell_map(const CommandApplyConditionalStyleSetArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandApplyConditionalStyleSetArchive::_Internal::redo_cell_map(const CommandApplyConditionalStyleSetArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
void CommandApplyConditionalStyleSetArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandApplyConditionalStyleSetArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandApplyConditionalStyleSetArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandApplyConditionalStyleSetArchive::CommandApplyConditionalStyleSetArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandApplyConditionalStyleSetArchive)
}
CommandApplyConditionalStyleSetArchive::CommandApplyConditionalStyleSetArchive(const CommandApplyConditionalStyleSetArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandApplyConditionalStyleSetArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandApplyConditionalStyleSetArchive)
}

inline void CommandApplyConditionalStyleSetArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.selection_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
  };
}

CommandApplyConditionalStyleSetArchive::~CommandApplyConditionalStyleSetArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandApplyConditionalStyleSetArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandApplyConditionalStyleSetArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.selection_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
}

void CommandApplyConditionalStyleSetArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandApplyConditionalStyleSetArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandApplyConditionalStyleSetArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandApplyConditionalStyleSetArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.SelectionArchive selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandApplyConditionalStyleSetArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandApplyConditionalStyleSetArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.SelectionArchive selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandApplyConditionalStyleSetArchive)
  return target;
}

size_t CommandApplyConditionalStyleSetArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandApplyConditionalStyleSetArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_selection()) {
    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandApplyConditionalStyleSetArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandApplyConditionalStyleSetArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.SelectionArchive selection = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);

    // required .TST.CellMapArchive undo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandApplyConditionalStyleSetArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandApplyConditionalStyleSetArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandApplyConditionalStyleSetArchive::GetClassData() const { return &_class_data_; }


void CommandApplyConditionalStyleSetArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandApplyConditionalStyleSetArchive*>(&to_msg);
  auto& from = static_cast<const CommandApplyConditionalStyleSetArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandApplyConditionalStyleSetArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandApplyConditionalStyleSetArchive::CopyFrom(const CommandApplyConditionalStyleSetArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandApplyConditionalStyleSetArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandApplyConditionalStyleSetArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  return true;
}

void CommandApplyConditionalStyleSetArchive::InternalSwap(CommandApplyConditionalStyleSetArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandApplyConditionalStyleSetArchive, _impl_.redo_cell_map_)
      + sizeof(CommandApplyConditionalStyleSetArchive::_impl_.redo_cell_map_)
      - PROTOBUF_FIELD_OFFSET(CommandApplyConditionalStyleSetArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandApplyConditionalStyleSetArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[87]);
}

// ===================================================================

class CommandSetFormulaTokenizationArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFormulaTokenizationArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const CommandSetFormulaTokenizationArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tokenization(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TSK::CommandArchive&
CommandSetFormulaTokenizationArchive::_Internal::super(const CommandSetFormulaTokenizationArchive* msg) {
  return *msg->_impl_.super_;
}
void CommandSetFormulaTokenizationArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CommandSetFormulaTokenizationArchive::CommandSetFormulaTokenizationArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFormulaTokenizationArchive)
}
CommandSetFormulaTokenizationArchive::CommandSetFormulaTokenizationArchive(const CommandSetFormulaTokenizationArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFormulaTokenizationArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tokenization_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  _this->_impl_.tokenization_ = from._impl_.tokenization_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFormulaTokenizationArchive)
}

inline void CommandSetFormulaTokenizationArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.tokenization_){false}
  };
}

CommandSetFormulaTokenizationArchive::~CommandSetFormulaTokenizationArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFormulaTokenizationArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFormulaTokenizationArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFormulaTokenizationArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFormulaTokenizationArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFormulaTokenizationArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.tokenization_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFormulaTokenizationArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool tokenization = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tokenization(&has_bits);
          _impl_.tokenization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFormulaTokenizationArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFormulaTokenizationArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required bool tokenization = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_tokenization(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFormulaTokenizationArchive)
  return target;
}

size_t CommandSetFormulaTokenizationArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFormulaTokenizationArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_tokenization()) {
    // required bool tokenization = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetFormulaTokenizationArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFormulaTokenizationArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required bool tokenization = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFormulaTokenizationArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFormulaTokenizationArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFormulaTokenizationArchive::GetClassData() const { return &_class_data_; }


void CommandSetFormulaTokenizationArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFormulaTokenizationArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFormulaTokenizationArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFormulaTokenizationArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tokenization_ = from._impl_.tokenization_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFormulaTokenizationArchive::CopyFrom(const CommandSetFormulaTokenizationArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFormulaTokenizationArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFormulaTokenizationArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFormulaTokenizationArchive::InternalSwap(CommandSetFormulaTokenizationArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFormulaTokenizationArchive, _impl_.tokenization_)
      + sizeof(CommandSetFormulaTokenizationArchive::_impl_.tokenization_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFormulaTokenizationArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFormulaTokenizationArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[88]);
}

// ===================================================================

class CommandSetFilterEnabledArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFilterEnabledArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetFilterEnabledArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetFilterEnabledArchive::_Internal::super(const CommandSetFilterEnabledArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetFilterEnabledArchive::CommandSetFilterEnabledArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFilterEnabledArchive)
}
CommandSetFilterEnabledArchive::CommandSetFilterEnabledArchive(const CommandSetFilterEnabledArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFilterEnabledArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.filter_index_, &from._impl_.filter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFilterEnabledArchive)
}

inline void CommandSetFilterEnabledArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){0u}
    , decltype(_impl_.enabled_){false}
  };
}

CommandSetFilterEnabledArchive::~CommandSetFilterEnabledArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFilterEnabledArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFilterEnabledArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFilterEnabledArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFilterEnabledArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFilterEnabledArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.filter_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enabled_) -
        reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFilterEnabledArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 filter_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_filter_index(&has_bits);
          _impl_.filter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFilterEnabledArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFilterEnabledArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 filter_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_filter_index(), target);
  }

  // required bool enabled = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFilterEnabledArchive)
  return target;
}

size_t CommandSetFilterEnabledArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFilterEnabledArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_index()) {
    // required uint32 filter_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());
  }

  if (_internal_has_enabled()) {
    // required bool enabled = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetFilterEnabledArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFilterEnabledArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 filter_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());

    // required bool enabled = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFilterEnabledArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFilterEnabledArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFilterEnabledArchive::GetClassData() const { return &_class_data_; }


void CommandSetFilterEnabledArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFilterEnabledArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFilterEnabledArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFilterEnabledArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.filter_index_ = from._impl_.filter_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFilterEnabledArchive::CopyFrom(const CommandSetFilterEnabledArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFilterEnabledArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFilterEnabledArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFilterEnabledArchive::InternalSwap(CommandSetFilterEnabledArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFilterEnabledArchive, _impl_.enabled_)
      + sizeof(CommandSetFilterEnabledArchive::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFilterEnabledArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFilterEnabledArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[89]);
}

// ===================================================================

class CommandSetFilterRuleEnabledArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFilterRuleEnabledArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetFilterRuleEnabledArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_filter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rule_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetFilterRuleEnabledArchive::_Internal::super(const CommandSetFilterRuleEnabledArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetFilterRuleEnabledArchive::CommandSetFilterRuleEnabledArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFilterRuleEnabledArchive)
}
CommandSetFilterRuleEnabledArchive::CommandSetFilterRuleEnabledArchive(const CommandSetFilterRuleEnabledArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFilterRuleEnabledArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){}
    , decltype(_impl_.rule_index_){}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.filter_index_, &from._impl_.filter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enabled_) -
    reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.enabled_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFilterRuleEnabledArchive)
}

inline void CommandSetFilterRuleEnabledArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.filter_index_){0u}
    , decltype(_impl_.rule_index_){0u}
    , decltype(_impl_.enabled_){false}
  };
}

CommandSetFilterRuleEnabledArchive::~CommandSetFilterRuleEnabledArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFilterRuleEnabledArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFilterRuleEnabledArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFilterRuleEnabledArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFilterRuleEnabledArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFilterRuleEnabledArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.filter_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enabled_) -
        reinterpret_cast<char*>(&_impl_.filter_index_)) + sizeof(_impl_.enabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFilterRuleEnabledArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 filter_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_filter_index(&has_bits);
          _impl_.filter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 rule_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_rule_index(&has_bits);
          _impl_.rule_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFilterRuleEnabledArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFilterRuleEnabledArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 filter_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_filter_index(), target);
  }

  // required uint32 rule_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rule_index(), target);
  }

  // required bool enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFilterRuleEnabledArchive)
  return target;
}

size_t CommandSetFilterRuleEnabledArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFilterRuleEnabledArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_filter_index()) {
    // required uint32 filter_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());
  }

  if (_internal_has_rule_index()) {
    // required uint32 rule_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_index());
  }

  if (_internal_has_enabled()) {
    // required bool enabled = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CommandSetFilterRuleEnabledArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFilterRuleEnabledArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 filter_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_filter_index());

    // required uint32 rule_index = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rule_index());

    // required bool enabled = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFilterRuleEnabledArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFilterRuleEnabledArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFilterRuleEnabledArchive::GetClassData() const { return &_class_data_; }


void CommandSetFilterRuleEnabledArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFilterRuleEnabledArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFilterRuleEnabledArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFilterRuleEnabledArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.filter_index_ = from._impl_.filter_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rule_index_ = from._impl_.rule_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.enabled_ = from._impl_.enabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFilterRuleEnabledArchive::CopyFrom(const CommandSetFilterRuleEnabledArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFilterRuleEnabledArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFilterRuleEnabledArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFilterRuleEnabledArchive::InternalSwap(CommandSetFilterRuleEnabledArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFilterRuleEnabledArchive, _impl_.enabled_)
      + sizeof(CommandSetFilterRuleEnabledArchive::_impl_.enabled_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFilterRuleEnabledArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFilterRuleEnabledArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[90]);
}

// ===================================================================

class CommandSetFilterSetTypeArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetFilterSetTypeArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetFilterSetTypeArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_filter_set_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_filter_set_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetFilterSetTypeArchive::_Internal::super(const CommandSetFilterSetTypeArchive* msg) {
  return *msg->_impl_.super_;
}
CommandSetFilterSetTypeArchive::CommandSetFilterSetTypeArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetFilterSetTypeArchive)
}
CommandSetFilterSetTypeArchive::CommandSetFilterSetTypeArchive(const CommandSetFilterSetTypeArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetFilterSetTypeArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_filter_set_type_){}
    , decltype(_impl_.new_filter_set_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.old_filter_set_type_, &from._impl_.old_filter_set_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_filter_set_type_) -
    reinterpret_cast<char*>(&_impl_.old_filter_set_type_)) + sizeof(_impl_.new_filter_set_type_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetFilterSetTypeArchive)
}

inline void CommandSetFilterSetTypeArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_filter_set_type_){0}
    , decltype(_impl_.new_filter_set_type_){0}
  };
}

CommandSetFilterSetTypeArchive::~CommandSetFilterSetTypeArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetFilterSetTypeArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetFilterSetTypeArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandSetFilterSetTypeArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetFilterSetTypeArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetFilterSetTypeArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.old_filter_set_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_filter_set_type_) -
        reinterpret_cast<char*>(&_impl_.old_filter_set_type_)) + sizeof(_impl_.new_filter_set_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetFilterSetTypeArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FilterSetArchive_FilterSetType_IsValid(val))) {
            _internal_set_old_filter_set_type(static_cast<::TST::FilterSetArchive_FilterSetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TST::FilterSetArchive_FilterSetType_IsValid(val))) {
            _internal_set_new_filter_set_type(static_cast<::TST::FilterSetArchive_FilterSetType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetFilterSetTypeArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetFilterSetTypeArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_old_filter_set_type(), target);
  }

  // required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_new_filter_set_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetFilterSetTypeArchive)
  return target;
}

size_t CommandSetFilterSetTypeArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetFilterSetTypeArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_old_filter_set_type()) {
    // required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_old_filter_set_type());
  }

  if (_internal_has_new_filter_set_type()) {
    // required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_new_filter_set_type());
  }

  return total_size;
}
size_t CommandSetFilterSetTypeArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetFilterSetTypeArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.FilterSetArchive.FilterSetType old_filter_set_type = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_old_filter_set_type());

    // required .TST.FilterSetArchive.FilterSetType new_filter_set_type = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_new_filter_set_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetFilterSetTypeArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetFilterSetTypeArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetFilterSetTypeArchive::GetClassData() const { return &_class_data_; }


void CommandSetFilterSetTypeArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetFilterSetTypeArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetFilterSetTypeArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetFilterSetTypeArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_filter_set_type_ = from._impl_.old_filter_set_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_filter_set_type_ = from._impl_.new_filter_set_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetFilterSetTypeArchive::CopyFrom(const CommandSetFilterSetTypeArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetFilterSetTypeArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetFilterSetTypeArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetFilterSetTypeArchive::InternalSwap(CommandSetFilterSetTypeArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetFilterSetTypeArchive, _impl_.new_filter_set_type_)
      + sizeof(CommandSetFilterSetTypeArchive::_impl_.new_filter_set_type_)
      - PROTOBUF_FIELD_OFFSET(CommandSetFilterSetTypeArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetFilterSetTypeArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[91]);
}

// ===================================================================

class CommandSetStyleNetworkArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetStyleNetworkArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetStyleNetworkArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::TableStyleNetworkArchive& old_style_network(const CommandSetStyleNetworkArchive* msg);
  static void set_has_old_style_network(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::TableStyleNetworkArchive& new_style_network(const CommandSetStyleNetworkArchive* msg);
  static void set_has_new_style_network(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetStyleNetworkArchive::_Internal::super(const CommandSetStyleNetworkArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::TableStyleNetworkArchive&
CommandSetStyleNetworkArchive::_Internal::old_style_network(const CommandSetStyleNetworkArchive* msg) {
  return *msg->_impl_.old_style_network_;
}
const ::TST::TableStyleNetworkArchive&
CommandSetStyleNetworkArchive::_Internal::new_style_network(const CommandSetStyleNetworkArchive* msg) {
  return *msg->_impl_.new_style_network_;
}
void CommandSetStyleNetworkArchive::clear_old_style_network() {
  if (_impl_.old_style_network_ != nullptr) _impl_.old_style_network_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetStyleNetworkArchive::clear_new_style_network() {
  if (_impl_.new_style_network_ != nullptr) _impl_.new_style_network_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CommandSetStyleNetworkArchive::CommandSetStyleNetworkArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetStyleNetworkArchive)
}
CommandSetStyleNetworkArchive::CommandSetStyleNetworkArchive(const CommandSetStyleNetworkArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetStyleNetworkArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_style_network_){nullptr}
    , decltype(_impl_.new_style_network_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_style_network()) {
    _this->_impl_.old_style_network_ = new ::TST::TableStyleNetworkArchive(*from._impl_.old_style_network_);
  }
  if (from._internal_has_new_style_network()) {
    _this->_impl_.new_style_network_ = new ::TST::TableStyleNetworkArchive(*from._impl_.new_style_network_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetStyleNetworkArchive)
}

inline void CommandSetStyleNetworkArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_style_network_){nullptr}
    , decltype(_impl_.new_style_network_){nullptr}
  };
}

CommandSetStyleNetworkArchive::~CommandSetStyleNetworkArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetStyleNetworkArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetStyleNetworkArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_style_network_;
  if (this != internal_default_instance()) delete _impl_.new_style_network_;
}

void CommandSetStyleNetworkArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetStyleNetworkArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetStyleNetworkArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_style_network_ != nullptr);
      _impl_.old_style_network_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_style_network_ != nullptr);
      _impl_.new_style_network_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetStyleNetworkArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive old_style_network = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_style_network(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.TableStyleNetworkArchive new_style_network = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_style_network(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetStyleNetworkArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetStyleNetworkArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableStyleNetworkArchive old_style_network = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_style_network(this),
        _Internal::old_style_network(this).GetCachedSize(), target, stream);
  }

  // required .TST.TableStyleNetworkArchive new_style_network = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_style_network(this),
        _Internal::new_style_network(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetStyleNetworkArchive)
  return target;
}

size_t CommandSetStyleNetworkArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetStyleNetworkArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_old_style_network()) {
    // required .TST.TableStyleNetworkArchive old_style_network = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_network_);
  }

  if (_internal_has_new_style_network()) {
    // required .TST.TableStyleNetworkArchive new_style_network = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_network_);
  }

  return total_size;
}
size_t CommandSetStyleNetworkArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetStyleNetworkArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.TableStyleNetworkArchive old_style_network = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.old_style_network_);

    // required .TST.TableStyleNetworkArchive new_style_network = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.new_style_network_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetStyleNetworkArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetStyleNetworkArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetStyleNetworkArchive::GetClassData() const { return &_class_data_; }


void CommandSetStyleNetworkArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetStyleNetworkArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetStyleNetworkArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetStyleNetworkArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_style_network()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_old_style_network());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_style_network()->::TST::TableStyleNetworkArchive::MergeFrom(
          from._internal_new_style_network());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetStyleNetworkArchive::CopyFrom(const CommandSetStyleNetworkArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetStyleNetworkArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetStyleNetworkArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_old_style_network()) {
    if (!_impl_.old_style_network_->IsInitialized()) return false;
  }
  if (_internal_has_new_style_network()) {
    if (!_impl_.new_style_network_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetStyleNetworkArchive::InternalSwap(CommandSetStyleNetworkArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetStyleNetworkArchive, _impl_.new_style_network_)
      + sizeof(CommandSetStyleNetworkArchive::_impl_.new_style_network_)
      - PROTOBUF_FIELD_OFFSET(CommandSetStyleNetworkArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetStyleNetworkArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[92]);
}

// ===================================================================

class CommandMutateCellsArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMutateCellsArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandMutateCellsArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandMutateCellsArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandMutateCellsArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::SelectionArchive& selection(const CommandMutateCellsArchive* msg);
  static void set_has_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandMutateCellsArchive::_Internal::super(const CommandMutateCellsArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellMapArchive&
CommandMutateCellsArchive::_Internal::undo_cell_map(const CommandMutateCellsArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandMutateCellsArchive::_Internal::redo_cell_map(const CommandMutateCellsArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TST::SelectionArchive&
CommandMutateCellsArchive::_Internal::selection(const CommandMutateCellsArchive* msg) {
  return *msg->_impl_.selection_;
}
void CommandMutateCellsArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandMutateCellsArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandMutateCellsArchive::clear_selection() {
  if (_impl_.selection_ != nullptr) _impl_.selection_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandMutateCellsArchive::CommandMutateCellsArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandMutateCellsArchive)
}
CommandMutateCellsArchive::CommandMutateCellsArchive(const CommandMutateCellsArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandMutateCellsArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.selection_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_selection()) {
    _this->_impl_.selection_ = new ::TST::SelectionArchive(*from._impl_.selection_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandMutateCellsArchive)
}

inline void CommandMutateCellsArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.selection_){nullptr}
  };
}

CommandMutateCellsArchive::~CommandMutateCellsArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandMutateCellsArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandMutateCellsArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.selection_;
}

void CommandMutateCellsArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandMutateCellsArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandMutateCellsArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.selection_ != nullptr);
      _impl_.selection_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandMutateCellsArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive undo_cell_map = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellMapArchive redo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.SelectionArchive selection = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandMutateCellsArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandMutateCellsArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive undo_cell_map = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellMapArchive redo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TST.SelectionArchive selection = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::selection(this),
        _Internal::selection(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandMutateCellsArchive)
  return target;
}

size_t CommandMutateCellsArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandMutateCellsArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_undo_cell_map()) {
    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);
  }

  if (_internal_has_redo_cell_map()) {
    // required .TST.CellMapArchive redo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);
  }

  return total_size;
}
size_t CommandMutateCellsArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandMutateCellsArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellMapArchive undo_cell_map = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_cell_map_);

    // required .TST.CellMapArchive redo_cell_map = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.redo_cell_map_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TST.SelectionArchive selection = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.selection_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandMutateCellsArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandMutateCellsArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandMutateCellsArchive::GetClassData() const { return &_class_data_; }


void CommandMutateCellsArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandMutateCellsArchive*>(&to_msg);
  auto& from = static_cast<const CommandMutateCellsArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandMutateCellsArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_selection()->::TST::SelectionArchive::MergeFrom(
          from._internal_selection());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandMutateCellsArchive::CopyFrom(const CommandMutateCellsArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandMutateCellsArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMutateCellsArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_selection()) {
    if (!_impl_.selection_->IsInitialized()) return false;
  }
  return true;
}

void CommandMutateCellsArchive::InternalSwap(CommandMutateCellsArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandMutateCellsArchive, _impl_.selection_)
      + sizeof(CommandMutateCellsArchive::_impl_.selection_)
      - PROTOBUF_FIELD_OFFSET(CommandMutateCellsArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandMutateCellsArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[93]);
}

// ===================================================================

class CommandDisableFilterRulesForColumnArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandDisableFilterRulesForColumnArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandDisableFilterRulesForColumnArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandDisableFilterRulesForColumnArchive::_Internal::super(const CommandDisableFilterRulesForColumnArchive* msg) {
  return *msg->_impl_.super_;
}
CommandDisableFilterRulesForColumnArchive::CommandDisableFilterRulesForColumnArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandDisableFilterRulesForColumnArchive)
}
CommandDisableFilterRulesForColumnArchive::CommandDisableFilterRulesForColumnArchive(const CommandDisableFilterRulesForColumnArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandDisableFilterRulesForColumnArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_indices_){from._impl_.rule_indices_}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.column_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.column_index_ = from._impl_.column_index_;
  // @@protoc_insertion_point(copy_constructor:TST.CommandDisableFilterRulesForColumnArchive)
}

inline void CommandDisableFilterRulesForColumnArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rule_indices_){arena}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.column_index_){0u}
  };
}

CommandDisableFilterRulesForColumnArchive::~CommandDisableFilterRulesForColumnArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandDisableFilterRulesForColumnArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandDisableFilterRulesForColumnArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rule_indices_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandDisableFilterRulesForColumnArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandDisableFilterRulesForColumnArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandDisableFilterRulesForColumnArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rule_indices_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.column_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandDisableFilterRulesForColumnArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 column_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_column_index(&has_bits);
          _impl_.column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 rule_indices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_rule_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_rule_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandDisableFilterRulesForColumnArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandDisableFilterRulesForColumnArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required uint32 column_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_column_index(), target);
  }

  // repeated uint32 rule_indices = 3;
  for (int i = 0, n = this->_internal_rule_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rule_indices(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandDisableFilterRulesForColumnArchive)
  return target;
}

size_t CommandDisableFilterRulesForColumnArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandDisableFilterRulesForColumnArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_column_index()) {
    // required uint32 column_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());
  }

  return total_size;
}
size_t CommandDisableFilterRulesForColumnArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandDisableFilterRulesForColumnArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required uint32 column_index = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 rule_indices = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.rule_indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_rule_indices_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandDisableFilterRulesForColumnArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandDisableFilterRulesForColumnArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandDisableFilterRulesForColumnArchive::GetClassData() const { return &_class_data_; }


void CommandDisableFilterRulesForColumnArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandDisableFilterRulesForColumnArchive*>(&to_msg);
  auto& from = static_cast<const CommandDisableFilterRulesForColumnArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandDisableFilterRulesForColumnArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rule_indices_.MergeFrom(from._impl_.rule_indices_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.column_index_ = from._impl_.column_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandDisableFilterRulesForColumnArchive::CopyFrom(const CommandDisableFilterRulesForColumnArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandDisableFilterRulesForColumnArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandDisableFilterRulesForColumnArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandDisableFilterRulesForColumnArchive::InternalSwap(CommandDisableFilterRulesForColumnArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rule_indices_.InternalSwap(&other->_impl_.rule_indices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandDisableFilterRulesForColumnArchive, _impl_.column_index_)
      + sizeof(CommandDisableFilterRulesForColumnArchive::_impl_.column_index_)
      - PROTOBUF_FIELD_OFFSET(CommandDisableFilterRulesForColumnArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandDisableFilterRulesForColumnArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[94]);
}

// ===================================================================

class CommandSetTextStyleArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetTextStyleArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandSetTextStyleArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TST::CellRegion& region(const CommandSetTextStyleArchive* msg);
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TST::CellMapArchive& undo_cell_map(const CommandSetTextStyleArchive* msg);
  static void set_has_undo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TST::CellMapArchive& redo_cell_map(const CommandSetTextStyleArchive* msg);
  static void set_has_redo_cell_map(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::TSP::Reference& subcommands(const CommandSetTextStyleArchive* msg);
  static void set_has_subcommands(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandSetTextStyleArchive::_Internal::super(const CommandSetTextStyleArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TST::CellRegion&
CommandSetTextStyleArchive::_Internal::region(const CommandSetTextStyleArchive* msg) {
  return *msg->_impl_.region_;
}
const ::TST::CellMapArchive&
CommandSetTextStyleArchive::_Internal::undo_cell_map(const CommandSetTextStyleArchive* msg) {
  return *msg->_impl_.undo_cell_map_;
}
const ::TST::CellMapArchive&
CommandSetTextStyleArchive::_Internal::redo_cell_map(const CommandSetTextStyleArchive* msg) {
  return *msg->_impl_.redo_cell_map_;
}
const ::TSP::Reference&
CommandSetTextStyleArchive::_Internal::subcommands(const CommandSetTextStyleArchive* msg) {
  return *msg->_impl_.subcommands_;
}
void CommandSetTextStyleArchive::clear_region() {
  if (_impl_.region_ != nullptr) _impl_.region_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetTextStyleArchive::clear_undo_cell_map() {
  if (_impl_.undo_cell_map_ != nullptr) _impl_.undo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetTextStyleArchive::clear_redo_cell_map() {
  if (_impl_.redo_cell_map_ != nullptr) _impl_.redo_cell_map_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CommandSetTextStyleArchive::clear_subcommands() {
  if (_impl_.subcommands_ != nullptr) _impl_.subcommands_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CommandSetTextStyleArchive::CommandSetTextStyleArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetTextStyleArchive)
}
CommandSetTextStyleArchive::CommandSetTextStyleArchive(const CommandSetTextStyleArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetTextStyleArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.subcommands_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_region()) {
    _this->_impl_.region_ = new ::TST::CellRegion(*from._impl_.region_);
  }
  if (from._internal_has_undo_cell_map()) {
    _this->_impl_.undo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.undo_cell_map_);
  }
  if (from._internal_has_redo_cell_map()) {
    _this->_impl_.redo_cell_map_ = new ::TST::CellMapArchive(*from._impl_.redo_cell_map_);
  }
  if (from._internal_has_subcommands()) {
    _this->_impl_.subcommands_ = new ::TSP::Reference(*from._impl_.subcommands_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetTextStyleArchive)
}

inline void CommandSetTextStyleArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.region_){nullptr}
    , decltype(_impl_.undo_cell_map_){nullptr}
    , decltype(_impl_.redo_cell_map_){nullptr}
    , decltype(_impl_.subcommands_){nullptr}
  };
}

CommandSetTextStyleArchive::~CommandSetTextStyleArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetTextStyleArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetTextStyleArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.region_;
  if (this != internal_default_instance()) delete _impl_.undo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.redo_cell_map_;
  if (this != internal_default_instance()) delete _impl_.subcommands_;
}

void CommandSetTextStyleArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetTextStyleArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetTextStyleArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.region_ != nullptr);
      _impl_.region_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_cell_map_ != nullptr);
      _impl_.undo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.redo_cell_map_ != nullptr);
      _impl_.redo_cell_map_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.subcommands_ != nullptr);
      _impl_.subcommands_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetTextStyleArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TST.CellRegion region = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_region(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive undo_cell_map = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TST.CellMapArchive redo_cell_map = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_redo_cell_map(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference subcommands = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_subcommands(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetTextStyleArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetTextStyleArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TST.CellRegion region = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::region(this),
        _Internal::region(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive undo_cell_map = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_cell_map(this),
        _Internal::undo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TST.CellMapArchive redo_cell_map = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::redo_cell_map(this),
        _Internal::redo_cell_map(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference subcommands = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::subcommands(this),
        _Internal::subcommands(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetTextStyleArchive)
  return target;
}

size_t CommandSetTextStyleArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetTextStyleArchive)
  size_t total_size = 0;

  if (_internal_has_super()) {
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_region()) {
    // required .TST.CellRegion region = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.region_);
  }

  return total_size;
}
size_t CommandSetTextStyleArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetTextStyleArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .TST.TableCommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TST.CellRegion region = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.region_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional .TST.CellMapArchive undo_cell_map = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_cell_map_);
    }

    // optional .TST.CellMapArchive redo_cell_map = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.redo_cell_map_);
    }

    // optional .TSP.Reference subcommands = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.subcommands_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetTextStyleArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetTextStyleArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetTextStyleArchive::GetClassData() const { return &_class_data_; }


void CommandSetTextStyleArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetTextStyleArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetTextStyleArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetTextStyleArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_region()->::TST::CellRegion::MergeFrom(
          from._internal_region());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_undo_cell_map());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_redo_cell_map()->::TST::CellMapArchive::MergeFrom(
          from._internal_redo_cell_map());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_subcommands()->::TSP::Reference::MergeFrom(
          from._internal_subcommands());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetTextStyleArchive::CopyFrom(const CommandSetTextStyleArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetTextStyleArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetTextStyleArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_region()) {
    if (!_impl_.region_->IsInitialized()) return false;
  }
  if (_internal_has_undo_cell_map()) {
    if (!_impl_.undo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_redo_cell_map()) {
    if (!_impl_.redo_cell_map_->IsInitialized()) return false;
  }
  if (_internal_has_subcommands()) {
    if (!_impl_.subcommands_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetTextStyleArchive::InternalSwap(CommandSetTextStyleArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetTextStyleArchive, _impl_.subcommands_)
      + sizeof(CommandSetTextStyleArchive::_impl_.subcommands_)
      - PROTOBUF_FIELD_OFFSET(CommandSetTextStyleArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetTextStyleArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[95]);
}

// ===================================================================

class CommandNotifyForTransformingArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandNotifyForTransformingArchive>()._impl_._has_bits_);
  static const ::TST::TableCommandArchive& super(const CommandNotifyForTransformingArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TST::TableCommandArchive&
CommandNotifyForTransformingArchive::_Internal::super(const CommandNotifyForTransformingArchive* msg) {
  return *msg->_impl_.super_;
}
CommandNotifyForTransformingArchive::CommandNotifyForTransformingArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandNotifyForTransformingArchive)
}
CommandNotifyForTransformingArchive::CommandNotifyForTransformingArchive(const CommandNotifyForTransformingArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandNotifyForTransformingArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TST::TableCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TST.CommandNotifyForTransformingArchive)
}

inline void CommandNotifyForTransformingArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

CommandNotifyForTransformingArchive::~CommandNotifyForTransformingArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandNotifyForTransformingArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandNotifyForTransformingArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void CommandNotifyForTransformingArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandNotifyForTransformingArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandNotifyForTransformingArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandNotifyForTransformingArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TST.TableCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandNotifyForTransformingArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandNotifyForTransformingArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TST.TableCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandNotifyForTransformingArchive)
  return target;
}

size_t CommandNotifyForTransformingArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandNotifyForTransformingArchive)
  size_t total_size = 0;

  // required .TST.TableCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandNotifyForTransformingArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandNotifyForTransformingArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandNotifyForTransformingArchive::GetClassData() const { return &_class_data_; }


void CommandNotifyForTransformingArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandNotifyForTransformingArchive*>(&to_msg);
  auto& from = static_cast<const CommandNotifyForTransformingArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandNotifyForTransformingArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TST::TableCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandNotifyForTransformingArchive::CopyFrom(const CommandNotifyForTransformingArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandNotifyForTransformingArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandNotifyForTransformingArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void CommandNotifyForTransformingArchive::InternalSwap(CommandNotifyForTransformingArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandNotifyForTransformingArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[96]);
}

// ===================================================================

class CommandSetStorageLanguageArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandSetStorageLanguageArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const CommandSetStorageLanguageArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& storage(const CommandSetStorageLanguageArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const CommandSetStorageLanguageArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000037) ^ 0x00000037) != 0;
  }
};

const ::TSK::CommandArchive&
CommandSetStorageLanguageArchive::_Internal::super(const CommandSetStorageLanguageArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CommandSetStorageLanguageArchive::_Internal::storage(const CommandSetStorageLanguageArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
CommandSetStorageLanguageArchive::_Internal::undo_transaction(const CommandSetStorageLanguageArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void CommandSetStorageLanguageArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CommandSetStorageLanguageArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CommandSetStorageLanguageArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CommandSetStorageLanguageArchive::CommandSetStorageLanguageArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TST.CommandSetStorageLanguageArchive)
}
CommandSetStorageLanguageArchive::CommandSetStorageLanguageArchive(const CommandSetStorageLanguageArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CommandSetStorageLanguageArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.range_location_){}
    , decltype(_impl_.range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.range_location_, &from._impl_.range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.range_length_) -
    reinterpret_cast<char*>(&_impl_.range_location_)) + sizeof(_impl_.range_length_));
  // @@protoc_insertion_point(copy_constructor:TST.CommandSetStorageLanguageArchive)
}

inline void CommandSetStorageLanguageArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.range_location_){0u}
    , decltype(_impl_.range_length_){0u}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommandSetStorageLanguageArchive::~CommandSetStorageLanguageArchive() {
  // @@protoc_insertion_point(destructor:TST.CommandSetStorageLanguageArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandSetStorageLanguageArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void CommandSetStorageLanguageArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandSetStorageLanguageArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TST.CommandSetStorageLanguageArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.range_length_) -
        reinterpret_cast<char*>(&_impl_.range_location_)) + sizeof(_impl_.range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandSetStorageLanguageArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TST.CommandSetStorageLanguageArchive.language");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required uint32 range_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_range_location(&has_bits);
          _impl_.range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 range_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_range_length(&has_bits);
          _impl_.range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandSetStorageLanguageArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TST.CommandSetStorageLanguageArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // required .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // required string language = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TST.CommandSetStorageLanguageArchive.language");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_language(), target);
  }

  // required uint32 range_location = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_range_location(), target);
  }

  // required uint32 range_length = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TST.CommandSetStorageLanguageArchive)
  return target;
}

size_t CommandSetStorageLanguageArchive::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TST.CommandSetStorageLanguageArchive)
  size_t total_size = 0;

  if (_internal_has_language()) {
    // required string language = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());
  }

  if (_internal_has_super()) {
    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }

  if (_internal_has_storage()) {
    // required .TSP.Reference storage = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_);
  }

  if (_internal_has_range_location()) {
    // required uint32 range_location = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_location());
  }

  if (_internal_has_range_length()) {
    // required uint32 range_length = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_length());
  }

  return total_size;
}
size_t CommandSetStorageLanguageArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TST.CommandSetStorageLanguageArchive)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000037) ^ 0x00000037) == 0) {  // All required fields are present.
    // required string language = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_language());

    // required .TSK.CommandArchive super = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);

    // required .TSP.Reference storage = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.storage_);

    // required uint32 range_location = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_location());

    // required uint32 range_length = 5;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_range_length());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.undo_transaction_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandSetStorageLanguageArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandSetStorageLanguageArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandSetStorageLanguageArchive::GetClassData() const { return &_class_data_; }


void CommandSetStorageLanguageArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandSetStorageLanguageArchive*>(&to_msg);
  auto& from = static_cast<const CommandSetStorageLanguageArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TST.CommandSetStorageLanguageArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.range_location_ = from._impl_.range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.range_length_ = from._impl_.range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandSetStorageLanguageArchive::CopyFrom(const CommandSetStorageLanguageArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TST.CommandSetStorageLanguageArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandSetStorageLanguageArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void CommandSetStorageLanguageArchive::InternalSwap(CommandSetStorageLanguageArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommandSetStorageLanguageArchive, _impl_.range_length_)
      + sizeof(CommandSetStorageLanguageArchive::_impl_.range_length_)
      - PROTOBUF_FIELD_OFFSET(CommandSetStorageLanguageArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandSetStorageLanguageArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSTCommandArchives_2eproto_getter, &descriptor_table_TSTCommandArchives_2eproto_once,
      file_level_metadata_TSTCommandArchives_2eproto[97]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TST
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TST::TableCommandArchive*
Arena::CreateMaybeMessage< ::TST::TableCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandChangeFreezeHeaderStateArchive*
Arena::CreateMaybeMessage< ::TST::CommandChangeFreezeHeaderStateArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandChangeFreezeHeaderStateArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandDeleteCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandDeleteCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandDeleteCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandDeleteCellContentsArchive*
Arena::CreateMaybeMessage< ::TST::CommandDeleteCellContentsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandDeleteCellContentsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleCellsCustomArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleCellsCustomArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleCellsCustomArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleCellsMultipleChoiceListArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleCellsMultipleChoiceListArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleCellsMultipleChoiceListArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandCoerceMultipleCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandCoerceMultipleCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandCoerceMultipleCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetControlCellsDisplayNumberFormatArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetControlCellsDisplayNumberFormatArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetControlCellsDisplayNumberFormatArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetAutomaticFormatArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetAutomaticFormatArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetAutomaticFormatArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetAutomaticDurationUnitsArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetAutomaticDurationUnitsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetAutomaticDurationUnitsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair*
Arena::CreateMaybeMessage< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandInsertColumnsOrRowsArchive_StyleIndexPair >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandInsertColumnsOrRowsArchive*
Arena::CreateMaybeMessage< ::TST::CommandInsertColumnsOrRowsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandInsertColumnsOrRowsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandPasteArchive*
Arena::CreateMaybeMessage< ::TST::CommandPasteArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandPasteArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRemoveColumnsOrRowsArchive*
Arena::CreateMaybeMessage< ::TST::CommandRemoveColumnsOrRowsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRemoveColumnsOrRowsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandResizeColumnOrRowArchive*
Arena::CreateMaybeMessage< ::TST::CommandResizeColumnOrRowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandResizeColumnOrRowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetCellArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetCellArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetCellArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandTextPreflightInsertCellArchive*
Arena::CreateMaybeMessage< ::TST::CommandTextPreflightInsertCellArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandTextPreflightInsertCellArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandPostflightSetCellArchive*
Arena::CreateMaybeMessage< ::TST::CommandPostflightSetCellArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandPostflightSetCellArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetNumberOfHeadersOrFootersArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetNumberOfHeadersOrFootersArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetNumberOfHeadersOrFootersArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandFixWPStylesInRowsOrColumnsArchive*
Arena::CreateMaybeMessage< ::TST::CommandFixWPStylesInRowsOrColumnsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandFixWPStylesInRowsOrColumnsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandFixStylesInHeadersOrFootersArchive*
Arena::CreateMaybeMessage< ::TST::CommandFixStylesInHeadersOrFootersArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandFixStylesInHeadersOrFootersArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTableNameArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTableNameArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTableNameArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTableNameEnabledArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTableNameEnabledArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTableNameEnabledArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTableFontSizeArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTableFontSizeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTableFontSizeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTableFontNameArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTableFontNameArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTableFontNameArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTableNameHeightArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTableNameHeightArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTableNameHeightArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandStyleCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandStyleCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandStyleCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandStyleTableArchive*
Arena::CreateMaybeMessage< ::TST::CommandStyleTableArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandStyleTableArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandFillCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandFillCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandFillCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandReplaceTextArchive*
Arena::CreateMaybeMessage< ::TST::CommandReplaceTextArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandReplaceTextArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandReplaceAllTextArchive*
Arena::CreateMaybeMessage< ::TST::CommandReplaceAllTextArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandReplaceAllTextArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetRepeatingHeaderEnabledArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetRepeatingHeaderEnabledArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetRepeatingHeaderEnabledArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFiltersEnabledArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFiltersEnabledArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFiltersEnabledArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandAddQuickFilterRulesArchive*
Arena::CreateMaybeMessage< ::TST::CommandAddQuickFilterRulesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandAddQuickFilterRulesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandDeleteFilterRulesArchive*
Arena::CreateMaybeMessage< ::TST::CommandDeleteFilterRulesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandDeleteFilterRulesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandModifyFilterRuleArchive*
Arena::CreateMaybeMessage< ::TST::CommandModifyFilterRuleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandModifyFilterRuleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyStrokePresetArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyStrokePresetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyStrokePresetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple*
Arena::CreateMaybeMessage< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyTableStylePresetArchive_StyleIndexTuple >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyTableStylePresetArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyTableStylePresetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyTableStylePresetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetStyleApplyClearsAllFlagArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetStyleApplyClearsAllFlagArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetStyleApplyClearsAllFlagArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyThemeToTableArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyThemeToTableArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyThemeToTableArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyThemeChildForTableArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyThemeChildForTableArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyThemeChildForTableArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandToggleTextPropertyArchive*
Arena::CreateMaybeMessage< ::TST::CommandToggleTextPropertyArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandToggleTextPropertyArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandResetFillPropertyToDefault*
Arena::CreateMaybeMessage< ::TST::CommandResetFillPropertyToDefault >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandResetFillPropertyToDefault >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetSingleNumberFormatParameterArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetSingleNumberFormatParameterArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetSingleNumberFormatParameterArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetBaseArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetBaseArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetBaseArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetBasePlacesArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetBasePlacesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetBasePlacesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetBaseUseMinusSignArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetBaseUseMinusSignArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetBaseUseMinusSignArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetControlMinimumArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetControlMinimumArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetControlMinimumArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetControlMaximumArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetControlMaximumArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetControlMaximumArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetControlIncrementArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetControlIncrementArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetControlIncrementArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetCurrencyCodeArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetCurrencyCodeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetCurrencyCodeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFractionAccuracyArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFractionAccuracyArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFractionAccuracyArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleChoiceListFormatForEditedItemArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleChoiceListFormatForDeleteItemArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleChoiceListFormatForReorderItemArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetMultipleChoiceListFormatForInitialValueArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetNegativeNumberStyleArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetNegativeNumberStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetNegativeNumberStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetExplicitFormatArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetExplicitFormatArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetExplicitFormatArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetNumberOfDecimalPlacesArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetNumberOfDecimalPlacesArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetNumberOfDecimalPlacesArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetDateTimeFormatArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetDateTimeFormatArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetDateTimeFormatArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetShowThousandsSeparatorArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetShowThousandsSeparatorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetShowThousandsSeparatorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetUseAccountingStyleArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetUseAccountingStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetUseAccountingStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandMoveRowsArchive*
Arena::CreateMaybeMessage< ::TST::CommandMoveRowsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandMoveRowsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandMoveColumnsArchive*
Arena::CreateMaybeMessage< ::TST::CommandMoveColumnsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandMoveColumnsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSortArchive*
Arena::CreateMaybeMessage< ::TST::CommandSortArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSortArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFormulasForSortArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFormulasForSortArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFormulasForSortArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFormulasForTectonicShiftArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFormulasForTectonicShiftArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFormulasForTectonicShiftArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFormulasForMoveArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFormulasForMoveArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFormulasForMoveArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFormulasForCellMergeArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFormulasForCellMergeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFormulasForCellMergeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFilterFormulasForTableResizeArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFilterFormulasForTableResizeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFilterFormulasForTableResizeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFilterFormulasForTectonicShiftArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFilterFormulasForTectonicShiftArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFilterFormulasForTectonicShiftArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteFilterFormulasForSortArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteFilterFormulasForSortArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteFilterFormulasForSortArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteConditionalStylesForTectonicShiftArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteConditionalStylesForTectonicShiftArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteConditionalStylesForTectonicShiftArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteConditionalStylesForSortArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteConditionalStylesForSortArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteConditionalStylesForSortArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteConditionalStylesForRangeMoveArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteConditionalStylesForRangeMoveArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteConditionalStylesForRangeMoveArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandRewriteConditionalStylesForCellMergeArchive*
Arena::CreateMaybeMessage< ::TST::CommandRewriteConditionalStylesForCellMergeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandRewriteConditionalStylesForCellMergeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandMergeUnmergeArchive*
Arena::CreateMaybeMessage< ::TST::CommandMergeUnmergeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandMergeUnmergeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandHideShowArchive*
Arena::CreateMaybeMessage< ::TST::CommandHideShowArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandHideShowArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableInfoGeometryCommandArchive*
Arena::CreateMaybeMessage< ::TST::TableInfoGeometryCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableInfoGeometryCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FormulaEditingCommandGroupArchive*
Arena::CreateMaybeMessage< ::TST::FormulaEditingCommandGroupArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FormulaEditingCommandGroupArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::FormulaEditingCommandSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TST::FormulaEditingCommandSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::FormulaEditingCommandSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::UndoRedoStateCommandSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TST::UndoRedoStateCommandSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::UndoRedoStateCommandSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::TableCommandSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TST::TableCommandSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::TableCommandSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::DisableTableNameSelectionBehaviorArchive*
Arena::CreateMaybeMessage< ::TST::DisableTableNameSelectionBehaviorArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::DisableTableNameSelectionBehaviorArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyCellCommentArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyCellCommentArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyCellCommentArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandApplyConditionalStyleSetArchive*
Arena::CreateMaybeMessage< ::TST::CommandApplyConditionalStyleSetArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandApplyConditionalStyleSetArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFormulaTokenizationArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFormulaTokenizationArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFormulaTokenizationArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFilterEnabledArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFilterEnabledArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFilterEnabledArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFilterRuleEnabledArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFilterRuleEnabledArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFilterRuleEnabledArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetFilterSetTypeArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetFilterSetTypeArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetFilterSetTypeArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetStyleNetworkArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetStyleNetworkArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetStyleNetworkArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandMutateCellsArchive*
Arena::CreateMaybeMessage< ::TST::CommandMutateCellsArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandMutateCellsArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandDisableFilterRulesForColumnArchive*
Arena::CreateMaybeMessage< ::TST::CommandDisableFilterRulesForColumnArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandDisableFilterRulesForColumnArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetTextStyleArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetTextStyleArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetTextStyleArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandNotifyForTransformingArchive*
Arena::CreateMaybeMessage< ::TST::CommandNotifyForTransformingArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandNotifyForTransformingArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TST::CommandSetStorageLanguageArchive*
Arena::CreateMaybeMessage< ::TST::CommandSetStorageLanguageArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TST::CommandSetStorageLanguageArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
