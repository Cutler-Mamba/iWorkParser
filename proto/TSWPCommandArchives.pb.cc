// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TSWPCommandArchives.proto

#include "TSWPCommandArchives.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TSWP {
PROTOBUF_CONSTEXPR DummyCommandArchive::DummyCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.foo_)*/0u} {}
struct DummyCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DummyCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DummyCommandArchiveDefaultTypeInternal() {}
  union {
    DummyCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DummyCommandArchiveDefaultTypeInternal _DummyCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TextCommandArchive::TextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.restore_range_location_)*/0u
  , /*decltype(_impl_.restore_range_length_)*/0u
  , /*decltype(_impl_.redo_restore_range_location_)*/0u
  , /*decltype(_impl_.redo_restore_range_length_)*/0u
  , /*decltype(_impl_.text_command_flags_)*/0u
  , /*decltype(_impl_.kind_)*/0} {}
struct TextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextCommandArchiveDefaultTypeInternal() {}
  union {
    TextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextCommandArchiveDefaultTypeInternal _TextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAllTextCommandArchive::ReplaceAllTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ReplaceAllTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAllTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAllTextCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAllTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAllTextCommandArchiveDefaultTypeInternal _ReplaceAllTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR FormatTextCommandArchive::FormatTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u
  , /*decltype(_impl_.text_command_flags_)*/0u} {}
struct FormatTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormatTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormatTextCommandArchiveDefaultTypeInternal() {}
  union {
    FormatTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormatTextCommandArchiveDefaultTypeInternal _FormatTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct SetColumnStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetColumnStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetColumnStyleCommandArchiveDefaultTypeInternal() {}
  union {
    SetColumnStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetColumnStyleCommandArchiveDefaultTypeInternal _SetColumnStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal() {}
  union {
    ReplaceAllUsesOfStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplaceAllUsesOfStyleCommandArchiveDefaultTypeInternal _ReplaceAllUsesOfStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertAttachmentCommandArchive::InsertAttachmentCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.attachment_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u
  , /*decltype(_impl_.text_command_flags_)*/0u
  , /*decltype(_impl_.redo_restore_range_location_)*/0u
  , /*decltype(_impl_.redo_restore_range_length_)*/0u} {}
struct InsertAttachmentCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertAttachmentCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertAttachmentCommandArchiveDefaultTypeInternal() {}
  union {
    InsertAttachmentCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertAttachmentCommandArchiveDefaultTypeInternal _InsertAttachmentCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertColumnsCommandArchive::InsertColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.column_index_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct InsertColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    InsertColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertColumnsCommandArchiveDefaultTypeInternal _InsertColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR InsertRowsCommandArchive::InsertRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_index_)*/0u
  , /*decltype(_impl_.row_count_)*/0u} {}
struct InsertRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InsertRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InsertRowsCommandArchiveDefaultTypeInternal() {}
  union {
    InsertRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InsertRowsCommandArchiveDefaultTypeInternal _InsertRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.column_index_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct RemoveColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveColumnsCommandArchiveDefaultTypeInternal _RemoveColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveRowsCommandArchive::RemoveRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_index_)*/0u
  , /*decltype(_impl_.row_count_)*/0u} {}
struct RemoveRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveRowsCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveRowsCommandArchiveDefaultTypeInternal _RemoveRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MergeCellsCommandArchive::MergeCellsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.row_)*/0u
  , /*decltype(_impl_.column_)*/0u
  , /*decltype(_impl_.row_count_)*/0u
  , /*decltype(_impl_.column_count_)*/0u} {}
struct MergeCellsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MergeCellsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MergeCellsCommandArchiveDefaultTypeInternal() {}
  union {
    MergeCellsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MergeCellsCommandArchiveDefaultTypeInternal _MergeCellsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct ApplyPlaceholderTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyPlaceholderTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyPlaceholderTextCommandArchiveDefaultTypeInternal() {}
  union {
    ApplyPlaceholderTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyPlaceholderTextCommandArchiveDefaultTypeInternal _ApplyPlaceholderTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ApplyHighlightTextCommandArchive::ApplyHighlightTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u
  , /*decltype(_impl_.remove_)*/false} {}
struct ApplyHighlightTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyHighlightTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyHighlightTextCommandArchiveDefaultTypeInternal() {}
  union {
    ApplyHighlightTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyHighlightTextCommandArchiveDefaultTypeInternal _ApplyHighlightTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR CreateHyperlinkCommandArchive::CreateHyperlinkCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct CreateHyperlinkCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateHyperlinkCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateHyperlinkCommandArchiveDefaultTypeInternal() {}
  union {
    CreateHyperlinkCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateHyperlinkCommandArchiveDefaultTypeInternal _CreateHyperlinkCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveHyperlinkCommandArchive::RemoveHyperlinkCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u
  , /*decltype(_impl_.is_remove_character_style_)*/true} {}
struct RemoveHyperlinkCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveHyperlinkCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveHyperlinkCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveHyperlinkCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveHyperlinkCommandArchiveDefaultTypeInternal _RemoveHyperlinkCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyHyperlinkCommandArchive::ModifyHyperlinkCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.display_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_ref_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.hyperlink_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ModifyHyperlinkCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyHyperlinkCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyHyperlinkCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyHyperlinkCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyHyperlinkCommandArchiveDefaultTypeInternal _ModifyHyperlinkCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.date_time_field_)*/nullptr
  , /*decltype(_impl_.date_)*/nullptr
  , /*decltype(_impl_.date_style_)*/0
  , /*decltype(_impl_.time_style_)*/0} {}
struct UpdateDateTimeFieldCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateDateTimeFieldCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateDateTimeFieldCommandArchiveDefaultTypeInternal() {}
  union {
    UpdateDateTimeFieldCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateDateTimeFieldCommandArchiveDefaultTypeInternal _UpdateDateTimeFieldCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ruby_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct ApplyRubyTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ApplyRubyTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ApplyRubyTextCommandArchiveDefaultTypeInternal() {}
  union {
    ApplyRubyTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ApplyRubyTextCommandArchiveDefaultTypeInternal _ApplyRubyTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR RemoveRubyTextCommandArchive::RemoveRubyTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.selection_range_location_)*/0u
  , /*decltype(_impl_.selection_range_length_)*/0u} {}
struct RemoveRubyTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoveRubyTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoveRubyTextCommandArchiveDefaultTypeInternal() {}
  union {
    RemoveRubyTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveRubyTextCommandArchiveDefaultTypeInternal _RemoveRubyTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ruby_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.base_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.ruby_field_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct ModifyRubyTextCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyRubyTextCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyRubyTextCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyRubyTextCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyRubyTextCommandArchiveDefaultTypeInternal _ModifyRubyTextCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_toc_settings_)*/nullptr
  , /*decltype(_impl_.new_toc_settings_)*/nullptr} {}
struct ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsBaseCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsBaseCommandArchiveDefaultTypeInternal _ModifyTOCSettingsBaseCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.toc_info_)*/nullptr} {}
struct ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsForTOCInfoCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsForTOCInfoCommandArchiveDefaultTypeInternal _ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0u} {}
struct ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal() {}
  union {
    ModifyTOCSettingsPresetForThemeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModifyTOCSettingsPresetForThemeCommandArchiveDefaultTypeInternal _ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.attachment_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.h_offset_type_)*/0u
  , /*decltype(_impl_.h_offset_)*/0
  , /*decltype(_impl_.v_offset_type_)*/0u
  , /*decltype(_impl_.v_offset_)*/0
  , /*decltype(_impl_.is_html_wrap_)*/false} {}
struct AnchorAttachmentCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnchorAttachmentCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnchorAttachmentCommandArchiveDefaultTypeInternal() {}
  union {
    AnchorAttachmentCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnchorAttachmentCommandArchiveDefaultTypeInternal _AnchorAttachmentCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr} {}
struct TextApplyThemeCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextApplyThemeCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextApplyThemeCommandArchiveDefaultTypeInternal() {}
  union {
    TextApplyThemeCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextApplyThemeCommandArchiveDefaultTypeInternal _TextApplyThemeCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveColumnsCommandArchive::MoveColumnsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.src_index_)*/0u
  , /*decltype(_impl_.dst_index_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct MoveColumnsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveColumnsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveColumnsCommandArchiveDefaultTypeInternal() {}
  union {
    MoveColumnsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveColumnsCommandArchiveDefaultTypeInternal _MoveColumnsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR MoveRowsCommandArchive::MoveRowsCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.storage_)*/nullptr
  , /*decltype(_impl_.undo_transaction_)*/nullptr
  , /*decltype(_impl_.src_index_)*/0u
  , /*decltype(_impl_.dst_index_)*/0u
  , /*decltype(_impl_.count_)*/0u} {}
struct MoveRowsCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveRowsCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveRowsCommandArchiveDefaultTypeInternal() {}
  union {
    MoveRowsCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveRowsCommandArchiveDefaultTypeInternal _MoveRowsCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct ShapeApplyPresetCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeApplyPresetCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeApplyPresetCommandArchiveDefaultTypeInternal() {}
  union {
    ShapeApplyPresetCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeApplyPresetCommandArchiveDefaultTypeInternal _ShapeApplyPresetCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR ShapePasteStyleCommandArchive::ShapePasteStyleCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.paragraph_style_)*/nullptr
  , /*decltype(_impl_.list_style_)*/nullptr
  , /*decltype(_impl_.character_style_)*/nullptr} {}
struct ShapePasteStyleCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapePasteStyleCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapePasteStyleCommandArchiveDefaultTypeInternal() {}
  union {
    ShapePasteStyleCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapePasteStyleCommandArchiveDefaultTypeInternal _ShapePasteStyleCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleBaseCommandArchive::StyleBaseCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.theme_)*/nullptr
  , /*decltype(_impl_.style_)*/nullptr} {}
struct StyleBaseCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleBaseCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleBaseCommandArchiveDefaultTypeInternal() {}
  union {
    StyleBaseCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleBaseCommandArchiveDefaultTypeInternal _StyleBaseCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleCreateCommandArchive::StyleCreateCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.preset_index_)*/0u} {}
struct StyleCreateCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleCreateCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleCreateCommandArchiveDefaultTypeInternal() {}
  union {
    StyleCreateCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleCreateCommandArchiveDefaultTypeInternal _StyleCreateCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleRenameCommandArchive::StyleRenameCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.updated_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.old_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct StyleRenameCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleRenameCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleRenameCommandArchiveDefaultTypeInternal() {}
  union {
    StyleRenameCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleRenameCommandArchiveDefaultTypeInternal _StyleRenameCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleUpdateCommandArchive::StyleUpdateCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.original_style_)*/nullptr
  , /*decltype(_impl_.updated_style_)*/nullptr} {}
struct StyleUpdateCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleUpdateCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleUpdateCommandArchiveDefaultTypeInternal() {}
  union {
    StyleUpdateCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleUpdateCommandArchiveDefaultTypeInternal _StyleUpdateCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleDeleteCommandArchive::StyleDeleteCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_preset_index_)*/0u} {}
struct StyleDeleteCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleDeleteCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleDeleteCommandArchiveDefaultTypeInternal() {}
  union {
    StyleDeleteCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleDeleteCommandArchiveDefaultTypeInternal _StyleDeleteCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleReorderCommandArchive::StyleReorderCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr
  , /*decltype(_impl_.old_preset_index_)*/0u
  , /*decltype(_impl_.new_preset_index_)*/0u} {}
struct StyleReorderCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleReorderCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleReorderCommandArchiveDefaultTypeInternal() {}
  union {
    StyleReorderCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleReorderCommandArchiveDefaultTypeInternal _StyleReorderCommandArchive_default_instance_;
PROTOBUF_CONSTEXPR StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.super_)*/nullptr} {}
struct StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal() {}
  union {
    StyleUpdatePropertyMapCommandArchive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleUpdatePropertyMapCommandArchiveDefaultTypeInternal _StyleUpdatePropertyMapCommandArchive_default_instance_;
}  // namespace TSWP
static ::_pb::Metadata file_level_metadata_TSWPCommandArchives_2eproto[37];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_TSWPCommandArchives_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TSWPCommandArchives_2eproto = nullptr;

const uint32_t TableStruct_TSWPCommandArchives_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::DummyCommandArchive, _impl_.foo_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.restore_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.restore_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.redo_restore_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.redo_restore_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.text_command_flags_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextCommandArchive, _impl_.kind_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllTextCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::FormatTextCommandArchive, _impl_.text_command_flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::SetColumnStyleCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ReplaceAllUsesOfStyleCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.attachment_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.text_command_flags_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.redo_restore_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertAttachmentCommandArchive, _impl_.redo_restore_range_length_),
  0,
  1,
  4,
  5,
  2,
  3,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.column_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.row_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::InsertRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.column_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.row_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.row_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.column_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.row_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.column_count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MergeCellsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  6,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyPlaceholderTextCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyHighlightTextCommandArchive, _impl_.remove_),
  0,
  1,
  3,
  4,
  2,
  5,
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.url_ref_),
  PROTOBUF_FIELD_OFFSET(::TSWP::CreateHyperlinkCommandArchive, _impl_.undo_transaction_),
  1,
  2,
  4,
  5,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveHyperlinkCommandArchive, _impl_.is_remove_character_style_),
  0,
  1,
  3,
  4,
  2,
  5,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_.hyperlink_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_.display_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_.url_ref_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyHyperlinkCommandArchive, _impl_.undo_transaction_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_time_field_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.date_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::UpdateDateTimeFieldCommandArchive, _impl_.time_style_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.ruby_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ApplyRubyTextCommandArchive, _impl_.undo_transaction_),
  1,
  2,
  4,
  5,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_.selection_range_location_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_.selection_range_length_),
  PROTOBUF_FIELD_OFFSET(::TSWP::RemoveRubyTextCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.ruby_field_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.ruby_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.base_text_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyRubyTextCommandArchive, _impl_.undo_transaction_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.old_toc_settings_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsBaseCommandArchive, _impl_.new_toc_settings_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.toc_info_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.preset_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.attachment_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.h_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.h_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.v_offset_type_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.v_offset_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.undo_transaction_),
  PROTOBUF_FIELD_OFFSET(::TSWP::AnchorAttachmentCommandArchive, _impl_.is_html_wrap_),
  0,
  1,
  2,
  4,
  5,
  6,
  7,
  3,
  8,
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::TextApplyThemeCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.src_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.dst_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveColumnsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.storage_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.src_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.dst_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::TSWP::MoveRowsCommandArchive, _impl_.undo_transaction_),
  0,
  1,
  3,
  4,
  5,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapeApplyPresetCommandArchive, _impl_.super_),
  0,
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _impl_.paragraph_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _impl_.list_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::ShapePasteStyleCommandArchive, _impl_.character_style_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.theme_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleBaseCommandArchive, _impl_.style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleCreateCommandArchive, _impl_.preset_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.updated_name_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleRenameCommandArchive, _impl_.old_name_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.original_style_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdateCommandArchive, _impl_.updated_style_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleDeleteCommandArchive, _impl_.old_preset_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.super_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.old_preset_index_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleReorderCommandArchive, _impl_.new_preset_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TSWP::StyleUpdatePropertyMapCommandArchive, _impl_.super_),
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::TSWP::DummyCommandArchive)},
  { 8, 23, -1, sizeof(::TSWP::TextCommandArchive)},
  { 32, 41, -1, sizeof(::TSWP::ReplaceAllTextCommandArchive)},
  { 44, 56, -1, sizeof(::TSWP::FormatTextCommandArchive)},
  { 62, 71, -1, sizeof(::TSWP::SetColumnStyleCommandArchive)},
  { 74, 83, -1, sizeof(::TSWP::ReplaceAllUsesOfStyleCommandArchive)},
  { 86, 101, -1, sizeof(::TSWP::InsertAttachmentCommandArchive)},
  { 110, 121, -1, sizeof(::TSWP::InsertColumnsCommandArchive)},
  { 126, 137, -1, sizeof(::TSWP::InsertRowsCommandArchive)},
  { 142, 153, -1, sizeof(::TSWP::RemoveColumnsCommandArchive)},
  { 158, 169, -1, sizeof(::TSWP::RemoveRowsCommandArchive)},
  { 174, 187, -1, sizeof(::TSWP::MergeCellsCommandArchive)},
  { 194, 205, -1, sizeof(::TSWP::ApplyPlaceholderTextCommandArchive)},
  { 210, 222, -1, sizeof(::TSWP::ApplyHighlightTextCommandArchive)},
  { 228, 240, -1, sizeof(::TSWP::CreateHyperlinkCommandArchive)},
  { 246, 258, -1, sizeof(::TSWP::RemoveHyperlinkCommandArchive)},
  { 264, 275, -1, sizeof(::TSWP::ModifyHyperlinkCommandArchive)},
  { 280, 291, -1, sizeof(::TSWP::UpdateDateTimeFieldCommandArchive)},
  { 296, 308, -1, sizeof(::TSWP::ApplyRubyTextCommandArchive)},
  { 314, 325, -1, sizeof(::TSWP::RemoveRubyTextCommandArchive)},
  { 330, 341, -1, sizeof(::TSWP::ModifyRubyTextCommandArchive)},
  { 346, 355, -1, sizeof(::TSWP::ModifyTOCSettingsBaseCommandArchive)},
  { 358, 366, -1, sizeof(::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive)},
  { 368, 377, -1, sizeof(::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive)},
  { 380, 395, -1, sizeof(::TSWP::AnchorAttachmentCommandArchive)},
  { 404, 413, -1, sizeof(::TSWP::TextApplyThemeCommandArchive)},
  { 416, 428, -1, sizeof(::TSWP::MoveColumnsCommandArchive)},
  { 434, 446, -1, sizeof(::TSWP::MoveRowsCommandArchive)},
  { 452, 459, -1, sizeof(::TSWP::ShapeApplyPresetCommandArchive)},
  { 460, 470, -1, sizeof(::TSWP::ShapePasteStyleCommandArchive)},
  { 474, 483, -1, sizeof(::TSWP::StyleBaseCommandArchive)},
  { 486, 494, -1, sizeof(::TSWP::StyleCreateCommandArchive)},
  { 496, 505, -1, sizeof(::TSWP::StyleRenameCommandArchive)},
  { 508, 517, -1, sizeof(::TSWP::StyleUpdateCommandArchive)},
  { 520, 528, -1, sizeof(::TSWP::StyleDeleteCommandArchive)},
  { 530, 539, -1, sizeof(::TSWP::StyleReorderCommandArchive)},
  { 542, 549, -1, sizeof(::TSWP::StyleUpdatePropertyMapCommandArchive)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TSWP::_DummyCommandArchive_default_instance_._instance,
  &::TSWP::_TextCommandArchive_default_instance_._instance,
  &::TSWP::_ReplaceAllTextCommandArchive_default_instance_._instance,
  &::TSWP::_FormatTextCommandArchive_default_instance_._instance,
  &::TSWP::_SetColumnStyleCommandArchive_default_instance_._instance,
  &::TSWP::_ReplaceAllUsesOfStyleCommandArchive_default_instance_._instance,
  &::TSWP::_InsertAttachmentCommandArchive_default_instance_._instance,
  &::TSWP::_InsertColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_InsertRowsCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveRowsCommandArchive_default_instance_._instance,
  &::TSWP::_MergeCellsCommandArchive_default_instance_._instance,
  &::TSWP::_ApplyPlaceholderTextCommandArchive_default_instance_._instance,
  &::TSWP::_ApplyHighlightTextCommandArchive_default_instance_._instance,
  &::TSWP::_CreateHyperlinkCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveHyperlinkCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyHyperlinkCommandArchive_default_instance_._instance,
  &::TSWP::_UpdateDateTimeFieldCommandArchive_default_instance_._instance,
  &::TSWP::_ApplyRubyTextCommandArchive_default_instance_._instance,
  &::TSWP::_RemoveRubyTextCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyRubyTextCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsBaseCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsForTOCInfoCommandArchive_default_instance_._instance,
  &::TSWP::_ModifyTOCSettingsPresetForThemeCommandArchive_default_instance_._instance,
  &::TSWP::_AnchorAttachmentCommandArchive_default_instance_._instance,
  &::TSWP::_TextApplyThemeCommandArchive_default_instance_._instance,
  &::TSWP::_MoveColumnsCommandArchive_default_instance_._instance,
  &::TSWP::_MoveRowsCommandArchive_default_instance_._instance,
  &::TSWP::_ShapeApplyPresetCommandArchive_default_instance_._instance,
  &::TSWP::_ShapePasteStyleCommandArchive_default_instance_._instance,
  &::TSWP::_StyleBaseCommandArchive_default_instance_._instance,
  &::TSWP::_StyleCreateCommandArchive_default_instance_._instance,
  &::TSWP::_StyleRenameCommandArchive_default_instance_._instance,
  &::TSWP::_StyleUpdateCommandArchive_default_instance_._instance,
  &::TSWP::_StyleDeleteCommandArchive_default_instance_._instance,
  &::TSWP::_StyleReorderCommandArchive_default_instance_._instance,
  &::TSWP::_StyleUpdatePropertyMapCommandArchive_default_instance_._instance,
};

const char descriptor_table_protodef_TSWPCommandArchives_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\031TSWPCommandArchives.proto\022\004TSWP\032\021TSPMe"
  "ssages.proto\032\021TSSArchives.proto\032\021TSDArch"
  "ives.proto\032\030TSDCommandArchives.proto\032\021TS"
  "KArchives.proto\032\022TSWPArchives.proto\"\"\n\023D"
  "ummyCommandArchive\022\013\n\003foo\030\001 \002(\r\"\205\007\n\022Text"
  "CommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Comm"
  "andArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Refere"
  "nce\022/\n\020undo_transaction\030\003 \001(\0132\025.TSWP.Und"
  "oTransaction\022\036\n\026restore_range_location\030\004"
  " \001(\r\022\034\n\024restore_range_length\030\005 \001(\r\022#\n\033re"
  "do_restore_range_location\030\006 \001(\r\022!\n\031redo_"
  "restore_range_length\030\007 \001(\r\022\032\n\022text_comma"
  "nd_flags\030\t \001(\r\022;\n\004kind\030\n \001(\0162\035.TSWP.Text"
  "CommandArchive.Kind:\016kKindContained\"\231\004\n\004"
  "Kind\022\022\n\016kKindContained\020\000\022\024\n\020kKindReplace"
  "Text\020\001\022\016\n\nkKindPaste\020\002\022\027\n\023kKindParagraph"
  "Style\020\003\022\022\n\016kKindListStyle\020\004\022\035\n\031kKindInde"
  "ntParagraphLevel\020\005\022\021\n\rkKindDragText\020\006\022\023\n"
  "\017kKindPasteStyle\020\007\022\034\n\030kKindApplyChangesI"
  "nRange\020\010\022\032\n\026kKindSetParagraphLevel\020\t\022\034\n\030"
  "kKindInsertCitationField\020\n\022 \n\034kKindInser"
  "tBibliographyEntry\020\013\022\035\n\031kKindFormatCitat"
  "ionFields\020\014\022\034\n\030kKindInsertTOCSmartField\020"
  "\r\022\034\n\030kKindInsertDateTimeField\020\016\022\034\n\030kKind"
  "UpdateDateTimeField\020\017\022%\n!kKindSetParagra"
  "phFirstTopicNumber\020\020\022\027\n\023kKindCharacterSt"
  "yle\020\021\022\025\n\021kKindRevertStyles\020\022\022\031\n\025kKindSet"
  "ParagraphBidi\020\023\"\243\001\n\034ReplaceAllTextComman"
  "dArchive\0221\n\005super\030\001 \001(\0132\".TSK.ReplaceAll"
  "ChildCommandArchive\022\037\n\007storage\030\002 \001(\0132\016.T"
  "SP.Reference\022/\n\020undo_transaction\030\003 \001(\0132\025"
  ".TSWP.UndoTransaction\"\356\001\n\030FormatTextComm"
  "andArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandA"
  "rchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022"
  "/\n\020undo_transaction\030\003 \001(\0132\025.TSWP.UndoTra"
  "nsaction\022 \n\030selection_range_location\030\010 \001"
  "(\r\022\036\n\026selection_range_length\030\t \001(\r\022\032\n\022te"
  "xt_command_flags\030\013 \001(\r\"\224\001\n\034SetColumnStyl"
  "eCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Com"
  "mandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Refer"
  "ence\022/\n\020undo_transaction\030\003 \001(\0132\025.TSWP.Un"
  "doTransaction\"\233\001\n#ReplaceAllUsesOfStyleC"
  "ommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Comma"
  "ndArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Referen"
  "ce\022/\n\020undo_transaction\030\003 \001(\0132\025.TSWP.Undo"
  "Transaction\"\340\002\n\036InsertAttachmentCommandA"
  "rchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchi"
  "ve\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022 \n\030s"
  "election_range_location\030\003 \001(\r\022\036\n\026selecti"
  "on_range_length\030\004 \001(\r\022\"\n\nattachment\030\005 \001("
  "\0132\016.TSP.Reference\022/\n\020undo_transaction\030\006 "
  "\001(\0132\025.TSWP.UndoTransaction\022\032\n\022text_comma"
  "nd_flags\030\007 \001(\r\022#\n\033redo_restore_range_loc"
  "ation\030\010 \001(\r\022!\n\031redo_restore_range_length"
  "\030\t \001(\r\"\277\001\n\033InsertColumnsCommandArchive\022\""
  "\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007st"
  "orage\030\002 \001(\0132\016.TSP.Reference\022\024\n\014column_in"
  "dex\030\003 \001(\r\022\024\n\014column_count\030\004 \001(\r\022/\n\020undo_"
  "transaction\030\005 \001(\0132\025.TSWP.UndoTransaction"
  "\"\266\001\n\030InsertRowsCommandArchive\022\"\n\005super\030\001"
  " \001(\0132\023.TSK.CommandArchive\022\037\n\007storage\030\002 \001"
  "(\0132\016.TSP.Reference\022\021\n\trow_index\030\003 \001(\r\022\021\n"
  "\trow_count\030\004 \001(\r\022/\n\020undo_transaction\030\005 \001"
  "(\0132\025.TSWP.UndoTransaction\"\277\001\n\033RemoveColu"
  "mnsCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.C"
  "ommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Ref"
  "erence\022\024\n\014column_index\030\003 \001(\r\022\024\n\014column_c"
  "ount\030\004 \001(\r\022/\n\020undo_transaction\030\005 \001(\0132\025.T"
  "SWP.UndoTransaction\"\266\001\n\030RemoveRowsComman"
  "dArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArc"
  "hive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022\021\n"
  "\trow_index\030\003 \001(\r\022\021\n\trow_count\030\004 \001(\r\022/\n\020u"
  "ndo_transaction\030\005 \001(\0132\025.TSWP.UndoTransac"
  "tion\"\326\001\n\030MergeCellsCommandArchive\022\"\n\005sup"
  "er\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007storage"
  "\030\002 \001(\0132\016.TSP.Reference\022\013\n\003row\030\003 \001(\r\022\016\n\006c"
  "olumn\030\004 \001(\r\022\021\n\trow_count\030\005 \001(\r\022\024\n\014column"
  "_count\030\006 \001(\r\022/\n\020undo_transaction\030\007 \001(\0132\025"
  ".TSWP.UndoTransaction\"\334\001\n\"ApplyPlacehold"
  "erTextCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TS"
  "K.CommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP."
  "Reference\022 \n\030selection_range_location\030\003 "
  "\001(\r\022\036\n\026selection_range_length\030\004 \001(\r\022/\n\020u"
  "ndo_transaction\030\005 \001(\0132\025.TSWP.UndoTransac"
  "tion\"\352\001\n ApplyHighlightTextCommandArchiv"
  "e\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n"
  "\007storage\030\002 \001(\0132\016.TSP.Reference\022 \n\030select"
  "ion_range_location\030\003 \001(\r\022\036\n\026selection_ra"
  "nge_length\030\004 \001(\r\022/\n\020undo_transaction\030\005 \001"
  "(\0132\025.TSWP.UndoTransaction\022\016\n\006remove\030\006 \001("
  "\010\"\350\001\n\035CreateHyperlinkCommandArchive\022\"\n\005s"
  "uper\030\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007stora"
  "ge\030\002 \001(\0132\016.TSP.Reference\022 \n\030selection_ra"
  "nge_location\030\003 \001(\r\022\036\n\026selection_range_le"
  "ngth\030\004 \001(\r\022\017\n\007url_ref\030\005 \001(\t\022/\n\020undo_tran"
  "saction\030\006 \001(\0132\025.TSWP.UndoTransaction\"\200\002\n"
  "\035RemoveHyperlinkCommandArchive\022\"\n\005super\030"
  "\001 \001(\0132\023.TSK.CommandArchive\022\037\n\007storage\030\002 "
  "\001(\0132\016.TSP.Reference\022 \n\030selection_range_l"
  "ocation\030\003 \001(\r\022\036\n\026selection_range_length\030"
  "\004 \001(\r\022/\n\020undo_transaction\030\005 \001(\0132\025.TSWP.U"
  "ndoTransaction\022\'\n\031is_remove_character_st"
  "yle\030\006 \001(\010:\004true\"\276\001\n\035ModifyHyperlinkComma"
  "ndArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandAr"
  "chive\022!\n\thyperlink\030\002 \001(\0132\016.TSP.Reference"
  "\022\024\n\014display_text\030\003 \001(\t\022\017\n\007url_ref\030\004 \001(\t\022"
  "/\n\020undo_transaction\030\005 \001(\0132\025.TSWP.UndoTra"
  "nsaction\"\246\002\n!UpdateDateTimeFieldCommandA"
  "rchive\022\'\n\005super\030\001 \001(\0132\030.TSWP.TextCommand"
  "Archive\022\'\n\017date_time_field\030\002 \001(\0132\016.TSP.R"
  "eference\022\027\n\004date\030\003 \001(\0132\t.TSP.Date\022J\n\ndat"
  "e_style\030\004 \001(\01626.TSWP.DateTimeSmartFieldA"
  "rchive.DateTimeFormatterStyle\022J\n\ntime_st"
  "yle\030\005 \001(\01626.TSWP.DateTimeSmartFieldArchi"
  "ve.DateTimeFormatterStyle\"\350\001\n\033ApplyRubyT"
  "extCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.C"
  "ommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Ref"
  "erence\022 \n\030selection_range_location\030\003 \001(\r"
  "\022\036\n\026selection_range_length\030\004 \001(\r\022\021\n\truby"
  "_text\030\005 \001(\t\022/\n\020undo_transaction\030\006 \001(\0132\025."
  "TSWP.UndoTransaction\"\326\001\n\034RemoveRubyTextC"
  "ommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Comma"
  "ndArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Referen"
  "ce\022 \n\030selection_range_location\030\003 \001(\r\022\036\n\026"
  "selection_range_length\030\004 \001(\r\022/\n\020undo_tra"
  "nsaction\030\005 \001(\0132\025.TSWP.UndoTransaction\"\275\001"
  "\n\034ModifyRubyTextCommandArchive\022\"\n\005super\030"
  "\001 \001(\0132\023.TSK.CommandArchive\022\"\n\nruby_field"
  "\030\002 \001(\0132\016.TSP.Reference\022\021\n\truby_text\030\003 \001("
  "\t\022\021\n\tbase_text\030\004 \001(\t\022/\n\020undo_transaction"
  "\030\005 \001(\0132\025.TSWP.UndoTransaction\"\235\001\n#Modify"
  "TOCSettingsBaseCommandArchive\022\"\n\005super\030\001"
  " \001(\0132\023.TSK.CommandArchive\022(\n\020old_toc_set"
  "tings\030\002 \001(\0132\016.TSP.Reference\022(\n\020new_toc_s"
  "ettings\030\003 \001(\0132\016.TSP.Reference\"\207\001\n)Modify"
  "TOCSettingsForTOCInfoCommandArchive\0228\n\005s"
  "uper\030\001 \001(\0132).TSWP.ModifyTOCSettingsBaseC"
  "ommandArchive\022 \n\010toc_info\030\002 \001(\0132\016.TSP.Re"
  "ference\"\236\001\n-ModifyTOCSettingsPresetForTh"
  "emeCommandArchive\0228\n\005super\030\001 \001(\0132).TSWP."
  "ModifyTOCSettingsBaseCommandArchive\022\035\n\005t"
  "heme\030\002 \001(\0132\016.TSP.Reference\022\024\n\014preset_ind"
  "ex\030\003 \001(\r\"\242\002\n\036AnchorAttachmentCommandArch"
  "ive\022\"\n\005super\030\001 \001(\0132\023.TSK.CommandArchive\022"
  "\037\n\007storage\030\002 \001(\0132\016.TSP.Reference\022\"\n\natta"
  "chment\030\003 \001(\0132\016.TSP.Reference\022\025\n\rh_offset"
  "_type\030\004 \001(\r\022\020\n\010h_offset\030\005 \001(\002\022\025\n\rv_offse"
  "t_type\030\006 \001(\r\022\020\n\010v_offset\030\007 \001(\002\022/\n\020undo_t"
  "ransaction\030\010 \001(\0132\025.TSWP.UndoTransaction\022"
  "\024\n\014is_html_wrap\030\t \001(\010\"\243\001\n\034TextApplyTheme"
  "CommandArchive\0221\n\005super\030\001 \001(\0132\".TSS.Appl"
  "yThemeChildCommandArchive\022\037\n\007storage\030\002 \001"
  "(\0132\016.TSP.Reference\022/\n\020undo_transaction\030\006"
  " \001(\0132\025.TSWP.UndoTransaction\"\306\001\n\031MoveColu"
  "mnsCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.C"
  "ommandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Ref"
  "erence\022\021\n\tsrc_index\030\003 \001(\r\022\021\n\tdst_index\030\004"
  " \001(\r\022\r\n\005count\030\005 \001(\r\022/\n\020undo_transaction\030"
  "\006 \001(\0132\025.TSWP.UndoTransaction\"\303\001\n\026MoveRow"
  "sCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.Com"
  "mandArchive\022\037\n\007storage\030\002 \001(\0132\016.TSP.Refer"
  "ence\022\021\n\tsrc_index\030\003 \001(\r\022\021\n\tdst_index\030\004 \001"
  "(\r\022\r\n\005count\030\005 \001(\r\022/\n\020undo_transaction\030\006 "
  "\001(\0132\025.TSWP.UndoTransaction\"T\n\036ShapeApply"
  "PresetCommandArchive\0222\n\005super\030\001 \002(\0132#.TS"
  "D.ShapeApplyPresetCommandArchive\"\303\001\n\035Sha"
  "pePasteStyleCommandArchive\022,\n\005super\030\001 \002("
  "\0132\035.TSD.PasteStyleCommandArchive\022\'\n\017para"
  "graph_style\030\002 \001(\0132\016.TSP.Reference\022\"\n\nlis"
  "t_style\030\003 \001(\0132\016.TSP.Reference\022\'\n\017charact"
  "er_style\030\004 \001(\0132\016.TSP.Reference\"{\n\027StyleB"
  "aseCommandArchive\022\"\n\005super\030\001 \001(\0132\023.TSK.C"
  "ommandArchive\022\035\n\005theme\030\002 \001(\0132\016.TSP.Refer"
  "ence\022\035\n\005style\030\003 \001(\0132\016.TSP.Reference\"_\n\031S"
  "tyleCreateCommandArchive\022,\n\005super\030\001 \001(\0132"
  "\035.TSWP.StyleBaseCommandArchive\022\024\n\014preset"
  "_index\030\002 \001(\r\"q\n\031StyleRenameCommandArchiv"
  "e\022,\n\005super\030\001 \001(\0132\035.TSWP.StyleBaseCommand"
  "Archive\022\024\n\014updated_name\030\002 \001(\t\022\020\n\010old_nam"
  "e\030\003 \001(\t\"\230\001\n\031StyleUpdateCommandArchive\022,\n"
  "\005super\030\001 \001(\0132\035.TSWP.StyleBaseCommandArch"
  "ive\022&\n\016original_style\030\002 \001(\0132\016.TSP.Refere"
  "nce\022%\n\rupdated_style\030\003 \001(\0132\016.TSP.Referen"
  "ce\"c\n\031StyleDeleteCommandArchive\022,\n\005super"
  "\030\001 \001(\0132\035.TSWP.StyleBaseCommandArchive\022\030\n"
  "\020old_preset_index\030\002 \001(\r\"~\n\032StyleReorderC"
  "ommandArchive\022,\n\005super\030\001 \001(\0132\035.TSWP.Styl"
  "eBaseCommandArchive\022\030\n\020old_preset_index\030"
  "\002 \001(\r\022\030\n\020new_preset_index\030\003 \001(\r\"`\n$Style"
  "UpdatePropertyMapCommandArchive\0228\n\005super"
  "\030\001 \002(\0132).TSS.StyleUpdatePropertyMapComma"
  "ndArchive"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_TSWPCommandArchives_2eproto_deps[6] = {
  &::descriptor_table_TSDArchives_2eproto,
  &::descriptor_table_TSDCommandArchives_2eproto,
  &::descriptor_table_TSKArchives_2eproto,
  &::descriptor_table_TSPMessages_2eproto,
  &::descriptor_table_TSSArchives_2eproto,
  &::descriptor_table_TSWPArchives_2eproto,
};
static ::_pbi::once_flag descriptor_table_TSWPCommandArchives_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TSWPCommandArchives_2eproto = {
    false, false, 7649, descriptor_table_protodef_TSWPCommandArchives_2eproto,
    "TSWPCommandArchives.proto",
    &descriptor_table_TSWPCommandArchives_2eproto_once, descriptor_table_TSWPCommandArchives_2eproto_deps, 6, 37,
    schemas, file_default_instances, TableStruct_TSWPCommandArchives_2eproto::offsets,
    file_level_metadata_TSWPCommandArchives_2eproto, file_level_enum_descriptors_TSWPCommandArchives_2eproto,
    file_level_service_descriptors_TSWPCommandArchives_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TSWPCommandArchives_2eproto_getter() {
  return &descriptor_table_TSWPCommandArchives_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TSWPCommandArchives_2eproto(&descriptor_table_TSWPCommandArchives_2eproto);
namespace TSWP {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TextCommandArchive_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_TSWPCommandArchives_2eproto);
  return file_level_enum_descriptors_TSWPCommandArchives_2eproto[0];
}
bool TextCommandArchive_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TextCommandArchive_Kind TextCommandArchive::kKindContained;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindReplaceText;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindPaste;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindParagraphStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindListStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindIndentParagraphLevel;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindDragText;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindPasteStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindApplyChangesInRange;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindSetParagraphLevel;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertCitationField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertBibliographyEntry;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindFormatCitationFields;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertTOCSmartField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindInsertDateTimeField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindUpdateDateTimeField;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindSetParagraphFirstTopicNumber;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindCharacterStyle;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindRevertStyles;
constexpr TextCommandArchive_Kind TextCommandArchive::kKindSetParagraphBidi;
constexpr TextCommandArchive_Kind TextCommandArchive::Kind_MIN;
constexpr TextCommandArchive_Kind TextCommandArchive::Kind_MAX;
constexpr int TextCommandArchive::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DummyCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<DummyCommandArchive>()._impl_._has_bits_);
  static void set_has_foo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

DummyCommandArchive::DummyCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.DummyCommandArchive)
}
DummyCommandArchive::DummyCommandArchive(const DummyCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DummyCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.foo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.foo_ = from._impl_.foo_;
  // @@protoc_insertion_point(copy_constructor:TSWP.DummyCommandArchive)
}

inline void DummyCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.foo_){0u}
  };
}

DummyCommandArchive::~DummyCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.DummyCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DummyCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DummyCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DummyCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.DummyCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.foo_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DummyCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 foo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_foo(&has_bits);
          _impl_.foo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DummyCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.DummyCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 foo = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_foo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.DummyCommandArchive)
  return target;
}

size_t DummyCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.DummyCommandArchive)
  size_t total_size = 0;

  // required uint32 foo = 1;
  if (_internal_has_foo()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_foo());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DummyCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DummyCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DummyCommandArchive::GetClassData() const { return &_class_data_; }


void DummyCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DummyCommandArchive*>(&to_msg);
  auto& from = static_cast<const DummyCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.DummyCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_foo()) {
    _this->_internal_set_foo(from._internal_foo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DummyCommandArchive::CopyFrom(const DummyCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.DummyCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DummyCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DummyCommandArchive::InternalSwap(DummyCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.foo_, other->_impl_.foo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DummyCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[0]);
}

// ===================================================================

class TextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const TextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const TextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const TextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_restore_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_restore_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_redo_restore_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_redo_restore_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_text_command_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::TSK::CommandArchive&
TextCommandArchive::_Internal::super(const TextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TextCommandArchive::_Internal::storage(const TextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
TextCommandArchive::_Internal::undo_transaction(const TextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void TextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TextCommandArchive::TextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.TextCommandArchive)
}
TextCommandArchive::TextCommandArchive(const TextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.restore_range_location_){}
    , decltype(_impl_.restore_range_length_){}
    , decltype(_impl_.redo_restore_range_location_){}
    , decltype(_impl_.redo_restore_range_length_){}
    , decltype(_impl_.text_command_flags_){}
    , decltype(_impl_.kind_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.restore_range_location_, &from._impl_.restore_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.kind_) -
    reinterpret_cast<char*>(&_impl_.restore_range_location_)) + sizeof(_impl_.kind_));
  // @@protoc_insertion_point(copy_constructor:TSWP.TextCommandArchive)
}

inline void TextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.restore_range_location_){0u}
    , decltype(_impl_.restore_range_length_){0u}
    , decltype(_impl_.redo_restore_range_location_){0u}
    , decltype(_impl_.redo_restore_range_length_){0u}
    , decltype(_impl_.text_command_flags_){0u}
    , decltype(_impl_.kind_){0}
  };
}

TextCommandArchive::~TextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.TextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void TextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.TextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.restore_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.text_command_flags_) -
        reinterpret_cast<char*>(&_impl_.restore_range_location_)) + sizeof(_impl_.text_command_flags_));
  }
  _impl_.kind_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 restore_range_location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_restore_range_location(&has_bits);
          _impl_.restore_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 restore_range_length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_restore_range_length(&has_bits);
          _impl_.restore_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_location = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_redo_restore_range_location(&has_bits);
          _impl_.redo_restore_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_redo_restore_range_length(&has_bits);
          _impl_.redo_restore_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_command_flags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_text_command_flags(&has_bits);
          _impl_.text_command_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::TextCommandArchive_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::TSWP::TextCommandArchive_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.TextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional uint32 restore_range_location = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_restore_range_location(), target);
  }

  // optional uint32 restore_range_length = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_restore_range_length(), target);
  }

  // optional uint32 redo_restore_range_location = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_redo_restore_range_location(), target);
  }

  // optional uint32 redo_restore_range_length = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_redo_restore_range_length(), target);
  }

  // optional uint32 text_command_flags = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_text_command_flags(), target);
  }

  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_kind(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.TextCommandArchive)
  return target;
}

size_t TextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.TextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 restore_range_location = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_restore_range_location());
    }

    // optional uint32 restore_range_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_restore_range_length());
    }

    // optional uint32 redo_restore_range_location = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_location());
    }

    // optional uint32 redo_restore_range_length = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_length());
    }

    // optional uint32 text_command_flags = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_command_flags());
    }

  }
  // optional .TSWP.TextCommandArchive.Kind kind = 10 [default = kKindContained];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextCommandArchive::GetClassData() const { return &_class_data_; }


void TextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextCommandArchive*>(&to_msg);
  auto& from = static_cast<const TextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.TextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.restore_range_location_ = from._impl_.restore_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.restore_range_length_ = from._impl_.restore_range_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.redo_restore_range_location_ = from._impl_.redo_restore_range_location_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.redo_restore_range_length_ = from._impl_.redo_restore_range_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.text_command_flags_ = from._impl_.text_command_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_kind(from._internal_kind());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextCommandArchive::CopyFrom(const TextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.TextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void TextCommandArchive::InternalSwap(TextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextCommandArchive, _impl_.kind_)
      + sizeof(TextCommandArchive::_impl_.kind_)
      - PROTOBUF_FIELD_OFFSET(TextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[1]);
}

// ===================================================================

class ReplaceAllTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAllTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::ReplaceAllChildCommandArchive& super(const ReplaceAllTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const ReplaceAllTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ReplaceAllTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::ReplaceAllChildCommandArchive&
ReplaceAllTextCommandArchive::_Internal::super(const ReplaceAllTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ReplaceAllTextCommandArchive::_Internal::storage(const ReplaceAllTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ReplaceAllTextCommandArchive::_Internal::undo_transaction(const ReplaceAllTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ReplaceAllTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ReplaceAllTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ReplaceAllTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ReplaceAllTextCommandArchive::ReplaceAllTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ReplaceAllTextCommandArchive)
}
ReplaceAllTextCommandArchive::ReplaceAllTextCommandArchive(const ReplaceAllTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAllTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::ReplaceAllChildCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ReplaceAllTextCommandArchive)
}

inline void ReplaceAllTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

ReplaceAllTextCommandArchive::~ReplaceAllTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ReplaceAllTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAllTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ReplaceAllTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAllTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ReplaceAllTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAllTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.ReplaceAllChildCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAllTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ReplaceAllTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.ReplaceAllChildCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ReplaceAllTextCommandArchive)
  return target;
}

size_t ReplaceAllTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ReplaceAllTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.ReplaceAllChildCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAllTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAllTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAllTextCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAllTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAllTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAllTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ReplaceAllTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::ReplaceAllChildCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAllTextCommandArchive::CopyFrom(const ReplaceAllTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ReplaceAllTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAllTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAllTextCommandArchive::InternalSwap(ReplaceAllTextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplaceAllTextCommandArchive, _impl_.undo_transaction_)
      + sizeof(ReplaceAllTextCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ReplaceAllTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAllTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[2]);
}

// ===================================================================

class FormatTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<FormatTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const FormatTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const FormatTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const FormatTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_text_command_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSK::CommandArchive&
FormatTextCommandArchive::_Internal::super(const FormatTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
FormatTextCommandArchive::_Internal::storage(const FormatTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
FormatTextCommandArchive::_Internal::undo_transaction(const FormatTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void FormatTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void FormatTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void FormatTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
FormatTextCommandArchive::FormatTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.FormatTextCommandArchive)
}
FormatTextCommandArchive::FormatTextCommandArchive(const FormatTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FormatTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}
    , decltype(_impl_.text_command_flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.text_command_flags_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.text_command_flags_));
  // @@protoc_insertion_point(copy_constructor:TSWP.FormatTextCommandArchive)
}

inline void FormatTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
    , decltype(_impl_.text_command_flags_){0u}
  };
}

FormatTextCommandArchive::~FormatTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.FormatTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormatTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void FormatTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FormatTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.FormatTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.text_command_flags_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.text_command_flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FormatTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_command_flags = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_text_command_flags(&has_bits);
          _impl_.text_command_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormatTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.FormatTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_selection_range_length(), target);
  }

  // optional uint32 text_command_flags = 11;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_text_command_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.FormatTextCommandArchive)
  return target;
}

size_t FormatTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.FormatTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

    // optional uint32 text_command_flags = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_command_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FormatTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FormatTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FormatTextCommandArchive::GetClassData() const { return &_class_data_; }


void FormatTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FormatTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const FormatTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.FormatTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.text_command_flags_ = from._impl_.text_command_flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FormatTextCommandArchive::CopyFrom(const FormatTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.FormatTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormatTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void FormatTextCommandArchive::InternalSwap(FormatTextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FormatTextCommandArchive, _impl_.text_command_flags_)
      + sizeof(FormatTextCommandArchive::_impl_.text_command_flags_)
      - PROTOBUF_FIELD_OFFSET(FormatTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FormatTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[3]);
}

// ===================================================================

class SetColumnStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<SetColumnStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const SetColumnStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const SetColumnStyleCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const SetColumnStyleCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
SetColumnStyleCommandArchive::_Internal::super(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
SetColumnStyleCommandArchive::_Internal::storage(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
SetColumnStyleCommandArchive::_Internal::undo_transaction(const SetColumnStyleCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void SetColumnStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void SetColumnStyleCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void SetColumnStyleCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.SetColumnStyleCommandArchive)
}
SetColumnStyleCommandArchive::SetColumnStyleCommandArchive(const SetColumnStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetColumnStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.SetColumnStyleCommandArchive)
}

inline void SetColumnStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

SetColumnStyleCommandArchive::~SetColumnStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.SetColumnStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetColumnStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void SetColumnStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetColumnStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.SetColumnStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetColumnStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetColumnStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.SetColumnStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.SetColumnStyleCommandArchive)
  return target;
}

size_t SetColumnStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.SetColumnStyleCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetColumnStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetColumnStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetColumnStyleCommandArchive::GetClassData() const { return &_class_data_; }


void SetColumnStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetColumnStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const SetColumnStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.SetColumnStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetColumnStyleCommandArchive::CopyFrom(const SetColumnStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.SetColumnStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetColumnStyleCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void SetColumnStyleCommandArchive::InternalSwap(SetColumnStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SetColumnStyleCommandArchive, _impl_.undo_transaction_)
      + sizeof(SetColumnStyleCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(SetColumnStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SetColumnStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[4]);
}

// ===================================================================

class ReplaceAllUsesOfStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplaceAllUsesOfStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ReplaceAllUsesOfStyleCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
ReplaceAllUsesOfStyleCommandArchive::_Internal::super(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ReplaceAllUsesOfStyleCommandArchive::_Internal::storage(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ReplaceAllUsesOfStyleCommandArchive::_Internal::undo_transaction(const ReplaceAllUsesOfStyleCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ReplaceAllUsesOfStyleCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
}
ReplaceAllUsesOfStyleCommandArchive::ReplaceAllUsesOfStyleCommandArchive(const ReplaceAllUsesOfStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplaceAllUsesOfStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
}

inline void ReplaceAllUsesOfStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

ReplaceAllUsesOfStyleCommandArchive::~ReplaceAllUsesOfStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplaceAllUsesOfStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ReplaceAllUsesOfStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplaceAllUsesOfStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplaceAllUsesOfStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReplaceAllUsesOfStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  return target;
}

size_t ReplaceAllUsesOfStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplaceAllUsesOfStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplaceAllUsesOfStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplaceAllUsesOfStyleCommandArchive::GetClassData() const { return &_class_data_; }


void ReplaceAllUsesOfStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplaceAllUsesOfStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const ReplaceAllUsesOfStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplaceAllUsesOfStyleCommandArchive::CopyFrom(const ReplaceAllUsesOfStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ReplaceAllUsesOfStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplaceAllUsesOfStyleCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ReplaceAllUsesOfStyleCommandArchive::InternalSwap(ReplaceAllUsesOfStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReplaceAllUsesOfStyleCommandArchive, _impl_.undo_transaction_)
      + sizeof(ReplaceAllUsesOfStyleCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ReplaceAllUsesOfStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplaceAllUsesOfStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[5]);
}

// ===================================================================

class InsertAttachmentCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertAttachmentCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertAttachmentCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const InsertAttachmentCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSP::Reference& attachment(const InsertAttachmentCommandArchive* msg);
  static void set_has_attachment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const InsertAttachmentCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_text_command_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_redo_restore_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_redo_restore_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::TSK::CommandArchive&
InsertAttachmentCommandArchive::_Internal::super(const InsertAttachmentCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertAttachmentCommandArchive::_Internal::storage(const InsertAttachmentCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSP::Reference&
InsertAttachmentCommandArchive::_Internal::attachment(const InsertAttachmentCommandArchive* msg) {
  return *msg->_impl_.attachment_;
}
const ::TSWP::UndoTransaction&
InsertAttachmentCommandArchive::_Internal::undo_transaction(const InsertAttachmentCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void InsertAttachmentCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertAttachmentCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertAttachmentCommandArchive::clear_attachment() {
  if (_impl_.attachment_ != nullptr) _impl_.attachment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void InsertAttachmentCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
InsertAttachmentCommandArchive::InsertAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.InsertAttachmentCommandArchive)
}
InsertAttachmentCommandArchive::InsertAttachmentCommandArchive(const InsertAttachmentCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertAttachmentCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}
    , decltype(_impl_.text_command_flags_){}
    , decltype(_impl_.redo_restore_range_location_){}
    , decltype(_impl_.redo_restore_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_attachment()) {
    _this->_impl_.attachment_ = new ::TSP::Reference(*from._impl_.attachment_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.redo_restore_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.redo_restore_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.InsertAttachmentCommandArchive)
}

inline void InsertAttachmentCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
    , decltype(_impl_.text_command_flags_){0u}
    , decltype(_impl_.redo_restore_range_location_){0u}
    , decltype(_impl_.redo_restore_range_length_){0u}
  };
}

InsertAttachmentCommandArchive::~InsertAttachmentCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.InsertAttachmentCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertAttachmentCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.attachment_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void InsertAttachmentCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertAttachmentCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.InsertAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.attachment_ != nullptr);
      _impl_.attachment_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.redo_restore_range_location_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.redo_restore_range_location_));
  }
  _impl_.redo_restore_range_length_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertAttachmentCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference attachment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 text_command_flags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_text_command_flags(&has_bits);
          _impl_.text_command_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_location = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_redo_restore_range_location(&has_bits);
          _impl_.redo_restore_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 redo_restore_range_length = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_redo_restore_range_length(&has_bits);
          _impl_.redo_restore_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertAttachmentCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.InsertAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSP.Reference attachment = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::attachment(this),
        _Internal::attachment(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional uint32 text_command_flags = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_text_command_flags(), target);
  }

  // optional uint32 redo_restore_range_location = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_redo_restore_range_location(), target);
  }

  // optional uint32 redo_restore_range_length = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_redo_restore_range_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.InsertAttachmentCommandArchive)
  return target;
}

size_t InsertAttachmentCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.InsertAttachmentCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSP.Reference attachment = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachment_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

    // optional uint32 text_command_flags = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_text_command_flags());
    }

    // optional uint32 redo_restore_range_location = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_location());
    }

  }
  // optional uint32 redo_restore_range_length = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redo_restore_range_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertAttachmentCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertAttachmentCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertAttachmentCommandArchive::GetClassData() const { return &_class_data_; }


void InsertAttachmentCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertAttachmentCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertAttachmentCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.InsertAttachmentCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_attachment()->::TSP::Reference::MergeFrom(
          from._internal_attachment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.text_command_flags_ = from._impl_.text_command_flags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.redo_restore_range_location_ = from._impl_.redo_restore_range_location_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_redo_restore_range_length(from._internal_redo_restore_range_length());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertAttachmentCommandArchive::CopyFrom(const InsertAttachmentCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.InsertAttachmentCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertAttachmentCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_attachment()) {
    if (!_impl_.attachment_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void InsertAttachmentCommandArchive::InternalSwap(InsertAttachmentCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertAttachmentCommandArchive, _impl_.redo_restore_range_length_)
      + sizeof(InsertAttachmentCommandArchive::_impl_.redo_restore_range_length_)
      - PROTOBUF_FIELD_OFFSET(InsertAttachmentCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertAttachmentCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[6]);
}

// ===================================================================

class InsertColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const InsertColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const InsertColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
InsertColumnsCommandArchive::_Internal::super(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertColumnsCommandArchive::_Internal::storage(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
InsertColumnsCommandArchive::_Internal::undo_transaction(const InsertColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void InsertColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
InsertColumnsCommandArchive::InsertColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.InsertColumnsCommandArchive)
}
InsertColumnsCommandArchive::InsertColumnsCommandArchive(const InsertColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.column_index_, &from._impl_.column_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.InsertColumnsCommandArchive)
}

inline void InsertColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

InsertColumnsCommandArchive::~InsertColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.InsertColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void InsertColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.InsertColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.column_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_column_index(&has_bits);
          _impl_.column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.InsertColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 column_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_column_index(), target);
  }

  // optional uint32 column_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.InsertColumnsCommandArchive)
  return target;
}

size_t InsertColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.InsertColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 column_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());
    }

    // optional uint32 column_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void InsertColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.InsertColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.column_index_ = from._impl_.column_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertColumnsCommandArchive::CopyFrom(const InsertColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.InsertColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void InsertColumnsCommandArchive::InternalSwap(InsertColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertColumnsCommandArchive, _impl_.column_count_)
      + sizeof(InsertColumnsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(InsertColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[7]);
}

// ===================================================================

class InsertRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const InsertRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const InsertRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const InsertRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
InsertRowsCommandArchive::_Internal::super(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
InsertRowsCommandArchive::_Internal::storage(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
InsertRowsCommandArchive::_Internal::undo_transaction(const InsertRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void InsertRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void InsertRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void InsertRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
InsertRowsCommandArchive::InsertRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.InsertRowsCommandArchive)
}
InsertRowsCommandArchive::InsertRowsCommandArchive(const InsertRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InsertRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){}
    , decltype(_impl_.row_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_index_, &from._impl_.row_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.row_count_) -
    reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.InsertRowsCommandArchive)
}

inline void InsertRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){0u}
    , decltype(_impl_.row_count_){0u}
  };
}

InsertRowsCommandArchive::~InsertRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.InsertRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InsertRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void InsertRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InsertRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.InsertRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.row_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.row_count_) -
        reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row_index(&has_bits);
          _impl_.row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InsertRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.InsertRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row_index(), target);
  }

  // optional uint32 row_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_row_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.InsertRowsCommandArchive)
  return target;
}

size_t InsertRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.InsertRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_index());
    }

    // optional uint32 row_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InsertRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertRowsCommandArchive::GetClassData() const { return &_class_data_; }


void InsertRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InsertRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const InsertRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.InsertRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_index_ = from._impl_.row_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertRowsCommandArchive::CopyFrom(const InsertRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.InsertRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void InsertRowsCommandArchive::InternalSwap(InsertRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertRowsCommandArchive, _impl_.row_count_)
      + sizeof(InsertRowsCommandArchive::_impl_.row_count_)
      - PROTOBUF_FIELD_OFFSET(InsertRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[8]);
}

// ===================================================================

class RemoveColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_column_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
RemoveColumnsCommandArchive::_Internal::super(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveColumnsCommandArchive::_Internal::storage(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveColumnsCommandArchive::_Internal::undo_transaction(const RemoveColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveColumnsCommandArchive)
}
RemoveColumnsCommandArchive::RemoveColumnsCommandArchive(const RemoveColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.column_index_, &from._impl_.column_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveColumnsCommandArchive)
}

inline void RemoveColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.column_index_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

RemoveColumnsCommandArchive::~RemoveColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.column_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.column_index_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_column_index(&has_bits);
          _impl_.column_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 column_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_column_index(), target);
  }

  // optional uint32 column_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveColumnsCommandArchive)
  return target;
}

size_t RemoveColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 column_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_index());
    }

    // optional uint32 column_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.column_index_ = from._impl_.column_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveColumnsCommandArchive::CopyFrom(const RemoveColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveColumnsCommandArchive::InternalSwap(RemoveColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveColumnsCommandArchive, _impl_.column_count_)
      + sizeof(RemoveColumnsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(RemoveColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[9]);
}

// ===================================================================

class RemoveRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
RemoveRowsCommandArchive::_Internal::super(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveRowsCommandArchive::_Internal::storage(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveRowsCommandArchive::_Internal::undo_transaction(const RemoveRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveRowsCommandArchive::RemoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveRowsCommandArchive)
}
RemoveRowsCommandArchive::RemoveRowsCommandArchive(const RemoveRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){}
    , decltype(_impl_.row_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_index_, &from._impl_.row_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.row_count_) -
    reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveRowsCommandArchive)
}

inline void RemoveRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_index_){0u}
    , decltype(_impl_.row_count_){0u}
  };
}

RemoveRowsCommandArchive::~RemoveRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.row_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.row_count_) -
        reinterpret_cast<char*>(&_impl_.row_index_)) + sizeof(_impl_.row_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row_index(&has_bits);
          _impl_.row_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row_index(), target);
  }

  // optional uint32 row_count = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_row_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveRowsCommandArchive)
  return target;
}

size_t RemoveRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_index());
    }

    // optional uint32 row_count = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveRowsCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_index_ = from._impl_.row_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveRowsCommandArchive::CopyFrom(const RemoveRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveRowsCommandArchive::InternalSwap(RemoveRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveRowsCommandArchive, _impl_.row_count_)
      + sizeof(RemoveRowsCommandArchive::_impl_.row_count_)
      - PROTOBUF_FIELD_OFFSET(RemoveRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[10]);
}

// ===================================================================

class MergeCellsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MergeCellsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MergeCellsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MergeCellsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_row(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_column(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_row_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_column_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MergeCellsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MergeCellsCommandArchive::_Internal::super(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MergeCellsCommandArchive::_Internal::storage(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MergeCellsCommandArchive::_Internal::undo_transaction(const MergeCellsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MergeCellsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MergeCellsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MergeCellsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MergeCellsCommandArchive::MergeCellsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MergeCellsCommandArchive)
}
MergeCellsCommandArchive::MergeCellsCommandArchive(const MergeCellsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MergeCellsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_){}
    , decltype(_impl_.column_){}
    , decltype(_impl_.row_count_){}
    , decltype(_impl_.column_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.row_, &from._impl_.row_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_count_) -
    reinterpret_cast<char*>(&_impl_.row_)) + sizeof(_impl_.column_count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MergeCellsCommandArchive)
}

inline void MergeCellsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.row_){0u}
    , decltype(_impl_.column_){0u}
    , decltype(_impl_.row_count_){0u}
    , decltype(_impl_.column_count_){0u}
  };
}

MergeCellsCommandArchive::~MergeCellsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MergeCellsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MergeCellsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MergeCellsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MergeCellsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MergeCellsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.row_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.column_count_) -
        reinterpret_cast<char*>(&_impl_.row_)) + sizeof(_impl_.column_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MergeCellsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_row(&has_bits);
          _impl_.row_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_column(&has_bits);
          _impl_.column_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 row_count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_row_count(&has_bits);
          _impl_.row_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 column_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_column_count(&has_bits);
          _impl_.column_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MergeCellsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MergeCellsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 row = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_row(), target);
  }

  // optional uint32 column = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column(), target);
  }

  // optional uint32 row_count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_row_count(), target);
  }

  // optional uint32 column_count = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_column_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MergeCellsCommandArchive)
  return target;
}

size_t MergeCellsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MergeCellsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 row = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row());
    }

    // optional uint32 column = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column());
    }

    // optional uint32 row_count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_row_count());
    }

    // optional uint32 column_count = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MergeCellsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MergeCellsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MergeCellsCommandArchive::GetClassData() const { return &_class_data_; }


void MergeCellsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MergeCellsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MergeCellsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MergeCellsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.row_ = from._impl_.row_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.column_ = from._impl_.column_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.row_count_ = from._impl_.row_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.column_count_ = from._impl_.column_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MergeCellsCommandArchive::CopyFrom(const MergeCellsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MergeCellsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeCellsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MergeCellsCommandArchive::InternalSwap(MergeCellsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MergeCellsCommandArchive, _impl_.column_count_)
      + sizeof(MergeCellsCommandArchive::_impl_.column_count_)
      - PROTOBUF_FIELD_OFFSET(MergeCellsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MergeCellsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[11]);
}

// ===================================================================

class ApplyPlaceholderTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyPlaceholderTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ApplyPlaceholderTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
ApplyPlaceholderTextCommandArchive::_Internal::super(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ApplyPlaceholderTextCommandArchive::_Internal::storage(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ApplyPlaceholderTextCommandArchive::_Internal::undo_transaction(const ApplyPlaceholderTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ApplyPlaceholderTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ApplyPlaceholderTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ApplyPlaceholderTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ApplyPlaceholderTextCommandArchive)
}
ApplyPlaceholderTextCommandArchive::ApplyPlaceholderTextCommandArchive(const ApplyPlaceholderTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyPlaceholderTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ApplyPlaceholderTextCommandArchive)
}

inline void ApplyPlaceholderTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
}

ApplyPlaceholderTextCommandArchive::~ApplyPlaceholderTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ApplyPlaceholderTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyPlaceholderTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ApplyPlaceholderTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyPlaceholderTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ApplyPlaceholderTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyPlaceholderTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyPlaceholderTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ApplyPlaceholderTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ApplyPlaceholderTextCommandArchive)
  return target;
}

size_t ApplyPlaceholderTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ApplyPlaceholderTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyPlaceholderTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyPlaceholderTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyPlaceholderTextCommandArchive::GetClassData() const { return &_class_data_; }


void ApplyPlaceholderTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyPlaceholderTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ApplyPlaceholderTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ApplyPlaceholderTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyPlaceholderTextCommandArchive::CopyFrom(const ApplyPlaceholderTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ApplyPlaceholderTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyPlaceholderTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ApplyPlaceholderTextCommandArchive::InternalSwap(ApplyPlaceholderTextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyPlaceholderTextCommandArchive, _impl_.selection_range_length_)
      + sizeof(ApplyPlaceholderTextCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(ApplyPlaceholderTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyPlaceholderTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[12]);
}

// ===================================================================

class ApplyHighlightTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyHighlightTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ApplyHighlightTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const ApplyHighlightTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ApplyHighlightTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSK::CommandArchive&
ApplyHighlightTextCommandArchive::_Internal::super(const ApplyHighlightTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ApplyHighlightTextCommandArchive::_Internal::storage(const ApplyHighlightTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ApplyHighlightTextCommandArchive::_Internal::undo_transaction(const ApplyHighlightTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ApplyHighlightTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ApplyHighlightTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ApplyHighlightTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ApplyHighlightTextCommandArchive::ApplyHighlightTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ApplyHighlightTextCommandArchive)
}
ApplyHighlightTextCommandArchive::ApplyHighlightTextCommandArchive(const ApplyHighlightTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyHighlightTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}
    , decltype(_impl_.remove_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.remove_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.remove_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ApplyHighlightTextCommandArchive)
}

inline void ApplyHighlightTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
    , decltype(_impl_.remove_){false}
  };
}

ApplyHighlightTextCommandArchive::~ApplyHighlightTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ApplyHighlightTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyHighlightTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ApplyHighlightTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyHighlightTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ApplyHighlightTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.remove_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.remove_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyHighlightTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool remove = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_remove(&has_bits);
          _impl_.remove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyHighlightTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ApplyHighlightTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional bool remove = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_remove(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ApplyHighlightTextCommandArchive)
  return target;
}

size_t ApplyHighlightTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ApplyHighlightTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

    // optional bool remove = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyHighlightTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyHighlightTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyHighlightTextCommandArchive::GetClassData() const { return &_class_data_; }


void ApplyHighlightTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyHighlightTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ApplyHighlightTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ApplyHighlightTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.remove_ = from._impl_.remove_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyHighlightTextCommandArchive::CopyFrom(const ApplyHighlightTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ApplyHighlightTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyHighlightTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ApplyHighlightTextCommandArchive::InternalSwap(ApplyHighlightTextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyHighlightTextCommandArchive, _impl_.remove_)
      + sizeof(ApplyHighlightTextCommandArchive::_impl_.remove_)
      - PROTOBUF_FIELD_OFFSET(ApplyHighlightTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyHighlightTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[13]);
}

// ===================================================================

class CreateHyperlinkCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateHyperlinkCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const CreateHyperlinkCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& storage(const CreateHyperlinkCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_url_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const CreateHyperlinkCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSK::CommandArchive&
CreateHyperlinkCommandArchive::_Internal::super(const CreateHyperlinkCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
CreateHyperlinkCommandArchive::_Internal::storage(const CreateHyperlinkCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
CreateHyperlinkCommandArchive::_Internal::undo_transaction(const CreateHyperlinkCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void CreateHyperlinkCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CreateHyperlinkCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CreateHyperlinkCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CreateHyperlinkCommandArchive::CreateHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.CreateHyperlinkCommandArchive)
}
CreateHyperlinkCommandArchive::CreateHyperlinkCommandArchive(const CreateHyperlinkCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateHyperlinkCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_ref_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.url_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_ref()) {
    _this->_impl_.url_ref_.Set(from._internal_url_ref(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.CreateHyperlinkCommandArchive)
}

inline void CreateHyperlinkCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_ref_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
  _impl_.url_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateHyperlinkCommandArchive::~CreateHyperlinkCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.CreateHyperlinkCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateHyperlinkCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.url_ref_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void CreateHyperlinkCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateHyperlinkCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.CreateHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_ref_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateHyperlinkCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url_ref = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_url_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.CreateHyperlinkCommandArchive.url_ref");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateHyperlinkCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.CreateHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional string url_ref = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url_ref().data(), static_cast<int>(this->_internal_url_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.CreateHyperlinkCommandArchive.url_ref");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_url_ref(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.CreateHyperlinkCommandArchive)
  return target;
}

size_t CreateHyperlinkCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.CreateHyperlinkCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string url_ref = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url_ref());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateHyperlinkCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateHyperlinkCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateHyperlinkCommandArchive::GetClassData() const { return &_class_data_; }


void CreateHyperlinkCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateHyperlinkCommandArchive*>(&to_msg);
  auto& from = static_cast<const CreateHyperlinkCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.CreateHyperlinkCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url_ref(from._internal_url_ref());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateHyperlinkCommandArchive::CopyFrom(const CreateHyperlinkCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.CreateHyperlinkCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateHyperlinkCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void CreateHyperlinkCommandArchive::InternalSwap(CreateHyperlinkCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_ref_, lhs_arena,
      &other->_impl_.url_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CreateHyperlinkCommandArchive, _impl_.selection_range_length_)
      + sizeof(CreateHyperlinkCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(CreateHyperlinkCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateHyperlinkCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[14]);
}

// ===================================================================

class RemoveHyperlinkCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveHyperlinkCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveHyperlinkCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveHyperlinkCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveHyperlinkCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_remove_character_style(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::TSK::CommandArchive&
RemoveHyperlinkCommandArchive::_Internal::super(const RemoveHyperlinkCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveHyperlinkCommandArchive::_Internal::storage(const RemoveHyperlinkCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveHyperlinkCommandArchive::_Internal::undo_transaction(const RemoveHyperlinkCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveHyperlinkCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveHyperlinkCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveHyperlinkCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveHyperlinkCommandArchive::RemoveHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveHyperlinkCommandArchive)
}
RemoveHyperlinkCommandArchive::RemoveHyperlinkCommandArchive(const RemoveHyperlinkCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveHyperlinkCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}
    , decltype(_impl_.is_remove_character_style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_remove_character_style_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.is_remove_character_style_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveHyperlinkCommandArchive)
}

inline void RemoveHyperlinkCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
    , decltype(_impl_.is_remove_character_style_){true}
  };
}

RemoveHyperlinkCommandArchive::~RemoveHyperlinkCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveHyperlinkCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveHyperlinkCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveHyperlinkCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveHyperlinkCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
    _impl_.is_remove_character_style_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveHyperlinkCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_remove_character_style = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_remove_character_style(&has_bits);
          _impl_.is_remove_character_style_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveHyperlinkCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional bool is_remove_character_style = 6 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_remove_character_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveHyperlinkCommandArchive)
  return target;
}

size_t RemoveHyperlinkCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveHyperlinkCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

    // optional bool is_remove_character_style = 6 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveHyperlinkCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveHyperlinkCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveHyperlinkCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveHyperlinkCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveHyperlinkCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveHyperlinkCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveHyperlinkCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.is_remove_character_style_ = from._impl_.is_remove_character_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveHyperlinkCommandArchive::CopyFrom(const RemoveHyperlinkCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveHyperlinkCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveHyperlinkCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveHyperlinkCommandArchive::InternalSwap(RemoveHyperlinkCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveHyperlinkCommandArchive, _impl_.selection_range_length_)
      + sizeof(RemoveHyperlinkCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(RemoveHyperlinkCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
  swap(_impl_.is_remove_character_style_, other->_impl_.is_remove_character_style_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveHyperlinkCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[15]);
}

// ===================================================================

class ModifyHyperlinkCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyHyperlinkCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ModifyHyperlinkCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& hyperlink(const ModifyHyperlinkCommandArchive* msg);
  static void set_has_hyperlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_display_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ModifyHyperlinkCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSK::CommandArchive&
ModifyHyperlinkCommandArchive::_Internal::super(const ModifyHyperlinkCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyHyperlinkCommandArchive::_Internal::hyperlink(const ModifyHyperlinkCommandArchive* msg) {
  return *msg->_impl_.hyperlink_;
}
const ::TSWP::UndoTransaction&
ModifyHyperlinkCommandArchive::_Internal::undo_transaction(const ModifyHyperlinkCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ModifyHyperlinkCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ModifyHyperlinkCommandArchive::clear_hyperlink() {
  if (_impl_.hyperlink_ != nullptr) _impl_.hyperlink_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ModifyHyperlinkCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ModifyHyperlinkCommandArchive::ModifyHyperlinkCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyHyperlinkCommandArchive)
}
ModifyHyperlinkCommandArchive::ModifyHyperlinkCommandArchive(const ModifyHyperlinkCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyHyperlinkCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.display_text_){}
    , decltype(_impl_.url_ref_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.hyperlink_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.display_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_text()) {
    _this->_impl_.display_text_.Set(from._internal_display_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_ref()) {
    _this->_impl_.url_ref_.Set(from._internal_url_ref(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_hyperlink()) {
    _this->_impl_.hyperlink_ = new ::TSP::Reference(*from._impl_.hyperlink_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyHyperlinkCommandArchive)
}

inline void ModifyHyperlinkCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.display_text_){}
    , decltype(_impl_.url_ref_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.hyperlink_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
  _impl_.display_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_ref_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_ref_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModifyHyperlinkCommandArchive::~ModifyHyperlinkCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyHyperlinkCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyHyperlinkCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.display_text_.Destroy();
  _impl_.url_ref_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.hyperlink_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ModifyHyperlinkCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyHyperlinkCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.display_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_ref_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.hyperlink_ != nullptr);
      _impl_.hyperlink_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyHyperlinkCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference hyperlink = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hyperlink(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string display_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_display_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyHyperlinkCommandArchive.display_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url_ref = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_url_ref();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyHyperlinkCommandArchive.url_ref");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyHyperlinkCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyHyperlinkCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference hyperlink = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::hyperlink(this),
        _Internal::hyperlink(this).GetCachedSize(), target, stream);
  }

  // optional string display_text = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_display_text().data(), static_cast<int>(this->_internal_display_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyHyperlinkCommandArchive.display_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_display_text(), target);
  }

  // optional string url_ref = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url_ref().data(), static_cast<int>(this->_internal_url_ref().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyHyperlinkCommandArchive.url_ref");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_url_ref(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyHyperlinkCommandArchive)
  return target;
}

size_t ModifyHyperlinkCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyHyperlinkCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string display_text = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_text());
    }

    // optional string url_ref = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url_ref());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference hyperlink = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hyperlink_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyHyperlinkCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyHyperlinkCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyHyperlinkCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyHyperlinkCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyHyperlinkCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyHyperlinkCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyHyperlinkCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_display_text(from._internal_display_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url_ref(from._internal_url_ref());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_hyperlink()->::TSP::Reference::MergeFrom(
          from._internal_hyperlink());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyHyperlinkCommandArchive::CopyFrom(const ModifyHyperlinkCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyHyperlinkCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyHyperlinkCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_hyperlink()) {
    if (!_impl_.hyperlink_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ModifyHyperlinkCommandArchive::InternalSwap(ModifyHyperlinkCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_text_, lhs_arena,
      &other->_impl_.display_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_ref_, lhs_arena,
      &other->_impl_.url_ref_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyHyperlinkCommandArchive, _impl_.undo_transaction_)
      + sizeof(ModifyHyperlinkCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ModifyHyperlinkCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyHyperlinkCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[16]);
}

// ===================================================================

class UpdateDateTimeFieldCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateDateTimeFieldCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::TextCommandArchive& super(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& date_time_field(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_date_time_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Date& date(const UpdateDateTimeFieldCommandArchive* msg);
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_date_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_style(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSWP::TextCommandArchive&
UpdateDateTimeFieldCommandArchive::_Internal::super(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
UpdateDateTimeFieldCommandArchive::_Internal::date_time_field(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.date_time_field_;
}
const ::TSP::Date&
UpdateDateTimeFieldCommandArchive::_Internal::date(const UpdateDateTimeFieldCommandArchive* msg) {
  return *msg->_impl_.date_;
}
void UpdateDateTimeFieldCommandArchive::clear_date_time_field() {
  if (_impl_.date_time_field_ != nullptr) _impl_.date_time_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void UpdateDateTimeFieldCommandArchive::clear_date() {
  if (_impl_.date_ != nullptr) _impl_.date_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.UpdateDateTimeFieldCommandArchive)
}
UpdateDateTimeFieldCommandArchive::UpdateDateTimeFieldCommandArchive(const UpdateDateTimeFieldCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateDateTimeFieldCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.date_time_field_){nullptr}
    , decltype(_impl_.date_){nullptr}
    , decltype(_impl_.date_style_){}
    , decltype(_impl_.time_style_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::TextCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_date_time_field()) {
    _this->_impl_.date_time_field_ = new ::TSP::Reference(*from._impl_.date_time_field_);
  }
  if (from._internal_has_date()) {
    _this->_impl_.date_ = new ::TSP::Date(*from._impl_.date_);
  }
  ::memcpy(&_impl_.date_style_, &from._impl_.date_style_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_style_) -
    reinterpret_cast<char*>(&_impl_.date_style_)) + sizeof(_impl_.time_style_));
  // @@protoc_insertion_point(copy_constructor:TSWP.UpdateDateTimeFieldCommandArchive)
}

inline void UpdateDateTimeFieldCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.date_time_field_){nullptr}
    , decltype(_impl_.date_){nullptr}
    , decltype(_impl_.date_style_){0}
    , decltype(_impl_.time_style_){0}
  };
}

UpdateDateTimeFieldCommandArchive::~UpdateDateTimeFieldCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.UpdateDateTimeFieldCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateDateTimeFieldCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.date_time_field_;
  if (this != internal_default_instance()) delete _impl_.date_;
}

void UpdateDateTimeFieldCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateDateTimeFieldCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.UpdateDateTimeFieldCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.date_time_field_ != nullptr);
      _impl_.date_time_field_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.date_ != nullptr);
      _impl_.date_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.date_style_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_style_) -
        reinterpret_cast<char*>(&_impl_.date_style_)) + sizeof(_impl_.time_style_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateDateTimeFieldCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.TextCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference date_time_field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_date_time_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Date date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(val))) {
            _internal_set_date_style(static_cast<::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle_IsValid(val))) {
            _internal_set_time_style(static_cast<::TSWP::DateTimeSmartFieldArchive_DateTimeFormatterStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateDateTimeFieldCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.UpdateDateTimeFieldCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.TextCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference date_time_field = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::date_time_field(this),
        _Internal::date_time_field(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Date date = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::date(this),
        _Internal::date(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_date_style(), target);
  }

  // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_time_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.UpdateDateTimeFieldCommandArchive)
  return target;
}

size_t UpdateDateTimeFieldCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.UpdateDateTimeFieldCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSWP.TextCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference date_time_field = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_time_field_);
    }

    // optional .TSP.Date date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.date_);
    }

    // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_date_style());
    }

    // optional .TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_time_style());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateDateTimeFieldCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateDateTimeFieldCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateDateTimeFieldCommandArchive::GetClassData() const { return &_class_data_; }


void UpdateDateTimeFieldCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateDateTimeFieldCommandArchive*>(&to_msg);
  auto& from = static_cast<const UpdateDateTimeFieldCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.UpdateDateTimeFieldCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::TextCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_date_time_field()->::TSP::Reference::MergeFrom(
          from._internal_date_time_field());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_date()->::TSP::Date::MergeFrom(
          from._internal_date());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.date_style_ = from._impl_.date_style_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.time_style_ = from._impl_.time_style_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateDateTimeFieldCommandArchive::CopyFrom(const UpdateDateTimeFieldCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.UpdateDateTimeFieldCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateDateTimeFieldCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_date_time_field()) {
    if (!_impl_.date_time_field_->IsInitialized()) return false;
  }
  if (_internal_has_date()) {
    if (!_impl_.date_->IsInitialized()) return false;
  }
  return true;
}

void UpdateDateTimeFieldCommandArchive::InternalSwap(UpdateDateTimeFieldCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateDateTimeFieldCommandArchive, _impl_.time_style_)
      + sizeof(UpdateDateTimeFieldCommandArchive::_impl_.time_style_)
      - PROTOBUF_FIELD_OFFSET(UpdateDateTimeFieldCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateDateTimeFieldCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[17]);
}

// ===================================================================

class ApplyRubyTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyRubyTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ApplyRubyTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& storage(const ApplyRubyTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ruby_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ApplyRubyTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::TSK::CommandArchive&
ApplyRubyTextCommandArchive::_Internal::super(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ApplyRubyTextCommandArchive::_Internal::storage(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
ApplyRubyTextCommandArchive::_Internal::undo_transaction(const ApplyRubyTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ApplyRubyTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ApplyRubyTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ApplyRubyTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ApplyRubyTextCommandArchive)
}
ApplyRubyTextCommandArchive::ApplyRubyTextCommandArchive(const ApplyRubyTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ApplyRubyTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ruby_text()) {
    _this->_impl_.ruby_text_.Set(from._internal_ruby_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.ApplyRubyTextCommandArchive)
}

inline void ApplyRubyTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ApplyRubyTextCommandArchive::~ApplyRubyTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ApplyRubyTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ApplyRubyTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ruby_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ApplyRubyTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ApplyRubyTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ApplyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ruby_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyRubyTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ruby_text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ruby_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ApplyRubyTextCommandArchive.ruby_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ApplyRubyTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ApplyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional string ruby_text = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ruby_text().data(), static_cast<int>(this->_internal_ruby_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ApplyRubyTextCommandArchive.ruby_text");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ruby_text(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ApplyRubyTextCommandArchive)
  return target;
}

size_t ApplyRubyTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ApplyRubyTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string ruby_text = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ruby_text());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyRubyTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ApplyRubyTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyRubyTextCommandArchive::GetClassData() const { return &_class_data_; }


void ApplyRubyTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ApplyRubyTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ApplyRubyTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ApplyRubyTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ruby_text(from._internal_ruby_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyRubyTextCommandArchive::CopyFrom(const ApplyRubyTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ApplyRubyTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyRubyTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ApplyRubyTextCommandArchive::InternalSwap(ApplyRubyTextCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ruby_text_, lhs_arena,
      &other->_impl_.ruby_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyRubyTextCommandArchive, _impl_.selection_range_length_)
      + sizeof(ApplyRubyTextCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(ApplyRubyTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyRubyTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[18]);
}

// ===================================================================

class RemoveRubyTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveRubyTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const RemoveRubyTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const RemoveRubyTextCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selection_range_location(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selection_range_length(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const RemoveRubyTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
RemoveRubyTextCommandArchive::_Internal::super(const RemoveRubyTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
RemoveRubyTextCommandArchive::_Internal::storage(const RemoveRubyTextCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
RemoveRubyTextCommandArchive::_Internal::undo_transaction(const RemoveRubyTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void RemoveRubyTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RemoveRubyTextCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RemoveRubyTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RemoveRubyTextCommandArchive::RemoveRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.RemoveRubyTextCommandArchive)
}
RemoveRubyTextCommandArchive::RemoveRubyTextCommandArchive(const RemoveRubyTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoveRubyTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){}
    , decltype(_impl_.selection_range_length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.selection_range_location_, &from._impl_.selection_range_location_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.selection_range_length_) -
    reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  // @@protoc_insertion_point(copy_constructor:TSWP.RemoveRubyTextCommandArchive)
}

inline void RemoveRubyTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.selection_range_location_){0u}
    , decltype(_impl_.selection_range_length_){0u}
  };
}

RemoveRubyTextCommandArchive::~RemoveRubyTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.RemoveRubyTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoveRubyTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void RemoveRubyTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoveRubyTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.RemoveRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.selection_range_location_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.selection_range_length_) -
        reinterpret_cast<char*>(&_impl_.selection_range_location_)) + sizeof(_impl_.selection_range_length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveRubyTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_selection_range_location(&has_bits);
          _impl_.selection_range_location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selection_range_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_selection_range_length(&has_bits);
          _impl_.selection_range_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoveRubyTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.RemoveRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 selection_range_location = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_selection_range_location(), target);
  }

  // optional uint32 selection_range_length = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_selection_range_length(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.RemoveRubyTextCommandArchive)
  return target;
}

size_t RemoveRubyTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.RemoveRubyTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 selection_range_location = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_location());
    }

    // optional uint32 selection_range_length = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_selection_range_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveRubyTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoveRubyTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveRubyTextCommandArchive::GetClassData() const { return &_class_data_; }


void RemoveRubyTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoveRubyTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const RemoveRubyTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.RemoveRubyTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.selection_range_location_ = from._impl_.selection_range_location_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.selection_range_length_ = from._impl_.selection_range_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveRubyTextCommandArchive::CopyFrom(const RemoveRubyTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.RemoveRubyTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveRubyTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void RemoveRubyTextCommandArchive::InternalSwap(RemoveRubyTextCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveRubyTextCommandArchive, _impl_.selection_range_length_)
      + sizeof(RemoveRubyTextCommandArchive::_impl_.selection_range_length_)
      - PROTOBUF_FIELD_OFFSET(RemoveRubyTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveRubyTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[19]);
}

// ===================================================================

class ModifyRubyTextCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyRubyTextCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ModifyRubyTextCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& ruby_field(const ModifyRubyTextCommandArchive* msg);
  static void set_has_ruby_field(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ruby_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_base_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const ModifyRubyTextCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::TSK::CommandArchive&
ModifyRubyTextCommandArchive::_Internal::super(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyRubyTextCommandArchive::_Internal::ruby_field(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.ruby_field_;
}
const ::TSWP::UndoTransaction&
ModifyRubyTextCommandArchive::_Internal::undo_transaction(const ModifyRubyTextCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void ModifyRubyTextCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ModifyRubyTextCommandArchive::clear_ruby_field() {
  if (_impl_.ruby_field_ != nullptr) _impl_.ruby_field_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void ModifyRubyTextCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyRubyTextCommandArchive)
}
ModifyRubyTextCommandArchive::ModifyRubyTextCommandArchive(const ModifyRubyTextCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyRubyTextCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.base_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.ruby_field_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ruby_text()) {
    _this->_impl_.ruby_text_.Set(from._internal_ruby_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.base_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_base_text()) {
    _this->_impl_.base_text_.Set(from._internal_base_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_ruby_field()) {
    _this->_impl_.ruby_field_ = new ::TSP::Reference(*from._impl_.ruby_field_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyRubyTextCommandArchive)
}

inline void ModifyRubyTextCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ruby_text_){}
    , decltype(_impl_.base_text_){}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.ruby_field_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
  _impl_.ruby_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ruby_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.base_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModifyRubyTextCommandArchive::~ModifyRubyTextCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyRubyTextCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyRubyTextCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ruby_text_.Destroy();
  _impl_.base_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.ruby_field_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void ModifyRubyTextCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyRubyTextCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ruby_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.base_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.ruby_field_ != nullptr);
      _impl_.ruby_field_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyRubyTextCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference ruby_field = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ruby_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ruby_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ruby_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyRubyTextCommandArchive.ruby_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string base_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_base_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.ModifyRubyTextCommandArchive.base_text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyRubyTextCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyRubyTextCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference ruby_field = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ruby_field(this),
        _Internal::ruby_field(this).GetCachedSize(), target, stream);
  }

  // optional string ruby_text = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ruby_text().data(), static_cast<int>(this->_internal_ruby_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyRubyTextCommandArchive.ruby_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ruby_text(), target);
  }

  // optional string base_text = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_base_text().data(), static_cast<int>(this->_internal_base_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.ModifyRubyTextCommandArchive.base_text");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_base_text(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyRubyTextCommandArchive)
  return target;
}

size_t ModifyRubyTextCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyRubyTextCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ruby_text = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ruby_text());
    }

    // optional string base_text = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_base_text());
    }

    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference ruby_field = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ruby_field_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyRubyTextCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyRubyTextCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyRubyTextCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyRubyTextCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyRubyTextCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyRubyTextCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyRubyTextCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ruby_text(from._internal_ruby_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_base_text(from._internal_base_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_ruby_field()->::TSP::Reference::MergeFrom(
          from._internal_ruby_field());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyRubyTextCommandArchive::CopyFrom(const ModifyRubyTextCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyRubyTextCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyRubyTextCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_ruby_field()) {
    if (!_impl_.ruby_field_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void ModifyRubyTextCommandArchive::InternalSwap(ModifyRubyTextCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ruby_text_, lhs_arena,
      &other->_impl_.ruby_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.base_text_, lhs_arena,
      &other->_impl_.base_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyRubyTextCommandArchive, _impl_.undo_transaction_)
      + sizeof(ModifyRubyTextCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(ModifyRubyTextCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyRubyTextCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[20]);
}

// ===================================================================

class ModifyTOCSettingsBaseCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsBaseCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& old_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_old_toc_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& new_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg);
  static void set_has_new_toc_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
ModifyTOCSettingsBaseCommandArchive::_Internal::super(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyTOCSettingsBaseCommandArchive::_Internal::old_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.old_toc_settings_;
}
const ::TSP::Reference&
ModifyTOCSettingsBaseCommandArchive::_Internal::new_toc_settings(const ModifyTOCSettingsBaseCommandArchive* msg) {
  return *msg->_impl_.new_toc_settings_;
}
void ModifyTOCSettingsBaseCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ModifyTOCSettingsBaseCommandArchive::clear_old_toc_settings() {
  if (_impl_.old_toc_settings_ != nullptr) _impl_.old_toc_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ModifyTOCSettingsBaseCommandArchive::clear_new_toc_settings() {
  if (_impl_.new_toc_settings_ != nullptr) _impl_.new_toc_settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
}
ModifyTOCSettingsBaseCommandArchive::ModifyTOCSettingsBaseCommandArchive(const ModifyTOCSettingsBaseCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsBaseCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_toc_settings_){nullptr}
    , decltype(_impl_.new_toc_settings_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_old_toc_settings()) {
    _this->_impl_.old_toc_settings_ = new ::TSP::Reference(*from._impl_.old_toc_settings_);
  }
  if (from._internal_has_new_toc_settings()) {
    _this->_impl_.new_toc_settings_ = new ::TSP::Reference(*from._impl_.new_toc_settings_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
}

inline void ModifyTOCSettingsBaseCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_toc_settings_){nullptr}
    , decltype(_impl_.new_toc_settings_){nullptr}
  };
}

ModifyTOCSettingsBaseCommandArchive::~ModifyTOCSettingsBaseCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsBaseCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsBaseCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.old_toc_settings_;
  if (this != internal_default_instance()) delete _impl_.new_toc_settings_;
}

void ModifyTOCSettingsBaseCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsBaseCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.old_toc_settings_ != nullptr);
      _impl_.old_toc_settings_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.new_toc_settings_ != nullptr);
      _impl_.new_toc_settings_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsBaseCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference old_toc_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_old_toc_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference new_toc_settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_toc_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsBaseCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference old_toc_settings = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::old_toc_settings(this),
        _Internal::old_toc_settings(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference new_toc_settings = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::new_toc_settings(this),
        _Internal::new_toc_settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsBaseCommandArchive)
  return target;
}

size_t ModifyTOCSettingsBaseCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference old_toc_settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.old_toc_settings_);
    }

    // optional .TSP.Reference new_toc_settings = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.new_toc_settings_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsBaseCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsBaseCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsBaseCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsBaseCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsBaseCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsBaseCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_old_toc_settings()->::TSP::Reference::MergeFrom(
          from._internal_old_toc_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_new_toc_settings()->::TSP::Reference::MergeFrom(
          from._internal_new_toc_settings());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsBaseCommandArchive::CopyFrom(const ModifyTOCSettingsBaseCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsBaseCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsBaseCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_old_toc_settings()) {
    if (!_impl_.old_toc_settings_->IsInitialized()) return false;
  }
  if (_internal_has_new_toc_settings()) {
    if (!_impl_.new_toc_settings_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsBaseCommandArchive::InternalSwap(ModifyTOCSettingsBaseCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsBaseCommandArchive, _impl_.new_toc_settings_)
      + sizeof(ModifyTOCSettingsBaseCommandArchive::_impl_.new_toc_settings_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsBaseCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsBaseCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[21]);
}

// ===================================================================

class ModifyTOCSettingsForTOCInfoCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsForTOCInfoCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super(const ModifyTOCSettingsForTOCInfoCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& toc_info(const ModifyTOCSettingsForTOCInfoCommandArchive* msg);
  static void set_has_toc_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::ModifyTOCSettingsBaseCommandArchive&
ModifyTOCSettingsForTOCInfoCommandArchive::_Internal::super(const ModifyTOCSettingsForTOCInfoCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyTOCSettingsForTOCInfoCommandArchive::_Internal::toc_info(const ModifyTOCSettingsForTOCInfoCommandArchive* msg) {
  return *msg->_impl_.toc_info_;
}
void ModifyTOCSettingsForTOCInfoCommandArchive::clear_toc_info() {
  if (_impl_.toc_info_ != nullptr) _impl_.toc_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
}
ModifyTOCSettingsForTOCInfoCommandArchive::ModifyTOCSettingsForTOCInfoCommandArchive(const ModifyTOCSettingsForTOCInfoCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsForTOCInfoCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.toc_info_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_toc_info()) {
    _this->_impl_.toc_info_ = new ::TSP::Reference(*from._impl_.toc_info_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
}

inline void ModifyTOCSettingsForTOCInfoCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.toc_info_){nullptr}
  };
}

ModifyTOCSettingsForTOCInfoCommandArchive::~ModifyTOCSettingsForTOCInfoCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsForTOCInfoCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.toc_info_;
}

void ModifyTOCSettingsForTOCInfoCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsForTOCInfoCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.toc_info_ != nullptr);
      _impl_.toc_info_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsForTOCInfoCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference toc_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_toc_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsForTOCInfoCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference toc_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::toc_info(this),
        _Internal::toc_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  return target;
}

size_t ModifyTOCSettingsForTOCInfoCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference toc_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.toc_info_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsForTOCInfoCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsForTOCInfoCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsForTOCInfoCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsForTOCInfoCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsForTOCInfoCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsForTOCInfoCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::ModifyTOCSettingsBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_toc_info()->::TSP::Reference::MergeFrom(
          from._internal_toc_info());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsForTOCInfoCommandArchive::CopyFrom(const ModifyTOCSettingsForTOCInfoCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsForTOCInfoCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsForTOCInfoCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_toc_info()) {
    if (!_impl_.toc_info_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsForTOCInfoCommandArchive::InternalSwap(ModifyTOCSettingsForTOCInfoCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.toc_info_)
      + sizeof(ModifyTOCSettingsForTOCInfoCommandArchive::_impl_.toc_info_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsForTOCInfoCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsForTOCInfoCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[22]);
}

// ===================================================================

class ModifyTOCSettingsPresetForThemeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ModifyTOCSettingsPresetForThemeCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::ModifyTOCSettingsBaseCommandArchive& super(const ModifyTOCSettingsPresetForThemeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const ModifyTOCSettingsPresetForThemeCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::ModifyTOCSettingsBaseCommandArchive&
ModifyTOCSettingsPresetForThemeCommandArchive::_Internal::super(const ModifyTOCSettingsPresetForThemeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ModifyTOCSettingsPresetForThemeCommandArchive::_Internal::theme(const ModifyTOCSettingsPresetForThemeCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
void ModifyTOCSettingsPresetForThemeCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
}
ModifyTOCSettingsPresetForThemeCommandArchive::ModifyTOCSettingsPresetForThemeCommandArchive(const ModifyTOCSettingsPresetForThemeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ModifyTOCSettingsPresetForThemeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::ModifyTOCSettingsBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
}

inline void ModifyTOCSettingsPresetForThemeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.preset_index_){0u}
  };
}

ModifyTOCSettingsPresetForThemeCommandArchive::~ModifyTOCSettingsPresetForThemeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModifyTOCSettingsPresetForThemeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
}

void ModifyTOCSettingsPresetForThemeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ModifyTOCSettingsPresetForThemeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
  }
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModifyTOCSettingsPresetForThemeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preset_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModifyTOCSettingsPresetForThemeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // optional uint32 preset_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  return target;
}

size_t ModifyTOCSettingsPresetForThemeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.ModifyTOCSettingsBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference theme = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.theme_);
    }

    // optional uint32 preset_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModifyTOCSettingsPresetForThemeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ModifyTOCSettingsPresetForThemeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModifyTOCSettingsPresetForThemeCommandArchive::GetClassData() const { return &_class_data_; }


void ModifyTOCSettingsPresetForThemeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ModifyTOCSettingsPresetForThemeCommandArchive*>(&to_msg);
  auto& from = static_cast<const ModifyTOCSettingsPresetForThemeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::ModifyTOCSettingsBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModifyTOCSettingsPresetForThemeCommandArchive::CopyFrom(const ModifyTOCSettingsPresetForThemeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ModifyTOCSettingsPresetForThemeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModifyTOCSettingsPresetForThemeCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  return true;
}

void ModifyTOCSettingsPresetForThemeCommandArchive::InternalSwap(ModifyTOCSettingsPresetForThemeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.preset_index_)
      + sizeof(ModifyTOCSettingsPresetForThemeCommandArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(ModifyTOCSettingsPresetForThemeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ModifyTOCSettingsPresetForThemeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[23]);
}

// ===================================================================

class AnchorAttachmentCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<AnchorAttachmentCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const AnchorAttachmentCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const AnchorAttachmentCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& attachment(const AnchorAttachmentCommandArchive* msg);
  static void set_has_attachment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_h_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_h_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_v_offset_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_v_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const AnchorAttachmentCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_html_wrap(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::TSK::CommandArchive&
AnchorAttachmentCommandArchive::_Internal::super(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
AnchorAttachmentCommandArchive::_Internal::storage(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSP::Reference&
AnchorAttachmentCommandArchive::_Internal::attachment(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.attachment_;
}
const ::TSWP::UndoTransaction&
AnchorAttachmentCommandArchive::_Internal::undo_transaction(const AnchorAttachmentCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void AnchorAttachmentCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void AnchorAttachmentCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void AnchorAttachmentCommandArchive::clear_attachment() {
  if (_impl_.attachment_ != nullptr) _impl_.attachment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void AnchorAttachmentCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.AnchorAttachmentCommandArchive)
}
AnchorAttachmentCommandArchive::AnchorAttachmentCommandArchive(const AnchorAttachmentCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AnchorAttachmentCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.h_offset_type_){}
    , decltype(_impl_.h_offset_){}
    , decltype(_impl_.v_offset_type_){}
    , decltype(_impl_.v_offset_){}
    , decltype(_impl_.is_html_wrap_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_attachment()) {
    _this->_impl_.attachment_ = new ::TSP::Reference(*from._impl_.attachment_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.h_offset_type_, &from._impl_.h_offset_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_html_wrap_) -
    reinterpret_cast<char*>(&_impl_.h_offset_type_)) + sizeof(_impl_.is_html_wrap_));
  // @@protoc_insertion_point(copy_constructor:TSWP.AnchorAttachmentCommandArchive)
}

inline void AnchorAttachmentCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.attachment_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.h_offset_type_){0u}
    , decltype(_impl_.h_offset_){0}
    , decltype(_impl_.v_offset_type_){0u}
    , decltype(_impl_.v_offset_){0}
    , decltype(_impl_.is_html_wrap_){false}
  };
}

AnchorAttachmentCommandArchive::~AnchorAttachmentCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.AnchorAttachmentCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AnchorAttachmentCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.attachment_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void AnchorAttachmentCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AnchorAttachmentCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.AnchorAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.attachment_ != nullptr);
      _impl_.attachment_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.h_offset_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.v_offset_) -
        reinterpret_cast<char*>(&_impl_.h_offset_type_)) + sizeof(_impl_.v_offset_));
  }
  _impl_.is_html_wrap_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnchorAttachmentCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference attachment = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 h_offset_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_h_offset_type(&has_bits);
          _impl_.h_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float h_offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_h_offset(&has_bits);
          _impl_.h_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 v_offset_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_v_offset_type(&has_bits);
          _impl_.v_offset_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float v_offset = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_v_offset(&has_bits);
          _impl_.v_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_html_wrap = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_html_wrap(&has_bits);
          _impl_.is_html_wrap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AnchorAttachmentCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.AnchorAttachmentCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference attachment = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::attachment(this),
        _Internal::attachment(this).GetCachedSize(), target, stream);
  }

  // optional uint32 h_offset_type = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_h_offset_type(), target);
  }

  // optional float h_offset = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_h_offset(), target);
  }

  // optional uint32 v_offset_type = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_v_offset_type(), target);
  }

  // optional float v_offset = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_v_offset(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  // optional bool is_html_wrap = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_html_wrap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.AnchorAttachmentCommandArchive)
  return target;
}

size_t AnchorAttachmentCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.AnchorAttachmentCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSP.Reference attachment = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachment_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 h_offset_type = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_h_offset_type());
    }

    // optional float h_offset = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 v_offset_type = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_v_offset_type());
    }

    // optional float v_offset = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional bool is_html_wrap = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnchorAttachmentCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AnchorAttachmentCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnchorAttachmentCommandArchive::GetClassData() const { return &_class_data_; }


void AnchorAttachmentCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AnchorAttachmentCommandArchive*>(&to_msg);
  auto& from = static_cast<const AnchorAttachmentCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.AnchorAttachmentCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_attachment()->::TSP::Reference::MergeFrom(
          from._internal_attachment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.h_offset_type_ = from._impl_.h_offset_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.h_offset_ = from._impl_.h_offset_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.v_offset_type_ = from._impl_.v_offset_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.v_offset_ = from._impl_.v_offset_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_is_html_wrap(from._internal_is_html_wrap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnchorAttachmentCommandArchive::CopyFrom(const AnchorAttachmentCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.AnchorAttachmentCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnchorAttachmentCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_attachment()) {
    if (!_impl_.attachment_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void AnchorAttachmentCommandArchive::InternalSwap(AnchorAttachmentCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnchorAttachmentCommandArchive, _impl_.is_html_wrap_)
      + sizeof(AnchorAttachmentCommandArchive::_impl_.is_html_wrap_)
      - PROTOBUF_FIELD_OFFSET(AnchorAttachmentCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnchorAttachmentCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[24]);
}

// ===================================================================

class TextApplyThemeCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<TextApplyThemeCommandArchive>()._impl_._has_bits_);
  static const ::TSS::ApplyThemeChildCommandArchive& super(const TextApplyThemeCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const TextApplyThemeCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const TextApplyThemeCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSS::ApplyThemeChildCommandArchive&
TextApplyThemeCommandArchive::_Internal::super(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
TextApplyThemeCommandArchive::_Internal::storage(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
TextApplyThemeCommandArchive::_Internal::undo_transaction(const TextApplyThemeCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void TextApplyThemeCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TextApplyThemeCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void TextApplyThemeCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.TextApplyThemeCommandArchive)
}
TextApplyThemeCommandArchive::TextApplyThemeCommandArchive(const TextApplyThemeCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TextApplyThemeCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::ApplyThemeChildCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.TextApplyThemeCommandArchive)
}

inline void TextApplyThemeCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
  };
}

TextApplyThemeCommandArchive::~TextApplyThemeCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.TextApplyThemeCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextApplyThemeCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void TextApplyThemeCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TextApplyThemeCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.TextApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TextApplyThemeCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSS.ApplyThemeChildCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextApplyThemeCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.TextApplyThemeCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSS.ApplyThemeChildCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.TextApplyThemeCommandArchive)
  return target;
}

size_t TextApplyThemeCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.TextApplyThemeCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSS.ApplyThemeChildCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TextApplyThemeCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TextApplyThemeCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TextApplyThemeCommandArchive::GetClassData() const { return &_class_data_; }


void TextApplyThemeCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TextApplyThemeCommandArchive*>(&to_msg);
  auto& from = static_cast<const TextApplyThemeCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.TextApplyThemeCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSS::ApplyThemeChildCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TextApplyThemeCommandArchive::CopyFrom(const TextApplyThemeCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.TextApplyThemeCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextApplyThemeCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void TextApplyThemeCommandArchive::InternalSwap(TextApplyThemeCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextApplyThemeCommandArchive, _impl_.undo_transaction_)
      + sizeof(TextApplyThemeCommandArchive::_impl_.undo_transaction_)
      - PROTOBUF_FIELD_OFFSET(TextApplyThemeCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TextApplyThemeCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[25]);
}

// ===================================================================

class MoveColumnsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveColumnsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveColumnsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MoveColumnsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dst_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveColumnsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MoveColumnsCommandArchive::_Internal::super(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveColumnsCommandArchive::_Internal::storage(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MoveColumnsCommandArchive::_Internal::undo_transaction(const MoveColumnsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveColumnsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveColumnsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveColumnsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveColumnsCommandArchive::MoveColumnsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MoveColumnsCommandArchive)
}
MoveColumnsCommandArchive::MoveColumnsCommandArchive(const MoveColumnsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveColumnsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){}
    , decltype(_impl_.dst_index_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.src_index_, &from._impl_.src_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MoveColumnsCommandArchive)
}

inline void MoveColumnsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){0u}
    , decltype(_impl_.dst_index_){0u}
    , decltype(_impl_.count_){0u}
  };
}

MoveColumnsCommandArchive::~MoveColumnsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MoveColumnsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveColumnsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveColumnsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveColumnsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.src_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveColumnsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_src_index(&has_bits);
          _impl_.src_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dst_index(&has_bits);
          _impl_.dst_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveColumnsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MoveColumnsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_src_index(), target);
  }

  // optional uint32 dst_index = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dst_index(), target);
  }

  // optional uint32 count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MoveColumnsCommandArchive)
  return target;
}

size_t MoveColumnsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MoveColumnsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 src_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_index());
    }

    // optional uint32 dst_index = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_index());
    }

    // optional uint32 count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveColumnsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveColumnsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveColumnsCommandArchive::GetClassData() const { return &_class_data_; }


void MoveColumnsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveColumnsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveColumnsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MoveColumnsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.src_index_ = from._impl_.src_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dst_index_ = from._impl_.dst_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveColumnsCommandArchive::CopyFrom(const MoveColumnsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MoveColumnsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveColumnsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveColumnsCommandArchive::InternalSwap(MoveColumnsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveColumnsCommandArchive, _impl_.count_)
      + sizeof(MoveColumnsCommandArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(MoveColumnsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveColumnsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[26]);
}

// ===================================================================

class MoveRowsCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<MoveRowsCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const MoveRowsCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& storage(const MoveRowsCommandArchive* msg);
  static void set_has_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_src_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dst_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::TSWP::UndoTransaction& undo_transaction(const MoveRowsCommandArchive* msg);
  static void set_has_undo_transaction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
MoveRowsCommandArchive::_Internal::super(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
MoveRowsCommandArchive::_Internal::storage(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.storage_;
}
const ::TSWP::UndoTransaction&
MoveRowsCommandArchive::_Internal::undo_transaction(const MoveRowsCommandArchive* msg) {
  return *msg->_impl_.undo_transaction_;
}
void MoveRowsCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MoveRowsCommandArchive::clear_storage() {
  if (_impl_.storage_ != nullptr) _impl_.storage_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MoveRowsCommandArchive::clear_undo_transaction() {
  if (_impl_.undo_transaction_ != nullptr) _impl_.undo_transaction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
MoveRowsCommandArchive::MoveRowsCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.MoveRowsCommandArchive)
}
MoveRowsCommandArchive::MoveRowsCommandArchive(const MoveRowsCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveRowsCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){}
    , decltype(_impl_.dst_index_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_storage()) {
    _this->_impl_.storage_ = new ::TSP::Reference(*from._impl_.storage_);
  }
  if (from._internal_has_undo_transaction()) {
    _this->_impl_.undo_transaction_ = new ::TSWP::UndoTransaction(*from._impl_.undo_transaction_);
  }
  ::memcpy(&_impl_.src_index_, &from._impl_.src_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:TSWP.MoveRowsCommandArchive)
}

inline void MoveRowsCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.storage_){nullptr}
    , decltype(_impl_.undo_transaction_){nullptr}
    , decltype(_impl_.src_index_){0u}
    , decltype(_impl_.dst_index_){0u}
    , decltype(_impl_.count_){0u}
  };
}

MoveRowsCommandArchive::~MoveRowsCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.MoveRowsCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveRowsCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.storage_;
  if (this != internal_default_instance()) delete _impl_.undo_transaction_;
}

void MoveRowsCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveRowsCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.MoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.storage_ != nullptr);
      _impl_.storage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.undo_transaction_ != nullptr);
      _impl_.undo_transaction_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.src_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.src_index_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveRowsCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference storage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 src_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_src_index(&has_bits);
          _impl_.src_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dst_index(&has_bits);
          _impl_.dst_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSWP.UndoTransaction undo_transaction = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_undo_transaction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveRowsCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.MoveRowsCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference storage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::storage(this),
        _Internal::storage(this).GetCachedSize(), target, stream);
  }

  // optional uint32 src_index = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_src_index(), target);
  }

  // optional uint32 dst_index = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_dst_index(), target);
  }

  // optional uint32 count = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count(), target);
  }

  // optional .TSWP.UndoTransaction undo_transaction = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::undo_transaction(this),
        _Internal::undo_transaction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.MoveRowsCommandArchive)
  return target;
}

size_t MoveRowsCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.MoveRowsCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference storage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.storage_);
    }

    // optional .TSWP.UndoTransaction undo_transaction = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.undo_transaction_);
    }

    // optional uint32 src_index = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_src_index());
    }

    // optional uint32 dst_index = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_index());
    }

    // optional uint32 count = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveRowsCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveRowsCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveRowsCommandArchive::GetClassData() const { return &_class_data_; }


void MoveRowsCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveRowsCommandArchive*>(&to_msg);
  auto& from = static_cast<const MoveRowsCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.MoveRowsCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_storage()->::TSP::Reference::MergeFrom(
          from._internal_storage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_undo_transaction()->::TSWP::UndoTransaction::MergeFrom(
          from._internal_undo_transaction());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.src_index_ = from._impl_.src_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.dst_index_ = from._impl_.dst_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveRowsCommandArchive::CopyFrom(const MoveRowsCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.MoveRowsCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveRowsCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_storage()) {
    if (!_impl_.storage_->IsInitialized()) return false;
  }
  if (_internal_has_undo_transaction()) {
    if (!_impl_.undo_transaction_->IsInitialized()) return false;
  }
  return true;
}

void MoveRowsCommandArchive::InternalSwap(MoveRowsCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveRowsCommandArchive, _impl_.count_)
      + sizeof(MoveRowsCommandArchive::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(MoveRowsCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveRowsCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[27]);
}

// ===================================================================

class ShapeApplyPresetCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeApplyPresetCommandArchive>()._impl_._has_bits_);
  static const ::TSD::ShapeApplyPresetCommandArchive& super(const ShapeApplyPresetCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::ShapeApplyPresetCommandArchive&
ShapeApplyPresetCommandArchive::_Internal::super(const ShapeApplyPresetCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void ShapeApplyPresetCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapeApplyPresetCommandArchive)
}
ShapeApplyPresetCommandArchive::ShapeApplyPresetCommandArchive(const ShapeApplyPresetCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapeApplyPresetCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::ShapeApplyPresetCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapeApplyPresetCommandArchive)
}

inline void ShapeApplyPresetCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

ShapeApplyPresetCommandArchive::~ShapeApplyPresetCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ShapeApplyPresetCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeApplyPresetCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void ShapeApplyPresetCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapeApplyPresetCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapeApplyPresetCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.ShapeApplyPresetCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeApplyPresetCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapeApplyPresetCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.ShapeApplyPresetCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapeApplyPresetCommandArchive)
  return target;
}

size_t ShapeApplyPresetCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapeApplyPresetCommandArchive)
  size_t total_size = 0;

  // required .TSD.ShapeApplyPresetCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapeApplyPresetCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapeApplyPresetCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapeApplyPresetCommandArchive::GetClassData() const { return &_class_data_; }


void ShapeApplyPresetCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapeApplyPresetCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapeApplyPresetCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapeApplyPresetCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSD::ShapeApplyPresetCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapeApplyPresetCommandArchive::CopyFrom(const ShapeApplyPresetCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapeApplyPresetCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeApplyPresetCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void ShapeApplyPresetCommandArchive::InternalSwap(ShapeApplyPresetCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapeApplyPresetCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[28]);
}

// ===================================================================

class ShapePasteStyleCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapePasteStyleCommandArchive>()._impl_._has_bits_);
  static const ::TSD::PasteStyleCommandArchive& super(const ShapePasteStyleCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& paragraph_style(const ShapePasteStyleCommandArchive* msg);
  static void set_has_paragraph_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& list_style(const ShapePasteStyleCommandArchive* msg);
  static void set_has_list_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::TSP::Reference& character_style(const ShapePasteStyleCommandArchive* msg);
  static void set_has_character_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSD::PasteStyleCommandArchive&
ShapePasteStyleCommandArchive::_Internal::super(const ShapePasteStyleCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
ShapePasteStyleCommandArchive::_Internal::paragraph_style(const ShapePasteStyleCommandArchive* msg) {
  return *msg->_impl_.paragraph_style_;
}
const ::TSP::Reference&
ShapePasteStyleCommandArchive::_Internal::list_style(const ShapePasteStyleCommandArchive* msg) {
  return *msg->_impl_.list_style_;
}
const ::TSP::Reference&
ShapePasteStyleCommandArchive::_Internal::character_style(const ShapePasteStyleCommandArchive* msg) {
  return *msg->_impl_.character_style_;
}
void ShapePasteStyleCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void ShapePasteStyleCommandArchive::clear_paragraph_style() {
  if (_impl_.paragraph_style_ != nullptr) _impl_.paragraph_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void ShapePasteStyleCommandArchive::clear_list_style() {
  if (_impl_.list_style_ != nullptr) _impl_.list_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void ShapePasteStyleCommandArchive::clear_character_style() {
  if (_impl_.character_style_ != nullptr) _impl_.character_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
ShapePasteStyleCommandArchive::ShapePasteStyleCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.ShapePasteStyleCommandArchive)
}
ShapePasteStyleCommandArchive::ShapePasteStyleCommandArchive(const ShapePasteStyleCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShapePasteStyleCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.paragraph_style_){nullptr}
    , decltype(_impl_.list_style_){nullptr}
    , decltype(_impl_.character_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSD::PasteStyleCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_paragraph_style()) {
    _this->_impl_.paragraph_style_ = new ::TSP::Reference(*from._impl_.paragraph_style_);
  }
  if (from._internal_has_list_style()) {
    _this->_impl_.list_style_ = new ::TSP::Reference(*from._impl_.list_style_);
  }
  if (from._internal_has_character_style()) {
    _this->_impl_.character_style_ = new ::TSP::Reference(*from._impl_.character_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.ShapePasteStyleCommandArchive)
}

inline void ShapePasteStyleCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.paragraph_style_){nullptr}
    , decltype(_impl_.list_style_){nullptr}
    , decltype(_impl_.character_style_){nullptr}
  };
}

ShapePasteStyleCommandArchive::~ShapePasteStyleCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.ShapePasteStyleCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapePasteStyleCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.paragraph_style_;
  if (this != internal_default_instance()) delete _impl_.list_style_;
  if (this != internal_default_instance()) delete _impl_.character_style_;
}

void ShapePasteStyleCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShapePasteStyleCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.ShapePasteStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.paragraph_style_ != nullptr);
      _impl_.paragraph_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.list_style_ != nullptr);
      _impl_.list_style_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.character_style_ != nullptr);
      _impl_.character_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShapePasteStyleCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSD.PasteStyleCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference paragraph_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_paragraph_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference list_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_list_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference character_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_character_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapePasteStyleCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.ShapePasteStyleCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSD.PasteStyleCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference paragraph_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::paragraph_style(this),
        _Internal::paragraph_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference list_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::list_style(this),
        _Internal::list_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference character_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::character_style(this),
        _Internal::character_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.ShapePasteStyleCommandArchive)
  return target;
}

size_t ShapePasteStyleCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.ShapePasteStyleCommandArchive)
  size_t total_size = 0;

  // required .TSD.PasteStyleCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .TSP.Reference paragraph_style = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.paragraph_style_);
    }

    // optional .TSP.Reference list_style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.list_style_);
    }

    // optional .TSP.Reference character_style = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.character_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShapePasteStyleCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShapePasteStyleCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShapePasteStyleCommandArchive::GetClassData() const { return &_class_data_; }


void ShapePasteStyleCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShapePasteStyleCommandArchive*>(&to_msg);
  auto& from = static_cast<const ShapePasteStyleCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.ShapePasteStyleCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSD::PasteStyleCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_paragraph_style()->::TSP::Reference::MergeFrom(
          from._internal_paragraph_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_list_style()->::TSP::Reference::MergeFrom(
          from._internal_list_style());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_character_style()->::TSP::Reference::MergeFrom(
          from._internal_character_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShapePasteStyleCommandArchive::CopyFrom(const ShapePasteStyleCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.ShapePasteStyleCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapePasteStyleCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_paragraph_style()) {
    if (!_impl_.paragraph_style_->IsInitialized()) return false;
  }
  if (_internal_has_list_style()) {
    if (!_impl_.list_style_->IsInitialized()) return false;
  }
  if (_internal_has_character_style()) {
    if (!_impl_.character_style_->IsInitialized()) return false;
  }
  return true;
}

void ShapePasteStyleCommandArchive::InternalSwap(ShapePasteStyleCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapePasteStyleCommandArchive, _impl_.character_style_)
      + sizeof(ShapePasteStyleCommandArchive::_impl_.character_style_)
      - PROTOBUF_FIELD_OFFSET(ShapePasteStyleCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ShapePasteStyleCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[29]);
}

// ===================================================================

class StyleBaseCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleBaseCommandArchive>()._impl_._has_bits_);
  static const ::TSK::CommandArchive& super(const StyleBaseCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& theme(const StyleBaseCommandArchive* msg);
  static void set_has_theme(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& style(const StyleBaseCommandArchive* msg);
  static void set_has_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSK::CommandArchive&
StyleBaseCommandArchive::_Internal::super(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
StyleBaseCommandArchive::_Internal::theme(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.theme_;
}
const ::TSP::Reference&
StyleBaseCommandArchive::_Internal::style(const StyleBaseCommandArchive* msg) {
  return *msg->_impl_.style_;
}
void StyleBaseCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StyleBaseCommandArchive::clear_theme() {
  if (_impl_.theme_ != nullptr) _impl_.theme_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StyleBaseCommandArchive::clear_style() {
  if (_impl_.style_ != nullptr) _impl_.style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
StyleBaseCommandArchive::StyleBaseCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleBaseCommandArchive)
}
StyleBaseCommandArchive::StyleBaseCommandArchive(const StyleBaseCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleBaseCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSK::CommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_theme()) {
    _this->_impl_.theme_ = new ::TSP::Reference(*from._impl_.theme_);
  }
  if (from._internal_has_style()) {
    _this->_impl_.style_ = new ::TSP::Reference(*from._impl_.style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleBaseCommandArchive)
}

inline void StyleBaseCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.theme_){nullptr}
    , decltype(_impl_.style_){nullptr}
  };
}

StyleBaseCommandArchive::~StyleBaseCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleBaseCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleBaseCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.theme_;
  if (this != internal_default_instance()) delete _impl_.style_;
}

void StyleBaseCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleBaseCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.theme_ != nullptr);
      _impl_.theme_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.style_ != nullptr);
      _impl_.style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleBaseCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSK.CommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference theme = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_theme(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleBaseCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleBaseCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSK.CommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference theme = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::theme(this),
        _Internal::theme(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::style(this),
        _Internal::style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleBaseCommandArchive)
  return target;
}

size_t StyleBaseCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleBaseCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSK.CommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference theme = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.theme_);
    }

    // optional .TSP.Reference style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleBaseCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleBaseCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleBaseCommandArchive::GetClassData() const { return &_class_data_; }


void StyleBaseCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleBaseCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleBaseCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleBaseCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSK::CommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_theme()->::TSP::Reference::MergeFrom(
          from._internal_theme());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_style()->::TSP::Reference::MergeFrom(
          from._internal_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleBaseCommandArchive::CopyFrom(const StyleBaseCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleBaseCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleBaseCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_theme()) {
    if (!_impl_.theme_->IsInitialized()) return false;
  }
  if (_internal_has_style()) {
    if (!_impl_.style_->IsInitialized()) return false;
  }
  return true;
}

void StyleBaseCommandArchive::InternalSwap(StyleBaseCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleBaseCommandArchive, _impl_.style_)
      + sizeof(StyleBaseCommandArchive::_impl_.style_)
      - PROTOBUF_FIELD_OFFSET(StyleBaseCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleBaseCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[30]);
}

// ===================================================================

class StyleCreateCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleCreateCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleCreateCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleCreateCommandArchive::_Internal::super(const StyleCreateCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleCreateCommandArchive::StyleCreateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleCreateCommandArchive)
}
StyleCreateCommandArchive::StyleCreateCommandArchive(const StyleCreateCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleCreateCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.preset_index_ = from._impl_.preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleCreateCommandArchive)
}

inline void StyleCreateCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.preset_index_){0u}
  };
}

StyleCreateCommandArchive::~StyleCreateCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleCreateCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleCreateCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleCreateCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleCreateCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleCreateCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleCreateCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_preset_index(&has_bits);
          _impl_.preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleCreateCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleCreateCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleCreateCommandArchive)
  return target;
}

size_t StyleCreateCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleCreateCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleCreateCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleCreateCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleCreateCommandArchive::GetClassData() const { return &_class_data_; }


void StyleCreateCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleCreateCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleCreateCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleCreateCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.preset_index_ = from._impl_.preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleCreateCommandArchive::CopyFrom(const StyleCreateCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleCreateCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleCreateCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleCreateCommandArchive::InternalSwap(StyleCreateCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleCreateCommandArchive, _impl_.preset_index_)
      + sizeof(StyleCreateCommandArchive::_impl_.preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleCreateCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleCreateCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[31]);
}

// ===================================================================

class StyleRenameCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleRenameCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleRenameCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_updated_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleRenameCommandArchive::_Internal::super(const StyleRenameCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleRenameCommandArchive::StyleRenameCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleRenameCommandArchive)
}
StyleRenameCommandArchive::StyleRenameCommandArchive(const StyleRenameCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleRenameCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_name_){}
    , decltype(_impl_.old_name_){}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.updated_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_updated_name()) {
    _this->_impl_.updated_name_.Set(from._internal_updated_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_old_name()) {
    _this->_impl_.old_name_.Set(from._internal_old_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleRenameCommandArchive)
}

inline void StyleRenameCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.updated_name_){}
    , decltype(_impl_.old_name_){}
    , decltype(_impl_.super_){nullptr}
  };
  _impl_.updated_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.updated_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.old_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.old_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StyleRenameCommandArchive::~StyleRenameCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleRenameCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleRenameCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.updated_name_.Destroy();
  _impl_.old_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleRenameCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleRenameCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleRenameCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.updated_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.old_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleRenameCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string updated_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_updated_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.StyleRenameCommandArchive.updated_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string old_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_old_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "TSWP.StyleRenameCommandArchive.old_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleRenameCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleRenameCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional string updated_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_updated_name().data(), static_cast<int>(this->_internal_updated_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.StyleRenameCommandArchive.updated_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_updated_name(), target);
  }

  // optional string old_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_old_name().data(), static_cast<int>(this->_internal_old_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TSWP.StyleRenameCommandArchive.old_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_old_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleRenameCommandArchive)
  return target;
}

size_t StyleRenameCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleRenameCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string updated_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_updated_name());
    }

    // optional string old_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_old_name());
    }

    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleRenameCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleRenameCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleRenameCommandArchive::GetClassData() const { return &_class_data_; }


void StyleRenameCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleRenameCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleRenameCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleRenameCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_updated_name(from._internal_updated_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_old_name(from._internal_old_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleRenameCommandArchive::CopyFrom(const StyleRenameCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleRenameCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleRenameCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleRenameCommandArchive::InternalSwap(StyleRenameCommandArchive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.updated_name_, lhs_arena,
      &other->_impl_.updated_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.old_name_, lhs_arena,
      &other->_impl_.old_name_, rhs_arena
  );
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleRenameCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[32]);
}

// ===================================================================

class StyleUpdateCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleUpdateCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleUpdateCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::TSP::Reference& original_style(const StyleUpdateCommandArchive* msg);
  static void set_has_original_style(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::TSP::Reference& updated_style(const StyleUpdateCommandArchive* msg);
  static void set_has_updated_style(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleUpdateCommandArchive::_Internal::super(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.super_;
}
const ::TSP::Reference&
StyleUpdateCommandArchive::_Internal::original_style(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.original_style_;
}
const ::TSP::Reference&
StyleUpdateCommandArchive::_Internal::updated_style(const StyleUpdateCommandArchive* msg) {
  return *msg->_impl_.updated_style_;
}
void StyleUpdateCommandArchive::clear_original_style() {
  if (_impl_.original_style_ != nullptr) _impl_.original_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void StyleUpdateCommandArchive::clear_updated_style() {
  if (_impl_.updated_style_ != nullptr) _impl_.updated_style_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
StyleUpdateCommandArchive::StyleUpdateCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleUpdateCommandArchive)
}
StyleUpdateCommandArchive::StyleUpdateCommandArchive(const StyleUpdateCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleUpdateCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.original_style_){nullptr}
    , decltype(_impl_.updated_style_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  if (from._internal_has_original_style()) {
    _this->_impl_.original_style_ = new ::TSP::Reference(*from._impl_.original_style_);
  }
  if (from._internal_has_updated_style()) {
    _this->_impl_.updated_style_ = new ::TSP::Reference(*from._impl_.updated_style_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleUpdateCommandArchive)
}

inline void StyleUpdateCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.original_style_){nullptr}
    , decltype(_impl_.updated_style_){nullptr}
  };
}

StyleUpdateCommandArchive::~StyleUpdateCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleUpdateCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleUpdateCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
  if (this != internal_default_instance()) delete _impl_.original_style_;
  if (this != internal_default_instance()) delete _impl_.updated_style_;
}

void StyleUpdateCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleUpdateCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleUpdateCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.super_ != nullptr);
      _impl_.super_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.original_style_ != nullptr);
      _impl_.original_style_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.updated_style_ != nullptr);
      _impl_.updated_style_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleUpdateCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference original_style = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_original_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .TSP.Reference updated_style = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_updated_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleUpdateCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleUpdateCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference original_style = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::original_style(this),
        _Internal::original_style(this).GetCachedSize(), target, stream);
  }

  // optional .TSP.Reference updated_style = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::updated_style(this),
        _Internal::updated_style(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleUpdateCommandArchive)
  return target;
}

size_t StyleUpdateCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleUpdateCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional .TSP.Reference original_style = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.original_style_);
    }

    // optional .TSP.Reference updated_style = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.updated_style_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleUpdateCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleUpdateCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleUpdateCommandArchive::GetClassData() const { return &_class_data_; }


void StyleUpdateCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleUpdateCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleUpdateCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleUpdateCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_original_style()->::TSP::Reference::MergeFrom(
          from._internal_original_style());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_updated_style()->::TSP::Reference::MergeFrom(
          from._internal_updated_style());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleUpdateCommandArchive::CopyFrom(const StyleUpdateCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleUpdateCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleUpdateCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  if (_internal_has_original_style()) {
    if (!_impl_.original_style_->IsInitialized()) return false;
  }
  if (_internal_has_updated_style()) {
    if (!_impl_.updated_style_->IsInitialized()) return false;
  }
  return true;
}

void StyleUpdateCommandArchive::InternalSwap(StyleUpdateCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleUpdateCommandArchive, _impl_.updated_style_)
      + sizeof(StyleUpdateCommandArchive::_impl_.updated_style_)
      - PROTOBUF_FIELD_OFFSET(StyleUpdateCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleUpdateCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[33]);
}

// ===================================================================

class StyleDeleteCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleDeleteCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleDeleteCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleDeleteCommandArchive::_Internal::super(const StyleDeleteCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleDeleteCommandArchive::StyleDeleteCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleDeleteCommandArchive)
}
StyleDeleteCommandArchive::StyleDeleteCommandArchive(const StyleDeleteCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleDeleteCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleDeleteCommandArchive)
}

inline void StyleDeleteCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){0u}
  };
}

StyleDeleteCommandArchive::~StyleDeleteCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleDeleteCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleDeleteCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleDeleteCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleDeleteCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleDeleteCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_.old_preset_index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleDeleteCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_preset_index(&has_bits);
          _impl_.old_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleDeleteCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleDeleteCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 old_preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleDeleteCommandArchive)
  return target;
}

size_t StyleDeleteCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleDeleteCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 old_preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleDeleteCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleDeleteCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleDeleteCommandArchive::GetClassData() const { return &_class_data_; }


void StyleDeleteCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleDeleteCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleDeleteCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleDeleteCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleDeleteCommandArchive::CopyFrom(const StyleDeleteCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleDeleteCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleDeleteCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleDeleteCommandArchive::InternalSwap(StyleDeleteCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleDeleteCommandArchive, _impl_.old_preset_index_)
      + sizeof(StyleDeleteCommandArchive::_impl_.old_preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleDeleteCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleDeleteCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[34]);
}

// ===================================================================

class StyleReorderCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleReorderCommandArchive>()._impl_._has_bits_);
  static const ::TSWP::StyleBaseCommandArchive& super(const StyleReorderCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_old_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_new_preset_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::TSWP::StyleBaseCommandArchive&
StyleReorderCommandArchive::_Internal::super(const StyleReorderCommandArchive* msg) {
  return *msg->_impl_.super_;
}
StyleReorderCommandArchive::StyleReorderCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleReorderCommandArchive)
}
StyleReorderCommandArchive::StyleReorderCommandArchive(const StyleReorderCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleReorderCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){}
    , decltype(_impl_.new_preset_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSWP::StyleBaseCommandArchive(*from._impl_.super_);
  }
  ::memcpy(&_impl_.old_preset_index_, &from._impl_.old_preset_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.new_preset_index_) -
    reinterpret_cast<char*>(&_impl_.old_preset_index_)) + sizeof(_impl_.new_preset_index_));
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleReorderCommandArchive)
}

inline void StyleReorderCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
    , decltype(_impl_.old_preset_index_){0u}
    , decltype(_impl_.new_preset_index_){0u}
  };
}

StyleReorderCommandArchive::~StyleReorderCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleReorderCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleReorderCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleReorderCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleReorderCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleReorderCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.old_preset_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.new_preset_index_) -
        reinterpret_cast<char*>(&_impl_.old_preset_index_)) + sizeof(_impl_.new_preset_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleReorderCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .TSWP.StyleBaseCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 old_preset_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_old_preset_index(&has_bits);
          _impl_.old_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 new_preset_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_new_preset_index(&has_bits);
          _impl_.new_preset_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleReorderCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleReorderCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .TSWP.StyleBaseCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  // optional uint32 old_preset_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_old_preset_index(), target);
  }

  // optional uint32 new_preset_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_new_preset_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleReorderCommandArchive)
  return target;
}

size_t StyleReorderCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleReorderCommandArchive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .TSWP.StyleBaseCommandArchive super = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.super_);
    }

    // optional uint32 old_preset_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_old_preset_index());
    }

    // optional uint32 new_preset_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_new_preset_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleReorderCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleReorderCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleReorderCommandArchive::GetClassData() const { return &_class_data_; }


void StyleReorderCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleReorderCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleReorderCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleReorderCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_super()->::TSWP::StyleBaseCommandArchive::MergeFrom(
          from._internal_super());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.old_preset_index_ = from._impl_.old_preset_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.new_preset_index_ = from._impl_.new_preset_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleReorderCommandArchive::CopyFrom(const StyleReorderCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleReorderCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleReorderCommandArchive::IsInitialized() const {
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleReorderCommandArchive::InternalSwap(StyleReorderCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleReorderCommandArchive, _impl_.new_preset_index_)
      + sizeof(StyleReorderCommandArchive::_impl_.new_preset_index_)
      - PROTOBUF_FIELD_OFFSET(StyleReorderCommandArchive, _impl_.super_)>(
          reinterpret_cast<char*>(&_impl_.super_),
          reinterpret_cast<char*>(&other->_impl_.super_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleReorderCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[35]);
}

// ===================================================================

class StyleUpdatePropertyMapCommandArchive::_Internal {
 public:
  using HasBits = decltype(std::declval<StyleUpdatePropertyMapCommandArchive>()._impl_._has_bits_);
  static const ::TSS::StyleUpdatePropertyMapCommandArchive& super(const StyleUpdatePropertyMapCommandArchive* msg);
  static void set_has_super(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::TSS::StyleUpdatePropertyMapCommandArchive&
StyleUpdatePropertyMapCommandArchive::_Internal::super(const StyleUpdatePropertyMapCommandArchive* msg) {
  return *msg->_impl_.super_;
}
void StyleUpdatePropertyMapCommandArchive::clear_super() {
  if (_impl_.super_ != nullptr) _impl_.super_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TSWP.StyleUpdatePropertyMapCommandArchive)
}
StyleUpdatePropertyMapCommandArchive::StyleUpdatePropertyMapCommandArchive(const StyleUpdatePropertyMapCommandArchive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StyleUpdatePropertyMapCommandArchive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_super()) {
    _this->_impl_.super_ = new ::TSS::StyleUpdatePropertyMapCommandArchive(*from._impl_.super_);
  }
  // @@protoc_insertion_point(copy_constructor:TSWP.StyleUpdatePropertyMapCommandArchive)
}

inline void StyleUpdatePropertyMapCommandArchive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.super_){nullptr}
  };
}

StyleUpdatePropertyMapCommandArchive::~StyleUpdatePropertyMapCommandArchive() {
  // @@protoc_insertion_point(destructor:TSWP.StyleUpdatePropertyMapCommandArchive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleUpdatePropertyMapCommandArchive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.super_;
}

void StyleUpdatePropertyMapCommandArchive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StyleUpdatePropertyMapCommandArchive::Clear() {
// @@protoc_insertion_point(message_clear_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.super_ != nullptr);
    _impl_.super_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StyleUpdatePropertyMapCommandArchive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_super(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleUpdatePropertyMapCommandArchive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::super(this),
        _Internal::super(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TSWP.StyleUpdatePropertyMapCommandArchive)
  return target;
}

size_t StyleUpdatePropertyMapCommandArchive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  size_t total_size = 0;

  // required .TSS.StyleUpdatePropertyMapCommandArchive super = 1;
  if (_internal_has_super()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.super_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StyleUpdatePropertyMapCommandArchive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StyleUpdatePropertyMapCommandArchive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StyleUpdatePropertyMapCommandArchive::GetClassData() const { return &_class_data_; }


void StyleUpdatePropertyMapCommandArchive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StyleUpdatePropertyMapCommandArchive*>(&to_msg);
  auto& from = static_cast<const StyleUpdatePropertyMapCommandArchive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_super()) {
    _this->_internal_mutable_super()->::TSS::StyleUpdatePropertyMapCommandArchive::MergeFrom(
        from._internal_super());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StyleUpdatePropertyMapCommandArchive::CopyFrom(const StyleUpdatePropertyMapCommandArchive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TSWP.StyleUpdatePropertyMapCommandArchive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleUpdatePropertyMapCommandArchive::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_super()) {
    if (!_impl_.super_->IsInitialized()) return false;
  }
  return true;
}

void StyleUpdatePropertyMapCommandArchive::InternalSwap(StyleUpdatePropertyMapCommandArchive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.super_, other->_impl_.super_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StyleUpdatePropertyMapCommandArchive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TSWPCommandArchives_2eproto_getter, &descriptor_table_TSWPCommandArchives_2eproto_once,
      file_level_metadata_TSWPCommandArchives_2eproto[36]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TSWP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TSWP::DummyCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::DummyCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::DummyCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::TextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::TextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::TextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ReplaceAllTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ReplaceAllTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ReplaceAllTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::FormatTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::FormatTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::FormatTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::SetColumnStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::SetColumnStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::SetColumnStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ReplaceAllUsesOfStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ReplaceAllUsesOfStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ReplaceAllUsesOfStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::InsertAttachmentCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::InsertAttachmentCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::InsertAttachmentCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::InsertColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::InsertColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::InsertColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::InsertRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::InsertRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::InsertRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MergeCellsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MergeCellsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MergeCellsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ApplyPlaceholderTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ApplyPlaceholderTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ApplyPlaceholderTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ApplyHighlightTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ApplyHighlightTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ApplyHighlightTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::CreateHyperlinkCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::CreateHyperlinkCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::CreateHyperlinkCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveHyperlinkCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveHyperlinkCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveHyperlinkCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyHyperlinkCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyHyperlinkCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyHyperlinkCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::UpdateDateTimeFieldCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::UpdateDateTimeFieldCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::UpdateDateTimeFieldCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ApplyRubyTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ApplyRubyTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ApplyRubyTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::RemoveRubyTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::RemoveRubyTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::RemoveRubyTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyRubyTextCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyRubyTextCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyRubyTextCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsBaseCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsBaseCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsBaseCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsForTOCInfoCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ModifyTOCSettingsPresetForThemeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::AnchorAttachmentCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::AnchorAttachmentCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::AnchorAttachmentCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::TextApplyThemeCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::TextApplyThemeCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::TextApplyThemeCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MoveColumnsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MoveColumnsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MoveColumnsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::MoveRowsCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::MoveRowsCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::MoveRowsCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapeApplyPresetCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ShapeApplyPresetCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapeApplyPresetCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::ShapePasteStyleCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::ShapePasteStyleCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::ShapePasteStyleCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleBaseCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleBaseCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleBaseCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleCreateCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleCreateCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleCreateCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleRenameCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleRenameCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleRenameCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleUpdateCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleUpdateCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleUpdateCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleDeleteCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleDeleteCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleDeleteCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleReorderCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleReorderCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleReorderCommandArchive >(arena);
}
template<> PROTOBUF_NOINLINE ::TSWP::StyleUpdatePropertyMapCommandArchive*
Arena::CreateMaybeMessage< ::TSWP::StyleUpdatePropertyMapCommandArchive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TSWP::StyleUpdatePropertyMapCommandArchive >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
